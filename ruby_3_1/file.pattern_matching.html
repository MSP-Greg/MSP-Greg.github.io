<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Pattern Matching &mdash; Ruby-3.1.7</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "pattern_matching",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Ruby-3.1.7</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Pattern Matching&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="file_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>

<h1 id="label-Pattern+matching">Pattern matching</h1>

<p>Pattern matching is a feature allowing deep matching of structured values: checking the structure and binding the matched parts to local variables.</p>

<p>Pattern matching in Ruby is implemented with the <code>case</code>/<code>in</code> expression:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> <span class='op'>&lt;</span><span class='id identifier rubyid_expression'>expression</span><span class='op'>&gt;</span>
<span class='kw'>in</span> <span class='op'>&lt;</span><span class='id identifier rubyid_pattern1'>pattern1</span><span class='op'>&gt;</span>
  <span class='comment'>#...
</span><span class='kw'>in</span> <span class='op'>&lt;</span><span class='id identifier rubyid_pattern2'>pattern2</span><span class='op'>&gt;</span>
  <span class='comment'>#...
</span><span class='kw'>in</span> <span class='op'>&lt;</span><span class='id identifier rubyid_pattern3'>pattern3</span><span class='op'>&gt;</span>
  <span class='comment'>#...
</span><span class='kw'>else</span>
  <span class='comment'>#...
</span><span class='kw'>end</span></code></pre>

<p>(Note that <code>in</code> and <code>when</code> branches can NOT be mixed in one <code>case</code> expression.)</p>

<p>Or with the <code>=&gt;</code> operator and the <code>in</code> operator, which can be used in a standalone expression:</p>

<pre class="code xml"><code class="xml">&lt;expression&gt; =&gt; &lt;pattern&gt;

&lt;expression&gt; in &lt;pattern&gt;
</code></pre>

<p>The <code>case</code>/<code>in</code> expression is <em>exhaustive</em>: if the value of the expression does not match any branch of the <code>case</code> expression (and the <code>else</code> branch is absent), <code>NoMatchingPatternError</code> is raised.</p>

<p>Therefore, the <code>case</code> expression might be used for conditional matching and unpacking:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_config'>config</span> <span class='op'>=</span> {<span class='label'>db:</span> {<span class='label'>user:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>admin</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>password:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>abc123</span><span class='tstring_end'>&#39;</span></span>}}

<span class='kw'>case</span> <span class='id identifier rubyid_config'>config</span>
<span class='kw'>in</span> <span class='label'>db:</span> {<span class='label'>user:</span>} <span class='comment'># matches subhash and puts matched value in variable user
</span>  <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Connect with user &#39;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_user'>user</span><span class='embexpr_end'>}</span><span class='tstring_content'>&#39;</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>in</span> <span class='label'>connection:</span> {<span class='label'>username:</span> }
  <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Connect with user &#39;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_username'>username</span><span class='embexpr_end'>}</span><span class='tstring_content'>&#39;</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Unrecognized structure of config</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'># Prints: &quot;Connect with user &#39;admin&#39;&quot;</span></code></pre>

<p>whilst the <code>=&gt;</code> operator is most useful when the expected data structure is known beforehand, to just unpack parts of it:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_config'>config</span> <span class='op'>=</span> {<span class='label'>db:</span> {<span class='label'>user:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>admin</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>password:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>abc123</span><span class='tstring_end'>&#39;</span></span>}}

<span class='id identifier rubyid_config'>config</span> <span class='op'>=&gt;</span> {<span class='label'>db:</span> {<span class='label'>user:</span>}} <span class='comment'># will raise if the config&#39;s structure is unexpected
</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Connect with user &#39;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_user'>user</span><span class='embexpr_end'>}</span><span class='tstring_content'>&#39;</span><span class='tstring_end'>&quot;</span></span>
<span class='comment'># Prints: &quot;Connect with user &#39;admin&#39;&quot;</span></code></pre>

<p><code>&lt;expression&gt; in &lt;pattern&gt;</code> is the same as <code>case &lt;expression&gt;; in &lt;pattern&gt;; true; else false; end</code>. You can use it when you only want to know if a pattern has been matched or not:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_users'>users</span> <span class='op'>=</span> [{<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Alice</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>age:</span> <span class='int'>12</span>}<span class='comma'>,</span> {<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Bob</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>age:</span> <span class='int'>23</span>}]
<span class='id identifier rubyid_users'>users</span>.<span class='id identifier rubyid_any?'>any?</span> {<span class='op'>|</span><span class='id identifier rubyid_user'>user</span><span class='op'>|</span> <span class='id identifier rubyid_user'>user</span> <span class='kw'>in</span> {<span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>B</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='label'>age:</span> <span class='int'>20</span><span class='op'>..</span>} } <span class='comment'>#=&gt; true</span></code></pre>

<p>See below for more examples and explanations of the syntax.</p>

<h2 id="label-Patterns">Patterns</h2>

<p>Patterns can be:</p>
<ul><li>
<p>any Ruby object (matched by the <code>===</code> operator, like in <code>when</code>); (<em>Value pattern</em>)</p>
</li><li>
<p>array pattern: <code>[&lt;subpattern&gt;, &lt;subpattern&gt;, &lt;subpattern&gt;, ...]</code>; (<em>Array pattern</em>)</p>
</li><li>
<p>find pattern: <code>[*variable, &lt;subpattern&gt;, &lt;subpattern&gt;, &lt;subpattern&gt;, ..., *variable]</code>; (<em>Find pattern</em>)</p>
</li><li>
<p>hash pattern: <code>{key: &lt;subpattern&gt;, key: &lt;subpattern&gt;, ...}</code>; (<em>Hash pattern</em>)</p>
</li><li>
<p>combination of patterns with <code>|</code>; (<em>Alternative pattern</em>)</p>
</li><li>
<p>variable capture: <code>&lt;pattern&gt; =&gt; variable</code> or <code>variable</code>; (<em>As pattern</em>, <em>Variable pattern</em>)</p>
</li></ul>

<p>Any pattern can be nested inside array/find/hash patterns where <code>&lt;subpattern&gt;</code> is specified.</p>

<p>Array patterns and find patterns match arrays, or objects that respond to <code>deconstruct</code> (see below about the latter). Hash patterns match hashes, or objects that respond to <code>deconstruct_keys</code> (see below about the latter). Note that only symbol keys are supported for hash patterns.</p>

<p>An important difference between array and hash pattern behavior is that arrays match only a <em>whole</em> array:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>3</span>]
<span class='kw'>in</span> [<span class='const'>Integer</span><span class='comma'>,</span> <span class='const'>Integer</span>]
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;not matched&quot;</span></code></pre>

<p>while the hash matches even if there are other keys besides the specified part:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> {<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>c:</span> <span class='int'>3</span>}
<span class='kw'>in</span> {<span class='label'>a:</span> <span class='const'>Integer</span>}
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched&quot;</span></code></pre>

<p><code>{}</code> is the only exclusion from this rule. It matches only if an empty hash is given:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> {<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>c:</span> <span class='int'>3</span>}
<span class='kw'>in</span> {}
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;not matched&quot;
</span>
<span class='kw'>case</span> {}
<span class='kw'>in</span> {}
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched&quot;</span></code></pre>

<p>There is also a way to specify there should be no other keys in the matched hash except those explicitly specified by the pattern, with <code>**nil</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> {<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span>}
<span class='kw'>in</span> {<span class='label'>a:</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='op'>**</span><span class='kw'>nil</span>} <span class='comment'># this will not match the pattern having keys other than a:
</span>  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched a part</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>in</span> {<span class='label'>a:</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='op'>**</span><span class='kw'>nil</span>}
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched a whole</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched a whole&quot;</span></code></pre>

<p>Both array and hash patterns support “rest” specification:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>3</span>]
<span class='kw'>in</span> [<span class='const'>Integer</span><span class='comma'>,</span> <span class='op'>*</span>]
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched&quot;
</span>
<span class='kw'>case</span> {<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>c:</span> <span class='int'>3</span>}
<span class='kw'>in</span> {<span class='label'>a:</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='op'>**</span>}
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched&quot;</span></code></pre>

<p>Parentheses around both kinds of patterns could be omitted:</p>

<pre class="code ruby"><code class="ruby"> <span class='kw'>case</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>]
 <span class='kw'>in</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='const'>Integer</span>
   <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
 <span class='kw'>else</span>
   <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
 <span class='kw'>end</span>
 <span class='comment'>#=&gt; &quot;matched&quot;
</span>
 <span class='kw'>case</span> {<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>c:</span> <span class='int'>3</span>}
 <span class='kw'>in</span> <span class='label'>a:</span> <span class='const'>Integer</span>
   <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
 <span class='kw'>else</span>
   <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
 <span class='kw'>end</span>
 <span class='comment'>#=&gt; &quot;matched&quot;
</span>
[<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>] <span class='op'>=&gt;</span> <span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span>
[<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>] <span class='kw'>in</span> <span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span>

{<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>c:</span> <span class='int'>3</span>} <span class='op'>=&gt;</span> <span class='label'>a:</span>
{<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>c:</span> <span class='int'>3</span>} <span class='kw'>in</span> <span class='label'>a:</span></code></pre>

<p>Find pattern is similar to array pattern but it can be used to check if the given object has any elements that match the pattern:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> [<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='int'>1</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>b</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>c</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='int'>2</span>]
<span class='kw'>in</span> [<span class='op'>*</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='op'>*</span>]
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span></code></pre>

<h2 id="label-Variable+binding">Variable binding</h2>

<p>Besides deep structural checks, one of the very important features of the pattern matching is the binding of the matched parts to local variables. The basic form of binding is just specifying <code>=&gt; variable_name</code> after the matched (sub)pattern (one might find this similar to storing exceptions in local variables in a <code>rescue ExceptionClass =&gt; var</code> clause):</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>]
<span class='kw'>in</span> <span class='const'>Integer</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='const'>Integer</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_a'>a</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched: 1&quot;
</span>
<span class='kw'>case</span> {<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>c:</span> <span class='int'>3</span>}
<span class='kw'>in</span> <span class='label'>a:</span> <span class='const'>Integer</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_m'>m</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_m'>m</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched: 1&quot;</span></code></pre>

<p>If no additional check is required, for only binding some part of the data to a variable, a simpler form could be used:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>]
<span class='kw'>in</span> <span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='const'>Integer</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_a'>a</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched: 1&quot;
</span>
<span class='kw'>case</span> {<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>c:</span> <span class='int'>3</span>}
<span class='kw'>in</span> <span class='label'>a:</span> <span class='id identifier rubyid_m'>m</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_m'>m</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched: 1&quot;</span></code></pre>

<p>For hash patterns, even a simpler form exists: key-only specification (without any sub-pattern) binds the local variable with the key’s name, too:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> {<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>c:</span> <span class='int'>3</span>}
<span class='kw'>in</span> <span class='label'>a:</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_a'>a</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched: 1&quot;</span></code></pre>

<p>Binding works for nested patterns as well:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> {<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>John</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>friends:</span> [{<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Jane</span><span class='tstring_end'>&#39;</span></span>}<span class='comma'>,</span> {<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Rajesh</span><span class='tstring_end'>&#39;</span></span>}]}
<span class='kw'>in</span> <span class='label'>name:</span><span class='comma'>,</span> <span class='label'>friends:</span> [{<span class='label'>name:</span> <span class='id identifier rubyid_first_friend'>first_friend</span>}<span class='comma'>,</span> <span class='op'>*</span>]
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_first_friend'>first_friend</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched: Jane&quot;</span></code></pre>

<p>The “rest” part of a pattern also can be bound to a variable:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>3</span>]
<span class='kw'>in</span> <span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_rest'>rest</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_a'>a</span><span class='embexpr_end'>}</span><span class='tstring_content'>, </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_rest'>rest</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched: 1, [2, 3]&quot;
</span>
<span class='kw'>case</span> {<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>c:</span> <span class='int'>3</span>}
<span class='kw'>in</span> <span class='label'>a:</span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_rest'>rest</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_a'>a</span><span class='embexpr_end'>}</span><span class='tstring_content'>, </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_rest'>rest</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched: 1, {:b=&gt;2, :c=&gt;3}&quot;</span></code></pre>

<p>Binding to variables currently does NOT work for alternative patterns joined with <code>|</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> {<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span>}
<span class='kw'>in</span> {<span class='label'>a:</span> } <span class='op'>|</span> <span class='const'>Array</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_a'>a</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'># SyntaxError (illegal variable in alternative pattern (a))</span></code></pre>

<p>Variables that start with <code>_</code> are the only exclusions from this rule:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> {<span class='label'>a:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span>}
<span class='kw'>in</span> {<span class='label'>a:</span> <span class='id identifier rubyid__'>_</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='id identifier rubyid__foo'>_foo</span>} <span class='op'>|</span> <span class='const'>Array</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid__'>_</span><span class='embexpr_end'>}</span><span class='tstring_content'>, </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid__foo'>_foo</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'># =&gt; &quot;matched: 1, 2&quot;</span></code></pre>

<p>It is, though, not advised to reuse the bound value, as this pattern’s goal is to signify a discarded value.</p>

<h2 id="label-Variable+pinning">Variable pinning</h2>

<p>Due to the variable binding feature, existing local variable can not be straightforwardly used as a sub-pattern:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_expectation'>expectation</span> <span class='op'>=</span> <span class='int'>18</span>

<span class='kw'>case</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>]
<span class='kw'>in</span> <span class='id identifier rubyid_expectation'>expectation</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_rest'>rest</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched. expectation was: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_expectation'>expectation</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched. expectation was: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_expectation'>expectation</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'># expected: &quot;not matched. expectation was: 18&quot;
</span><span class='comment'># real: &quot;matched. expectation was: 1&quot; -- local variable just rewritten</span></code></pre>

<p>For this case, the pin operator <code>^</code> can be used, to tell Ruby “just use this value as part of the pattern”:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_expectation'>expectation</span> <span class='op'>=</span> <span class='int'>18</span>
<span class='kw'>case</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>]
<span class='kw'>in</span> <span class='op'>^</span><span class='id identifier rubyid_expectation'>expectation</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_rest'>rest</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched. expectation was: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_expectation'>expectation</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched. expectation was: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_expectation'>expectation</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;not matched. expectation was: 18&quot;</span></code></pre>

<p>One important usage of variable pinning is specifying that the same value should occur in the pattern several times:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_jane'>jane</span> <span class='op'>=</span> {<span class='label'>school:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>high</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>schools:</span> [{<span class='label'>id:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>level:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>middle</span><span class='tstring_end'>&#39;</span></span>}<span class='comma'>,</span> {<span class='label'>id:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>level:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>high</span><span class='tstring_end'>&#39;</span></span>}]}
<span class='id identifier rubyid_john'>john</span> <span class='op'>=</span> {<span class='label'>school:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>high</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>schools:</span> [{<span class='label'>id:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>level:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>middle</span><span class='tstring_end'>&#39;</span></span>}]}

<span class='kw'>case</span> <span class='id identifier rubyid_jane'>jane</span>
<span class='kw'>in</span> <span class='label'>school:</span><span class='comma'>,</span> <span class='label'>schools:</span> [<span class='op'>*</span><span class='comma'>,</span> {<span class='label'>id:</span><span class='comma'>,</span> <span class='label'>level:</span> <span class='op'>^</span><span class='id identifier rubyid_school'>school</span>}] <span class='comment'># select the last school, level should match
</span>  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched. school: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_id'>id</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched. school: 2&quot;
</span>
<span class='kw'>case</span> <span class='id identifier rubyid_john'>john</span> <span class='comment'># the specified school level is &quot;high&quot;, but last school does not match
</span><span class='kw'>in</span> <span class='label'>school:</span><span class='comma'>,</span> <span class='label'>schools:</span> [<span class='op'>*</span><span class='comma'>,</span> {<span class='label'>id:</span><span class='comma'>,</span> <span class='label'>level:</span> <span class='op'>^</span><span class='id identifier rubyid_school'>school</span>}]
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched. school: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_id'>id</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;not matched&quot;</span></code></pre>

<p>In addition to pinning local variables, you can also pin instance, global, and class variables:</p>

<pre class="code ruby"><code class="ruby"><span class='gvar'>$gvar</span> <span class='op'>=</span> <span class='int'>1</span>
<span class='kw'>class</span> <span class='const'>A</span>
  <span class='ivar'>@ivar</span> <span class='op'>=</span> <span class='int'>2</span>
  <span class='cvar'>@@cvar</span> <span class='op'>=</span> <span class='int'>3</span>
  <span class='kw'>case</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>3</span>]
  <span class='kw'>in</span> <span class='op'>^</span><span class='gvar'>$gvar</span><span class='comma'>,</span> <span class='op'>^</span><span class='ivar'>@ivar</span><span class='comma'>,</span> <span class='op'>^</span><span class='cvar'>@@cvar</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>else</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
  <span class='comment'>#=&gt; &quot;matched&quot;
</span><span class='kw'>end</span></code></pre>

<p>You can also pin the result of arbitrary expressions using parentheses:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> <span class='int'>1</span>
<span class='id identifier rubyid_b'>b</span> <span class='op'>=</span> <span class='int'>2</span>
<span class='kw'>case</span> <span class='int'>3</span>
<span class='kw'>in</span> <span class='op'>^</span>(<span class='id identifier rubyid_a'>a</span> <span class='op'>+</span> <span class='id identifier rubyid_b'>b</span>)
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched&quot;</span></code></pre>

<h2 id="label-Matching+non-primitive+objects-3A+deconstruct+and+deconstruct_keys">Matching non-primitive objects: <code>deconstruct</code> and <code>deconstruct_keys</code></h2>

<p>As already mentioned above, array, find, and hash patterns besides literal arrays and hashes will try to match any object implementing <code>deconstruct</code> (for array/find patterns) or <code>deconstruct_keys</code> (for hash patterns).</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Point</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span>(<span class='id identifier rubyid_x'>x</span><span class='comma'>,</span> <span class='id identifier rubyid_y'>y</span>)
    <span class='ivar'>@x</span><span class='comma'>,</span> <span class='ivar'>@y</span> <span class='op'>=</span> <span class='id identifier rubyid_x'>x</span><span class='comma'>,</span> <span class='id identifier rubyid_y'>y</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_deconstruct'>deconstruct</span>
    <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>deconstruct called</span><span class='tstring_end'>&quot;</span></span>
    [<span class='ivar'>@x</span><span class='comma'>,</span> <span class='ivar'>@y</span>]
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_deconstruct_keys'>deconstruct_keys</span>(<span class='id identifier rubyid_keys'>keys</span>)
    <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>deconstruct_keys called with </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_keys'>keys</span>.<span class='id identifier rubyid_inspect'>inspect</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
    {<span class='label'>x:</span> <span class='ivar'>@x</span><span class='comma'>,</span> <span class='label'>y:</span> <span class='ivar'>@y</span>}
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='kw'>case</span> <span class='const'>Point</span>.<span class='id identifier rubyid_new'>new</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='op'>-</span><span class='int'>2</span>)
<span class='kw'>in</span> <span class='id identifier rubyid_px'>px</span><span class='comma'>,</span> <span class='const'>Integer</span>  <span class='comment'># sub-patterns and variable binding works
</span>  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_px'>px</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'># prints &quot;deconstruct called&quot;
</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: 1</span><span class='tstring_end'>&quot;</span></span>

<span class='kw'>case</span> <span class='const'>Point</span>.<span class='id identifier rubyid_new'>new</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='op'>-</span><span class='int'>2</span>)
<span class='kw'>in</span> <span class='label'>x:</span> <span class='int'>0</span><span class='op'>..</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_px'>px</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_px'>px</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'># prints: deconstruct_keys called with [:x]
</span><span class='comment'>#=&gt; &quot;matched: 1&quot;</span></code></pre>

<p><code>keys</code> are passed to <code>deconstruct_keys</code> to provide a room for optimization in the matched class: if calculating a full hash representation is expensive, one may calculate only the necessary subhash. When the <code>**rest</code> pattern is used, <code>nil</code> is passed as a <code>keys</code> value:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> <span class='const'>Point</span>.<span class='id identifier rubyid_new'>new</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='op'>-</span><span class='int'>2</span>)
<span class='kw'>in</span> <span class='label'>x:</span> <span class='int'>0</span><span class='op'>..</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_px'>px</span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_rest'>rest</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_px'>px</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'># prints: deconstruct_keys called with nil
</span><span class='comment'>#=&gt; &quot;matched: 1&quot;</span></code></pre>

<p>Additionally, when matching custom classes, the expected class can be specified as part of the pattern and is checked with <code>===</code></p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>SuperPoint</span> <span class='op'>&lt;</span> <span class='const'>Point</span>
<span class='kw'>end</span>

<span class='kw'>case</span> <span class='const'>Point</span>.<span class='id identifier rubyid_new'>new</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='op'>-</span><span class='int'>2</span>)
<span class='kw'>in</span> <span class='const'>SuperPoint</span>(<span class='label'>x:</span> <span class='int'>0</span><span class='op'>..</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_px'>px</span>)
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_px'>px</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;not matched&quot;
</span>
<span class='kw'>case</span> <span class='const'>SuperPoint</span>.<span class='id identifier rubyid_new'>new</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='op'>-</span><span class='int'>2</span>)
<span class='kw'>in</span> <span class='const'>SuperPoint</span>[<span class='label'>x:</span> <span class='int'>0</span><span class='op'>..</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_px'>px</span>] <span class='comment'># [] or () parentheses are allowed
</span>  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_px'>px</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched: 1&quot;</span></code></pre>

<h2 id="label-Guard+clauses">Guard clauses</h2>

<p><code>if</code> can be used to attach an additional condition (guard clause) when the pattern matches. This condition may use bound variables:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>]
<span class='kw'>in</span> <span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span> <span class='kw'>if</span> <span class='id identifier rubyid_b'>b</span> <span class='op'>==</span> <span class='id identifier rubyid_a'>a</span><span class='op'>*</span><span class='int'>2</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched&quot;
</span>
<span class='kw'>case</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>1</span>]
<span class='kw'>in</span> <span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span> <span class='kw'>if</span> <span class='id identifier rubyid_b'>b</span> <span class='op'>==</span> <span class='id identifier rubyid_a'>a</span><span class='op'>*</span><span class='int'>2</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;not matched&quot;</span></code></pre>

<p><code>unless</code> works, too:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>1</span>]
<span class='kw'>in</span> <span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span> <span class='kw'>unless</span> <span class='id identifier rubyid_b'>b</span> <span class='op'>==</span> <span class='id identifier rubyid_a'>a</span><span class='op'>*</span><span class='int'>2</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;matched&quot;</span></code></pre>

<h2 id="label-Current+feature+status">Current feature status</h2>

<p>As of Ruby 3.1, find patterns are considered <em>experimental</em>: its syntax can change in the future. Every time you use these features in code, a warning will be printed:</p>

<pre class="code ruby"><code class="ruby">[<span class='int'>0</span>] <span class='op'>=&gt;</span> [<span class='op'>*</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='op'>*</span>]
<span class='comment'># warning: Find pattern is experimental, and the behavior may change in future versions of Ruby!
</span><span class='comment'># warning: One-line pattern matching is experimental, and the behavior may change in future versions of Ruby!</span></code></pre>

<p>To suppress this warning, one may use the Warning::[]= method:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Warning</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_experimental'>experimental</span>] <span class='op'>=</span> <span class='kw'>false</span>
<span class='id identifier rubyid_eval'>eval</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>[0] =&gt; [*, 0, *]</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># ...no warning printed...</span></code></pre>

<p>Note that pattern-matching warnings are raised at compile time, so this will not suppress the warning:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Warning</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_experimental'>experimental</span>] <span class='op'>=</span> <span class='kw'>false</span> <span class='comment'># At the time this line is evaluated, the parsing happened and warning emitted
</span>[<span class='int'>0</span>] <span class='op'>=&gt;</span> [<span class='op'>*</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='op'>*</span>]</code></pre>

<p>So, only subsequently loaded files or ‘eval`-ed code is affected by switching the flag.</p>

<p>Alternatively, the command line option <code>-W:no-experimental</code> can be used to turn off “experimental” feature warnings.</p>

<h2 id="label-Appendix+A.+Pattern+syntax">Appendix A. Pattern syntax</h2>

<p>Approximate syntax is:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pattern'>pattern</span><span class='op'>:</span> <span class='id identifier rubyid_value_pattern'>value_pattern</span>
       <span class='op'>|</span> <span class='id identifier rubyid_variable_pattern'>variable_pattern</span>
       <span class='op'>|</span> <span class='id identifier rubyid_alternative_pattern'>alternative_pattern</span>
       <span class='op'>|</span> <span class='id identifier rubyid_as_pattern'>as_pattern</span>
       <span class='op'>|</span> <span class='id identifier rubyid_array_pattern'>array_pattern</span>
       <span class='op'>|</span> <span class='id identifier rubyid_find_pattern'>find_pattern</span>
       <span class='op'>|</span> <span class='id identifier rubyid_hash_pattern'>hash_pattern</span>

<span class='id identifier rubyid_value_pattern'>value_pattern</span><span class='op'>:</span> <span class='id identifier rubyid_literal'>literal</span>
             <span class='op'>|</span> <span class='const'>Constant</span>
             <span class='op'>|</span> <span class='op'>^</span><span class='id identifier rubyid_local_variable'>local_variable</span>
             <span class='op'>|</span> <span class='op'>^</span><span class='id identifier rubyid_instance_variable'>instance_variable</span>
             <span class='op'>|</span> <span class='op'>^</span><span class='id identifier rubyid_class_variable'>class_variable</span>
             <span class='op'>|</span> <span class='op'>^</span><span class='id identifier rubyid_global_variable'>global_variable</span>
             <span class='op'>|</span> <span class='op'>^</span>(<span class='id identifier rubyid_expression'>expression</span>)

<span class='id identifier rubyid_variable_pattern'>variable_pattern</span><span class='op'>:</span> <span class='id identifier rubyid_variable'>variable</span>

<span class='id identifier rubyid_alternative_pattern'>alternative_pattern</span><span class='op'>:</span> <span class='id identifier rubyid_pattern'>pattern</span> <span class='op'>|</span> <span class='id identifier rubyid_pattern'>pattern</span> <span class='op'>|</span> <span class='op'>...</span>

<span class='id identifier rubyid_as_pattern'>as_pattern</span><span class='op'>:</span> <span class='id identifier rubyid_pattern'>pattern</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_variable'>variable</span>

<span class='id identifier rubyid_array_pattern'>array_pattern</span><span class='op'>:</span> [<span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='op'>...</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_variable'>variable</span>]
             <span class='op'>|</span> <span class='const'>Constant</span>(<span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='op'>...</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_variable'>variable</span>)
             <span class='op'>|</span> <span class='const'>Constant</span>[<span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='op'>...</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_variable'>variable</span>]

<span class='id identifier rubyid_find_pattern'>find_pattern</span><span class='op'>:</span> [<span class='op'>*</span><span class='id identifier rubyid_variable'>variable</span><span class='comma'>,</span> <span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='op'>...</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_variable'>variable</span>]
            <span class='op'>|</span> <span class='const'>Constant</span>(<span class='op'>*</span><span class='id identifier rubyid_variable'>variable</span><span class='comma'>,</span> <span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='op'>...</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_variable'>variable</span>)
            <span class='op'>|</span> <span class='const'>Constant</span>[<span class='op'>*</span><span class='id identifier rubyid_variable'>variable</span><span class='comma'>,</span> <span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='op'>...</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_variable'>variable</span>]

<span class='id identifier rubyid_hash_pattern'>hash_pattern</span><span class='op'>:</span> {<span class='label'>key:</span> <span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='label'>key:</span><span class='comma'>,</span> <span class='op'>...</span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_variable'>variable</span>}
            <span class='op'>|</span> <span class='const'>Constant</span>(<span class='label'>key:</span> <span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='label'>key:</span><span class='comma'>,</span> <span class='op'>...</span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_variable'>variable</span>)
            <span class='op'>|</span> <span class='const'>Constant</span>[<span class='label'>key:</span> <span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='label'>key:</span><span class='comma'>,</span> <span class='op'>...</span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_variable'>variable</span>]</code></pre>

<h2 id="label-Appendix+B.+Some+undefined+behavior+examples">Appendix B. Some undefined behavior examples</h2>

<p>To leave room for optimization in the future, the specification contains some undefined behavior.</p>

<p>Use of a variable in an unmatched pattern:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> [<span class='int'>0</span><span class='comma'>,</span> <span class='int'>1</span>]
<span class='kw'>in</span> [<span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='int'>2</span>]
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>in</span> <span class='id identifier rubyid_b'>b</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>in</span> <span class='id identifier rubyid_c'>c</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='id identifier rubyid_a'>a</span> <span class='comment'>#=&gt; undefined
</span><span class='id identifier rubyid_c'>c</span> <span class='comment'>#=&gt; undefined</span></code></pre>

<p>Number of <code>deconstruct</code>, <code>deconstruct_keys</code> method calls:</p>

<pre class="code ruby"><code class="ruby"><span class='gvar'>$i</span> <span class='op'>=</span> <span class='int'>0</span>
<span class='id identifier rubyid_ary'>ary</span> <span class='op'>=</span> [<span class='int'>0</span>]
<span class='kw'>def</span> <span class='id identifier rubyid_ary'>ary</span>.<span class='id identifier rubyid_deconstruct'>deconstruct</span>
  <span class='gvar'>$i</span> <span class='op'>+=</span> <span class='int'>1</span>
  <span class='kw'>self</span>
<span class='kw'>end</span>
<span class='kw'>case</span> <span class='id identifier rubyid_ary'>ary</span>
<span class='kw'>in</span> [<span class='int'>0</span><span class='comma'>,</span> <span class='int'>1</span>]
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>in</span> [<span class='int'>0</span>]
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>matched</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='gvar'>$i</span> <span class='comment'>#=&gt; undefined</span></code></pre>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>