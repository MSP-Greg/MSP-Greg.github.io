<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Module: Racc &mdash; racc  Ruby-3.1.7 p261</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Racc",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../.'>Ruby-3.1.7</a> &raquo; 
      <a href='.'>racc</a> &raquo; 
      <a href='_index.html#alpha_R'>Index (R)</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>Racc&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='module'>
<h1>Module: Racc</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Namespace Children</td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Classes:</div>
      <div class='box_11'>
          <a href="Racc/Accept.html" title="Racc::Accept (class)"><code>Accept</code></a>,
        <a href="Racc/ActionTable.html" title="Racc::ActionTable (class)"><code>ActionTable</code></a>,
        <a href="Racc/CparseParams.html" title="Racc::CparseParams (class)"><code>CparseParams</code></a>,
        <a href="Racc/DebugFlags.html" title="Racc::DebugFlags (class)"><code>DebugFlags</code></a>,
        <a href="Racc/Goto.html" title="Racc::Goto (class)"><code>Goto</code></a>,
        <a href="Racc/Grammar.html" title="Racc::Grammar (class)"><code>Grammar</code></a>,
        <a href="Racc/GrammarFileParser.html" title="Racc::GrammarFileParser (class)"><code>GrammarFileParser</code></a>,
        <a href="Racc/GrammarFileScanner.html" title="Racc::GrammarFileScanner (class)"><code>GrammarFileScanner</code></a>,
        <a href="Racc/ISet.html" title="Racc::ISet (class)"><code>ISet</code></a>,
        <a href="Racc/Item.html" title="Racc::Item (class)"><code>Item</code></a>,
        <a href="Racc/LocationPointer.html" title="Racc::LocationPointer (class)"><code>LocationPointer</code></a>,
        <a href="Racc/LogFileGenerator.html" title="Racc::LogFileGenerator (class)"><code>LogFileGenerator</code></a>,
        <a href="Racc/OrMark.html" title="Racc::OrMark (class)"><code>OrMark</code></a>,
        <a href="Racc/Parser.html" title="Racc::Parser (class)"><code>Parser</code></a>,
        <a href="Racc/ParserClassGenerator.html" title="Racc::ParserClassGenerator (class)"><code>ParserClassGenerator</code></a>,
        <a href="Racc/ParserFileGenerator.html" title="Racc::ParserFileGenerator (class)"><code>ParserFileGenerator</code></a>,
        <a href="Racc/Prec.html" title="Racc::Prec (class)"><code>Prec</code></a>,
        <a href="Racc/RRconflict.html" title="Racc::RRconflict (class)"><code>RRconflict</code></a>,
        <a href="Racc/Reduce.html" title="Racc::Reduce (class)"><code>Reduce</code></a>,
        <a href="Racc/Rule.html" title="Racc::Rule (class)"><code>Rule</code></a>,
        <a href="Racc/SRconflict.html" title="Racc::SRconflict (class)"><code>SRconflict</code></a>,
        <a href="Racc/Shift.html" title="Racc::Shift (class)"><code>Shift</code></a>,
        <a href="Racc/SourceText.html" title="Racc::SourceText (class)"><code>SourceText</code></a>,
        <a href="Racc/State.html" title="Racc::State (class)"><code>State</code></a>,
        <a href="Racc/StateTransitionTable.html" title="Racc::StateTransitionTable (class)"><code>StateTransitionTable</code></a>,
        <a href="Racc/StateTransitionTableGenerator.html" title="Racc::StateTransitionTableGenerator (class)"><code>StateTransitionTableGenerator</code></a>,
        <a href="Racc/States.html" title="Racc::States (class)"><code>States</code></a>,
        <a href="Racc/Sym.html" title="Racc::Sym (class)"><code>Sym</code></a>,
        <a href="Racc/SymbolTable.html" title="Racc::SymbolTable (class)"><code>SymbolTable</code></a>,
        <a href="Racc/UserAction.html" title="Racc::UserAction (class)"><code>UserAction</code></a>      </div>
    </td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Exceptions:</div>
      <div class='box_11'>
          <a href="Racc/CompileError.html" title="Racc::CompileError (class)"><code>CompileError</code></a>,
        <a href="Racc/Error.html" title="Racc::Error (class)"><code>Error</code></a>,
        <a href="Racc/ParseError.html" title="Racc::ParseError (class)"><code>ParseError</code></a>      </div>
    </td></tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2 o'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/info.rb#L13'>lib/racc/info.rb</a><span class='defines'>,<br /><a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/ext/racc/cparse/cparse.c#L834'>ext/racc/cparse/cparse.c</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/debugflags.rb#L13'>lib/racc/debugflags.rb</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/exception.rb#L13'>lib/racc/exception.rb</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/grammar.rb#L20'>lib/racc/grammar.rb</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/grammarfileparser.rb#L20'>lib/racc/grammarfileparser.rb</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/iset.rb#L13'>lib/racc/iset.rb</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/logfilegenerator.rb#L13'>lib/racc/logfilegenerator.rb</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/parser-text.rb#L1'>lib/racc/parser-text.rb</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/parser.rb#L19'>lib/racc/parser.rb</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/parser.rb#L180'>lib/racc/parser.rb</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/parserfilegenerator.rb#L18'>lib/racc/parserfilegenerator.rb</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/sourcetext.rb#L13'>lib/racc/sourcetext.rb</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/state.rb#L18'>lib/racc/state.rb</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/statetransitiontable.rb#L15'>lib/racc/statetransitiontable.rb</a></span>
      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p><code>Racc</code> is a LALR(1) parser generator. It is written in Ruby itself, and generates Ruby programs.</p>

<h3 id="label-Command-line+Reference">Command-line Reference</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_racc'>racc</span> [<span class='op'>-</span><span class='id identifier rubyid_o'>o</span><span class='op'>&lt;</span><span class='id identifier rubyid_var'>var</span><span class='op'>&gt;</span><span class='id identifier rubyid_filename'>filename</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>var&gt;] [--output-file=&lt;var&gt;filename&lt;</span><span class='regexp_end'>/var</span></span><span class='op'>&gt;</span>]
     [<span class='op'>-</span><span class='id identifier rubyid_e'>e</span><span class='op'>&lt;</span><span class='id identifier rubyid_var'>var</span><span class='op'>&gt;</span><span class='id identifier rubyid_rubypath'>rubypath</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>var&gt;] [--executable=&lt;var&gt;rubypath&lt;</span><span class='regexp_end'>/var</span></span><span class='op'>&gt;</span>]
     [<span class='op'>-</span><span class='id identifier rubyid_v'>v</span>] [<span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_verbose'>verbose</span>]
     [<span class='op'>-</span><span class='const'>O</span><span class='op'>&lt;</span><span class='id identifier rubyid_var'>var</span><span class='op'>&gt;</span><span class='id identifier rubyid_filename'>filename</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>var&gt;] [--log-file=&lt;var&gt;filename&lt;</span><span class='regexp_end'>/var</span></span><span class='op'>&gt;</span>]
     [<span class='op'>-</span><span class='id identifier rubyid_g'>g</span>] [<span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_debug'>debug</span>]
     [<span class='op'>-</span><span class='const'>E</span>] [<span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_embedded'>embedded</span>]
     [<span class='op'>-</span><span class='id identifier rubyid_l'>l</span>] [<span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_no'>no</span><span class='op'>-</span><span class='id identifier rubyid_line'>line</span><span class='op'>-</span><span class='id identifier rubyid_convert'>convert</span>]
     [<span class='op'>-</span><span class='id identifier rubyid_c'>c</span>] [<span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_line'>line</span><span class='op'>-</span><span class='id identifier rubyid_convert'>convert</span><span class='op'>-</span><span class='id identifier rubyid_all'>all</span>]
     [<span class='op'>-</span><span class='id identifier rubyid_a'>a</span>] [<span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_no'>no</span><span class='op'>-</span><span class='id identifier rubyid_omit'>omit</span><span class='op'>-</span><span class='id identifier rubyid_actions'>actions</span>]
     [<span class='op'>-</span><span class='const'>C</span>] [<span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_check'>check</span><span class='op'>-</span><span class='id identifier rubyid_only'>only</span>]
     [<span class='op'>-</span><span class='const'>S</span>] [<span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_output'>output</span><span class='op'>-</span><span class='id identifier rubyid_status'>status</span>]
     [<span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_version'>version</span>] [<span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_copyright'>copyright</span>] [<span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_help'>help</span>] <span class='op'>&lt;</span><span class='id identifier rubyid_var'>var</span><span class='op'>&gt;</span><span class='id identifier rubyid_grammarfile'>grammarfile</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>var&gt;</span></code></pre>
<dl class="rdoc-list label-list"><dt><code>grammarfile</code></dt>
<dd>
<p>Racc grammar file. Any extension is permitted.</p>
</dd><dt>-o+outfile+, –output-file=<code>outfile</code></dt>
<dd>
<p>A filename for output. default is &lt;<code>filename</code>&gt;.tab.rb</p>
</dd><dt>-O+filename+, –log-file=<code>filename</code></dt>
<dd>
<p>Place logging output in file <code>filename</code>. Default log file name is &lt;<code>filename</code>&gt;.output.</p>
</dd><dt>-e+rubypath+, –executable=<code>rubypath</code></dt>
<dd>
<p>output executable file(mode 755). where <code>path</code> is the Ruby interpreter.</p>
</dd><dt>-v, –verbose</dt>
<dd>
<p>verbose mode. create <code>filename</code>.output file, like yacc’s y.output file.</p>
</dd><dt>-g, –debug</dt>
<dd>
<p>add debug code to parser class. To display debuggin information, use this ‘-g’ option and set @yydebug true in parser class.</p>
</dd><dt>-E, –embedded</dt>
<dd>
<p>Output parser which doesn’t need runtime files (racc/parser.rb).</p>
</dd><dt>-C, –check-only</dt>
<dd>
<p>Check syntax of racc grammar file and quit.</p>
</dd><dt>-S, –output-status</dt>
<dd>
<p>Print messages time to time while compiling.</p>
</dd><dt>-l, –no-line-convert</dt>
<dd>
<p>turns off line number converting.</p>
</dd><dt>-c, –line-convert-all</dt>
<dd>
<p>Convert line number of actions, inner, header and footer.</p>
</dd><dt>-a, –no-omit-actions</dt>
<dd>
<p>Call all actions, even if an action is empty.</p>
</dd><dt>–version</dt>
<dd>
<p>print Racc version and quit.</p>
</dd><dt>–copyright</dt>
<dd>
<p>Print copyright and quit.</p>
</dd><dt>–help</dt>
<dd>
<p>Print usage and quit.</p>
</dd></dl>

<h3 id="label-Generating+Parser+Using+Racc">Generating Parser Using Racc</h3>

<p>To compile <code>Racc</code> grammar file, simply type:</p>

<pre class="code ruby"><code class="ruby"><span class='gvar'>$ </span><span class='id identifier rubyid_racc'>racc</span> <span class='id identifier rubyid_parse'>parse</span>.<span class='id identifier rubyid_y'>y</span></code></pre>

<p>This creates Ruby script file “parse.tab.y”. The -o option can change the output filename.</p>

<h3 id="label-Writing+A+Racc+Grammar+File">Writing A Racc Grammar File</h3>

<p>If you want your own parser, you have to write a grammar file. A grammar file contains the name of your parser class, grammar for the parser, user code, and anything else. When writing a grammar file, yacc’s knowledge is helpful. If you have not used yacc before, <code>Racc</code> is not too difficult.</p>

<p>Here’s an example <code>Racc</code> grammar file.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Calcparser</span>
<span class='id identifier rubyid_rule'>rule</span>
  <span class='id identifier rubyid_target'>target</span><span class='op'>:</span> <span class='id identifier rubyid_exp'>exp</span> { <span class='id identifier rubyid_print'>print</span> <span class='id identifier rubyid_val'>val</span>[<span class='int'>0</span>] }

  <span class='id identifier rubyid_exp'>exp</span><span class='op'>:</span> <span class='id identifier rubyid_exp'>exp</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>+</span><span class='tstring_end'>&#39;</span></span> <span class='id identifier rubyid_exp'>exp</span>
     <span class='op'>|</span> <span class='id identifier rubyid_exp'>exp</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>*</span><span class='tstring_end'>&#39;</span></span> <span class='id identifier rubyid_exp'>exp</span>
     <span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>(</span><span class='tstring_end'>&#39;</span></span> <span class='id identifier rubyid_exp'>exp</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>)</span><span class='tstring_end'>&#39;</span></span>
     <span class='op'>|</span> <span class='const'>NUMBER</span>
<span class='kw'>end</span></code></pre>

<p><code>Racc</code> grammar files resemble yacc files. But (of course), this is Ruby code. yacc’s $$ is the ‘result’, $0, $1… is an array called ‘val’, and $-1, $-2… is an array called ‘_values’.</p>

<p>See the <a href="file.lib_2Fracc_2Frdoc_2Fgrammar.en.html" title="{Racc::Grammar">{Racc::Grammar</a> File Reference} for more information on grammar files.</p>

<h3 id="label-Parser">Parser</h3>

<p>Then you must prepare the parse entry method. There are two types of parse methods in <code>Racc</code>, <code>Racc::Parser#do_parse</code> and <code>Racc::Parser#yyparse</code></p>

<p><code>Racc::Parser#do_parse</code> is simple.</p>

<p>It’s yyparse() of yacc, and <a href="Racc/Parser.html#next_token-instance_method" title="Racc::Parser#next_token (method)">Parser#next_token</a> is yylex(). This method must returns an array like [TOKENSYMBOL, ITS_VALUE]. EOF is [false, false]. (TOKENSYMBOL is a Ruby symbol (taken from <code>String#intern</code>) by default. If you want to change this, see the grammar reference.</p>

<p><code>Racc::Parser#yyparse</code> is little complicated, but useful. It does not use <a href="Racc/Parser.html#next_token-instance_method" title="Racc::Parser#next_token (method)">Parser#next_token</a>, instead it gets tokens from any iterator.</p>

<p>For example, <code>yyparse(obj, :scan)</code> causes calling <code>obj#scan</code>, and you can return tokens by yielding them from <code>obj#scan</code>.</p>

<h3 id="label-Debugging">Debugging</h3>

<p>When debugging, “-v” or/and the “-g” option is helpful.</p>

<p>“-v” creates verbose log file (.output). “-g” creates a “Verbose Parser”. Verbose Parser prints the internal status when parsing. But it’s <em>not</em> automatic. You must use -g option and set <code>@yydebug</code> to <code>true</code> in order to get output. -g option only creates the verbose parser.</p>

<h4 id="label-Racc+reported+syntax+error.">Racc reported syntax error.</h4>

<p>Isn’t there too many “end”? grammar of racc file is changed in v0.10.</p>

<p><code>Racc</code> does not use ‘%’ mark, while yacc uses huge number of ‘%’ marks..</p>

<h4 id="label-Racc+reported+-22XXXX+conflicts-22.">Racc reported “XXXX conflicts”.</h4>

<p>Try “racc -v xxxx.y”. It causes producing racc’s internal log file, xxxx.output.</p>

<h4 id="label-Generated+parsers+does+not+work+correctly">Generated parsers does not work correctly</h4>

<p>Try “racc -g xxxx.y”. This command let racc generate “debugging parser”. Then set @yydebug=true in your parser. It produces a working log of your parser.</p>

<h3 id="label-Re-distributing+Racc+runtime">Re-distributing Racc runtime</h3>

<p>A parser, which is created by <code>Racc</code>, requires the <code>Racc</code> runtime module; racc/parser.rb.</p>

<p>Ruby 1.8.x comes with <code>Racc</code> runtime module, you need NOT distribute <code>Racc</code> runtime files.</p>

<p>If you want to include the <code>Racc</code> runtime module with your parser. This can be done by using ‘-E’ option:</p>

<pre class="code ruby"><code class="ruby"><span class='gvar'>$ </span><span class='id identifier rubyid_racc'>racc</span> <span class='op'>-</span><span class='const'>E</span> <span class='op'>-</span><span class='id identifier rubyid_omyparser'>omyparser</span>.<span class='id identifier rubyid_rb'>rb</span> <span class='id identifier rubyid_myparser'>myparser</span>.<span class='id identifier rubyid_y'>y</span></code></pre>

<p>This command creates myparser.rb which ‘includes’ <code>Racc</code> runtime. Only you must do is to distribute your parser file (myparser.rb).</p>

<p>Note: parser.rb is ruby license, but your parser is not. Your own parser is completely yours.</p>

  </div>
</div>
</div>
<h2 id='t2_cnst' class='h2_sum'>Constant Summary</h2>
<div>
<ul class='constants summary full'>
  <li>
    <span id='Copyright-constant' class='summary_signature'>Copyright =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/info.rb#L16-L16'># File 'lib/racc/info.rb', line 16</a>    <pre class='code ruby'><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Copyright (c) 1999-2006 Minero Aoki</span><span class='tstring_end'>&#39;</span></span></pre>
  </li>
  <li>
    <span id='PARSER_TEXT-constant' class='summary_signature nodoc'>PARSER_TEXT =</span>
    <span class='nodoc note title'>Internal use only</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/parser-text.rb#L2-L636'># File 'lib/racc/parser-text.rb', line 2</a>    <pre class='code ruby'><span class='heredoc_beg'>&lt;&lt;&#39;__end_of_file__&#39;</span>
<span class='tstring_content'># frozen_string_literal: false
#--
# Copyright (c) 1999-2006 Minero Aoki
#
# This program is free software.
# You can distribute/modify this program under the same terms of ruby.
#
# As a special exception, when this code is copied by Racc
# into a Racc output file, you may use that output file
# without restriction.
#++

require &#39;racc/info&#39;

unless defined?(NotImplementedError)
  NotImplementedError = NotImplementError # :nodoc:
end

module Racc
  class ParseError &lt; StandardError; end
end
unless defined?(::ParseError)
  ParseError = Racc::ParseError
end

# Racc is a LALR(1) parser generator.
# It is written in Ruby itself, and generates Ruby programs.
#
# == Command-line Reference
#
#     racc [-o&lt;var&gt;filename&lt;/var&gt;] [--output-file=&lt;var&gt;filename&lt;/var&gt;]
#          [-e&lt;var&gt;rubypath&lt;/var&gt;] [--executable=&lt;var&gt;rubypath&lt;/var&gt;]
#          [-v] [--verbose]
#          [-O&lt;var&gt;filename&lt;/var&gt;] [--log-file=&lt;var&gt;filename&lt;/var&gt;]
#          [-g] [--debug]
#          [-E] [--embedded]
#          [-l] [--no-line-convert]
#          [-c] [--line-convert-all]
#          [-a] [--no-omit-actions]
#          [-C] [--check-only]
#          [-S] [--output-status]
#          [--version] [--copyright] [--help] &lt;var&gt;grammarfile&lt;/var&gt;
#
# [grammarfile]
#   Racc grammar file. Any extension is permitted.
# [-ooutfile, --output-file=outfile]
#   A filename for output. default is &lt;filename&gt;.tab.rb
# [-Ofilename, --log-file=filename]
#   Place logging output in file filename.
#   Default log file name is &lt;filename&gt;.output.
# [-erubypath, --executable=rubypath]
#   output executable file(mode 755). where path is the Ruby interpreter.
# [-v, --verbose]
#   verbose mode. create filename.output file, like yacc&#39;s y.output file.
# [-g, --debug]
#   add debug code to parser class. To display debuggin information,
#   use this &#39;-g&#39; option and set @yydebug true in parser class.
# [-E, --embedded]
#   Output parser which doesn&#39;t need runtime files (racc/parser.rb).
# [-C, --check-only]
#   Check syntax of racc grammar file and quit.
# [-S, --output-status]
#   Print messages time to time while compiling.
# [-l, --no-line-convert]
#   turns off line number converting.
# [-c, --line-convert-all]
#   Convert line number of actions, inner, header and footer.
# [-a, --no-omit-actions]
#   Call all actions, even if an action is empty.
# [--version]
#   print Racc version and quit.
# [--copyright]
#   Print copyright and quit.
# [--help]
#   Print usage and quit.
#
# == Generating Parser Using Racc
#
# To compile Racc grammar file, simply type:
#
#   $ racc parse.y
#
# This creates Ruby script file &quot;parse.tab.y&quot;. The -o option can change the output filename.
#
# == Writing A Racc Grammar File
#
# If you want your own parser, you have to write a grammar file.
# A grammar file contains the name of your parser class, grammar for the parser,
# user code, and anything else.
# When writing a grammar file, yacc&#39;s knowledge is helpful.
# If you have not used yacc before, Racc is not too difficult.
#
# Here&#39;s an example Racc grammar file.
#
#   class Calcparser
#   rule
#     target: exp { print val[0] }
#
#     exp: exp &#39;+&#39; exp
#        | exp &#39;*&#39; exp
#        | &#39;(&#39; exp &#39;)&#39;
#        | NUMBER
#   end
#
# Racc grammar files resemble yacc files.
# But (of course), this is Ruby code.
# yacc&#39;s $$ is the &#39;result&#39;, $0, $1... is
# an array called &#39;val&#39;, and $-1, $-2... is an array called &#39;_values&#39;.
#
# See the {Grammar File Reference}[rdoc-ref:lib/racc/rdoc/grammar.en.rdoc] for
# more information on grammar files.
#
# == Parser
#
# Then you must prepare the parse entry method. There are two types of
# parse methods in Racc, Racc::Parser#do_parse and Racc::Parser#yyparse
#
# Racc::Parser#do_parse is simple.
#
# It&#39;s yyparse() of yacc, and Racc::Parser#next_token is yylex().
# This method must returns an array like [TOKENSYMBOL, ITS_VALUE].
# EOF is [false, false].
# (TOKENSYMBOL is a Ruby symbol (taken from String#intern) by default.
# If you want to change this, see the grammar reference.
#
# Racc::Parser#yyparse is little complicated, but useful.
# It does not use Racc::Parser#next_token, instead it gets tokens from any iterator.
#
# For example, &lt;code&gt;yyparse(obj, :scan)&lt;/code&gt; causes
# calling obj#scan, and you can return tokens by yielding them from obj#scan.
#
# == Debugging
#
# When debugging, &quot;-v&quot; or/and the &quot;-g&quot; option is helpful.
#
# &quot;-v&quot; creates verbose log file (.output).
# &quot;-g&quot; creates a &quot;Verbose Parser&quot;.
# Verbose Parser prints the internal status when parsing.
# But it&#39;s _not_ automatic.
# You must use -g option and set @yydebug to true in order to get output.
# -g option only creates the verbose parser.
#
# === Racc reported syntax error.
#
# Isn&#39;t there too many &quot;end&quot;?
# grammar of racc file is changed in v0.10.
#
# Racc does not use &#39;%&#39; mark, while yacc uses huge number of &#39;%&#39; marks..
#
# === Racc reported &quot;XXXX conflicts&quot;.
#
# Try &quot;racc -v xxxx.y&quot;.
# It causes producing racc&#39;s internal log file, xxxx.output.
#
# === Generated parsers does not work correctly
#
# Try &quot;racc -g xxxx.y&quot;.
# This command let racc generate &quot;debugging parser&quot;.
# Then set @yydebug=true in your parser.
# It produces a working log of your parser.
#
# == Re-distributing Racc runtime
#
# A parser, which is created by Racc, requires the Racc runtime module;
# racc/parser.rb.
#
# Ruby 1.8.x comes with Racc runtime module,
# you need NOT distribute Racc runtime files.
#
# If you want to include the Racc runtime module with your parser.
# This can be done by using &#39;-E&#39; option:
#
#   $ racc -E -omyparser.rb myparser.y
#
# This command creates myparser.rb which `includes&#39; Racc runtime.
# Only you must do is to distribute your parser file (myparser.rb).
#
# Note: parser.rb is ruby license, but your parser is not.
# Your own parser is completely yours.
module Racc

  unless defined?(Racc_No_Extensions)
    Racc_No_Extensions = false # :nodoc:
  end

  class Parser

    Racc_Runtime_Version = ::Racc::VERSION
    Racc_Runtime_Core_Version_R = ::Racc::VERSION

    begin
      if Object.const_defined?(:RUBY_ENGINE) and RUBY_ENGINE == &#39;jruby&#39;
        require &#39;jruby&#39;
        require &#39;racc/cparse-jruby.jar&#39;
        com.headius.racc.Cparse.new.load(JRuby.runtime, false)
      else
        require &#39;racc/cparse&#39;
      end

      unless new.respond_to?(:_racc_do_parse_c, true)
        raise LoadError, &#39;old cparse.so&#39;
      end
      if Racc_No_Extensions
        raise LoadError, &#39;selecting ruby version of racc runtime core&#39;
      end

      Racc_Main_Parsing_Routine    = :_racc_do_parse_c # :nodoc:
      Racc_YY_Parse_Method         = :_racc_yyparse_c # :nodoc:
      Racc_Runtime_Core_Version    = Racc_Runtime_Core_Version_C # :nodoc:
      Racc_Runtime_Type            = &#39;c&#39; # :nodoc:
    rescue LoadError
      Racc_Main_Parsing_Routine    = :_racc_do_parse_rb
      Racc_YY_Parse_Method         = :_racc_yyparse_rb
      Racc_Runtime_Core_Version    = Racc_Runtime_Core_Version_R
      Racc_Runtime_Type            = &#39;ruby&#39;
    end

    def Parser.racc_runtime_type # :nodoc:
      Racc_Runtime_Type
    end

    def _racc_setup
      @yydebug = false unless self.class::Racc_debug_parser
      @yydebug = false unless defined?(@yydebug)
      if @yydebug
        @racc_debug_out = $stderr unless defined?(@racc_debug_out)
        @racc_debug_out ||= $stderr
      end
      arg = self.class::Racc_arg
      arg[13] = true if arg.size &lt; 14
      arg
    end

    def _racc_init_sysvars
      @racc_state  = [0]
      @racc_tstack = []
      @racc_vstack = []

      @racc_t = nil
      @racc_val = nil

      @racc_read_next = true

      @racc_user_yyerror = false
      @racc_error_status = 0
    end

    # The entry point of the parser. This method is used with #next_token.
    # If Racc wants to get token (and its value), calls next_token.
    #
    # Example:
    #     def parse
    #       @q = [[1,1],
    #             [2,2],
    #             [3,3],
    #             [false, &#39;$&#39;]]
    #       do_parse
    #     end
    #
    #     def next_token
    #       @q.shift
    #     end
    class_eval %{
    def do_parse
      #{Racc_Main_Parsing_Routine}(_racc_setup(), false)
    end
    }

    # The method to fetch next token.
    # If you use #do_parse method, you must implement #next_token.
    #
    # The format of return value is [TOKEN_SYMBOL, VALUE].
    # token-symbol is represented by Ruby&#39;s symbol by default, e.g. :IDENT
    # for &#39;IDENT&#39;.  &quot;;&quot; (String) for &#39;;&#39;.
    #
    # The final symbol (End of file) must be false.
    def next_token
      raise NotImplementedError, &quot;#{self.class}\#next_token is not defined&quot;
    end

    def _racc_do_parse_rb(arg, in_debug)
      action_table, action_check, action_default, action_pointer,
      _,            _,            _,              _,
      _,            _,            token_table,    * = arg

      _racc_init_sysvars
      tok = act = i = nil

      catch(:racc_end_parse) {
        while true
          if i = action_pointer[@racc_state[-1]]
            if @racc_read_next
              if @racc_t != 0   # not EOF
                tok, @racc_val = next_token()
                unless tok      # EOF
                  @racc_t = 0
                else
                  @racc_t = (token_table[tok] or 1)   # error token
                end
                racc_read_token(@racc_t, tok, @racc_val) if @yydebug
                @racc_read_next = false
              end
            end
            i += @racc_t
            unless i &gt;= 0 and
                   act = action_table[i] and
                   action_check[i] == @racc_state[-1]
              act = action_default[@racc_state[-1]]
            end
          else
            act = action_default[@racc_state[-1]]
          end
          while act = _racc_evalact(act, arg)
            ;
          end
        end
      }
    end

    # Another entry point for the parser.
    # If you use this method, you must implement RECEIVER#METHOD_ID method.
    #
    # RECEIVER#METHOD_ID is a method to get next token.
    # It must &#39;yield&#39; the token, which format is [TOKEN-SYMBOL, VALUE].
    class_eval %{
    def yyparse(recv, mid)
      #{Racc_YY_Parse_Method}(recv, mid, _racc_setup(), false)
    end
    }

    def _racc_yyparse_rb(recv, mid, arg, c_debug)
      action_table, action_check, action_default, action_pointer,
      _,            _,            _,              _,
      _,            _,            token_table,    * = arg

      _racc_init_sysvars

      catch(:racc_end_parse) {
        until i = action_pointer[@racc_state[-1]]
          while act = _racc_evalact(action_default[@racc_state[-1]], arg)
            ;
          end
        end
        recv.__send__(mid) do |tok, val|
          unless tok
            @racc_t = 0
          else
            @racc_t = (token_table[tok] or 1)   # error token
          end
          @racc_val = val
          @racc_read_next = false

          i += @racc_t
          unless i &gt;= 0 and
                 act = action_table[i] and
                 action_check[i] == @racc_state[-1]
            act = action_default[@racc_state[-1]]
          end
          while act = _racc_evalact(act, arg)
            ;
          end

          while !(i = action_pointer[@racc_state[-1]]) ||
                ! @racc_read_next ||
                @racc_t == 0  # $
            unless i and i += @racc_t and
                   i &gt;= 0 and
                   act = action_table[i] and
                   action_check[i] == @racc_state[-1]
              act = action_default[@racc_state[-1]]
            end
            while act = _racc_evalact(act, arg)
              ;
            end
          end
        end
      }
    end

    ###
    ### common
    ###

    def _racc_evalact(act, arg)
      action_table, action_check, _, action_pointer,
      _,            _,            _, _,
      _,            _,            _, shift_n,
      reduce_n,     * = arg
      nerr = 0   # tmp

      if act &gt; 0 and act &lt; shift_n
        #
        # shift
        #
        if @racc_error_status &gt; 0
          @racc_error_status -= 1 unless @racc_t &lt;= 1 # error token or EOF
        end
        @racc_vstack.push @racc_val
        @racc_state.push act
        @racc_read_next = true
        if @yydebug
          @racc_tstack.push @racc_t
          racc_shift @racc_t, @racc_tstack, @racc_vstack
        end

      elsif act &lt; 0 and act &gt; -reduce_n
        #
        # reduce
        #
        code = catch(:racc_jump) {
          @racc_state.push _racc_do_reduce(arg, act)
          false
        }
        if code
          case code
          when 1 # yyerror
            @racc_user_yyerror = true   # user_yyerror
            return -reduce_n
          when 2 # yyaccept
            return shift_n
          else
            raise &#39;[Racc Bug] unknown jump code&#39;
          end
        end

      elsif act == shift_n
        #
        # accept
        #
        racc_accept if @yydebug
        throw :racc_end_parse, @racc_vstack[0]

      elsif act == -reduce_n
        #
        # error
        #
        case @racc_error_status
        when 0
          unless arg[21]    # user_yyerror
            nerr += 1
            on_error @racc_t, @racc_val, @racc_vstack
          end
        when 3
          if @racc_t == 0   # is $
            # We&#39;re at EOF, and another error occurred immediately after
            # attempting auto-recovery
            throw :racc_end_parse, nil
          end
          @racc_read_next = true
        end
        @racc_user_yyerror = false
        @racc_error_status = 3
        while true
          if i = action_pointer[@racc_state[-1]]
            i += 1   # error token
            if  i &gt;= 0 and
                (act = action_table[i]) and
                action_check[i] == @racc_state[-1]
              break
            end
          end
          throw :racc_end_parse, nil if @racc_state.size &lt;= 1
          @racc_state.pop
          @racc_vstack.pop
          if @yydebug
            @racc_tstack.pop
            racc_e_pop @racc_state, @racc_tstack, @racc_vstack
          end
        end
        return act

      else
        raise &quot;[Racc Bug] unknown action #{act.inspect}&quot;
      end

      racc_next_state(@racc_state[-1], @racc_state) if @yydebug

      nil
    end

    def _racc_do_reduce(arg, act)
      _,          _,            _,            _,
      goto_table, goto_check,   goto_default, goto_pointer,
      nt_base,    reduce_table, _,            _,
      _,          use_result,   * = arg

      state = @racc_state
      vstack = @racc_vstack
      tstack = @racc_tstack

      i = act * -3
      len       = reduce_table[i]
      reduce_to = reduce_table[i+1]
      method_id = reduce_table[i+2]
      void_array = []

      tmp_t = tstack[-len, len] if @yydebug
      tmp_v = vstack[-len, len]
      tstack[-len, len] = void_array if @yydebug
      vstack[-len, len] = void_array
      state[-len, len]  = void_array

      # tstack must be updated AFTER method call
      if use_result
        vstack.push __send__(method_id, tmp_v, vstack, tmp_v[0])
      else
        vstack.push __send__(method_id, tmp_v, vstack)
      end
      tstack.push reduce_to

      racc_reduce(tmp_t, reduce_to, tstack, vstack) if @yydebug

      k1 = reduce_to - nt_base
      if i = goto_pointer[k1]
        i += state[-1]
        if i &gt;= 0 and (curstate = goto_table[i]) and goto_check[i] == k1
          return curstate
        end
      end
      goto_default[k1]
    end

    # This method is called when a parse error is found.
    #
    # ERROR_TOKEN_ID is an internal ID of token which caused error.
    # You can get string representation of this ID by calling
    # #token_to_str.
    #
    # ERROR_VALUE is a value of error token.
    #
    # value_stack is a stack of symbol values.
    # DO NOT MODIFY this object.
    #
    # This method raises ParseError by default.
    #
    # If this method returns, parsers enter &quot;error recovering mode&quot;.
    def on_error(t, val, vstack)
      raise ParseError, sprintf(&quot;\nparse error on value %s (%s)&quot;,
                                val.inspect, token_to_str(t) || &#39;?&#39;)
    end

    # Enter error recovering mode.
    # This method does not call #on_error.
    def yyerror
      throw :racc_jump, 1
    end

    # Exit parser.
    # Return value is Symbol_Value_Stack[0].
    def yyaccept
      throw :racc_jump, 2
    end

    # Leave error recovering mode.
    def yyerrok
      @racc_error_status = 0
    end

    # For debugging output
    def racc_read_token(t, tok, val)
      @racc_debug_out.print &#39;read    &#39;
      @racc_debug_out.print tok.inspect, &#39;(&#39;, racc_token2str(t), &#39;) &#39;
      @racc_debug_out.puts val.inspect
      @racc_debug_out.puts
    end

    def racc_shift(tok, tstack, vstack)
      @racc_debug_out.puts &quot;shift   #{racc_token2str tok}&quot;
      racc_print_stacks tstack, vstack
      @racc_debug_out.puts
    end

    def racc_reduce(toks, sim, tstack, vstack)
      out = @racc_debug_out
      out.print &#39;reduce &#39;
      if toks.empty?
        out.print &#39; &lt;none&gt;&#39;
      else
        toks.each {|t| out.print &#39; &#39;, racc_token2str(t) }
      end
      out.puts &quot; --&gt; #{racc_token2str(sim)}&quot;
      racc_print_stacks tstack, vstack
      @racc_debug_out.puts
    end

    def racc_accept
      @racc_debug_out.puts &#39;accept&#39;
      @racc_debug_out.puts
    end

    def racc_e_pop(state, tstack, vstack)
      @racc_debug_out.puts &#39;error recovering mode: pop token&#39;
      racc_print_states state
      racc_print_stacks tstack, vstack
      @racc_debug_out.puts
    end

    def racc_next_state(curstate, state)
      @racc_debug_out.puts  &quot;goto    #{curstate}&quot;
      racc_print_states state
      @racc_debug_out.puts
    end

    def racc_print_stacks(t, v)
      out = @racc_debug_out
      out.print &#39;        [&#39;
      t.each_index do |i|
        out.print &#39; (&#39;, racc_token2str(t[i]), &#39; &#39;, v[i].inspect, &#39;)&#39;
      end
      out.puts &#39; ]&#39;
    end

    def racc_print_states(s)
      out = @racc_debug_out
      out.print &#39;        [&#39;
      s.each {|st| out.print &#39; &#39;, st }
      out.puts &#39; ]&#39;
    end

    def racc_token2str(tok)
      self.class::Racc_token_to_s_table[tok] or
          raise &quot;[Racc Bug] can&#39;t convert token #{tok} to string&quot;
    end

    # Convert internal ID of token symbol to the string.
    def token_to_str(t)
      self.class::Racc_token_to_s_table[t]
    end

  end

end

</span><span class='heredoc_end'>__end_of_file__</span></pre>
  </li>
  <li>
    <span id='Racc_No_Extensions-constant' class='summary_signature nodoc'>Racc_No_Extensions =</span>
    <span class='nodoc note title'>Internal use only</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/parser.rb#L183-L183'># File 'lib/racc/parser.rb', line 183</a>    <pre class='code ruby'><span class='kw'>false</span></pre>
  </li>
  <li>
    <span id='VERSION-constant' class='summary_signature'>VERSION =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/info.rb#L14-L14'># File 'lib/racc/info.rb', line 14</a>    <pre class='code ruby'><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>1.6.0</span><span class='tstring_end'>&#39;</span></span></pre>
  </li>
  <li>
    <span id='Version-constant' class='summary_signature'>Version =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_1_7/lib/racc/info.rb#L15-L15'># File 'lib/racc/info.rb', line 15</a>    <pre class='code ruby'><span class='const'><a href="#VERSION-constant" title="Racc::VERSION (constant)">VERSION</a></span></pre>
  </li>
</ul>
</div>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>