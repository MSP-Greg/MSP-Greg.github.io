<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: Prism::ParseResult::Comments &mdash; prism  Ruby-3.3.9 p170</title>

<link rel='stylesheet'  type='text/css' href='../../../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Prism::ParseResult::Comments",
    relpath = '../../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../../../'>Ruby-3.3.9</a> &raquo; 
      <a href='../../'>prism</a> &raquo; 
      <a href='../../_index.html#alpha_C'>Index (C)</a> &raquo; 
        <a href="../../Prism.html" title="Prism (module)">Prism</a> &raquo; 
        <a href="../ParseResult.html" title="Prism::ParseResult (class)">ParseResult</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>Comments&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: Prism::ParseResult::Comments</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Namespace Children</td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Classes:</div>
      <div class='box_11'>
          <a class='nodoc' href="Comments/LocationTarget.html" title="Prism::ParseResult::Comments::LocationTarget (class)"><code>LocationTarget</code></a>,
        <a class='nodoc' href="Comments/NodeTarget.html" title="Prism::ParseResult::Comments::NodeTarget (class)"><code>NodeTarget</code></a>      </div>
    </td></tr>
    <tr>
      <td id='t2_inherits' class='box_2'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'>Object</span>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby/ruby/blob/v3_3_9/lib/prism/parse_result/comments.rb#L19'>lib/prism/parse_result/comments.rb</a>      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p>When we’ve parsed the source, we have both the syntax tree and the list of comments that we found in the source. This class is responsible for walking the tree and finding the nearest location to attach each comment.</p>

<p>It does this by first finding the nearest locations to each comment. Locations can either come from nodes directly or from location fields on nodes. For example, a <code>ClassNode</code> has an overall location encompassing the entire class, but it also has a location for the <code>class</code> keyword.</p>

<p>Once the nearest locations are found, it determines which one to attach to. If it’s a trailing comment (a comment on the same line as other source code), it will favor attaching to the nearest location that occurs before the comment. Otherwise it will favor attaching to the nearest location that is after the comment.</p>

  </div>
</div>
</div>
<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#new-class_method" title=".new (class method)">.<strong>new</strong>(parse_result)  &#x21d2; Comments </a>
    </span>
    <span class='note title constructor'>constructor</span>
    <div class='summary_desc'>
      <div class='inline'><p>Create a new <code>Comments</code> object that will attach comments to the given parse result.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_attribute_summary'>Instance Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature ro'>
      <a href="#parse_result-instance_method" title="#parse_result (instance method)">#<strong>parse_result</strong>  </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>The parse result that we are attaching comments to.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- instance_attribute_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#attach!-instance_method" title="#attach! (instance method)">#<strong>attach!</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Attach the comments to their respective locations in the tree by mutating the parse result.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#nearest_targets-instance_method" title="#nearest_targets (instance method)">#<strong>nearest_targets</strong>(node, comment)  </a>
    </span>
    <span class='note title private'>private</span>
    <div class='summary_desc'>
      <div class='inline'><p>Responsible for finding the nearest targets to the given comment within the context of the given encapsulating node.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- instance_method_summary -->
<h2 id='Constructor_Details' class='y_details'>Constructor Details</h2>

  <section class='method_details first' id="new-class_method">
  <h3 class='signature  first'>
    .<strong>new</strong>(parse_result)  &#x21d2; <code>Comments</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Create a new <code>Comments</code> object that will attach comments to the given parse result.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_3_9/lib/prism/parse_result/comments.rb#L78-L80'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='78' data-end='80'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/prism/parse_result/comments.rb', line 78</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span>(<span class='id identifier rubyid_parse_result'><a href="#parse_result-instance_method" title="Prism::ParseResult::Comments#parse_result (method)">parse_result</a></span>)
  <span class='ivar'>@parse_result</span> <span class='op'>=</span> <span class='id identifier rubyid_parse_result'><a href="#parse_result-instance_method" title="Prism::ParseResult::Comments#parse_result (method)">parse_result</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Attribute Details</h2>
<section class='method_details first' id="parse_result-instance_method">
  <h3 class='signature ro first'>
    #<strong>parse_result</strong>   <span class="extras">(<span class='readonly'>readonly</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>The parse result that we are attaching comments to.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_3_9/lib/prism/parse_result/comments.rb#L74-L74'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='74' data-end='74'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/prism/parse_result/comments.rb', line 74</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_attr_reader'>attr_reader</span> <span class='symbeg'>:</span><span class='id identifier rubyid_parse_result'>parse_result</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="attach!-instance_method">
  <h3 class='signature  first'>
    #<strong>attach!</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Attach the comments to their respective locations in the tree by mutating the parse result.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_3_9/lib/prism/parse_result/comments.rb#L84-L97'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='84' data-end='97'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/prism/parse_result/comments.rb', line 84</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_attach!'>attach!</span>
  <span class='id identifier rubyid_parse_result'><a href="#parse_result-instance_method" title="Prism::ParseResult::Comments#parse_result (method)">parse_result</a></span>.<span class='id identifier rubyid_comments'><a href="../ParseResult.html#comments-instance_method" title="Prism::ParseResult#comments (method)">comments</a></span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_comment'>comment</span><span class='op'>|</span>
    <span class='id identifier rubyid_preceding'>preceding</span><span class='comma'>,</span> <span class='id identifier rubyid_enclosing'>enclosing</span><span class='comma'>,</span> <span class='id identifier rubyid_following'>following</span> <span class='op'>=</span> <span class='id identifier rubyid_nearest_targets'><a href="#nearest_targets-instance_method" title="Prism::ParseResult::Comments#nearest_targets (method)">nearest_targets</a></span>(<span class='id identifier rubyid_parse_result'><a href="#parse_result-instance_method" title="Prism::ParseResult::Comments#parse_result (method)">parse_result</a></span>.<span class='id identifier rubyid_value'><a href="../ParseResult.html#value-instance_method" title="Prism::ParseResult#value (method)">value</a></span><span class='comma'>,</span> <span class='id identifier rubyid_comment'>comment</span>)
    <span class='id identifier rubyid_target'>target</span> <span class='op'>=</span>
      <span class='kw'>if</span> <span class='id identifier rubyid_comment'>comment</span>.<span class='id identifier rubyid_trailing?'>trailing?</span>
        <span class='id identifier rubyid_preceding'>preceding</span> <span class='op'>||</span> <span class='id identifier rubyid_following'>following</span> <span class='op'>||</span> <span class='id identifier rubyid_enclosing'>enclosing</span> <span class='op'>||</span> <span class='const'><a href="Comments/NodeTarget.html" title="Prism::ParseResult::Comments::NodeTarget (class)">NodeTarget</a></span>.<span class='id identifier rubyid_new'><a href="Comments/NodeTarget.html#new-class_method" title="Prism::ParseResult::Comments::NodeTarget.new (method)">new</a></span>(<span class='id identifier rubyid_parse_result'><a href="#parse_result-instance_method" title="Prism::ParseResult::Comments#parse_result (method)">parse_result</a></span>.<span class='id identifier rubyid_value'><a href="../ParseResult.html#value-instance_method" title="Prism::ParseResult#value (method)">value</a></span>)
      <span class='kw'>else</span>
        <span class='comment'># If a comment exists on its own line, prefer a leading comment.
</span>        <span class='id identifier rubyid_following'>following</span> <span class='op'>||</span> <span class='id identifier rubyid_preceding'>preceding</span> <span class='op'>||</span> <span class='id identifier rubyid_enclosing'>enclosing</span> <span class='op'>||</span> <span class='const'><a href="Comments/NodeTarget.html" title="Prism::ParseResult::Comments::NodeTarget (class)">NodeTarget</a></span>.<span class='id identifier rubyid_new'><a href="Comments/NodeTarget.html#new-class_method" title="Prism::ParseResult::Comments::NodeTarget.new (method)">new</a></span>(<span class='id identifier rubyid_parse_result'><a href="#parse_result-instance_method" title="Prism::ParseResult::Comments#parse_result (method)">parse_result</a></span>.<span class='id identifier rubyid_value'><a href="../ParseResult.html#value-instance_method" title="Prism::ParseResult#value (method)">value</a></span>)
      <span class='kw'>end</span>

    <span class='id identifier rubyid_target'>target</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_comment'>comment</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="nearest_targets-instance_method">
  <h3 class='signature priv'>
    #<strong>nearest_targets</strong>(node, comment)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Responsible for finding the nearest targets to the given comment within the context of the given encapsulating node.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_3_9/lib/prism/parse_result/comments.rb#L103-L167'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='103' data-end='167'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/prism/parse_result/comments.rb', line 103</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_nearest_targets'>nearest_targets</span>(<span class='id identifier rubyid_node'>node</span><span class='comma'>,</span> <span class='id identifier rubyid_comment'>comment</span>)
  <span class='id identifier rubyid_comment_start'>comment_start</span> <span class='op'>=</span> <span class='id identifier rubyid_comment'>comment</span>.<span class='id identifier rubyid_location'>location</span>.<span class='id identifier rubyid_start_offset'>start_offset</span>
  <span class='id identifier rubyid_comment_end'>comment_end</span> <span class='op'>=</span> <span class='id identifier rubyid_comment'>comment</span>.<span class='id identifier rubyid_location'>location</span>.<span class='id identifier rubyid_end_offset'>end_offset</span>

  <span class='id identifier rubyid_targets'>targets</span> <span class='op'>=</span> []
  <span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_comment_targets'>comment_targets</span>.<span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_value'><a href="../ParseResult.html#value-instance_method" title="Prism::ParseResult#value (method)">value</a></span><span class='op'>|</span>
    <span class='kw'>case</span> <span class='id identifier rubyid_value'><a href="../ParseResult.html#value-instance_method" title="Prism::ParseResult#value (method)">value</a></span>
    <span class='kw'>when</span> <span class='const'>StatementsNode</span>
      <span class='id identifier rubyid_targets'>targets</span>.<span class='id identifier rubyid_concat'>concat</span>(<span class='id identifier rubyid_value'><a href="../ParseResult.html#value-instance_method" title="Prism::ParseResult#value (method)">value</a></span>.<span class='id identifier rubyid_body'>body</span>.<span class='id identifier rubyid_map'>map</span> { <span class='op'>|</span><span class='id identifier rubyid_node'>node</span><span class='op'>|</span> <span class='const'><a href="Comments/NodeTarget.html" title="Prism::ParseResult::Comments::NodeTarget (class)">NodeTarget</a></span>.<span class='id identifier rubyid_new'><a href="Comments/NodeTarget.html#new-class_method" title="Prism::ParseResult::Comments::NodeTarget.new (method)">new</a></span>(<span class='id identifier rubyid_node'>node</span>) })
    <span class='kw'>when</span> <span class='const'>Node</span>
      <span class='id identifier rubyid_targets'>targets</span> <span class='op'>&lt;&lt;</span> <span class='const'><a href="Comments/NodeTarget.html" title="Prism::ParseResult::Comments::NodeTarget (class)">NodeTarget</a></span>.<span class='id identifier rubyid_new'><a href="Comments/NodeTarget.html#new-class_method" title="Prism::ParseResult::Comments::NodeTarget.new (method)">new</a></span>(<span class='id identifier rubyid_value'><a href="../ParseResult.html#value-instance_method" title="Prism::ParseResult#value (method)">value</a></span>)
    <span class='kw'>when</span> <span class='const'><a href="../Location.html" title="Prism::Location (class)">Location</a></span>
      <span class='id identifier rubyid_targets'>targets</span> <span class='op'>&lt;&lt;</span> <span class='const'><a href="Comments/LocationTarget.html" title="Prism::ParseResult::Comments::LocationTarget (class)">LocationTarget</a></span>.<span class='id identifier rubyid_new'><a href="Comments/LocationTarget.html#new-class_method" title="Prism::ParseResult::Comments::LocationTarget.new (method)">new</a></span>(<span class='id identifier rubyid_value'><a href="../ParseResult.html#value-instance_method" title="Prism::ParseResult#value (method)">value</a></span>)
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_targets'>targets</span>.<span class='id identifier rubyid_sort_by!'>sort_by!</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_start_offset'>start_offset</span>)
  <span class='id identifier rubyid_preceding'>preceding</span> <span class='op'>=</span> <span class='kw'>nil</span>
  <span class='id identifier rubyid_following'>following</span> <span class='op'>=</span> <span class='kw'>nil</span>

  <span class='id identifier rubyid_left'>left</span> <span class='op'>=</span> <span class='int'>0</span>
  <span class='id identifier rubyid_right'>right</span> <span class='op'>=</span> <span class='id identifier rubyid_targets'>targets</span>.<span class='id identifier rubyid_length'>length</span>

  <span class='comment'># This is a custom binary search that finds the nearest nodes to the
</span>  <span class='comment'># given comment. When it finds a node that completely encapsulates the
</span>  <span class='comment'># comment, it recurses downward into the tree.
</span>  <span class='kw'>while</span> <span class='id identifier rubyid_left'>left</span> <span class='op'>&lt;</span> <span class='id identifier rubyid_right'>right</span>
    <span class='id identifier rubyid_middle'>middle</span> <span class='op'>=</span> (<span class='id identifier rubyid_left'>left</span> <span class='op'>+</span> <span class='id identifier rubyid_right'>right</span>) <span class='op'>/</span> <span class='int'>2</span>
    <span class='id identifier rubyid_target'>target</span> <span class='op'>=</span> <span class='id identifier rubyid_targets'>targets</span>[<span class='id identifier rubyid_middle'>middle</span>]

    <span class='id identifier rubyid_target_start'>target_start</span> <span class='op'>=</span> <span class='id identifier rubyid_target'>target</span>.<span class='id identifier rubyid_start_offset'>start_offset</span>
    <span class='id identifier rubyid_target_end'>target_end</span> <span class='op'>=</span> <span class='id identifier rubyid_target'>target</span>.<span class='id identifier rubyid_end_offset'>end_offset</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_target'>target</span>.<span class='id identifier rubyid_encloses?'>encloses?</span>(<span class='id identifier rubyid_comment'>comment</span>)
      <span class='comment'># The comment is completely contained by this target. Abandon the
</span>      <span class='comment'># binary search at this level.
</span>      <span class='kw'>return</span> <span class='id identifier rubyid_nearest_targets'>nearest_targets</span>(<span class='id identifier rubyid_target'>target</span>.<span class='id identifier rubyid_node'>node</span><span class='comma'>,</span> <span class='id identifier rubyid_comment'>comment</span>)
    <span class='kw'>end</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_target_end'>target_end</span> <span class='op'>&lt;=</span> <span class='id identifier rubyid_comment_start'>comment_start</span>
      <span class='comment'># This target falls completely before the comment. Because we will
</span>      <span class='comment'># never consider this target or any targets before it again, this
</span>      <span class='comment'># target must be the closest preceding target we have encountered so
</span>      <span class='comment'># far.
</span>      <span class='id identifier rubyid_preceding'>preceding</span> <span class='op'>=</span> <span class='id identifier rubyid_target'>target</span>
      <span class='id identifier rubyid_left'>left</span> <span class='op'>=</span> <span class='id identifier rubyid_middle'>middle</span> <span class='op'>+</span> <span class='int'>1</span>
      <span class='kw'>next</span>
    <span class='kw'>end</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_comment_end'>comment_end</span> <span class='op'>&lt;=</span> <span class='id identifier rubyid_target_start'>target_start</span>
      <span class='comment'># This target falls completely after the comment. Because we will
</span>      <span class='comment'># never consider this target or any targets after it again, this
</span>      <span class='comment'># target must be the closest following target we have encountered so
</span>      <span class='comment'># far.
</span>      <span class='id identifier rubyid_following'>following</span> <span class='op'>=</span> <span class='id identifier rubyid_target'>target</span>
      <span class='id identifier rubyid_right'>right</span> <span class='op'>=</span> <span class='id identifier rubyid_middle'>middle</span>
      <span class='kw'>next</span>
    <span class='kw'>end</span>

    <span class='comment'># This should only happen if there is a bug in this parser.
</span>    <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Comment location overlaps with a target location</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  [<span class='id identifier rubyid_preceding'>preceding</span><span class='comma'>,</span> <span class='const'><a href="Comments/NodeTarget.html" title="Prism::ParseResult::Comments::NodeTarget (class)">NodeTarget</a></span>.<span class='id identifier rubyid_new'><a href="Comments/NodeTarget.html#new-class_method" title="Prism::ParseResult::Comments::NodeTarget.new (method)">new</a></span>(<span class='id identifier rubyid_node'>node</span>)<span class='comma'>,</span> <span class='id identifier rubyid_following'>following</span>]
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>