<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Calling Methods &mdash; Ruby-3.3.9</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "calling_methods",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Ruby-3.3.9</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Calling Methods&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="file_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>

<h1 id="label-Calling+Methods">Calling Methods</h1>

<p>Calling a method sends a message to an object so it can perform some work.</p>

<p>In ruby you send a message to an object like this:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span>()</code></pre>

<p>Note that the parenthesis are optional:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span></code></pre>

<p>Except when there is difference between using and omitting parentheses, this document uses parenthesis when arguments are present to avoid confusion.</p>

<p>This section only covers calling methods.  See also the <a href="file.methods.html" title="syntax documentation on defining methods">syntax documentation on defining methods</a>.</p>

<h2 id="label-Receiver">Receiver</h2>

<p><code>self</code> is the default receiver.  If you don’t specify any receiver <code>self</code> will be used.  To specify a receiver use <code>.</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_object'>my_object</span>.<span class='id identifier rubyid_my_method'>my_method</span></code></pre>

<p>This sends the <code>my_method</code> message to <code>my_object</code>.  Any object can be a receiver but depending on the method’s visibility sending a message may raise a NoMethodError.</p>

<p>You may also use <code>::</code> to designate a receiver, but this is rarely used due to the potential for confusion with <code>::</code> for namespaces.</p>

<h3 id="label-Chaining+Method+Calls">Chaining Method Calls</h3>

<p>You can “chain” method calls by immediately following one method call with another.</p>

<p>This example chains methods Array#append and Array#compact:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_foo'>foo</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>bar</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>2</span>]
<span class='id identifier rubyid_a1'>a1</span> <span class='op'>=</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_baz'>baz</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_bam'>bam</span><span class='comma'>,</span> <span class='kw'>nil</span>]
<span class='id identifier rubyid_a2'>a2</span> <span class='op'>=</span> <span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_append'>append</span>(<span class='op'>*</span><span class='id identifier rubyid_a1'>a1</span>).<span class='id identifier rubyid_compact'>compact</span>
<span class='id identifier rubyid_a2'>a2</span> <span class='comment'># =&gt; [:foo, &quot;bar&quot;, 2, :baz, :bam]</span></code></pre>

<p>Details:</p>
<ul><li>
<p>First method <code>merge</code> creates a copy of <code>a</code>, appends (separately) each element of <code>a1</code> to the copy, and returns</p>

<pre class="code ruby"><code class="ruby">[<span class='symbeg'>:</span><span class='id identifier rubyid_foo'>foo</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>bar</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_baz'>baz</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_bam'>bam</span><span class='comma'>,</span> <span class='kw'>nil</span>]</code></pre>
</li><li>
<p>Chained method <code>compact</code> creates a copy of that return value, removes its <code>nil</code>-valued entries, and returns</p>

<pre class="code ruby"><code class="ruby">[<span class='symbeg'>:</span><span class='id identifier rubyid_foo'>foo</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>bar</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_baz'>baz</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_bam'>bam</span>]</code></pre>
</li></ul>

<p>You can chain methods that are in different classes. This example chains methods Hash#to_a and Array#reverse:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_h'>h</span> <span class='op'>=</span> {<span class='label'>foo:</span> <span class='int'>0</span><span class='comma'>,</span> <span class='label'>bar:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>baz:</span> <span class='int'>2</span>}
<span class='id identifier rubyid_h'>h</span>.<span class='id identifier rubyid_to_a'>to_a</span>.<span class='id identifier rubyid_reverse'>reverse</span> <span class='comment'># =&gt; [[:baz, 2], [:bar, 1], [:foo, 0]]</span></code></pre>

<p>Details:</p>
<ul><li>
<p>First method Hash#to_a converts <code>a</code> to an Array, and returns</p>

<pre class="code ruby"><code class="ruby">[[<span class='symbeg'>:</span><span class='id identifier rubyid_foo'>foo</span><span class='comma'>,</span> <span class='int'>0</span>]<span class='comma'>,</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_bar'>bar</span><span class='comma'>,</span> <span class='int'>1</span>]<span class='comma'>,</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_baz'>baz</span><span class='comma'>,</span> <span class='int'>2</span>]]</code></pre>
</li><li>
<p>Chained method Array#reverse creates copy of that return value, reverses it, and  returns</p>

<pre class="code ruby"><code class="ruby">[[<span class='symbeg'>:</span><span class='id identifier rubyid_baz'>baz</span><span class='comma'>,</span> <span class='int'>2</span>]<span class='comma'>,</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_bar'>bar</span><span class='comma'>,</span> <span class='int'>1</span>]<span class='comma'>,</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_foo'>foo</span><span class='comma'>,</span> <span class='int'>0</span>]]</code></pre>
</li></ul>

<h3 id="label-Safe+Navigation+Operator">Safe Navigation Operator</h3>

<p><code>&amp;.</code>, called “safe navigation operator”, allows to skip method call when receiver is <code>nil</code>. It returns <code>nil</code> and doesn’t evaluate method’s arguments if the call is skipped.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>REGEX</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(ruby) is (\w+)</span><span class='regexp_end'>/i</span></span>
<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Ruby is awesome!</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='const'>REGEX</span>).<span class='id identifier rubyid_values_at'>values_at</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>)
<span class='comment'># =&gt; [&quot;Ruby&quot;, &quot;awesome&quot;]
</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Python is fascinating!</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='const'>REGEX</span>).<span class='id identifier rubyid_values_at'>values_at</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>)
<span class='comment'># NoMethodError: undefined method `values_at&#39; for nil:NilClass
</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Python is fascinating!</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='const'>REGEX</span>)<span class='op'>&amp;.</span><span class='id identifier rubyid_values_at'>values_at</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>)
<span class='comment'># =&gt; nil</span></code></pre>

<p>This allows to easily chain methods which could return empty value. Note that <code>&amp;.</code> skips only one next call, so for a longer chain it is necessary to add operator on each level:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Python is fascinating!</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='const'>REGEX</span>)<span class='op'>&amp;.</span><span class='id identifier rubyid_values_at'>values_at</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>).<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'> - </span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># NoMethodError: undefined method `join&#39; for nil:NilClass
</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Python is fascinating!</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='const'>REGEX</span>)<span class='op'>&amp;.</span><span class='id identifier rubyid_values_at'>values_at</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>)<span class='op'>&amp;.</span><span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'> - </span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; nil</span></code></pre>

<h2 id="label-Arguments">Arguments</h2>

<p>There are three types of arguments when sending a message, the positional arguments, keyword (or named) arguments and the block argument.  Each message sent may use one, two or all types of arguments, but the arguments must be supplied in this order.</p>

<p>All arguments in ruby are passed by reference and are not lazily evaluated.</p>

<p>Each argument is separated by a <code>,</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>2</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_three'>three</span>)</code></pre>

<p>Arguments may be an expression, a hash argument:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>key</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_value'>value</span></code></pre>

<p>or a keyword argument:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_key'>key</span><span class='op'>:</span> <span class='id identifier rubyid_value'>value</span></code></pre>

<p>Hash and keyword arguments must be contiguous and must appear after all positional arguments, but may be mixed:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>c</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='int'>3</span>)</code></pre>

<h3 id="label-Positional+Arguments">Positional Arguments</h3>

<p>The positional arguments for the message follow the method name:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span>(<span class='id identifier rubyid_argument1'>argument1</span><span class='comma'>,</span> <span class='id identifier rubyid_argument2'>argument2</span>)</code></pre>

<p>In many cases, parenthesis are not necessary when sending a message:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span> <span class='id identifier rubyid_argument1'>argument1</span><span class='comma'>,</span> <span class='id identifier rubyid_argument2'>argument2</span></code></pre>

<p>However, parenthesis are necessary to avoid ambiguity.  This will raise a SyntaxError because ruby does not know which method argument3 should be sent to:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_method_one'>method_one</span> <span class='id identifier rubyid_argument1'>argument1</span><span class='comma'>,</span> <span class='id identifier rubyid_method_two'>method_two</span> <span class='id identifier rubyid_argument2'>argument2</span><span class='comma'>,</span> <span class='id identifier rubyid_argument3'>argument3</span></code></pre>

<p>If the method definition has a <code>*argument</code> extra positional arguments will be assigned to <code>argument</code> in the method as an Array.</p>

<p>If the method definition doesn’t include keyword arguments, the keyword or hash-type arguments are assigned as a single hash to the last argument:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_my_method'>my_method</span>(<span class='id identifier rubyid_options'>options</span>)
  <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_options'>options</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_my_method'>my_method</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>b:</span> <span class='int'>2</span>) <span class='comment'># prints: {&#39;a&#39;=&gt;1, :b=&gt;2}</span></code></pre>

<p>If too many positional arguments are given, an ArgumentError is raised.</p>

<h3 id="label-Default+Positional+Arguments">Default Positional Arguments</h3>

<p>When the method defines default arguments you do not need to supply all the arguments to the method.  Ruby will fill in the missing arguments in-order.</p>

<p>First we’ll cover the simple case where the default arguments appear on the right.  Consider this method:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_my_method'>my_method</span>(<span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='int'>3</span><span class='comma'>,</span> <span class='id identifier rubyid_d'>d</span> <span class='op'>=</span> <span class='int'>4</span>)
  <span class='id identifier rubyid_p'>p</span> [<span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span><span class='comma'>,</span> <span class='id identifier rubyid_d'>d</span>]
<span class='kw'>end</span></code></pre>

<p>Here <code>c</code> and <code>d</code> have default values which ruby will apply for you.  If you send only two arguments to this method:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>)</code></pre>

<p>You will see ruby print <code>[1, 2, 3, 4]</code>.</p>

<p>If you send three arguments:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>5</span>)</code></pre>

<p>You will see ruby print <code>[1, 2, 5, 4]</code></p>

<p>Ruby fills in the missing arguments from left to right.</p>

<p>Ruby allows default values to appear in the middle of positional arguments. Consider this more complicated method:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_my_method'>my_method</span>(<span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span> <span class='op'>=</span> <span class='int'>2</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='int'>3</span><span class='comma'>,</span> <span class='id identifier rubyid_d'>d</span>)
  <span class='id identifier rubyid_p'>p</span> [<span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span><span class='comma'>,</span> <span class='id identifier rubyid_d'>d</span>]
<span class='kw'>end</span></code></pre>

<p>Here <code>b</code> and <code>c</code> have default values.  If you send only two arguments to this method:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='int'>4</span>)</code></pre>

<p>You will see ruby print <code>[1, 2, 3, 4]</code>.</p>

<p>If you send three arguments:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='int'>5</span><span class='comma'>,</span> <span class='int'>6</span>)</code></pre>

<p>You will see ruby print <code>[1, 5, 3, 6]</code>.</p>

<p>Describing this in words gets complicated and confusing. I’ll describe it in variables and values instead.</p>

<p>First <code>1</code> is assigned to <code>a</code>, then <code>6</code> is assigned to <code>d</code>.  This leaves only the arguments with default values.  Since <code>5</code> has not been assigned to a value yet, it is given to <code>b</code> and <code>c</code> uses its default value of <code>3</code>.</p>

<h3 id="label-Keyword+Arguments">Keyword Arguments</h3>

<p>Keyword arguments follow any positional arguments and are separated by commas like positional arguments:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span>(<span class='id identifier rubyid_positional1'>positional1</span><span class='comma'>,</span> <span class='label'>keyword1:</span> <span class='id identifier rubyid_value1'>value1</span><span class='comma'>,</span> <span class='label'>keyword2:</span> <span class='id identifier rubyid_value2'>value2</span>)</code></pre>

<p>Any keyword arguments not given will use the default value from the method definition.  If a keyword argument is given that the method did not list, and the method definition does not accept arbitrary keyword arguments, an ArgumentError will be raised.</p>

<p>Keyword argument value can be omitted, meaning the value will be be fetched from the context by the name of the key</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_keyword1'>keyword1</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some value</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_my_method'>my_method</span>(<span class='id identifier rubyid_positional1'>positional1</span><span class='comma'>,</span> <span class='label'>keyword1:</span>)
<span class='comment'># ...is the same as
</span><span class='id identifier rubyid_my_method'>my_method</span>(<span class='id identifier rubyid_positional1'>positional1</span><span class='comma'>,</span> <span class='label'>keyword1:</span> <span class='id identifier rubyid_keyword1'>keyword1</span>)</code></pre>

<p>Be aware that when method parenthesis are omitted, too, the parsing order might be unexpected:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span> <span class='id identifier rubyid_positional1'>positional1</span><span class='comma'>,</span> <span class='label'>keyword1:</span>

<span class='id identifier rubyid_some_other_expression'>some_other_expression</span>

<span class='comment'># ...is actually parsed as
</span><span class='id identifier rubyid_my_method'>my_method</span>(<span class='id identifier rubyid_positional1'>positional1</span><span class='comma'>,</span> <span class='label'>keyword1:</span> <span class='id identifier rubyid_some_other_expression'>some_other_expression</span>)</code></pre>

<h3 id="label-Block+Argument">Block Argument</h3>

<p>The block argument sends a closure from the calling scope to the method.</p>

<p>The block argument is always last when sending a message to a method.  A block is sent to a method using <code>do ... end</code> or <code>{ ... }</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span> <span class='kw'>do</span>
  <span class='comment'># ...
</span><span class='kw'>end</span></code></pre>

<p>or:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span> {
  <span class='comment'># ...
</span>}</code></pre>

<p><code>do end</code> has lower precedence than <code>{ }</code> so:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_method_1'>method_1</span> <span class='id identifier rubyid_method_2'>method_2</span> {
  <span class='comment'># ...
</span>}</code></pre>

<p>Sends the block to <code>method_2</code> while:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_method_1'>method_1</span> <span class='id identifier rubyid_method_2'>method_2</span> <span class='kw'>do</span>
  <span class='comment'># ...
</span><span class='kw'>end</span></code></pre>

<p>Sends the block to <code>method_1</code>.  Note that in the first case if parentheses are used the block is sent to <code>method_1</code>.</p>

<p>A block will accept arguments from the method it was sent to.  Arguments are defined similar to the way a method defines arguments.  The block’s arguments go in <code>| ... |</code> following the opening <code>do</code> or <code>{</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_argument1'>argument1</span><span class='comma'>,</span> <span class='id identifier rubyid_argument2'>argument2</span><span class='op'>|</span>
  <span class='comment'># ...
</span><span class='kw'>end</span></code></pre>

<h4 id="label-Block+Local+Arguments">Block Local Arguments</h4>

<p>You may also declare block-local arguments to a block using <code>;</code> in the block arguments list.  Assigning to a block-local argument will not override local arguments outside the block in the caller’s scope:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_my_method'>my_method</span>
  <span class='kw'>yield</span> <span class='kw'>self</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_place'>place</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>world</span><span class='tstring_end'>&quot;</span></span>

<span class='id identifier rubyid_my_method'>my_method</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_obj'>obj</span><span class='semicolon'>;</span> <span class='id identifier rubyid_place'>place</span><span class='op'>|</span>
  <span class='id identifier rubyid_place'>place</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>block</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hello </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_obj'>obj</span><span class='embexpr_end'>}</span><span class='tstring_content'> this is </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_place'>place</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>

<span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>place is: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_place'>place</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span></code></pre>

<p>This prints:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_hello'>hello</span> <span class='id identifier rubyid_main'>main</span> <span class='id identifier rubyid_this'>this</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_block'>block</span>
<span class='id identifier rubyid_place'>place</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_world'>world</span></code></pre>

<p>So the <code>place</code> variable in the block is not the same <code>place</code> variable as outside the block.  Removing <code>; place</code> from the block arguments gives this result:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_hello'>hello</span> <span class='id identifier rubyid_main'>main</span> <span class='id identifier rubyid_this'>this</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_block'>block</span>
<span class='id identifier rubyid_place'>place</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_block'>block</span></code></pre>

<h3 id="label-Array+to+Arguments+Conversion">Array to Arguments Conversion</h3>

<p>Given the following method:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_my_method'>my_method</span>(<span class='id identifier rubyid_argument1'>argument1</span><span class='comma'>,</span> <span class='id identifier rubyid_argument2'>argument2</span><span class='comma'>,</span> <span class='id identifier rubyid_argument3'>argument3</span>)
<span class='kw'>end</span></code></pre>

<p>You can turn an Array into an argument list with <code>*</code> (or splat) operator:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_arguments'>arguments</span> <span class='op'>=</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>3</span>]
<span class='id identifier rubyid_my_method'>my_method</span>(<span class='op'>*</span><span class='id identifier rubyid_arguments'>arguments</span>)</code></pre>

<p>or:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_arguments'>arguments</span> <span class='op'>=</span> [<span class='int'>2</span><span class='comma'>,</span> <span class='int'>3</span>]
<span class='id identifier rubyid_my_method'>my_method</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_arguments'>arguments</span>)</code></pre>

<p>Both are equivalent to:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>3</span>)</code></pre>

<p>You may also use the <code>**</code> (described next) to convert a Hash into keyword arguments.</p>

<p>If the number of objects in the Array do not match the number of arguments for the method, an ArgumentError will be raised.</p>

<p>If the splat operator comes first in the call, parentheses must be used to avoid a warning:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span> <span class='op'>*</span><span class='id identifier rubyid_arguments'>arguments</span>  <span class='comment'># warning
</span><span class='id identifier rubyid_my_method'>my_method</span>(<span class='op'>*</span><span class='id identifier rubyid_arguments'>arguments</span>) <span class='comment'># no warning</span></code></pre>

<h3 id="label-Hash+to+Keyword+Arguments+Conversion">Hash to Keyword Arguments Conversion</h3>

<p>Given the following method:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_my_method'>my_method</span>(<span class='label'>first:</span> <span class='int'>1</span><span class='comma'>,</span> <span class='label'>second:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>third:</span> <span class='int'>3</span>)
<span class='kw'>end</span></code></pre>

<p>You can turn a Hash into keyword arguments with the <code>**</code> (keyword splat) operator:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_arguments'>arguments</span> <span class='op'>=</span> { <span class='label'>first:</span> <span class='int'>3</span><span class='comma'>,</span> <span class='label'>second:</span> <span class='int'>4</span><span class='comma'>,</span> <span class='label'>third:</span> <span class='int'>5</span> }
<span class='id identifier rubyid_my_method'>my_method</span>(<span class='op'>**</span><span class='id identifier rubyid_arguments'>arguments</span>)</code></pre>

<p>or:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_arguments'>arguments</span> <span class='op'>=</span> { <span class='label'>first:</span> <span class='int'>3</span><span class='comma'>,</span> <span class='label'>second:</span> <span class='int'>4</span> }
<span class='id identifier rubyid_my_method'>my_method</span>(<span class='label'>third:</span> <span class='int'>5</span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_arguments'>arguments</span>)</code></pre>

<p>Both are equivalent to:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span>(<span class='label'>first:</span> <span class='int'>3</span><span class='comma'>,</span> <span class='label'>second:</span> <span class='int'>4</span><span class='comma'>,</span> <span class='label'>third:</span> <span class='int'>5</span>)</code></pre>

<p>If the method definition uses the keyword splat operator to gather arbitrary keyword arguments, they will not be gathered by <code>*</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_my_method'>my_method</span>(<span class='op'>*</span><span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_kw'>kw</span>)
  <span class='id identifier rubyid_p'>p</span> <span class='label'>arguments:</span> <span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='label'>keywords:</span> <span class='id identifier rubyid_kw'>kw</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_my_method'>my_method</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>3</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='int'>4</span><span class='comma'>,</span> <span class='label'>five:</span> <span class='int'>6</span>)</code></pre>

<p>Prints:</p>

<pre class="code ruby"><code class="ruby">{<span class='symbeg'>:</span><span class='id identifier rubyid_arguments'>arguments</span><span class='op'>=&gt;</span>[<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>]<span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_keywords'>keywords</span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>3</span><span class='tstring_end'>&#39;</span></span><span class='op'>=&gt;</span><span class='int'>4</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_five'>five</span><span class='op'>=&gt;</span><span class='int'>6</span>}}</code></pre>

<h3 id="label-Proc+to+Block+Conversion">Proc to Block Conversion</h3>

<p>Given a method that use a block:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_my_method'>my_method</span>
  <span class='kw'>yield</span> <span class='kw'>self</span>
<span class='kw'>end</span></code></pre>

<p>You can convert a proc or lambda to a block argument with the <code>&amp;</code> (block conversion) operator:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_argument'>argument</span> <span class='op'>=</span> <span class='id identifier rubyid_proc'>proc</span> { <span class='op'>|</span><span class='id identifier rubyid_a'>a</span><span class='op'>|</span> <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_inspect'>inspect</span><span class='embexpr_end'>}</span><span class='tstring_content'> was yielded</span><span class='tstring_end'>&quot;</span></span> }

<span class='id identifier rubyid_my_method'>my_method</span>(<span class='op'>&amp;</span><span class='id identifier rubyid_argument'>argument</span>)</code></pre>

<p>If the block conversion operator comes first in the call, parenthesis must be used to avoid a warning:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_method'>my_method</span> <span class='op'>&amp;</span><span class='id identifier rubyid_argument'>argument</span>  <span class='comment'># warning
</span><span class='id identifier rubyid_my_method'>my_method</span>(<span class='op'>&amp;</span><span class='id identifier rubyid_argument'>argument</span>) <span class='comment'># no warning</span></code></pre>

<h2 id="label-Method+Lookup">Method Lookup</h2>

<p>When you send a message, Ruby looks up the method that matches the name of the message for the receiver.  Methods are stored in classes and modules so method lookup walks these, not the objects themselves.</p>

<p>Here is the order of method lookup for the receiver’s class or module <code>R</code>:</p>
<ul><li>
<p>The prepended modules of <code>R</code> in reverse order</p>
</li><li>
<p>For a matching method in <code>R</code></p>
</li><li>
<p>The included modules of <code>R</code> in reverse order</p>
</li></ul>

<p>If <code>R</code> is a class with a superclass, this is repeated with <code>R</code>‘s superclass until a method is found.</p>

<p>Once a match is found method lookup stops.</p>

<p>If no match is found this repeats from the beginning, but looking for <code>method_missing</code>.  The default <code>method_missing</code> is BasicObject#method_missing which raises a NameError when invoked.</p>

<p>If refinements (an experimental feature) are active, the method lookup changes. See the {file:syntax/refinements.rdoc refinements documentation} for details.</p>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>