<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Action Cable Readme &mdash; Rails-5.1.0</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />
<link rel='stylesheet'  type='text/css' href='../css/custom.css' />
<link rel='stylesheet'  type='text/css' href='../css/common.css' />

<script type='text/javascript'>
  var pathId = "action_cable_readme",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
  <svg id='y_wait' class viewBox='0 0 90 90'></svg>
  <div id='tbl_cont'>
    <div id='y_list' class='d h'>
      <button id='list_sizer' class='y_sizer' title='LIST Resizer'></button>
      <header id='list_header'>
        <div id='list_title'>&#160;</div>
        <div id='list_menu'><span>&#160;</span></div>
        <input  id='list_search_text' type='search' placeholder='Search' size='12' value='' autocomplete='off' class='search_input'/>
        <svg id='list_search_icon' viewBox='0 0 30 30'>
          <path class='s_main' d='M21.189,17.213C22.022,15.726,22.5,14.014,22.5,12.188C22.5,6.493,17.884,1.875,12.188,1.875S1.875,6.493,1.875,12.188C1.875,17.882,6.491,22.5,12.188,22.5c1.826,0,3.536-0.48,5.025-1.311l6.113,6.113C23.873,27.851,24.593,28.125,25.313,28.125s1.44-0.274,1.989-0.823c1.099-1.099,1.099-2.878,0-3.977L21.189,17.213z M12.188,19.329c-3.943,0-7.14-3.197-7.14-7.142c0.0-3.943,3.197-7.14,7.14-7.14c3.941,0,7.14,3.195,7.14,7.14C19.328,16.133,16.129,19.329,12.188,19.329z'/>
          <path class='s_clear' d='M 4.414, 1.586 A 1,1 0 1,0 1.586, 4.414 L 21.586,24.414 A 1,1 0 1,0 24.414,21.586 z' />
          <path class='s_clear' d='M 1.586,21.586 A 1,1 0 1,0 4.414,24.414 L 24.414, 4.414 A 1,1 0 1,0 21.586, 1.586 z' />
        </svg>
        <button class='y_minus' title='Collapse All'></button>
        <button class='y_plus' title='Expand All'></button>
      </header>
      <nav id= 'list_nav' class='y_nav l_nav'>
        <ul id='list_items'></ul>
      </nav>
    </div>
    <div id='y_toc' class='f h'>
      <button id='toc_sizer' class='y_sizer' title='TOC Resizer'></button>
      <header id='toc_header'>
        <div>Table of Contents</div>
        <button class='y_minus' title='Collapse All'></button>
        <button class='y_plus' title='Expand All' ></button>
      </header>
      <nav id= 'toc_nav' class='y_nav t_nav'>
      <ol id='toc_items'></ol>
      </nav>
    </div>
    <div id='y_main' tabindex='-1'>
      <header id='y_header'>
        <div id='y_menu'>
          <a href='../index.html'>Home</a> &raquo; 
          <a href='index.html'>Rails-5.1.0</a> &raquo; 
          <a href='_index.html'>Index</a> &raquo; 
          <span class='title'>File: Action Cable Readme</span>
                </div>

        <div id='y_measure_em' class='y_measure'></div>
        <div id='y_measure_vh' class='y_measure'></div>
        <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
        <a id='list_href' href="file_list.html"></a>
        <div id='hdr_button'>
          <button id='src' class='c' title='Source Show / Hide'>S<svg class='c' viewBox='0 0 36 28'>
              <rect x='8'  y='12' width='28' height='4'  rx='1.0' ry='1.0'/>
              <rect x='20' y='0'  width='4'  height='28' rx='1.0' ry='1.0'/>
            </svg><svg class='o' viewBox='0 0 34 28'>
              <rect x='8'  y='12' width='28' height='4'  rx='1.0' ry='1.0'/>
            </svg></button>
          <button id='list_loc' class='d' title='LIST Location'>L<svg class='f' viewBox='0 0 36 28'>
            <path d='M36 0 L36 28 8 14'/></svg><svg class='d' viewBox='0 0 36 28'><path d='M 8 0 L36 14 8 28'/></svg></button>
          <button id='toc_loc' class='f' title='TOC Location'>T<svg class='f' viewBox='0 0 34 28'>
            <path d='M36 0 L36 28 8 14'/></svg><svg class='d' viewBox='0 0 36 28'><path d='M 8 0 L36 14 8 28'/></svg></button>
          <button id='list_vis' title='LIST Show / Hide'>LIST</button>
          <button id='toc_vis' title='TOC Show / Hide'>TOC</button>
        </div>
        <div id='y_debug'></div>
      </header>
<div id='content' class='file'>
<h1>Action Cable – Integrated WebSockets for Rails</h1>

<p>Action Cable seamlessly integrates WebSockets with the rest of your Rails application.
It allows for real-time features to be written in Ruby in the same style
and form as the rest of your Rails application, while still being performant
and scalable. It&#39;s a full-stack offering that provides both a client-side
JavaScript framework and a server-side Ruby framework. You have access to your full
domain model written with Active Record or your ORM of choice.</p>

<h2>Terminology</h2>

<p>A single Action Cable server can handle multiple connection instances. It has one
connection instance per WebSocket connection. A single user may have multiple
WebSockets open to your application if they use multiple browser tabs or devices.
The client of a WebSocket connection is called the consumer.</p>

<p>Each consumer can in turn subscribe to multiple cable channels. Each channel encapsulates
a logical unit of work, similar to what a controller does in a regular MVC setup. For example,
you could have a <code>ChatChannel</code> and an <code>AppearancesChannel</code>, and a consumer could be subscribed to either
or to both of these channels. At the very least, a consumer should be subscribed to one channel.</p>

<p>When the consumer is subscribed to a channel, they act as a subscriber. The connection between
the subscriber and the channel is, surprise-surprise, called a subscription. A consumer
can act as a subscriber to a given channel any number of times. For example, a consumer
could subscribe to multiple chat rooms at the same time. (And remember that a physical user may
have multiple consumers, one per tab/device open to your connection).</p>

<p>Each channel can then again be streaming zero or more broadcastings. A broadcasting is a
pubsub link where anything transmitted by the broadcaster is sent directly to the channel
subscribers who are streaming that named broadcasting.</p>

<p>As you can see, this is a fairly deep architectural stack. There&#39;s a lot of new terminology
to identify the new pieces, and on top of that, you&#39;re dealing with both client and server side
reflections of each unit.</p>

<h2>Examples</h2>

<h3>A full-stack example</h3>

<p>The first thing you must do is define your <code>ApplicationCable::Connection</code> class in Ruby. This
is the place where you authorize the incoming connection, and proceed to establish it,
if all is well. Here&#39;s the simplest example starting with the server-side connection class:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># app/channels/application_cable/connection.rb
</span><span class='kw'>module</span> <span class='const'>ApplicationCable</span>
  <span class='kw'>class</span> <span class='const'>Connection</span> <span class='op'>&lt;</span> <span class='const'><a href="ActionCable.html" title="ActionCable (module)">ActionCable</a></span><span class='op'>::</span><span class='const'><a href="ActionCable/Connection.html" title="ActionCable::Connection (module)">Connection</a></span><span class='op'>::</span><span class='const'><a href="ActionCable/Connection/Base.html" title="ActionCable::Connection::Base (class)">Base</a></span>
    <span class='id identifier rubyid_identified_by'>identified_by</span> <span class='symbeg'>:</span><span class='id identifier rubyid_current_user'>current_user</span>

    <span class='kw'>def</span> <span class='id identifier rubyid_connect'>connect</span>
      <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_current_user'>current_user</span> <span class='op'>=</span> <span class='id identifier rubyid_find_verified_user'>find_verified_user</span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_protected'>protected</span>
      <span class='kw'>def</span> <span class='id identifier rubyid_find_verified_user'>find_verified_user</span>
        <span class='kw'>if</span> <span class='id identifier rubyid_current_user'>current_user</span> <span class='op'>=</span> <span class='const'>User</span><span class='period'>.</span><span class='id identifier rubyid_find_by'>find_by</span><span class='lparen'>(</span><span class='label'>id:</span> <span class='id identifier rubyid_cookies'>cookies</span><span class='period'>.</span><span class='id identifier rubyid_signed'>signed</span><span class='lbracket'>[</span><span class='symbeg'>:</span><span class='id identifier rubyid_user_id'>user_id</span><span class='rbracket'>]</span><span class='rparen'>)</span>
          <span class='id identifier rubyid_current_user'>current_user</span>
        <span class='kw'>else</span>
          <span class='id identifier rubyid_reject_unauthorized_connection'>reject_unauthorized_connection</span>
        <span class='kw'>end</span>
      <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Here <code>identified_by</code> is a connection identifier that can be used to find the specific connection again or later.
Note that anything marked as an identifier will automatically create a delegate by the same name on any channel instances created off the connection.</p>

<p>This relies on the fact that you will already have handled authentication of the user, and
that a successful authentication sets a signed cookie with the <code>user_id</code>. This cookie is then
automatically sent to the connection instance when a new connection is attempted, and you
use that to set the <code>current_user</code>. By identifying the connection by this same current_user,
you&#39;re also ensuring that you can later retrieve all open connections by a given user (and
potentially disconnect them all if the user is deleted or deauthorized).</p>

<p>Next, you should define your <code>ApplicationCable::Channel</code> class in Ruby. This is the place where you put
shared logic between your channels.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># app/channels/application_cable/channel.rb
</span><span class='kw'>module</span> <span class='const'>ApplicationCable</span>
  <span class='kw'>class</span> <span class='const'>Channel</span> <span class='op'>&lt;</span> <span class='const'><a href="ActionCable.html" title="ActionCable (module)">ActionCable</a></span><span class='op'>::</span><span class='const'><a href="ActionCable/Channel.html" title="ActionCable::Channel (module)">Channel</a></span><span class='op'>::</span><span class='const'><a href="ActionCable/Channel/Base.html" title="ActionCable::Channel::Base (class)">Base</a></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>The client-side needs to setup a consumer instance of this connection. That&#39;s done like so:</p>

<pre class="code js"><code class="js">// app/assets/javascripts/cable.js
//= require action_cable
//= require_self
//= require_tree ./channels

(function() {
  this.App || (this.App = {});

  App.cable = ActionCable.createConsumer(&quot;ws://cable.example.com&quot;);
}).call(this);
</code></pre>

<p>The <code>ws://cable.example.com</code> address must point to your Action Cable server(s), and it
must share a cookie namespace with the rest of the application (which may live under <a href="http://example.com">http://example.com</a>).
This ensures that the signed cookie will be correctly sent.</p>

<p>That&#39;s all you need to establish the connection! But of course, this isn&#39;t very useful in
itself. This just gives you the plumbing. To make stuff happen, you need content. That content
is defined by declaring channels on the server and allowing the consumer to subscribe to them.</p>

<h3>Channel example 1: User appearances</h3>

<p>Here&#39;s a simple example of a channel that tracks whether a user is online or not, and also what page they are currently on.
(This is useful for creating presence features like showing a green dot next to a user&#39;s name if they&#39;re online).</p>

<p>First you declare the server-side channel:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># app/channels/appearance_channel.rb
</span><span class='kw'>class</span> <span class='const'>AppearanceChannel</span> <span class='op'>&lt;</span> <span class='const'>ApplicationCable</span><span class='op'>::</span><span class='const'>Channel</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_subscribed'>subscribed</span>
    <span class='id identifier rubyid_current_user'>current_user</span><span class='period'>.</span><span class='id identifier rubyid_appear'>appear</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_unsubscribed'>unsubscribed</span>
    <span class='id identifier rubyid_current_user'>current_user</span><span class='period'>.</span><span class='id identifier rubyid_disappear'>disappear</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_appear'>appear</span><span class='lparen'>(</span><span class='id identifier rubyid_data'>data</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_current_user'>current_user</span><span class='period'>.</span><span class='id identifier rubyid_appear'>appear</span> <span class='label'>on:</span> <span class='id identifier rubyid_data'>data</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>appearing_on</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_away'>away</span>
    <span class='id identifier rubyid_current_user'>current_user</span><span class='period'>.</span><span class='id identifier rubyid_away'>away</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>The <code>#subscribed</code> callback is invoked when, as we&#39;ll show below, a client-side subscription is initiated. In this case,
we take that opportunity to say &quot;the current user has indeed appeared&quot;. That appear/disappear API could be backed by
Redis or a database or whatever else. Here&#39;s what the client-side of that looks like:</p>

<pre class="code coffeescript"><code class="coffeescript"># app/assets/javascripts/cable/subscriptions/appearance.coffee
App.cable.subscriptions.create &quot;AppearanceChannel&quot;,
  # Called when the subscription is ready for use on the server
  connected: -&gt;
    @install()
    @appear()

  # Called when the WebSocket connection is closed
  disconnected: -&gt;
    @uninstall()

  # Called when the subscription is rejected by the server
  rejected: -&gt;
    @uninstall()

  appear: -&gt;
    # Calls `AppearanceChannel#appear(data)` on the server
    @perform(&quot;appear&quot;, appearing_on: $(&quot;main&quot;).data(&quot;appearing-on&quot;))

  away: -&gt;
    # Calls `AppearanceChannel#away` on the server
    @perform(&quot;away&quot;)


  buttonSelector = &quot;[data-behavior~=appear_away]&quot;

  install: -&gt;
    $(document).on &quot;page:change.appearance&quot;, =&gt;
      @appear()

    $(document).on &quot;click.appearance&quot;, buttonSelector, =&gt;
      @away()
      false

    $(buttonSelector).show()

  uninstall: -&gt;
    $(document).off(&quot;.appearance&quot;)
    $(buttonSelector).hide()
</code></pre>

<p>Simply calling <code>App.cable.subscriptions.create</code> will setup the subscription, which will call <code>AppearanceChannel#subscribed</code>,
which in turn is linked to the original <code>App.cable</code> -&gt; <code>ApplicationCable::Connection</code> instances.</p>

<p>Next, we link the client-side <code>appear</code> method to <code>AppearanceChannel#appear(data)</code>. This is possible because the server-side
channel instance will automatically expose the public methods declared on the class (minus the callbacks), so that these
can be reached as remote procedure calls via a subscription&#39;s <code>perform</code> method.</p>

<h3>Channel example 2: Receiving new web notifications</h3>

<p>The appearance example was all about exposing server functionality to client-side invocation over the WebSocket connection.
But the great thing about WebSockets is that it&#39;s a two-way street. So now let&#39;s show an example where the server invokes
an action on the client.</p>

<p>This is a web notification channel that allows you to trigger client-side web notifications when you broadcast to the right
streams:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># app/channels/web_notifications_channel.rb
</span><span class='kw'>class</span> <span class='const'>WebNotificationsChannel</span> <span class='op'>&lt;</span> <span class='const'>ApplicationCable</span><span class='op'>::</span><span class='const'>Channel</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_subscribed'>subscribed</span>
    <span class='id identifier rubyid_stream_from'>stream_from</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>web_notifications_</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_current_user'>current_user</span><span class='period'>.</span><span class='id identifier rubyid_id'>id</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<pre class="code coffeescript"><code class="coffeescript"># Client-side, which assumes you&#39;ve already requested the right to send web notifications
App.cable.subscriptions.create &quot;WebNotificationsChannel&quot;,
  received: (data) -&gt;
    new Notification data[&quot;title&quot;], body: data[&quot;body&quot;]
</code></pre>

<pre class="code ruby"><code class="ruby"><span class='comment'># Somewhere in your app this is called, perhaps from a NewCommentJob
</span><span class='const'><a href="ActionCable.html" title="ActionCable (module)">ActionCable</a></span><span class='period'>.</span><span class='id identifier rubyid_server'>server</span><span class='period'>.</span><span class='id identifier rubyid_broadcast'>broadcast</span> \
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>web_notifications_</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_current_user'>current_user</span><span class='period'>.</span><span class='id identifier rubyid_id'>id</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='lbrace'>{</span> <span class='label'>title:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>New things!</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>body:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>All the news that is fit to print</span><span class='tstring_end'>&#39;</span></span> <span class='rbrace'>}</span>
</code></pre>

<p>The <code>ActionCable.server.broadcast</code> call places a message in the Action Cable pubsub queue under a separate broadcasting name for each user. For a user with an ID of 1, the broadcasting name would be <code>web_notifications_1</code>.
The channel has been instructed to stream everything that arrives at <code>web_notifications_1</code> directly to the client by invoking the
<code>#received(data)</code> callback. The data is the hash sent as the second parameter to the server-side broadcast call, JSON encoded for the trip
across the wire, and unpacked for the data argument arriving to <code>#received</code>.</p>

<h3>Passing Parameters to Channel</h3>

<p>You can pass parameters from the client side to the server side when creating a subscription. For example:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># app/channels/chat_channel.rb
</span><span class='kw'>class</span> <span class='const'>ChatChannel</span> <span class='op'>&lt;</span> <span class='const'>ApplicationCable</span><span class='op'>::</span><span class='const'>Channel</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_subscribed'>subscribed</span>
    <span class='id identifier rubyid_stream_from'>stream_from</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>chat_</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_params'>params</span><span class='lbracket'>[</span><span class='symbeg'>:</span><span class='id identifier rubyid_room'>room</span><span class='rbracket'>]</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>If you pass an object as the first argument to <code>subscriptions.create</code>, that object will become the params hash in your cable channel. The keyword <code>channel</code> is required.</p>

<pre class="code coffeescript"><code class="coffeescript"># Client-side, which assumes you&#39;ve already requested the right to send web notifications
App.cable.subscriptions.create { channel: &quot;ChatChannel&quot;, room: &quot;Best Room&quot; },
  received: (data) -&gt;
    @appendLine(data)

  appendLine: (data) -&gt;
    html = @createLine(data)
    $(&quot;[data-chat-room=&#39;Best Room&#39;]&quot;).append(html)

  createLine: (data) -&gt;
    &quot;&quot;&quot;
    &lt;article class=&quot;chat-line&quot;&gt;
      &lt;span class=&quot;speaker&quot;&gt;#{data[&quot;sent_by&quot;]}&lt;/span&gt;
      &lt;span class=&quot;body&quot;&gt;#{data[&quot;body&quot;]}&lt;/span&gt;
    &lt;/article&gt;
    &quot;&quot;&quot;
</code></pre>

<pre class="code ruby"><code class="ruby"><span class='comment'># Somewhere in your app this is called, perhaps from a NewCommentJob
</span><span class='const'><a href="ActionCable.html" title="ActionCable (module)">ActionCable</a></span><span class='period'>.</span><span class='id identifier rubyid_server'>server</span><span class='period'>.</span><span class='id identifier rubyid_broadcast'>broadcast</span> \
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>chat_</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_room'>room</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='lbrace'>{</span> <span class='label'>sent_by:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Paul</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>body:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>This is a cool chat app.</span><span class='tstring_end'>&#39;</span></span> <span class='rbrace'>}</span>
</code></pre>

<h3>Rebroadcasting message</h3>

<p>A common use case is to rebroadcast a message sent by one client to any other connected clients.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># app/channels/chat_channel.rb
</span><span class='kw'>class</span> <span class='const'>ChatChannel</span> <span class='op'>&lt;</span> <span class='const'>ApplicationCable</span><span class='op'>::</span><span class='const'>Channel</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_subscribed'>subscribed</span>
    <span class='id identifier rubyid_stream_from'>stream_from</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>chat_</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_params'>params</span><span class='lbracket'>[</span><span class='symbeg'>:</span><span class='id identifier rubyid_room'>room</span><span class='rbracket'>]</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_receive'>receive</span><span class='lparen'>(</span><span class='id identifier rubyid_data'>data</span><span class='rparen'>)</span>
    <span class='const'><a href="ActionCable.html" title="ActionCable (module)">ActionCable</a></span><span class='period'>.</span><span class='id identifier rubyid_server'>server</span><span class='period'>.</span><span class='id identifier rubyid_broadcast'>broadcast</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>chat_</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_params'>params</span><span class='lbracket'>[</span><span class='symbeg'>:</span><span class='id identifier rubyid_room'>room</span><span class='rbracket'>]</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_data'>data</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<pre class="code coffeescript"><code class="coffeescript"># Client-side, which assumes you&#39;ve already requested the right to send web notifications
App.chatChannel = App.cable.subscriptions.create { channel: &quot;ChatChannel&quot;, room: &quot;Best Room&quot; },
  received: (data) -&gt;
    # data =&gt; { sent_by: &quot;Paul&quot;, body: &quot;This is a cool chat app.&quot; }

App.chatChannel.send({ sent_by: &quot;Paul&quot;, body: &quot;This is a cool chat app.&quot; })
</code></pre>

<p>The rebroadcast will be received by all connected clients, <em>including</em> the client that sent the message. Note that params are the same as they were when you subscribed to the channel.</p>

<h3>More complete examples</h3>

<p>See the <a href="https://github.com/rails/actioncable-examples">rails/actioncable-examples</a> repository for a full example of how to setup Action Cable in a Rails app, and how to add channels.</p>

<h2>Configuration</h2>

<p>Action Cable has three required configurations: a subscription adapter, allowed request origins, and the cable server URL (which can optionally be set on the client side).</p>

<h3>Redis</h3>

<p>By default, <code>ActionCable::Server::Base</code> will look for a configuration file in <code>Rails.root.join(&#39;config/cable.yml&#39;)</code>.
This file must specify an adapter and a URL for each Rails environment. It may use the following format:</p>

<pre class="code yaml"><code class="yaml">production: &amp;production
  adapter: redis
  url: redis://10.10.3.153:6381
development: &amp;development
  adapter: redis
  url: redis://localhost:6379
test: *development
</code></pre>

<p>You can also change the location of the Action Cable config file in a Rails initializer with something like:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Rails.html" title="Rails (module)">Rails</a></span><span class='period'>.</span><span class='id identifier rubyid_application'><a href="Rails.html#application-class_method" title="Rails.application (method)">application</a></span><span class='period'>.</span><span class='id identifier rubyid_paths'>paths</span><span class='period'>.</span><span class='id identifier rubyid_add'>add</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>config/cable</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>with:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>somewhere/else/cable.yml</span><span class='tstring_end'>&quot;</span></span>
</code></pre>

<h3>Allowed Request Origins</h3>

<p>Action Cable will only accept requests from specified origins, which are passed to the server config as an array. The origins can be instances of strings or regular expressions, against which a check for match will be performed.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Rails.html" title="Rails (module)">Rails</a></span><span class='period'>.</span><span class='id identifier rubyid_application'><a href="Rails.html#application-class_method" title="Rails.application (method)">application</a></span><span class='period'>.</span><span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_action_cable'>action_cable</span><span class='period'>.</span><span class='id identifier rubyid_allowed_request_origins'>allowed_request_origins</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://rubyonrails.com</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>http:\/\/ruby.*</span><span class='regexp_end'>/</span></span><span class='rbracket'>]</span>
</code></pre>

<p>When running in the development environment, this defaults to &quot;<a href="http://localhost:3000">http://localhost:3000</a>&quot;.</p>

<p>To disable and allow requests from any origin:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Rails.html" title="Rails (module)">Rails</a></span><span class='period'>.</span><span class='id identifier rubyid_application'><a href="Rails.html#application-class_method" title="Rails.application (method)">application</a></span><span class='period'>.</span><span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_action_cable'>action_cable</span><span class='period'>.</span><span class='id identifier rubyid_disable_request_forgery_protection'>disable_request_forgery_protection</span> <span class='op'>=</span> <span class='kw'>true</span>
</code></pre>

<h3>Consumer Configuration</h3>

<p>Once you have decided how to run your cable server (see below), you must provide the server URL (or path) to your client-side setup.
There are two ways you can do this.</p>

<p>The first is to simply pass it in when creating your consumer. For a standalone server,
this would be something like: <code>App.cable = ActionCable.createConsumer(&quot;ws://example.com:28080&quot;)</code>, and for an in-app server,
something like: <code>App.cable = ActionCable.createConsumer(&quot;/cable&quot;)</code>.</p>

<p>The second option is to pass the server URL through the <code>action_cable_meta_tag</code> in your layout.
This uses a URL or path typically set via <code>config.action_cable.url</code> in the environment configuration files, or defaults to &quot;/cable&quot;.</p>

<p>This method is especially useful if your WebSocket URL might change between environments. If you host your production server via https, you will need to use the wss scheme
for your Action Cable server, but development might remain http and use the ws scheme. You might use localhost in development and your
domain in production.</p>

<p>In any case, to vary the WebSocket URL between environments, add the following configuration to each environment:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_action_cable'>action_cable</span><span class='period'>.</span><span class='id identifier rubyid_url'>url</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ws://example.com:28080</span><span class='tstring_end'>&quot;</span></span>
</code></pre>

<p>Then add the following line to your layout before your JavaScript tag:</p>

<pre class="code erb"><code class="erb">&lt;%= action_cable_meta_tag %&gt;
</code></pre>

<p>And finally, create your consumer like so:</p>

<pre class="code coffeescript"><code class="coffeescript">App.cable = ActionCable.createConsumer()
</code></pre>

<h3>Other Configurations</h3>

<p>The other common option to configure is the log tags applied to the per-connection logger. Here&#39;s an example that uses the user account id if available, else &quot;no-account&quot; while tagging:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_action_cable'>action_cable</span><span class='period'>.</span><span class='id identifier rubyid_log_tags'>log_tags</span> <span class='op'>=</span> <span class='lbracket'>[</span>
  <span class='comment'>#=&gt; request { request.env[&#39;user_account_id&#39;] || &quot;no-account&quot; },
</span>  <span class='symbeg'>:</span><span class='id identifier rubyid_action_cable'>action_cable</span><span class='comma'>,</span>
  <span class='comment'>#=&gt; request { request.uuid }
</span><span class='rbracket'>]</span>
</code></pre>

<p>For a full list of all configuration options, see the <code>ActionCable::Server::Configuration</code> class.</p>

<p>Also note that your server must provide at least the same number of database connections as you have workers. The default worker pool is set to 4, so that means you have to make at least that available. You can change that in <code>config/database.yml</code> through the <code>pool</code> attribute.</p>

<h2>Running the cable server</h2>

<h3>Standalone</h3>

<p>The cable server(s) is separated from your normal application server. It&#39;s still a Rack application, but it is its own Rack
application. The recommended basic setup is as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># cable/config.ru
</span><span class='id identifier rubyid_require'>require</span> <span class='op'>::</span><span class='const'><a href="File.html" title="File (class)">File</a></span><span class='period'>.</span><span class='id identifier rubyid_expand_path'>expand_path</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>../../config/environment</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='kw'>__FILE__</span><span class='rparen'>)</span>
<span class='const'><a href="Rails.html" title="Rails (module)">Rails</a></span><span class='period'>.</span><span class='id identifier rubyid_application'><a href="Rails.html#application-class_method" title="Rails.application (method)">application</a></span><span class='period'>.</span><span class='id identifier rubyid_eager_load!'>eager_load!</span>

<span class='id identifier rubyid_run'>run</span> <span class='const'><a href="ActionCable.html" title="ActionCable (module)">ActionCable</a></span><span class='period'>.</span><span class='id identifier rubyid_server'>server</span>
</code></pre>

<p>Then you start the server using a binstub in bin/cable ala:</p>

<pre class="code sh"><code class="sh">#!/bin/bash
bundle exec puma -p 28080 cable/config.ru
</code></pre>

<p>The above will start a cable server on port 28080.</p>

<h3>In app</h3>

<p>If you are using a server that supports the <a href="http://www.rubydoc.info/github/rack/rack/file/SPEC#Hijacking">Rack socket hijacking API</a>, Action Cable can run alongside your Rails application. For example, to listen for WebSocket requests on <code>/websocket</code>, specify that path to <code>config.action_cable.mount_path</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># config/application.rb
</span><span class='kw'>class</span> <span class='const'>Application</span> <span class='op'>&lt;</span> <span class='const'><a href="Rails.html" title="Rails (module)">Rails</a></span><span class='op'>::</span><span class='const'><a href="Rails/Application.html" title="Rails::Application (class)">Application</a></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_action_cable'>action_cable</span><span class='period'>.</span><span class='id identifier rubyid_mount_path'>mount_path</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>/websocket</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>
</code></pre>

<p>For every instance of your server you create and for every worker your server spawns, you will also have a new instance of Action Cable, but the use of Redis keeps messages synced across connections.</p>

<h3>Notes</h3>

<p>Beware that currently, the cable server will <em>not</em> auto-reload any changes in the framework. As we&#39;ve discussed, long-running cable connections mean long-running objects. We don&#39;t yet have a way of reloading the classes of those objects in a safe manner. So when you change your channels, or the model your channels use, you must restart the cable server.</p>

<p>We&#39;ll get all this abstracted properly when the framework is integrated into Rails.</p>

<p>The WebSocket server doesn&#39;t have access to the session, but it has access to the cookies. This can be used when you need to handle authentication. You can see one way of doing that with Devise in this <a href="http://www.rubytutorial.io/actioncable-devise-authentication">article</a>.</p>

<h2>Dependencies</h2>

<p>Action Cable provides a subscription adapter interface to process its pubsub internals. By default, asynchronous, inline, PostgreSQL, evented Redis, and non-evented Redis adapters are included. The default adapter in new Rails applications is the asynchronous (<code>async</code>) adapter. To create your own adapter, you can look at <code>ActionCable::SubscriptionAdapter::Base</code> for all methods that must be implemented, and any of the adapters included within Action Cable as example implementations.</p>

<p>The Ruby side of things is built on top of <a href="https://github.com/faye/websocket-driver-ruby">websocket-driver</a>, <a href="https://github.com/celluloid/nio4r">nio4r</a>, and <a href="https://github.com/ruby-concurrency/concurrent-ruby">concurrent-ruby</a>.</p>

<h2>Deployment</h2>

<p>Action Cable is powered by a combination of WebSockets and threads. All of the
connection management is handled internally by utilizing Ruby’s native thread
support, which means you can use all your regular Rails models with no problems
as long as you haven’t committed any thread-safety sins.</p>

<p>The Action Cable server does <em>not</em> need to be a multi-threaded application server.
This is because Action Cable uses the <a href="http://www.rubydoc.info/github/rack/rack/file/SPEC#Hijacking">Rack socket hijacking API</a>
to take over control of connections from the application server. Action Cable
then manages connections internally, in a multithreaded manner, regardless of
whether the application server is multi-threaded or not. So Action Cable works
with all the popular application servers -- Unicorn, Puma and Passenger.</p>

<p>Action Cable does not work with WEBrick, because WEBrick does not support the
Rack socket hijacking API.</p>

<h2>Frontend assets</h2>

<p>Action Cable&#39;s frontend assets are distributed through two channels: the
official gem and npm package, both titled <code>actioncable</code>.</p>

<h3>Gem usage</h3>

<p>Through the <code>actioncable</code> gem, Action Cable&#39;s frontend assets are
available through the Rails Asset Pipeline. Create a <code>cable.js</code> or
<code>cable.coffee</code> file (this is automatically done for you with Rails
generators), and then simply require the assets:</p>

<p>In JavaScript...</p>

<pre class="code javascript"><code class="javascript">//= require action_cable
</code></pre>

<p>... and in CoffeeScript:</p>

<pre class="code coffeescript"><code class="coffeescript">#= require action_cable
</code></pre>

<h3>npm usage</h3>

<p>In addition to being available through the <code>actioncable</code> gem, Action Cable&#39;s
frontend JS assets are also bundled in an officially supported npm module,
intended for usage in standalone frontend applications that communicate with a
Rails application. A common use case for this could be if you have a decoupled
frontend application written in React, Ember.js, etc. and want to add real-time
WebSocket functionality.</p>

<h3>Installation</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_npm'>npm</span> <span class='id identifier rubyid_install'>install</span> <span class='id identifier rubyid_actioncable'>actioncable</span> <span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_save'>save</span>
</code></pre>

<h3>Usage</h3>

<p>The <code>ActionCable</code> constant is available as a <code>require</code>-able module, so
you only have to require the package to gain access to the API that is
provided.</p>

<p>In JavaScript...</p>

<pre class="code javascript"><code class="javascript">ActionCable = require(&#39;actioncable&#39;)

var cable = ActionCable.createConsumer(&#39;wss://RAILS-API-PATH.com/cable&#39;)

cable.subscriptions.create(&#39;AppearanceChannel&#39;, {
  // normal channel code goes here...
});
</code></pre>

<p>and in CoffeeScript...</p>

<pre class="code coffeescript"><code class="coffeescript">ActionCable = require(&#39;actioncable&#39;)

cable = ActionCable.createConsumer(&#39;wss://RAILS-API-PATH.com/cable&#39;)

cable.subscriptions.create &#39;AppearanceChannel&#39;,
    # normal channel code goes here...
</code></pre>

<h2>License</h2>

<p>Action Cable is released under the MIT license:</p>

<ul>
<li><a href="http://www.opensource.org/licenses/MIT">http://www.opensource.org/licenses/MIT</a></li>
</ul>

<h2>Support</h2>

<p>API documentation is at:</p>

<ul>
<li><a href="http://api.rubyonrails.org">http://api.rubyonrails.org</a></li>
</ul>

<p>Bug reports can be filed for the Ruby on Rails project here:</p>

<ul>
<li><a href="https://github.com/rails/rails/issues">https://github.com/rails/rails/issues</a></li>
</ul>

<p>Feature requests should be discussed on the rails-core mailing list here:</p>

<ul>
<li><a href="https://groups.google.com/forum/?fromgroups#!forum/rubyonrails-core">https://groups.google.com/forum/?fromgroups#!forum/rubyonrails-core</a></li>
</ul>

<div id='footer'>
  Generated by
  <a href='http://yardoc.org' title='Yay! A Ruby Documentation Tool' target="_parent">yard</a>
  0.9.5 with <a href='https://msp-greg.github.io/yard-t2/' title='yard-t2' target="_parent">yard-t2</a> 0.6.0 (ruby-2.3.2p135)
</div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</div> <!-- tbl_cont -->
</body>
</html>