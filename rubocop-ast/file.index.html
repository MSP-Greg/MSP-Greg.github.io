<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Index &mdash; RuboCop-AST master</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "index",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>RuboCop-AST master</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Index&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This gem introduces two core classes of RuboCop:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="RuboCop/AST/Node.html" title="RuboCop::AST::Node (class)"><code>::RuboCop::AST::Node</code></a> - this is an extension of the <a href="https://github.com/whitequark/parser/"><code>parser</code></a> gem&#8217;s <code>Node</code> class, which adds a simpler and more powerful object-oriented API to make it easier to work with nodes.</p>
</li>
<li>
<p><a href="RuboCop/AST/NodePattern.html" title="RuboCop::AST::NodePattern (class)"><code>::RuboCop::AST::NodePattern</code></a> - a regular expression-style method to traverse and match nodes in an Abstract Syntax Tree. See <a href="node_pattern.html">"Node Pattern"</a> to get yourself familiar with <code>NodePattern</code>'s capabilities.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This gem may be used independently from the main RuboCop gem. It was extracted from RuboCop in version 0.84 and its only
dependency is the <a href="https://github.com/whitequark/parser">parser</a> gem, which <code>rubocop-ast</code> extends.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rationale">Rationale</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While working with <code>parser</code>'s AST representation is fairly easy (especially when compared to the AST of Ruby&#8217;s built-in <code>ripper</code> library), there&#8217;s still areas we felt could be improved:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the canonical way to work with an AST node is to deconstruct the node in array-like fashion, which results in code that&#8217;s hard to read</p>
</li>
<li>
<p>looking for complex AST node patterns requires a lot of boilerplate code</p>
</li>
<li>
<p>there&#8217;s no easy way to tell apart AST nodes of certain types - e.g. prefix vs postfix conditionals</p>
</li>
<li>
<p>there&#8217;s no easy way to grab the parent node of some node</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Enter <code>rubocop-ast</code>, which aims to solve those problems. This library evolved for years as part of RuboCop and was eventually spun off in the hope that it might be useful
for other projects built on top of <code>parser</code>.</p>
</div>
<div class="paragraph">
<p><a href="RuboCop/AST/Node.html" title="RuboCop::AST::Node (class)"><code>::RuboCop::AST::Node</code></a> provides a wrapper around <code>parser</code>'s <code>Node</code> class (in other words, <code>RuboCop::AST::Node &lt; Parser::AST::Node</code>). In addition to a number of methods to make it easier to work with, the wrapper class also provides ways to inspect the <strong>parents</strong> of nodes, which the <code>parser</code> nodes do not support.</p>
</div>
<div class="paragraph">
<p>Here are a few examples using <code>parser</code> and <code>rubocop-ast</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>parser</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>rubocop-ast</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="code ruby"><code class="ruby"><span class='comment'># type = :if
</span><span class='id identifier rubyid_is_if'>is_if</span> <span class='op'>=</span> <span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_loc'>loc</span>.<span class='id identifier rubyid_keyword'>keyword</span> <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>if</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_if_branch'>if_branch</span> <span class='op'>=</span> <span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_children'>children</span>[<span class='int'>1</span>]
<span class='id identifier rubyid_else_branch'>else_branch</span> <span class='op'>=</span> <span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_children'>children</span>[<span class='int'>2</span>]
<span class='id identifier rubyid_has_elsif_branch'>has_elsif_branch</span> <span class='op'>=</span> <span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_children'>children</span>[<span class='int'>2</span>].<span class='id identifier rubyid_type'>type</span> <span class='op'>==</span> <span class='symbeg'>:</span><span class='kw'>if</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_children'>children</span>[<span class='int'>2</span>].<span class='id identifier rubyid_keyword'>keyword</span> <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>elsif</span><span class='tstring_end'>&#39;</span></span></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="code ruby"><code class="ruby"><span class='comment'># type = :if
</span><span class='id identifier rubyid_is_if'>is_if</span> <span class='op'>=</span> <span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_if?'>if?</span>
<span class='id identifier rubyid_if_branch'>if_branch</span> <span class='op'>=</span> <span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_if_branch'>if_branch</span>
<span class='id identifier rubyid_else_branch'>else_branch</span> <span class='op'>=</span> <span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_else_branch'>else_branch</span>
<span class='id identifier rubyid_has_elsif_branch'>has_elsif_branch</span> <span class='op'>=</span> <span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_elsif_conditional?'>elsif_conditional?</span></code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="code ruby"><code class="ruby"><span class='comment'># type = :hash
</span><span class='id identifier rubyid_pairs'>pairs</span> <span class='op'>=</span> <span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_children'>children</span>
<span class='id identifier rubyid_pairs'>pairs</span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_pair_node'>pair_node</span><span class='op'>|</span>
  <span class='id identifier rubyid_key'>key</span> <span class='op'>=</span> <span class='id identifier rubyid_pair_node'>pair_node</span>.<span class='id identifier rubyid_children'>children</span>[<span class='int'>0</span>]
  <span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_pair_node'>pair_node</span>.<span class='id identifier rubyid_children'>children</span>[<span class='int'>1</span>]
  <span class='id identifier rubyid_do_something'>do_something</span>(<span class='id identifier rubyid_key'>key</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span>)
<span class='kw'>end</span></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="code ruby"><code class="ruby"><span class='comment'># type = :hash
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_each_pair'>each_pair</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_pair_node'>pair_node</span><span class='op'>|</span>
  <span class='id identifier rubyid_do_something'>do_something</span>(<span class='id identifier rubyid_pair_node'>pair_node</span>.<span class='id identifier rubyid_key'>key</span><span class='comma'>,</span> <span class='id identifier rubyid_pair_node'>pair_node</span>.<span class='id identifier rubyid_value'>value</span>)
<span class='kw'>end</span></code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Sample usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>MyRule</span> <span class='op'>&lt;</span> <span class='const'>Parser</span><span class='op'>::</span><span class='const'>AST</span><span class='op'>::</span><span class='const'>Processor</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="RuboCop.html" title="RuboCop (module)">RuboCop</a></span><span class='op'>::</span><span class='const'><a href="RuboCop/AST.html" title="RuboCop::AST (module)">AST</a></span><span class='op'>::</span><span class='const'><a href="RuboCop/AST/Traversal.html" title="RuboCop::AST::Traversal (module)">Traversal</a></span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_sym'>on_sym</span>(<span class='id identifier rubyid_node'>node</span>)
    <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>I found a symbol! </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_value'>value</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_source'>source</span> <span class='op'>=</span> <span class='const'><a href="RuboCop.html" title="RuboCop (module)">RuboCop</a></span><span class='op'>::</span><span class='const'><a href="RuboCop/AST.html" title="RuboCop::AST (module)">AST</a></span><span class='op'>::</span><span class='const'><a href="RuboCop/AST/ProcessedSource.html" title="RuboCop::AST::ProcessedSource (class)">ProcessedSource</a></span>.<span class='id identifier rubyid_new'><a href="RuboCop/AST/ProcessedSource.html#new-class_method" title="RuboCop::AST::ProcessedSource.new (method)">new</a></span>(<span class='id identifier rubyid_code'>code</span><span class='comma'>,</span> <span class='float'>2.7</span>)
<span class='id identifier rubyid_rule'>rule</span> <span class='op'>=</span> <span class='const'>MyRule</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_source'>source</span>.<span class='id identifier rubyid_ast'>ast</span>.<span class='id identifier rubyid_each_node'>each_node</span> { <span class='op'>|</span><span class='id identifier rubyid_n'>n</span><span class='op'>|</span> <span class='id identifier rubyid_rule'>rule</span>.<span class='id identifier rubyid_process'>process</span>(<span class='id identifier rubyid_n'>n</span>) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have already parsed the Ruby code with <code>prism</code>, you can pass an instance of <code>Prism::ParseLexResult</code>
to the <code>:prism_result</code> keyword argument. This is a useful API for Ruby LSP, where <code>Prism::ParseLexResult</code> has
already been obtained externally from RuboCop. A <code>Prism::ParseLexResult</code> instance is a value that can be obtained,
for example, as the return value of <code>Prism.parse_lex(source)</code>.
The bypass occurs only when the source is processed by prism and an instance of <code>Prism::ParseLexResult</code> is specified
for the <code>:prism_result</code> keyword argument. Otherwise, the source code is parsed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="code ruby"><code class="ruby"><span class='comment'># `parser_prism` is chosen automatically for `ruby_version &gt;= 3.4` but you can also request
</span><span class='comment'># it explicitly starting from `ruby_version` 3.3. Requesting `parser_prism` for an earlier version
</span><span class='comment'># will raise an error.
</span><span class='const'>ProcessedSource</span>.<span class='id identifier rubyid_new'>new</span>(<span class='ivar'>@options</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_stdin'>stdin</span>]<span class='comma'>,</span> <span class='id identifier rubyid_ruby_version'>ruby_version</span><span class='comma'>,</span> <span class='id identifier rubyid_file'>file</span><span class='comma'>,</span> <span class='label'>parser_engine:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_parser_prism'>parser_prism</span><span class='comma'>,</span> <span class='label'>prism_result:</span> <span class='id identifier rubyid_parse_lex_result'>parse_lex_result</span>)</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
The Parser gem supports syntax up to Ruby 3.3, but it does not support syntax in Ruby 3.4,
such as <code>it</code> block parameters. Additionally, there are no plans to support Ruby 3.5 or later.
For Ruby 3.4 and later, <code>parser_engine: parser_prism</code> is chosen automatically.
</td>
</tr>
</table>
</div>
</div>
</div>
<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>