<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Cheat-sheet &mdash; Nokogiri main</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Cheat-sheet",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Nokogiri main</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Cheat-sheet&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<p>This is a digest of most of the methods documented at <a href="https://nokogiri.org/">nokogiri.org</a>. Reading <a href="https://github.com/sparklemotion/nokogiri">the source</a> can help, too.</p>

<p>Topics not covered: <a href="https://nokogiri.org/rdoc/Nokogiri/XML/RelaxNG.html">RelaxNG validation</a> or <a href="https://nokogiri.org/rdoc/Nokogiri/XML/Builder.html">Builder</a>
See also: <a href="http://cheat.errtheblog.com/s/nokogiri">http://cheat.errtheblog.com/s/nokogiri</a></p>

<p>Strings are always stored as UTF-8 internally. Methods that return text
values will always return UTF-8 encoded strings. Methods that return XML (like
to_xml, to_html and inner_html) will return a string encoded like the source
document.</p>

<p>More Resources</p>

<ul>
<li><a href="https://nokogiri.org/tutorials/parsing_an_html_xml_document.html">Official Tutorials</a></li>
<li><a href="https://www.w3.org/TR/2010/REC-xpath20-20101214/#abbrev">XPath Reference</a></li>
<li><a href="https://www.w3schools.com/xml/xpath_syntax.asp">XPath Reference 2</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/ms256122.aspx">XPath Reference 3</a></li>
<li><a href="https://www.w3.org/TR/selectors-3/#selectors">CSS Selector Reference</a></li>
<li><a href="https://www.w3schools.com/cssref/css_selectors.asp">CSS Selector Reference 2</a></li>
<li><a href="https://github.com/sparklemotion/mechanize">Mechanize</a></li>
<li><a href="https://github.com/flavorjones/loofah">Loofah</a></li>
<li><a href="https://github.com/rubys/nokogumbo/#readme">Nokogumbo</a></li>
<li><a href="https://awesome-ruby.com/#-html-xml-parsing">HTML/XML parsing tools</a></li>
<li><a href="https://stackoverflow.com/questions/tagged/nokogiri?sort=votes">StackOverflow top questions</a></li>
</ul>

<h2>Creating and working with Documents</h2>

<p><a href="https://nokogiri.org/rdoc/Nokogiri/HTML/Document.html">Nokogiri::HTML::Document</a>
<a href="https://nokogiri.org/rdoc/Nokogiri/XML/Document.html">Nokogiri::XML::Document</a></p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_doc'>doc</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span>(<span class='id identifier rubyid_string_or_io'>string_or_io</span>) <span class='comment'># Nokogiri will try to guess what type of document you are attempting to parse
</span><span class='id identifier rubyid_doc'>doc</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/HTML.html" title="Nokogiri::HTML (module)">HTML</a></span>(<span class='id identifier rubyid_string_or_io'>string_or_io</span>) <span class='comment'># [, url, encoding, options, &amp;block]
</span><span class='id identifier rubyid_doc'>doc</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML.html" title="Nokogiri::XML (module)">XML</a></span>(<span class='id identifier rubyid_string_or_io'>string_or_io</span>) <span class='comment'># [, url, encoding, options, &amp;block]
</span>  <span class='comment'># set options with block {|config| config.noblanks.noent.noerror.strict }
</span>  <span class='comment'># OR with a bitmask {|config| config.options = Nokogiri::XML::ParseOptions::NOBLANKS | Nokogiri::XML::ParseOptions::NOENT}
</span>  <span class='comment'># https://nokogiri.org/rdoc/Nokogiri/XML/ParseOptions.html
</span><span class='comment'># doc = Nokogiri.parse(...)
</span><span class='comment'># doc = Nokogiri::XML.parse(...) #shortcut to Nokogiri::XML::Document.parse
</span><span class='comment'># doc = Nokogiri::HTML.parse(...) #shortcut to Nokogiri::HTML::Document.parse
</span>
<span class='comment'># document namespaces
</span><span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_collect_namespaces'>collect_namespaces</span>
<span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_remove_namespaces!'>remove_namespaces!</span>
<span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_namespaces'>namespaces</span>

<span class='comment'># shortcuts for creating new nodes
</span><span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_create_cdata'>create_cdata</span>(<span class='id identifier rubyid_string'>string</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>)
<span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_create_comment'>create_comment</span>(<span class='id identifier rubyid_string'>string</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>)
<span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_create_element'>create_element</span>(<span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>) <span class='comment'># Create an element
</span>    <span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_create_element'>create_element</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>div</span><span class='tstring_end'>&quot;</span></span> <span class='comment'># &lt;div&gt;&lt;/div&gt;
</span>    <span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_create_element'>create_element</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>div</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='kw'>class</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>container</span><span class='tstring_end'>&quot;</span></span> <span class='comment'># &lt;div class=&#39;container&#39;&gt;&lt;/div&gt;
</span>    <span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_create_element'>create_element</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>div</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>contents</span><span class='tstring_end'>&quot;</span></span> <span class='comment'># &lt;div&gt;contents&lt;/div&gt;
</span>    <span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_create_element'>create_element</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>div</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>contents</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='kw'>class</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>container</span><span class='tstring_end'>&quot;</span></span> <span class='comment'># &lt;div class=&#39;container&#39;&gt;contents&lt;/div&gt;
</span>    <span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_create_element'>create_element</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>div</span><span class='tstring_end'>&quot;</span></span> { <span class='op'>|</span><span class='id identifier rubyid_node'>node</span><span class='op'>|</span> <span class='id identifier rubyid_node'>node</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>class</span><span class='tstring_end'>&#39;</span></span>] <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>container</span><span class='tstring_end'>&quot;</span></span> } <span class='comment'># &lt;div class=&#39;container&#39;&gt;&lt;/div&gt;
</span><span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_create_entity'>create_entity</span>
<span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_create_text_node'>create_text_node</span>(<span class='id identifier rubyid_string'>string</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>)

<span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_root'>root</span>
<span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_root'>root</span><span class='op'>=</span><span class='id identifier rubyid_node'>node</span>

<span class='comment'># A document is a Node, so see working_with_a_node</span></code></pre>

<h2>Working with Fragments</h2>

<p><a href="https://nokogiri.org/rdoc/Nokogiri/XML/DocumentFragment.html">Nokogiri::XML::DocumentFragment</a>
<a href="https://nokogiri.org/rdoc/Nokogiri/HTML/DocumentFragment.html">Nokogiri::HTML::DocumentFragment</a></p>

<p>Generally speaking, unless you expect to have a DOCTYPE and a single root node, you don’t have a document, you have a fragment. For HTML, another rule of thumb is that documents have html and body tags, and fragments usually do not.</p>

<p>A fragment is a <a href="https://nokogiri.org/rdoc/Nokogiri/XML/Node.html">Node</a>, but is not a <a href="https://nokogiri.org/rdoc/Nokogiri/XML/Document.html">Document</a>. If you need to call methods that are only available on Document, like <code>create_element</code>, call <code>fragment.document.create_element</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_fragment'>fragment</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML.html" title="Nokogiri::XML (module)">XML</a></span>.<span class='id identifier rubyid_fragment'><a href="Nokogiri/XML.html#fragment-class_method" title="Nokogiri::XML.fragment (method)">fragment</a></span>(<span class='id identifier rubyid_string'>string</span>)
<span class='id identifier rubyid_fragment'>fragment</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/HTML.html" title="Nokogiri::HTML (module)">HTML</a></span>.<span class='id identifier rubyid_fragment'>fragment</span>(<span class='id identifier rubyid_string'>string</span><span class='comma'>,</span> <span class='id identifier rubyid_encoding'>encoding</span> <span class='op'>=</span> <span class='kw'>nil</span>)
<span class='comment'># Note: Searching a fragment relative to the document root with xpath 
</span><span class='comment'># will probably not return what you expect. You should search relative to 
</span><span class='comment'># the current context instead. e.g.
</span><span class='id identifier rubyid_fragment'>fragment</span>.<span class='id identifier rubyid_xpath'>xpath</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>//*</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_size'>size</span> <span class='comment'>#=&gt; 0
</span><span class='id identifier rubyid_fragment'>fragment</span>.<span class='id identifier rubyid_xpath'>xpath</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>.//*</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_size'>size</span> <span class='comment'>#=&gt; 229</span></code></pre>

<h2>Working with a <a href="https://nokogiri.org/rdoc/Nokogiri/XML/Node.html">Nokogiri::XML::Node</a></h2>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_node'>node</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML.html" title="Nokogiri::XML (module)">XML</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML/Node.html" title="Nokogiri::XML::Node (class)">Node</a></span>.<span class='id identifier rubyid_new'><a href="Nokogiri/XML/Node.html#new-class_method" title="Nokogiri::XML::Node.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>name</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_document'>document</span>) <span class='comment'># initialize a new node
</span><span class='id identifier rubyid_node'>node</span> <span class='op'>=</span> <span class='id identifier rubyid_document'>document</span>.<span class='id identifier rubyid_create_element'>create_element</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>name</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># shortcut
</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_document'>document</span>

<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_name'>name</span> <span class='comment'># alias of node.node_name
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_name'>name</span><span class='op'>=</span> <span class='comment'># alias of node.node_name=
</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_read_only?'>read_only?</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_blank?'>blank?</span>

<span class='comment'># Type of Node
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_type'>type</span> <span class='comment'># alias of node.node_type
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_cdata?'>cdata?</span> <span class='comment'># type == CDATA_SECTION_NODE
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_comment?'>comment?</span> <span class='comment'># type == COMMENT_NODE
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_element?'>element?</span> <span class='comment'># type == ELEMENT_NODE alias node.elem? 
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_fragment?'>fragment?</span> <span class='comment'># type == DOCUMENT_FRAG_NODE (Document fragment node)
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_html?'>html?</span> <span class='comment'># type == HTML_DOCUMENT_NODE
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_text?'>text?</span> <span class='comment'># type == TEXT_NODE
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_xml?'>xml?</span> <span class='comment'># type == DOCUMENT_NODE (Document node type)
</span><span class='comment'># other types not covered by a convenience method
</span>  <span class='comment'># ATTRIBUTE_DECL: Attribute declaration type
</span>  <span class='comment'># ATTRIBUTE_NODE: Attribute node type
</span>  <span class='comment'># DOCB_DOCUMENT_NODE: DOCB document node type
</span>  <span class='comment'># DOCUMENT_TYPE_NODE: Document type node type
</span>  <span class='comment'># DTD_NODE: DTD node type
</span>  <span class='comment'># ELEMENT_DECL: Element declaration type
</span>  <span class='comment'># ENTITY_DECL: Entity declaration type
</span>  <span class='comment'># ENTITY_NODE: Entity node type
</span>  <span class='comment'># ENTITY_REF_NODE: Entity reference node type
</span>  <span class='comment'># NAMESPACE_DECL: Namespace declaration type
</span>  <span class='comment'># NOTATION_NODE: Notation node type
</span>  <span class='comment'># PI_NODE: PI node type
</span>  <span class='comment'># XINCLUDE_END: XInclude end type
</span>  <span class='comment'># XINCLUDE_START: XInclude start type
</span>
<span class='comment'># Attributes, like a hash that maps string keys to string values
</span><span class='id identifier rubyid_node'>node</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>src</span><span class='tstring_end'>&#39;</span></span>] <span class='comment'># aliases: node.get_attribute, node.attr.
</span><span class='id identifier rubyid_node'>node</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>src</span><span class='tstring_end'>&#39;</span></span>] <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>value</span><span class='tstring_end'>&#39;</span></span> <span class='comment'># alias node.set_attribute
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_key?'>key?</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>src</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># alias node.has_attribute?
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_keys'>keys</span> 
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_values'>values</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_delete'>delete</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>src</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># alias of node.remove_attribute
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_each'>each</span> { <span class='op'>|</span><span class='id identifier rubyid_attr_name'>attr_name</span><span class='comma'>,</span> <span class='id identifier rubyid_attr_value'>attr_value</span><span class='op'>|</span> }
<span class='comment'># Node includes Enumerable, which works on these attribute names and values
</span>
<span class='comment'># Attribute Nodes
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_attribute'>attribute</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>src</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># Get the attribute node with name src
</span>  <span class='comment'># Returns a Nokogiri::XML::Attr, a subclass of Nokogiri::XML::Node
</span>  <span class='comment'># that provides .content= and .value= to modify the attribute value
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_attribute_nodes'>attribute_nodes</span> <span class='comment'># returns an array of this&#39; the Node attributes as Attr objects.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_attribute_with_ns'>attribute_with_ns</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>src</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>namespace</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># Get the attribute node with name and namespace
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_attributes'>attributes</span> <span class='comment'># Returns a hash containing the node&#39;s attributes. 
</span>  <span class='comment'># The key is the attribute name without any namespace, 
</span>  <span class='comment'># the value is a Nokogiri::XML::Attr representing the attribute. 
</span>  <span class='comment'># If you need to distinguish attributes with the same name, but with different namespaces, use #attribute_nodes instead.
</span>



<span class='comment'># Traversing / Modifying
</span><span class='comment'># node_or_tags can be a Node, a DocumentFragment, a NodeSet, or a string containing markup.
</span><span class='comment'>## Self
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_traverse'>traverse</span> { <span class='op'>|</span><span class='id identifier rubyid_node'>node</span><span class='op'>|</span> } <span class='comment'># yields all children and self to a block, _recursively_.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_remove'>remove</span> <span class='comment'># alias of node.unlink # Unlink this node from its current context.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_replace'>replace</span>(<span class='id identifier rubyid_node_or_tags'>node_or_tags</span>)
  <span class='comment'># Replace this Node with node_or_tags.
</span>  <span class='comment'># Returns the reparented node (if node_or_tags is a Node), 
</span>  <span class='comment'>#   or returns a NodeSet (if node_or_tags is a DocumentFragment, NodeSet, or string).
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_swap'>swap</span>(<span class='id identifier rubyid_node_or_tags'>node_or_tags</span>) <span class='comment'># like replace, but returns self to support chaining
</span><span class='comment'>## Siblings
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_next'>next</span> <span class='comment'># alias of node.next_sibling # Returns the next sibling node
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_next'>next</span><span class='op'>=</span>(<span class='id identifier rubyid_node_or_tags'>node_or_tags</span>) <span class='comment'># alias of node.add_next_sibling 
</span>  <span class='comment'># Inserts node_or_tags after this node (as a sibling).
</span>  <span class='comment'># Returns the reparented node (if node_or_tags is a Node)
</span>  <span class='comment'>#   or returns a NodeSet if (if +node_or_tags is a DocumentFragment, NodeSet, or string.)
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_after'>after</span>(<span class='id identifier rubyid_node_or_tags'>node_or_tags</span>) <span class='comment'># like next=, but returns self to suppport chaining
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_next_element'>next_element</span> <span class='comment'># Returns the next Nokogiri::XML::Element sibling node.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_previous'>previous</span> <span class='comment'># alias of node.previous_sibling # Returns the previous sibling node
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_previous'>previous</span><span class='op'>=</span>(<span class='id identifier rubyid_node_or_tags'>node_or_tags</span>) <span class='comment'># alias of node.add_previous_sibling ?
</span>  <span class='comment'># Inserts node_or_tags before this node (as a sibling).
</span>  <span class='comment'># Returns the reparented node (if node_or_tags is a Node)
</span>  <span class='comment'>#   or returns a NodeSet (if node_or_tags is a DocumentFragment, NodeSet, or string.)
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_before'>before</span>(<span class='id identifier rubyid_node_or_tags'>node_or_tags</span>) <span class='comment'># just like previous=, but returns self to suppport chaining
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_previous_element'>previous_element</span> <span class='comment'># Returns the previous Nokogiri::XML::Element sibling node.
</span><span class='comment'>## Parent
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_parent'>parent</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_parent'>parent</span><span class='op'>=</span>(<span class='id identifier rubyid_node'>node</span>)
<span class='comment'>## Children
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_child'>child</span> <span class='comment'># returns a Node
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_children'>children</span> <span class='comment'># Get the list of children of this node as a NodeSet
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_children'>children</span><span class='op'>=</span>(<span class='id identifier rubyid_node_or_tags'>node_or_tags</span>)
  <span class='comment'># Set the inner html for this Node
</span>  <span class='comment'># Returns the reparented node (if node_or_tags is a Node), 
</span>  <span class='comment'>#   or returns a NodeSet (if node_or_tags is a DocumentFragment, NodeSet, or string).
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_elements'>elements</span> <span class='comment'># alias: node.element_children # Get the list of child Elements of this node as a NodeSet.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_add_child'>add_child</span>(<span class='id identifier rubyid_node_or_tags'>node_or_tags</span>)
  <span class='comment'># Add node_or_tags as a child of this Node.
</span>  <span class='comment'># Returns the reparented node (if node_or_tags is a Node), 
</span>  <span class='comment'>#   or returns a NodeSet (if node_or_tags is a DocumentFragment, NodeSet, or string.)
</span><span class='id identifier rubyid_node'>node</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_node_or_tags'>node_or_tags</span> <span class='comment'># like above, but returns self to support chaining, e.g. root &lt;&lt; child1 &lt;&lt; child2
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_first_element_child'>first_element_child</span> <span class='comment'># Returns the first child node of this node that is an element.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_last_element_child'>last_element_child</span> <span class='comment'># Returns the last child node of this node that is an element.
</span><span class='comment'>## Content / Children
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_content'>content</span> <span class='comment'># aliases node.text node.inner_text node.to_str
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_content'>content</span><span class='op'>=</span>(<span class='id identifier rubyid_string'>string</span>) <span class='comment'># Set the Node&#39;s content to a Text node containing string. The string gets XML escaped, and will not be interpreted as markup.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_inner_html'>inner_html</span> <span class='comment'># (*args) children.map { |x| x.to_html(*args) }.join
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_inner_html'>inner_html</span><span class='op'>=</span>(<span class='id identifier rubyid_node_or_tags'>node_or_tags</span>)
  <span class='comment'># Sets the inner html of this Node to node_or_tags
</span>  <span class='comment'># Returns self.
</span>  <span class='comment'># Also see related method children=
</span>




<span class='comment'>## Searching below (see Working with a Nodeset below)
</span><span class='comment'># see docs for namespace bindings, variable bindings, and custom xpath functions via a handler class
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_search'>search</span>(<span class='op'>*</span><span class='id identifier rubyid_paths'>paths</span>) <span class='comment'># alias: node / path # paths can be XPath or CSS
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_at'>at</span>(<span class='op'>*</span><span class='id identifier rubyid_paths'>paths</span>) <span class='comment'># alias node % path # Search for the first occurrence of path. Returns nil if nothing is found, otherwise a Node. (like search(path, ns).first)
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_xpath'>xpath</span>(<span class='op'>*</span><span class='id identifier rubyid_paths'>paths</span>) <span class='comment'># search for XPath queries
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_at_xpath'>at_xpath</span>(<span class='op'>*</span><span class='id identifier rubyid_paths'>paths</span>) <span class='comment'># like xpath(*paths).first
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_css'>css</span>(<span class='op'>*</span><span class='id identifier rubyid_rules'>rules</span>) <span class='comment'># search for CSS rules
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_at_css'>at_css</span>(<span class='op'>*</span><span class='id identifier rubyid_rules'>rules</span>) <span class='comment'># like css(*rules).first
</span><span class='id identifier rubyid_node'>node</span> <span class='op'>&gt;</span> <span class='id identifier rubyid_selector'>selector</span> <span class='comment'># Search this node&#39;s immediate children using a CSS selector
</span>

<span class='comment'># Searching above
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_ancestors'>ancestors</span> <span class='comment'># list of ancestor nodes, closest to furthest, as a NodeSet.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_ancestors'>ancestors</span>(<span class='id identifier rubyid_selector'>selector</span>) <span class='comment'># ancestors that match the selector
</span>

<span class='comment'># Where am I?
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_path'>path</span> <span class='comment'># Returns the path associated with this Node
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_css_path'>css_path</span> <span class='comment'># Get the path to this node as a CSS expression
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_matches?'>matches?</span>(<span class='id identifier rubyid_selector'>selector</span>) <span class='comment'># does this node match this selector?
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_line'>line</span> <span class='comment'># line number from input
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_pointer_id'>pointer_id</span> <span class='comment'># internal pointer number
</span>
<span class='comment'># Namespaces
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_add_namespace'>add_namespace</span>(<span class='id identifier rubyid_prefix'>prefix</span><span class='comma'>,</span> <span class='id identifier rubyid_href'>href</span>) <span class='comment'># alias of node.add_namespace_definition
</span>  <span class='comment'># Adds a namespace definition with prefix using href value. The result is as
</span>  <span class='comment'># if parsed XML for this node had included an attribute
</span>  <span class='comment'># ‘xmlns:prefix=value&#39;. A default namespace for this node (“xmlns=”) can be
</span>  <span class='comment'># added by passing ‘nil&#39; for prefix. Namespaces added this way will not show
</span>  <span class='comment'># up in #attributes, but they will be included as an xmlns attribute when
</span>  <span class='comment'># the node is serialized to XML.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_default_namespace'>default_namespace</span><span class='op'>=</span>(<span class='id identifier rubyid_url'>url</span>)
  <span class='comment'># Adds a default namespace supplied as a string url href, to self. The
</span>  <span class='comment'># consequence is as an xmlns attribute with supplied argument were present
</span>  <span class='comment'># in parsed XML. A default namespace set with this method will now show up
</span>  <span class='comment'># in #attributes, but when this node is serialized to XML an “xmlns”
</span>  <span class='comment'># attribute will appear. See also #namespace and #namespace=
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_namespace'>namespace</span> <span class='comment'>#   returns the default namespace set on this node (as with an “xmlns=” attribute), as a Namespace object.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_namespace'>namespace</span><span class='op'>=</span>(<span class='id identifier rubyid_ns'>ns</span>)
  <span class='comment'># Set the default namespace on this node (as would be defined with an
</span>  <span class='comment'># “xmlns=” attribute in XML source), as a Namespace object ns . Note that a
</span>  <span class='comment'># Namespace added this way will NOT be serialized as an xmlns attribute for
</span>  <span class='comment'># this node. You probably want #default_namespace= instead, or perhaps
</span>  <span class='comment'># #add_namespace_definition with a nil prefix argument.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_namespace_definitions'>namespace_definitions</span>
  <span class='comment'># returns namespaces defined on self element directly, as an array of
</span>  <span class='comment'># Namespace objects. Includes both a default namespace (as in“xmlns=”), and
</span>  <span class='comment'># prefixed namespaces (as in “xmlns:prefix=”).
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_namespace_scopes'>namespace_scopes</span>
  <span class='comment'># returns namespaces in scope for self – those defined on self element
</span>  <span class='comment'># directly or any ancestor node – as an array of Namespace objects. Default
</span>  <span class='comment'># namespaces (“xmlns=” style) for self are included in this array; Default
</span>  <span class='comment'># namespaces for ancestors, however, are not. See also #namespaces
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_namespaced_key?'>namespaced_key?</span>(<span class='id identifier rubyid_attribute'>attribute</span><span class='comma'>,</span> <span class='id identifier rubyid_namespace'>namespace</span>)
  <span class='comment'># Returns true if attribute is set with namespace
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_namespaces'>namespaces</span> <span class='comment'># Returns a Hash of {prefix =&gt; value} for all namespaces on this node and its ancestors.
</span>  <span class='comment'># This method returns the same namespaces as #namespace_scopes.
</span>  <span class='comment'># 
</span>  <span class='comment'># Returns namespaces in scope for self – those defined on self element
</span>  <span class='comment'># directly or any ancestor node – as a Hash of attribute-name/value pairs.
</span>  <span class='comment'># Note that the keys in this hash XML attributes that would be used to
</span>  <span class='comment'># define this namespace, such as “xmlns:prefix”, not just the prefix.
</span>  <span class='comment'># Default namespace set on self will be included with key “xmlns”. However,
</span>  <span class='comment'># default namespaces set on ancestor will NOT be, even if self has no
</span>  <span class='comment'># explicit default namespace.
</span><span class='comment'># see also attribute_with_ns
</span>

<span class='comment'># Rubyisms
</span><span class='id identifier rubyid_node'>node</span> <span class='op'>&lt;=&gt;</span> <span class='id identifier rubyid_another_node'>another_node</span> <span class='comment'># Compare two Node objects with respect to their Document. Nodes from different documents cannot be compared.
</span>  <span class='comment'># uses xmlXPathCmpNodes &quot;Compare two nodes w.r.t document order&quot;
</span><span class='id identifier rubyid_node'>node</span> <span class='op'>==</span> <span class='id identifier rubyid_another_node'>another_node</span> <span class='comment'># compares pointer_id
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_clone'>clone</span> <span class='comment'># alias node.dup # Copy this node. An optional depth may be passed in, but it defaults to a deep copy. 0 is a shallow copy, 1 is a deep copy.
</span>
<span class='comment'># Visitor pattern
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_accept'>accept</span>(<span class='id identifier rubyid_visitor'>visitor</span>) <span class='comment'># calls visitor.visit(self)
</span>
<span class='comment'># Write it out (sorted from most flexible/hardest to use to least flexible/easiest to use)
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_write_to'>write_to</span>(<span class='id identifier rubyid_io'>io</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_options'>options</span>)
  <span class='comment'># Write Node to io with options. options modify the output of
</span>  <span class='comment'># this method.  Valid options are:
</span>  <span class='comment'>#
</span>  <span class='comment'># * :encoding for changing the encoding
</span>  <span class='comment'># * :indent_text the indentation text, defaults to one space
</span>  <span class='comment'># * :indent the number of :indent_text to use, defaults to 2
</span>  <span class='comment'># * :save_with a combination of SaveOptions constants.
</span>    <span class='comment'># SaveOptions
</span>      <span class='comment'># AS_BUILDER: Save builder created document
</span>      <span class='comment'># AS_HTML: Save as HTML
</span>      <span class='comment'># AS_XHTML: Save as XHTML
</span>      <span class='comment'># AS_XML: Save as XML
</span>      <span class='comment'># DEFAULT_HTML: the default for HTML document
</span>      <span class='comment'># DEFAULT_XHTML: the default for XHTML document
</span>      <span class='comment'># DEFAULT_XML: the default for XML documents
</span>      <span class='comment'># FORMAT: Format serialized xml
</span>      <span class='comment'># NO_DECLARATION: Do not include declarations
</span>      <span class='comment'># NO_EMPTY_TAGS: Do not include empty tags
</span>      <span class='comment'># NO_XHTML: Do not save XHTML
</span>  <span class='comment'># e.g. node.write_to(io, :encoding =&gt; &#39;UTF-8&#39;, :indent =&gt; 2)
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_write_html_to'>write_html_to</span>(<span class='id identifier rubyid_io'>io</span><span class='comma'>,</span> <span class='id identifier rubyid_options'>options</span><span class='op'>=</span>{}) <span class='comment'># uses write_to with :save_with =&gt; DEFAULT_HTML option (libxml2.6 does dump_html)
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_write_xhtml_to'>write_xhtml_to</span>(<span class='id identifier rubyid_io'>io</span>. <span class='id identifier rubyid_options'>options</span><span class='op'>=</span>{}) <span class='comment'># uses write_to with :save_with =&gt; DEFAULT_XHTML option (libxml2.6 does dump_html)
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_write_xml_to'>write_xml_to</span>(<span class='id identifier rubyid_io'>io</span><span class='comma'>,</span> <span class='id identifier rubyid_options'>options</span><span class='op'>=</span>{}) <span class='comment'># uses write_to with :save_with =&gt; DEFAULT_XML option
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_serialize'>serialize</span> <span class='comment'># Serialize Node a string using options, provided as a hash or block. Uses write_to (via StringIO)
</span>  <span class='comment'># node.serialize(:encoding =&gt; &#39;UTF-8&#39;, :save_with =&gt; FORMAT | AS_XML)
</span>  <span class='comment'># node.serialize(:encoding =&gt; &#39;UTF-8&#39;) do |config|
</span>  <span class='comment'>#   config.format.as_xml
</span>  <span class='comment'># end
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_to_html'>to_html</span>(<span class='id identifier rubyid_options'>options</span><span class='op'>=</span>{}) <span class='comment'># serializes with :save_with =&gt; DEFAULT_HTML option (libxml2.6 does dump_html)
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_to_xhtml'>to_xhtml</span>(<span class='id identifier rubyid_options'>options</span><span class='op'>=</span>{}) <span class='comment'># serializes with :save_with =&gt; DEFAULT_XHTML option (libxml2.6 does dump_html)
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_to_xml'>to_xml</span>(<span class='id identifier rubyid_options'>options</span><span class='op'>=</span>{}) <span class='comment'># serializes with :save_with =&gt; DEFAULT_XML option
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_to_s'>to_s</span> <span class='comment'># document.xml? ? to_xml : to_html
</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_inspect'>inspect</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_pretty_print'>pretty_print</span>(<span class='id identifier rubyid_pp'>pp</span>) <span class='comment'># to enhance pp
</span>
<span class='comment'># Utility
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_encode_special_chars'>encode_special_chars</span>(<span class='id identifier rubyid_str'>str</span>) <span class='comment'># Encodes special characters :P
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_fragment'>fragment</span>(<span class='id identifier rubyid_tags'>tags</span>) <span class='comment'># Create a DocumentFragment containing tags that is relative to this context node.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_parse'>parse</span>(<span class='id identifier rubyid_string_or_io'>string_or_io</span><span class='comma'>,</span> <span class='id identifier rubyid_options'>options</span><span class='op'>=</span>{})
  <span class='comment'># Parse string_or_io as a document fragment within the context of
</span>  <span class='comment'># *this* node.  Returns a XML::NodeSet containing the nodes parsed from
</span>  <span class='comment'># string_or_io.
</span>
<span class='comment'># External subsets, like DTD declarations
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_create_external_subset'>create_external_subset</span>(<span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_external_id'>external_id</span><span class='comma'>,</span> <span class='id identifier rubyid_system_id'>system_id</span>)
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_create_internal_subset'>create_internal_subset</span>(<span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_external_id'>external_id</span><span class='comma'>,</span> <span class='id identifier rubyid_system_id'>system_id</span>)
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_external_subset'>external_subset</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_internal_subset'>internal_subset</span>

<span class='comment'># Other:
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_description'>description</span> <span class='comment'># Fetch the Nokogiri::HTML::ElementDescription for this node. Returns nil on XML documents and on unknown tags.
</span>  <span class='comment'># e.g. if node is an &lt;img&gt; tag: Nokogiri::HTML::ElementDescription[&#39;img&#39;]  Nokogiri::HTML::ElementDescription: img embedded image &gt;
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_decorate!'>decorate!</span> <span class='comment'># Decorate this node with the decorators set up in this node&#39;s Document. Used internally to provide Slop support and Hpricot compatibility via Nokogiri::Hpricot
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_do_xinclude'>do_xinclude</span> <span class='comment'># options as a block or hash
</span>  <span class='comment'># Do xinclude substitution on the subtree below node. If given a block, a
</span>  <span class='comment'># Nokogiri::XML::ParseOptions object initialized from options, will be
</span>  <span class='comment'># passed to it, allowing more convenient modification of the parser options.</span></code></pre>

<h2>Working with a <a href="https://nokogiri.org/rdoc/Nokogiri/XML/NodeSet.html">Nokogiri::XML::NodeSet</a></h2>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_nodes'>nodes</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML.html" title="Nokogiri::XML (module)">XML</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML/NodeSet.html" title="Nokogiri::XML::NodeSet (class)">NodeSet</a></span>.<span class='id identifier rubyid_new'><a href="Nokogiri/XML/NodeSet.html#new-class_method" title="Nokogiri::XML::NodeSet.new (method)">new</a></span>(<span class='id identifier rubyid_document'>document</span><span class='comma'>,</span> <span class='id identifier rubyid_list'>list</span><span class='op'>=</span>[])

<span class='comment'># Set operations
</span><span class='id identifier rubyid_nodes'>nodes</span> <span class='op'>|</span> <span class='id identifier rubyid_other_nodeset'>other_nodeset</span> <span class='comment'># UNION, i.e. merging the sets, returning a new set
</span><span class='id identifier rubyid_nodes'>nodes</span> <span class='op'>+</span> <span class='id identifier rubyid_other_nodeset'>other_nodeset</span> <span class='comment'># UNION, i.e. merging the sets, returning a new set
</span><span class='id identifier rubyid_nodes'>nodes</span> <span class='op'>&amp;</span> <span class='id identifier rubyid_other_nodeset'>other_nodeset</span> <span class='comment'># INTERSECTION # i.e. return a new NodeSet with the common nodes only
</span><span class='id identifier rubyid_nodes'>nodes</span> <span class='op'>-</span> <span class='id identifier rubyid_other_nodeset'>other_nodeset</span> <span class='comment'># DIFFERENCE Returns a new NodeSet containing the nodes in this NodeSet that aren&#39;t in other_nodeset
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_include?'>include?</span>(<span class='id identifier rubyid_node'>node</span>)
<span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_empty?'>empty?</span>
<span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_length'>length</span> <span class='comment'># alias nodes.size
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_delete'>delete</span>(<span class='id identifier rubyid_node'>node</span>) <span class='comment'># Delete node from the Nodeset, if it is a member. Returns the deleted node if found, otherwise returns nil.
</span>
<span class='comment'># List operations (includes Enumerable)
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_each'>each</span> { <span class='op'>|</span><span class='id identifier rubyid_node'>node</span><span class='op'>|</span> }
<span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_first'>first</span>
<span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_last'>last</span>
<span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_reverse'>reverse</span> <span class='comment'># Returns a new NodeSet containing all the nodes in the NodeSet in reverse order
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_index'>index</span>(<span class='id identifier rubyid_node'>node</span>) <span class='comment'># returns the numeric index or nil
</span><span class='id identifier rubyid_nodes'>nodes</span>[<span class='int'>3</span>] <span class='comment'># element at index 3
</span><span class='id identifier rubyid_nodes'>nodes</span>[<span class='int'>3</span><span class='comma'>,</span><span class='int'>4</span>] <span class='comment'># return a NodeSet of size 4, starting at index 3
</span><span class='id identifier rubyid_nodes'>nodes</span>[<span class='int'>3</span><span class='op'>..</span><span class='int'>6</span>] <span class='comment'># or return a NodeSet using a range of indexes
</span><span class='comment'># alias nodes.slice
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_pop'>pop</span> <span class='comment'># Removes the last element from set and returns it, or nil if the set is empty
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_push'>push</span>(<span class='id identifier rubyid_node'>node</span>) <span class='comment'># alias nodes &lt;&lt; node # Append node to the NodeSet.
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_shift'>shift</span> <span class='comment'># Returns the first element of the NodeSet and removes it. Returns nil if the set is empty.
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_filter'>filter</span>(<span class='id identifier rubyid_expr'>expr</span>) <span class='comment'># Filter this list for nodes that match an XPATH or CSS query
</span>  <span class='comment'># find_all { |node| node.matches?(expr) }
</span>
<span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_children'>children</span> <span class='comment'># Returns a new NodeSet containing all the children of all the nodes in the NodeSet
</span>
<span class='comment'># Content
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_inner_html'>inner_html</span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>) <span class='comment'># Get the inner html of all contained Node objects
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_inner_text'>inner_text</span> <span class='comment'># alias nodes.text
</span>
<span class='comment'># Convenience modifiers
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_remove'>remove</span> <span class='comment'># alias of nodes.unlink # Unlink this NodeSet and all Node objects it contains from their current context.
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_wrap'>wrap</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>&lt;div class=&#39;container&#39;&gt;&lt;/div&gt;</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'># wrap new xml around EACH NODE in a Nodeset
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_before'>before</span>(<span class='id identifier rubyid_datum'>datum</span>) <span class='comment'># Insert datum before the first Node in this NodeSet # e.g. first.before(datum)
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_after'>after</span>(<span class='id identifier rubyid_datum'>datum</span>) <span class='comment'># Insert datum after the last Node in this NodeSet # e.g. last.after(datum)
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_attr'>attr</span>(<span class='id identifier rubyid_key'>key</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span>) <span class='comment'># set the attribute key to value on all Node objects in the NodeSet
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_attr'>attr</span>(<span class='id identifier rubyid_key'>key</span>) { <span class='op'>|</span><span class='id identifier rubyid_node'>node</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>value</span><span class='tstring_end'>&#39;</span></span> } <span class='comment'># set the attribute key to the result of the block on all Node objects in the NodeSet
</span>  <span class='comment'># alias nodes.attribute, nodes.set
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_remove_attr'>remove_attr</span>(<span class='id identifier rubyid_name'>name</span>) <span class='comment'># removes the attribute from all nodes in the nodeset
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_add_class'>add_class</span>(<span class='id identifier rubyid_name'>name</span>) <span class='comment'># Append the class attribute name to all Node objects in the NodeSet.
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_remove_class'>remove_class</span>(<span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='kw'>nil</span>) <span class='comment'># if nil, removes the class attrinute from all nodes in the nodeset
</span>
<span class='comment'># Searching
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_search'>search</span>(<span class='op'>*</span><span class='id identifier rubyid_paths'>paths</span>) <span class='comment'># alias nodes / path
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_at'>at</span>(<span class='op'>*</span><span class='id identifier rubyid_paths'>paths</span>) <span class='comment'># alias nodes % path
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_xpath'>xpath</span>(<span class='op'>*</span><span class='id identifier rubyid_paths'>paths</span>)
<span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_at_xpath'>at_xpath</span>(<span class='op'>*</span><span class='id identifier rubyid_paths'>paths</span>)
<span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_css'>css</span>(<span class='op'>*</span><span class='id identifier rubyid_rules'>rules</span>)
<span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_at_css'>at_css</span>(<span class='op'>*</span><span class='id identifier rubyid_rules'>rules</span>)
<span class='id identifier rubyid_nodes'>nodes</span> <span class='op'>&gt;</span> <span class='id identifier rubyid_selector'>selector</span> <span class='comment'># Search this NodeSet&#39;s nodes&#39; immediate children using CSS selector
</span>
<span class='comment'># Writing out
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_to_a'>to_a</span> <span class='comment'># alias nodes.to_ary # Return this list as an Array
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_to_html'>to_html</span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>)
<span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_to_s'>to_s</span>
<span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_to_xhtml'>to_xhtml</span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>)
<span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_to_xml'>to_xml</span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>)

<span class='comment'># Rubyisms
</span><span class='id identifier rubyid_nodes'>nodes</span> <span class='op'>==</span> <span class='id identifier rubyid_nodes'>nodes</span> <span class='comment'># Two NodeSets are equal if the contain the same number of elements and if each element is equal to the corresponding element in the other NodeSet
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_dup'>dup</span> <span class='comment'># Duplicate this node set
</span><span class='id identifier rubyid_nodes'>nodes</span>.<span class='id identifier rubyid_inspect'>inspect</span></code></pre>

<h2>Miscellany</h2>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_nc'>nc</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/HTML.html" title="Nokogiri::HTML (module)">HTML</a></span><span class='op'>::</span><span class='const'>NamedCharacters</span> <span class='comment'># a Nokogiri::HTML::EntityLookup
</span><span class='id identifier rubyid_nc'>nc</span>[<span class='id identifier rubyid_key'>key</span>] <span class='comment'># like nc.get(key).try(:value) # e.g. nc[&#39;gt&#39;] (62) or nc[&#39;rsquo&#39;] (8217)
</span><span class='id identifier rubyid_nc'>nc</span>.<span class='id identifier rubyid_get'>get</span>(<span class='id identifier rubyid_key'>key</span>) <span class='comment'># returns an Nokogiri::HTML::EntityDescription
</span>  <span class='comment'># e.g. nc.get(&#39;rsquo&#39;) #=&gt;  #&lt;struct Nokogiri::HTML::EntityDescription value=8217, name=&quot;rsquo&quot;, description=&quot;right single quotation mark, U+2019 ISOnum&quot;&gt;
</span>
<span class='comment'># Adding a Processing Instruction (like &lt;?xml-stylesheet?&gt;)
</span><span class='comment'># Nokogiri::XML::ProcessingInstruction https://nokogiri.org/tutorials/modifying_an_html_xml_document.html
</span><span class='id identifier rubyid_pi'>pi</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML.html" title="Nokogiri::XML (module)">XML</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML/ProcessingInstruction.html" title="Nokogiri::XML::ProcessingInstruction (class)">ProcessingInstruction</a></span>.<span class='id identifier rubyid_new'><a href="Nokogiri/XML/ProcessingInstruction.html#new-class_method" title="Nokogiri::XML::ProcessingInstruction.new (method)">new</a></span>(<span class='id identifier rubyid_doc'>doc</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>xml-stylesheet</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>type=&quot;text/xsl&quot; href=&quot;foo.xsl&quot;</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_root'>root</span>.<span class='id identifier rubyid_add_previous_sibling'>add_previous_sibling</span>(<span class='id identifier rubyid_pi'>pi</span>)</code></pre>

<h2><a href="https://nokogiri.org/rdoc/Nokogiri/XML/Reader.html">Reader</a> parsers</h2>

<p>Reader parsers can be used to parse very large XML documents quickly without the need to load the entire document into memory or write a SAX document parser. The reader makes each node in the XML document available exactly once, only moving forward, like a cursor.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_reader'>reader</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML.html" title="Nokogiri::XML (module)">XML</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML/Reader.html" title="Nokogiri::XML::Reader (class)">Reader</a></span>(<span class='id identifier rubyid_string_or_io'>string_or_io</span>)
  <span class='comment'># attrs
</span>  <span class='comment'># .encoding
</span>  <span class='comment'># .errors
</span>  <span class='comment'># .source
</span>
<span class='comment'># Reading
</span><span class='id identifier rubyid_reader'>reader</span>.<span class='id identifier rubyid_each'>each</span> {<span class='op'>|</span><span class='id identifier rubyid_node'>node</span><span class='op'>|</span>  } <span class='comment'># node and reader are the same object. shortcut for while(node = self.read) yield(node); end;
</span><span class='id identifier rubyid_reader'>reader</span>.<span class='id identifier rubyid_read'>read</span> <span class='comment'># Move the Reader forward through the XML document.
</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_name'>name</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_local_name'>local_name</span>

<span class='comment'># Attributes
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_attribute'>attribute</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>src</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_attribute_at'>attribute_at</span>(<span class='int'>1</span>)
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_attribute_count'>attribute_count</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_attribute_nodes'>attribute_nodes</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_attributes'>attributes</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_attributes?'>attributes?</span>

<span class='comment'># Content
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_empty_element?'>empty_element?</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_self_closing?'>self_closing?</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_value'>value</span> <span class='comment'># Get the text value of the node if present as a utf-8 encoded string. Does NOT advance the reader.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_value?'>value?</span> <span class='comment'># Does this node have a text value?
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_inner_xml'>inner_xml</span> <span class='comment'># Read the contents of the current node, including child nodes and markup into a utf-8 encoded string. Does NOT advance the reader
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_outer_xml'>outer_xml</span> <span class='comment'># Does NOT advance the reader
</span>
<span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_base_uri'>base_uri</span> <span class='comment'># Get the xml:base of the node
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_default?'>default?</span> <span class='comment'># Was an attribute generated from the default value in the DTD or schema?
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_depth'>depth</span>

<span class='comment'># Namespaces and the rest
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_namespace_uri'>namespace_uri</span> <span class='comment'># Get the URI defining the namespace associated with the node
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_namespaces'>namespaces</span> <span class='comment'># Get a hash of namespaces for this Node
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_prefix'>prefix</span> <span class='comment'># Get the shorthand reference to the namespace associated with the node.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_xml_version'>xml_version</span> <span class='comment'># Get the XML version of the document being read
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_lang'>lang</span> <span class='comment'># Get the xml:lang scope within which the node resides.
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_node_type'>node_type</span>
  <span class='comment'># one of 
</span>  <span class='comment'># TYPE_ATTRIBUTE
</span>  <span class='comment'># TYPE_CDATA
</span>  <span class='comment'># TYPE_COMMENT
</span>  <span class='comment'># TYPE_DOCUMENT
</span>  <span class='comment'># TYPE_DOCUMENT_FRAGMENT
</span>  <span class='comment'># TYPE_DOCUMENT_TYPE
</span>  <span class='comment'># TYPE_ELEMENT
</span>  <span class='comment'># TYPE_END_ELEMENT
</span>  <span class='comment'># TYPE_END_ENTITY
</span>  <span class='comment'># TYPE_ENTITY
</span>  <span class='comment'># TYPE_ENTITY_REFERENCE
</span>  <span class='comment'># TYPE_NONE
</span>  <span class='comment'># TYPE_NOTATION
</span>  <span class='comment'># TYPE_PROCESSING_INSTRUCTION
</span>  <span class='comment'># TYPE_SIGNIFICANT_WHITESPACE
</span>  <span class='comment'># TYPE_TEXT
</span>  <span class='comment'># TYPE_WHITESPACE
</span>  <span class='comment'># TYPE_XML_DECLARATION
</span><span class='id identifier rubyid_node'>node</span>.<span class='id identifier rubyid_state'>state</span> <span class='comment'># Get the state of the reader</span></code></pre>

<h2>XSD Validation</h2>

<p><a href="https://nokogiri.org/rdoc/XSD.html">XSD</a>
<a href="https://nokogiri.org/rdoc/XSD/XMLParser.html">XSD::XMLParser</a>
<a href="https://nokogiri.org/rdoc/XSD/XMLParser/Nokogiri.html">XSD::XMLParser::Nokogiri</a></p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_xsd'>xsd</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML.html" title="Nokogiri::XML (module)">XML</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML/Schema.html" title="Nokogiri::XML::Schema (class)">Schema</a></span>(<span class='id identifier rubyid_string_or_io_to_schema_file'>string_or_io_to_schema_file</span>)
<span class='id identifier rubyid_doc'>doc</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML.html" title="Nokogiri::XML (module)">XML</a></span>(<span class='const'>File</span>.<span class='id identifier rubyid_read'>read</span>(<span class='const'>PO_XML_FILE</span>))

<span class='id identifier rubyid_xsd'>xsd</span>.<span class='id identifier rubyid_valid?'>valid?</span>(<span class='id identifier rubyid_doc'>doc</span>) <span class='comment'># =&gt; true/false
</span>
<span class='id identifier rubyid_xsd'>xsd</span>.<span class='id identifier rubyid_validate'>validate</span>(<span class='id identifier rubyid_doc'>doc</span>) <span class='comment'># returns an an array of SyntaxError s
</span><span class='id identifier rubyid_xsd'>xsd</span>.<span class='id identifier rubyid_validate'>validate</span>(<span class='id identifier rubyid_doc'>doc</span>).<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_syntax_error'>syntax_error</span><span class='op'>|</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_error?'>error?</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_fatal?'>fatal?</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_none?'>none?</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_to_s'>to_s</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_warning?'>warning?</span>

  <span class='comment'># undocumented attributes
</span>  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_code'>code</span> <span class='const'>R</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_column'>column</span> <span class='const'>R</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_domain'>domain</span> <span class='const'>R</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_file'>file</span> <span class='const'>R</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_int1'>int1</span> <span class='const'>R</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_level'>level</span> <span class='const'>R</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_line'>line</span> <span class='const'>R</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_str1'>str1</span> <span class='const'>R</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_str2'>str2</span> <span class='const'>R</span>
  <span class='id identifier rubyid_syntax_error'>syntax_error</span>.<span class='id identifier rubyid_str3'>str3</span> <span class='const'>R</span>
<span class='kw'>end</span>


<span class='comment'># https://nokogiri.org/rdoc/Nokogiri/XML/Schema.html
</span><span class='comment'># https://nokogiri.org/rdoc/Nokogiri/XML/AttributeDecl.html
</span><span class='comment'># https://nokogiri.org/rdoc/Nokogiri/XML/DTD.html
</span><span class='comment'># https://nokogiri.org/rdoc/Nokogiri/XML/ElementDecl.html
</span><span class='comment'># https://nokogiri.org/rdoc/Nokogiri/XML/ElementContent.html
</span><span class='comment'># https://nokogiri.org/rdoc/Nokogiri/XML/EntityDecl.html
</span><span class='comment'># https://nokogiri.org/rdoc/Nokogiri/XML/EntityReference.html
</span>
<span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_validate'>validate</span> <span class='comment'># validate it against its DTD, if it has one</span></code></pre>

<h2>CSS Parsing</h2>

<p><a href="https://nokogiri.org/rdoc/Nokogiri/CSS.html">Nokogiri::CSS</a>
<a href="https://nokogiri.org/rdoc/Nokogiri/CSS/Node.html">Nokogiri::CSS::Node</a>
<a href="https://nokogiri.org/rdoc/Nokogiri/CSS/Parser.html">Nokogiri::CSS::Parser</a>
<a href="https://nokogiri.org/rdoc/Nokogiri/CSS/SyntaxError.html">Nokogiri::CSS::SyntaxError</a>
<a href="https://nokogiri.org/rdoc/Nokogiri/CSS/Tokenizer.html">Nokogiri::CSS::Tokenizer</a>
<a href="https://nokogiri.org/rdoc/Nokogiri/CSS/Tokenizer/ScanError.html">Nokogiri::CSS::Tokenizer::ScanError</a></p>

<pre class="code ruby"><code class="ruby"><span class='comment'># https://nokogiri.org/rdoc/Nokogiri/CSS.html
</span><span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/CSS.html" title="Nokogiri::CSS (module)">CSS</a></span>.<span class='id identifier rubyid_parse'><a href="Nokogiri/CSS.html#parse-class_method" title="Nokogiri::CSS.parse (method)">parse</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>selector</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># =&gt; returns an AST
</span><span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/CSS.html" title="Nokogiri::CSS (module)">CSS</a></span>.<span class='id identifier rubyid_xpath_for'><a href="Nokogiri/CSS.html#xpath_for-class_method" title="Nokogiri::CSS.xpath_for (method)">xpath_for</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>selector</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_options'>options</span><span class='op'>=</span>{})

<span class='comment'># https://nokogiri.org/rdoc/Nokogiri/CSS/Node.html
</span>  <span class='comment'># attr: type, value
</span>  <span class='comment'>#methods
</span>  <span class='comment'># accept(visitor)
</span>  <span class='comment'># find_by_type
</span>  <span class='comment'># new
</span>  <span class='comment'># preprocess!
</span>  <span class='comment'># to_a
</span>  <span class='comment'># to_type
</span>  <span class='comment'># to_xpath
</span><span class='comment'># https://nokogiri.org/rdoc/Nokogiri/CSS/Parser.html # a Racc generated Parser</span></code></pre>

<h2>XSLT Transformation</h2>

<p><a href="https://nokogiri.org/rdoc/Nokogiri/XSLT.html">Nokogiri::XSLT</a>
<a href="https://nokogiri.org/rdoc/Nokogiri/XSLT/Stylesheet.html">Nokogiri::XSLT::Stylesheet</a></p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_doc'>doc</span>   <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML.html" title="Nokogiri::XML (module)">XML</a></span>(<span class='const'>File</span>.<span class='id identifier rubyid_read'>read</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some_file.xml</span><span class='tstring_end'>&#39;</span></span>))
<span class='id identifier rubyid_xslt'>xslt</span>  <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XSLT.html" title="Nokogiri::XSLT (module)">XSLT</a></span>(<span class='const'>File</span>.<span class='id identifier rubyid_read'>read</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some_transformer.xslt</span><span class='tstring_end'>&#39;</span></span>))
<span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_xslt'>xslt</span>.<span class='id identifier rubyid_transform'>transform</span>(<span class='id identifier rubyid_doc'>doc</span>) <span class='comment'># [, xslt_parameters]
</span><span class='comment'>#   xslt.serialize(doc) # to am xml string
</span><span class='comment'>#   xslt.apply_to(doc, params=[]) # equivalent to xslt.serialize(xslt.transform(doc, params))</span></code></pre>

<h2><a href="https://nokogiri.org/rdoc/Nokogiri/XML/SAX.html">SAX</a> Parsing</h2>

<p>Event-driving XML parsing appropriate for reading very large XML files without reading the entire document into memory. <a href="https://github.com/sparklemotion/nokogiri/blob/main/lib/nokogiri/xml/sax/document.rb">The best documentation is in this file.</a></p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Document template
</span><span class='comment'># Define any or all of these methods to get their notifications:
</span><span class='comment'># Your document doesn&#39;t have to subclass Nokogiri::XML::SAX::Document, 
</span><span class='comment'># doing so just saves you from having to define all the sax methods, 
</span><span class='comment'># rather than the few you need.
</span><span class='kw'>class</span> <span class='const'>MyDocument</span> <span class='op'>&lt;</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML.html" title="Nokogiri::XML (module)">XML</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML/SAX.html" title="Nokogiri::XML::SAX (module)">SAX</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML/SAX/Document.html" title="Nokogiri::XML::SAX::Document (class)">Document</a></span>
  <span class='kw'>def</span> <span class='id identifier rubyid_xmldecl'>xmldecl</span>(<span class='id identifier rubyid_version'>version</span><span class='comma'>,</span> <span class='id identifier rubyid_encoding'>encoding</span><span class='comma'>,</span> <span class='id identifier rubyid_standalone'>standalone</span>)
  <span class='kw'>end</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_start_document'>start_document</span>
  <span class='kw'>end</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_end_document'>end_document</span>
  <span class='kw'>end</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_start_element'>start_element</span>(<span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_attrs'>attrs</span> <span class='op'>=</span> [])
  <span class='kw'>end</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_end_element'>end_element</span>(<span class='id identifier rubyid_name'>name</span>)
  <span class='kw'>end</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_start_element_namespace'>start_element_namespace</span>(<span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_attrs'>attrs</span> <span class='op'>=</span> []<span class='comma'>,</span> <span class='id identifier rubyid_prefix'>prefix</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_uri'>uri</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_ns'>ns</span> <span class='op'>=</span> [])
  <span class='kw'>end</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_end_element_namespace'>end_element_namespace</span>(<span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_prefix'>prefix</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_uri'>uri</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='kw'>end</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_characters'>characters</span>(<span class='id identifier rubyid_string'>string</span>)
  <span class='kw'>end</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_comment'>comment</span>(<span class='id identifier rubyid_string'>string</span>)
  <span class='kw'>end</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_warning'>warning</span>(<span class='id identifier rubyid_string'>string</span>)
  <span class='kw'>end</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_error'>error</span>(<span class='id identifier rubyid_string'>string</span>)
  <span class='kw'>end</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_cdata_block'>cdata_block</span>(<span class='id identifier rubyid_string'>string</span>)
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='comment'># Standard Parser
</span><span class='id identifier rubyid_parser'>parser</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML.html" title="Nokogiri::XML (module)">XML</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML/SAX.html" title="Nokogiri::XML::SAX (module)">SAX</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML/SAX/Parser.html" title="Nokogiri::XML::SAX::Parser (class)">Parser</a></span>.<span class='id identifier rubyid_new'><a href="Nokogiri/XML/SAX/Parser.html#new-class_method" title="Nokogiri::XML::SAX::Parser.new (method)">new</a></span>(<span class='const'>MyDocument</span>.<span class='id identifier rubyid_new'>new</span>) <span class='comment'># [, encoding = &#39;UTF-8]
</span><span class='comment'># A block can be passed to the parse methods to get the ParserContext before parsing, but you probably don&#39;t need that
</span><span class='id identifier rubyid_parser'>parser</span>.<span class='id identifier rubyid_parse'>parse</span>(<span class='id identifier rubyid_string_or_io'>string_or_io</span>)
<span class='id identifier rubyid_parser'>parser</span>.<span class='id identifier rubyid_parse_io'>parse_io</span>(<span class='id identifier rubyid_io'>io</span>) <span class='comment'># [, encoding = &quot;ASCII&quot;]
</span><span class='id identifier rubyid_parser'>parser</span>.<span class='id identifier rubyid_parse_file'>parse_file</span>(<span class='id identifier rubyid_filename'>filename</span>)
<span class='id identifier rubyid_parser'>parser</span>.<span class='id identifier rubyid_parse_memory'>parse_memory</span>(<span class='id identifier rubyid_string'>string</span>)

<span class='comment'># If you want HTML correction features, instantiate this parser instead
</span><span class='id identifier rubyid_parser'>parser</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/HTML.html" title="Nokogiri::HTML (module)">HTML</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/HTML/SAX.html" title="Nokogiri::HTML::SAX (module)">SAX</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/HTML/SAX/Parser.html" title="Nokogiri::HTML::SAX::Parser (class)">Parser</a></span>.<span class='id identifier rubyid_new'><a href="Nokogiri/XML/SAX/Parser.html#new-class_method" title="Nokogiri::XML::SAX::Parser.new (method)">new</a></span>(<span class='const'>MyDoc</span>.<span class='id identifier rubyid_new'>new</span>)</code></pre>

<p>(If you&#39;re a weirdo,) You can stream the XML manually using <a href="https://nokogiri.org/rdoc/Nokogiri/XML/SAX/PushParser.html">Nokogiri::SAX::PushParser</a>
The best documentation is <a href="https://github.com/sparklemotion/nokogiri/blob/main/lib/nokogiri/xml/sax/push_parser.rb">this file</a>.</p>

<h2><a href="https://nokogiri.org/rdoc/Nokogiri/Decorators/Slop.html">Slop</a> decorator (Don’t use this)</h2>

<p>The ::Slop decorator implements method_missing such that methods may be used instead of CSS or XPath. 
See the bottom of <a href="https://nokogiri.org/tutorials/searching_a_xml_html_document.html">this page</a>
<a href="https://nokogiri.org/rdoc/Nokogiri.html#Slop-class_method">Nokogiri.Slop</a>
<a href="https://nokogiri.org/rdoc/Nokogiri/XML/Document.html#slop!-instance_method">Nokogiri::XML::Document#slop!</a>
<a href="https://nokogiri.org/rdoc/Nokogiri/Decorators/Slop.html">Nokogiri::Decorators::Slop</a></p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_doc'>doc</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'>Slop</span>(<span class='id identifier rubyid_string_or_io'>string_or_io</span>)
<span class='id identifier rubyid_doc'>doc</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span>(<span class='id identifier rubyid_string_or_io'>string_or_io</span>).<span class='id identifier rubyid_slop!'>slop!</span>
<span class='id identifier rubyid_doc'>doc</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/HTML.html" title="Nokogiri::HTML (module)">HTML</a></span>(<span class='id identifier rubyid_string_or_io'>string_or_io</span>).<span class='id identifier rubyid_slop!'>slop!</span>
<span class='id identifier rubyid_doc'>doc</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'><a href="Nokogiri/XML.html" title="Nokogiri::XML (module)">XML</a></span>(<span class='id identifier rubyid_string_or_io'>string_or_io</span>).<span class='id identifier rubyid_slop!'>slop!</span>

<span class='id identifier rubyid_doc'>doc</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'>Slop</span>(<span class='heredoc_beg'>&lt;&lt;-eohtml</span>)
<span class='tstring_content'>  &lt;html&gt;
    &lt;body&gt;
      &lt;p&gt;first&lt;/p&gt;
      &lt;p&gt;second&lt;/p&gt;
    &lt;/body&gt;
  &lt;/html&gt;
</span><span class='heredoc_end'>eohtml
</span><span class='id identifier rubyid_assert_equal'>assert_equal</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>second</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_html'>html</span>.<span class='id identifier rubyid_body'>body</span>.<span class='id identifier rubyid_p'>p</span>[<span class='int'>1</span>].<span class='id identifier rubyid_text'>text</span>)


<span class='id identifier rubyid_doc'>doc</span> <span class='op'>=</span> <span class='const'><a href="Nokogiri.html" title="Nokogiri (module)">Nokogiri</a></span><span class='op'>::</span><span class='const'>Slop</span> <span class='heredoc_beg'>&lt;&lt;-EOXML</span>
<span class='tstring_content'>&lt;employees&gt;
  &lt;employee status=&quot;active&quot;&gt;
    &lt;fullname&gt;Dean Martin&lt;/fullname&gt;
  &lt;/employee&gt;
  &lt;employee status=&quot;inactive&quot;&gt;
    &lt;fullname&gt;Jerry Lewis&lt;/fullname&gt;
  &lt;/employee&gt;
&lt;/employees&gt;
</span><span class='heredoc_end'>EOXML
</span>
<span class='comment'># navigate!
</span><span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_employees'>employees</span>.<span class='id identifier rubyid_employee'>employee</span>.<span class='id identifier rubyid_last'>last</span>.<span class='id identifier rubyid_fullname'>fullname</span>.<span class='id identifier rubyid_content'>content</span> <span class='comment'># =&gt; &quot;Jerry Lewis&quot;
</span>
<span class='comment'># access node attributes!
</span><span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_employees'>employees</span>.<span class='id identifier rubyid_employee'>employee</span>.<span class='id identifier rubyid_first'>first</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>status</span><span class='tstring_end'>&quot;</span></span>] <span class='comment'># =&gt; &quot;active&quot;
</span>
<span class='comment'># use some xpath!
</span><span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_employees'>employees</span>.<span class='id identifier rubyid_employee'>employee</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>[@status=&#39;active&#39;]</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_fullname'>fullname</span>.<span class='id identifier rubyid_content'>content</span> <span class='comment'># =&gt; &quot;Dean Martin&quot;
</span><span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_employees'>employees</span>.<span class='id identifier rubyid_employee'>employee</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_xpath'>xpath</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>@status=&#39;active&#39;</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_fullname'>fullname</span>.<span class='id identifier rubyid_content'>content</span> <span class='comment'># =&gt; &quot;Dean Martin&quot;
</span>
<span class='comment'># use some css!
</span><span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_employees'>employees</span>.<span class='id identifier rubyid_employee'>employee</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>[status=&#39;active&#39;]</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_fullname'>fullname</span>.<span class='id identifier rubyid_content'>content</span> <span class='comment'># =&gt; &quot;Dean Martin&quot;
</span><span class='id identifier rubyid_doc'>doc</span>.<span class='id identifier rubyid_employees'>employees</span>.<span class='id identifier rubyid_employee'>employee</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_css'>css</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>[status=&#39;active&#39;]</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_fullname'>fullname</span>.<span class='id identifier rubyid_content'>content</span> <span class='comment'># =&gt; &quot;Dean Martin&quot;</span></code></pre>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>