<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Channels and Goroutines &mdash; Concurrent RubyÂ master</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "channel",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Concurrent</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Channels and Goroutines&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<h1>Channels and Goroutines</h1>

<p>Channels, popularized by the <a href="https://golang.org/doc/effective_go.html#channels">Go programming language</a>, are a modern variation of <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">communicating sequential processes (CSP)</a>. CSP was first proposed by  C. A. R. Hoare in 1978. The Go philosophy on concurrency is:</p>

<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>

<p>As <a href="https://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a> eloquently explains in his <a href="https://vimeo.com/49718712">Concurrency Is Not Parallelism</a> conference talk, concurrency is the &quot;composition of independently executing things.&quot; Combining these two ideas, channels are a queue-like mechanism that can be used to communicate between independently executing things.</p>

<p>The channel implementation in this library was highly influenced by Go, but also incorporates ideas from Clojure&#39;s <a href="https://clojure.github.io/core.async/">core.async</a> library. Runtime differences aside, this channel library is functionally equivalent to Go and even includes a few features Go does not.</p>

<h3>Example Programs</h3>

<p>Every code example in the channel chapters of both <a href="https://tour.golang.org/welcome/1">A Tour of Go</a> and <a href="https://gobyexample.com/">Go By Example</a> has been reproduced in Ruby. The code can be found in the <a href="https://github.com/ruby-concurrency/concurrent-ruby/tree/master/examples">examples</a> directory of the source repository. Many of those examples appear in the documentation below, but many do not. They are a valuable resource for learning how to use channels.</p>

<h3>Additional Resources</h3>

<ul>
<li>&quot;A Tour of Go&quot; <a href="https://tour.golang.org/concurrency/2">channels exercises</a></li>
<li>&quot;Go By Example&quot; <a href="https://gobyexample.com/channels">channels exercises</a></li>
<li>&quot;Effective Go&quot; <a href="https://golang.org/doc/effective_go.html#concurrency">concurrency chapters</a></li>
<li>&quot;Concurrency Is Not Parallelims&quot; <a href="https://vimeo.com/49718712">conference presentation</a> by Rob Pike, principal designer of Go</li>
<li>&quot;Clojure core.async Channels&quot; <a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">blog post</a> by Rich Hickey, inventor of Clojure</li>
<li>Clojure core.async <a href="https://clojure.github.io/core.async/">API reference</a></li>
</ul>

<h2>Goroutines</h2>

<p>The Go programming language uses &quot;goroutines&quot; as the core concurrency mechanism. A goroutine is little more than an independently executing function, multiplexed with all other goroutines onto a thread pool managed by the runtime. Ruby has a very different runtime so true goroutines are not possible. Instead, a <code>.go</code> method is provided for running a block asynchronously, multiplexed onto a special thread pool reserved just for <a href="Concurrent/Channel.html" title="Concurrent::Channel (class)"><code>Channel</code></a> operations. This is similar to what Clojure does with the <code>go</code> function from the <a href="https://clojure.github.io/core.async/#clojure.core.async/go">core.async</a> library.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Main thread: </span><span class='embexpr_beg'>#{</span><span class='const'>Thread</span>.<span class='id identifier rubyid_current'>current</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>

<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_go'><a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">go</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Goroutine thread: </span><span class='embexpr_beg'>#{</span><span class='const'>Thread</span>.<span class='id identifier rubyid_current'>current</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>

<span class='comment'># Main thread: #&lt;Thread:0x007fcb4c8bc3f0&gt;
</span><span class='comment'># Goroutine thread: #&lt;Thread:0x007fcb4c21f4e8&gt;</span></code></pre>

<p>Although it is possible to use <a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">Concurrent::Channel.go</a> independent of channels or to use channels with other asynchronous processing tools (such as <a href="Concurrent/Future.html" title="Concurrent::Future (class)"><code>Future</code></a> and <a href="Concurrent/Actor.html" title="Concurrent::Actor (module)"><code>Actor</code></a>), mixing the tools is not advised. Most high-level asynchronous processing tools already have a queue-like mechanism built in. Adding channels to the mix may indicate a design flaw. Conversely, <a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">Concurrent::Channel.go</a> provides no mechanism for coordination and communication. That&#39;s what channels are for. Additionally, strictly using <a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">Concurrent::Channel.go</a> along with channels provides an opportunity for future optimizations, such as Clojure&#39;s inversion of control (IOC) threads.</p>

<h2>Channel Basics</h2>

<p>Channels are &quot;pipes&quot; through which values can be sent. They are thread safe and naturally concurrent. When shared between goroutines they provide a communication mechanism for coordinating asynchronous actions.</p>

<p>The core channel operations are <code>#put</code> and <code>#take</code> (aliased as <code>#send</code> and <code>#receive</code>, respectively). The former function inserts a value into a channel where the latter removes a value. By default these are blocking operations. A call to <code>put</code> will block until the channel is ready to receive the value. Similarly, a call to <code>take</code> will block until a value is available to be removed.</p>

<p>The following, simple example creates a channel, launches a goroutine from which a value is placed into the channel, then reads that value from the channel. When run this example will display &quot;ping&quot; in the console.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_messages'>messages</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Channel.html#new-class_method" title="Concurrent::Channel.new (method)">new</a></span>

<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_go'><a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">go</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_messages'>messages</span>.<span class='id identifier rubyid_put'>put</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>ping</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>

<span class='id identifier rubyid_msg'>msg</span> <span class='op'>=</span> <span class='id identifier rubyid_messages'>messages</span>.<span class='id identifier rubyid_take'>take</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_msg'>msg</span></code></pre>

<p>By default, channels are <em>unbuffered</em>, meaning that they have a capacity of zero and only accept puts and takes when both a putting and a taking thread are available. If a <code>put</code> is started when there is no taker thread the call will block. As soon as another thread calls <code>take</code> the exchange will occur and both calls will return on their respective threads. Similarly, if a <code>take</code> is started when there is no putting thread the call will block until another thread calls <code>put</code>.</p>

<p>The following, slightly more complex example, concurrently sums two different halves of a list then combines the results. It uses an unbuffered channel to pass the results from the two goroutines back to the main thread. The main thread blocks on the two <code>take</code> calls until the worker goroutines are done. This example also uses the convenience aliases <code>#<<</code> and <code>#~</code>. Since channels in Go are part of the language, channel operations are performed using special channel operators rather than functions. These operators help clearly indicate that channel operations are being performed. The operator overloads <code>&lt;&lt;</code> for <code>put</code> and <code>~</code> for <code>take</code> help reinforce this idea in Ruby.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_sum'>sum</span>(<span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span>)
  <span class='id identifier rubyid_sum'>sum</span> <span class='op'>=</span> <span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_reduce'>reduce</span>(<span class='int'>0</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='symbeg'>:</span><span class='op'>+</span>)
  <span class='id identifier rubyid_c'>c</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_sum'>sum</span> <span class='comment'># `&lt;&lt;` is an alias for `put` or `send`
</span><span class='kw'>end</span>

<span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> [<span class='int'>7</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>8</span><span class='comma'>,</span> <span class='op'>-</span><span class='int'>9</span><span class='comma'>,</span> <span class='int'>4</span><span class='comma'>,</span> <span class='int'>0</span>]
<span class='id identifier rubyid_l'>l</span> <span class='op'>=</span> <span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_length'>length</span> <span class='op'>/</span> <span class='int'>2</span>
<span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Channel.html#new-class_method" title="Concurrent::Channel.new (method)">new</a></span>

<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_go'><a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">go</a></span> { <span class='id identifier rubyid_sum'>sum</span>(<span class='id identifier rubyid_a'>a</span>[<span class='op'>-</span><span class='id identifier rubyid_l'>l</span><span class='comma'>,</span> <span class='id identifier rubyid_l'>l</span>]<span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span>) }
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_go'><a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">go</a></span> { <span class='id identifier rubyid_sum'>sum</span>(<span class='id identifier rubyid_a'>a</span>[<span class='int'>0</span><span class='comma'>,</span> <span class='id identifier rubyid_l'>l</span>]<span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span>) }
<span class='id identifier rubyid_x'>x</span><span class='comma'>,</span> <span class='id identifier rubyid_y'>y</span> <span class='op'>=</span> <span class='op'>~</span><span class='id identifier rubyid_c'>c</span><span class='comma'>,</span> <span class='op'>~</span><span class='id identifier rubyid_c'>c</span> <span class='comment'># `~` is an alias for `take` or `receive`
</span>
<span class='id identifier rubyid_puts'>puts</span> [<span class='id identifier rubyid_x'>x</span><span class='comma'>,</span> <span class='id identifier rubyid_y'>y</span><span class='comma'>,</span> <span class='id identifier rubyid_x'>x</span><span class='op'>+</span><span class='id identifier rubyid_y'>y</span>].<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'> </span><span class='tstring_end'>&#39;</span></span>)</code></pre>

<h2>Channel Buffering</h2>

<p>One common channel variation is a <em>buffered</em> channel. A buffered channel has a finite number of slots in the buffer which can be filled. Putting threads can put values into the channel even if there is no taking threads, up to the point where the buffer is filled. Once a buffer becomes full the normal blocking behavior resumes. A buffered channel is created by giving a <code>:capacity</code> option on channel creation:</p>

<p>The following example creates a buffered channel with two slots. It then makes two <code>put</code> calls, adding values to the channel. These calls do not block because the buffer has room. Were a third <code>put</code> call to be made before an <code>take</code> calls, the third <code>put</code> would block.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Channel.html#new-class_method" title="Concurrent::Channel.new (method)">new</a></span>(<span class='label'>capacity:</span> <span class='int'>2</span>)
<span class='id identifier rubyid_ch'>ch</span> <span class='op'>&lt;&lt;</span> <span class='int'>1</span>
<span class='id identifier rubyid_ch'>ch</span> <span class='op'>&lt;&lt;</span> <span class='int'>2</span>

<span class='id identifier rubyid_puts'>puts</span> <span class='op'>~</span><span class='id identifier rubyid_ch'>ch</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='op'>~</span><span class='id identifier rubyid_ch'>ch</span></code></pre>

<h2>Channel Synchronization</h2>

<p>The main purpose of channels is to synchronize operations across goroutines. One common pattern for this is to create a <code>capacity: 1</code> buffered channel which is used to signal that work is complete. The following example calls a <code>worker</code> function on a goroutine and passes it a &quot;done&quot; channel. The main thread then calls <code>take</code> on the &quot;done&quot; channel and blocks until signaled.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_worker'>worker</span>(<span class='id identifier rubyid_done_channel'>done_channel</span>)
  <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>working...\n</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_sleep'>sleep</span>(<span class='int'>1</span>)
  <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>done\n</span><span class='tstring_end'>&quot;</span></span>

  <span class='id identifier rubyid_done_channel'>done_channel</span> <span class='op'>&lt;&lt;</span> <span class='kw'>true</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_done'>done</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Channel.html#new-class_method" title="Concurrent::Channel.new (method)">new</a></span>(<span class='label'>capacity:</span> <span class='int'>1</span>)
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_go'><a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">go</a></span>{ <span class='id identifier rubyid_worker'>worker</span>(<span class='id identifier rubyid_done'>done</span>) }

<span class='op'>~</span><span class='id identifier rubyid_done'>done</span> <span class='comment'># block until signaled</span></code></pre>

<h2>Multichannel Select</h2>

<p>Often it is necessary for a single thread to operate on more than one channel. The <code>.select</code> method facilitates multivariate channel operations. The <code>select</code> method takes a block and passes through a special &quot;selector&quot; object as the first block parameter. The selector can then be used to specify various channel operations. The <code>select</code> call will block until one of the operations occurs. If a block is provided for the triggered clause (required for some clauses, optional for others) the block will then be called. Finally, the <code>select</code> call will immediately exit, guaranteeing that only one of the select clauses will trigger.</p>

<p>The following example spawns two goroutines, each of which goes to sleep before putting a value onto a channel. The main thread loops twice over a <code>select</code> and, in each loop, takes a value off of whichever channel returns one first.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_c1'>c1</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Channel.html#new-class_method" title="Concurrent::Channel.new (method)">new</a></span>
<span class='id identifier rubyid_c2'>c2</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Channel.html#new-class_method" title="Concurrent::Channel.new (method)">new</a></span>

<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_go'><a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">go</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_sleep'>sleep</span>(<span class='int'>1</span>)
  <span class='id identifier rubyid_c1'>c1</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>one</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>

<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_go'><a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">go</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_sleep'>sleep</span>(<span class='int'>2</span>)
  <span class='id identifier rubyid_c1'>c1</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>two</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>

<span class='int'>2</span>.<span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span>
  <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_select'><a href="Concurrent/Channel.html#select-class_method" title="Concurrent::Channel.select (method)">select</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_s'>s</span><span class='op'>|</span>
    <span class='id identifier rubyid_s'>s</span>.<span class='id identifier rubyid_take'>take</span>(<span class='id identifier rubyid_c1'>c1</span>) { <span class='op'>|</span><span class='id identifier rubyid_msg'>msg</span><span class='op'>|</span> <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>received </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_msg'>msg</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span> }
    <span class='id identifier rubyid_s'>s</span>.<span class='id identifier rubyid_take'>take</span>(<span class='id identifier rubyid_c2'>c2</span>) { <span class='op'>|</span><span class='id identifier rubyid_msg'>msg</span><span class='op'>|</span> <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>received </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_msg'>msg</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span> }
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>The output from the above example is:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_received'>received</span> <span class='id identifier rubyid_one'>one</span>
<span class='id identifier rubyid_received'>received</span> <span class='id identifier rubyid_two'>two</span></code></pre>

<p>The next example calculates the first 10 fibonacci numbers, passing them to the main thread via a channel. The fibonacci function puts each calculated value onto a channel while simultaneously listening to a different channel for the signal to stop. This example uses the <code>case</code> method on the selector object. This is just a convenience method for <code>put</code> and <code>take</code>, allowing the Ruby code to look more like Go.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_fibonacci'>fibonacci</span>(<span class='id identifier rubyid_c'>c</span><span class='comma'>,</span> <span class='id identifier rubyid_quit'>quit</span>)
  <span class='id identifier rubyid_x'>x</span><span class='comma'>,</span> <span class='id identifier rubyid_y'>y</span> <span class='op'>=</span> <span class='int'>0</span><span class='comma'>,</span> <span class='int'>1</span>
  <span class='id identifier rubyid_loop'>loop</span> <span class='kw'>do</span>
    <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_select'><a href="Concurrent/Channel.html#select-class_method" title="Concurrent::Channel.select (method)">select</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_s'>s</span><span class='op'>|</span>
      <span class='id identifier rubyid_s'>s</span>.<span class='id identifier rubyid_case'>case</span>(<span class='id identifier rubyid_c'>c</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='op'>&lt;&lt;</span><span class='comma'>,</span> <span class='id identifier rubyid_x'>x</span>) { <span class='id identifier rubyid_x'>x</span><span class='comma'>,</span> <span class='id identifier rubyid_y'>y</span> <span class='op'>=</span> <span class='id identifier rubyid_y'>y</span><span class='comma'>,</span> <span class='id identifier rubyid_x'>x</span><span class='op'>+</span><span class='id identifier rubyid_y'>y</span><span class='semicolon'>;</span> <span class='id identifier rubyid_x'>x</span> } <span class='comment'># alias for `s.put`
</span>      <span class='id identifier rubyid_s'>s</span>.<span class='id identifier rubyid_case'>case</span>(<span class='id identifier rubyid_quit'>quit</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='op'>~</span>) <span class='kw'>do</span>                    <span class='comment'># alias for `s.take`
</span>        <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>quit</span><span class='tstring_end'>&#39;</span></span>
        <span class='kw'>return</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Channel.html#new-class_method" title="Concurrent::Channel.new (method)">new</a></span>
<span class='id identifier rubyid_quit'>quit</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Channel.html#new-class_method" title="Concurrent::Channel.new (method)">new</a></span>

<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_go'><a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">go</a></span> <span class='kw'>do</span>
  <span class='int'>10</span>.<span class='id identifier rubyid_times'>times</span> { <span class='id identifier rubyid_puts'>puts</span> <span class='op'>~</span><span class='id identifier rubyid_c'>c</span> }
  <span class='id identifier rubyid_quit'>quit</span> <span class='op'>&lt;&lt;</span> <span class='int'>0</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_fibonacci'>fibonacci</span>(<span class='id identifier rubyid_c'>c</span><span class='comma'>,</span> <span class='id identifier rubyid_quit'>quit</span>)</code></pre>

<h2>Closing and Iterating Over Channels</h2>

<p>Newly created channels are in an &quot;open&quot; state. Open channels can receive values via <code>put</code> operations. When a program is done with a channel it can be closed by calling the <code>#close</code> method. Once a channel is closed it will no longer allow values to be <code>put</code>. If the channel is buffered and values are in the buffer when the channel is closed, the remaining values can still be removed via <code>take</code> operations.</p>

<p>The <a href="Concurrent/Channel.html" title="Concurrent::Channel (class)"><code>Channel</code></a> class implements an <code>#each</code> method which can be used to retrieve successive values from the channel. The <code>each</code> method is a blocking method. When the channel is open and there are no values in the buffer, <code>each</code> will block until a new item is <code>put</code>. The <code>each</code> method will not exit until the channel is closed.</p>

<p>The following example launches a goroutine which calculates several fibonacci values and puts them into a channel. The main thread uses the <code>each</code> method to retrieve all the values successively and display them in the console. Once the fibonacci goroutine is done it closes the channel which subsequently causes the <code>each</code> iteration to end, unblocking the main thread.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_fibonacci'>fibonacci</span>(<span class='id identifier rubyid_n'>n</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span>)
  <span class='id identifier rubyid_x'>x</span><span class='comma'>,</span> <span class='id identifier rubyid_y'>y</span> <span class='op'>=</span> <span class='int'>0</span><span class='comma'>,</span> <span class='int'>1</span>
  (<span class='int'>1</span><span class='op'>..</span><span class='id identifier rubyid_n'>n</span>).<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_c'>c</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_x'>x</span>
    <span class='id identifier rubyid_x'>x</span><span class='comma'>,</span> <span class='id identifier rubyid_y'>y</span> <span class='op'>=</span> <span class='id identifier rubyid_y'>y</span><span class='comma'>,</span> <span class='id identifier rubyid_x'>x</span><span class='op'>+</span><span class='id identifier rubyid_y'>y</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_c'>c</span>.<span class='id identifier rubyid_close'>close</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_chan'>chan</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Channel.html#new-class_method" title="Concurrent::Channel.new (method)">new</a></span>(<span class='label'>capacity:</span> <span class='int'>10</span>)
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_go'><a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">go</a></span> { <span class='id identifier rubyid_fibonacci'>fibonacci</span>(<span class='id identifier rubyid_chan'>chan</span>.<span class='id identifier rubyid_capacity'>capacity</span><span class='comma'>,</span> <span class='id identifier rubyid_chan'>chan</span>) }
<span class='id identifier rubyid_chan'>chan</span>.<span class='id identifier rubyid_each'>each</span> { <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_i'>i</span> }</code></pre>

<p><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)"><code>Channel</code></a> also includes Ruby&#39;s <a href="http://ruby-doc.org/core-2.2.3/Enumerable.html">Enumerable</a> mixin, allowing for a wide range of list comprehensions. Since the <code>Enumerable</code> methods iterate over the entire set of objects they can only complete once the channel is closed. Calling a method from <code>Enumerable</code> on an open channel will cause the method to block until the channel is closed.</p>

<h2>Timers and Tickers</h2>

<p>A <code>.timer</code> is a specialized channel which triggers at a predefined time, specified as a number of seconds in the future. It is similar in concept to a <a href="Concurrent/ScheduledTask.html" title="Concurrent::ScheduledTask (class)"><code>ScheduledTask</code></a> but operates as a channel and can fully participate in all channel operations.</p>

<p>The following code example creates two timers with different delay values. The first timer is allowed to expire (trigger) by having the main thread perform a <code>take</code> on it. When the timer expires it puts a <a href="Concurrent/Channel/Tick.html" title="Concurrent::Channel::Tick (class)"><code>Channel::Tick</code></a> object into its buffer and closes. The second timer is listened to on a goroutine but the it never expires: the main thread stops (closes) the timer before it expires. Note that the goroutine in this example blocks forever and never exits. Since the timer is closed it never puts the <code>Tick</code> into its buffer.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_timer1'>timer1</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_timer'><a href="Concurrent/Channel.html#timer-class_method" title="Concurrent::Channel.timer (method)">timer</a></span>(<span class='int'>2</span>)

<span class='op'>~</span><span class='id identifier rubyid_timer1'>timer1</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Timer 1 expired</span><span class='tstring_end'>&#39;</span></span>

<span class='id identifier rubyid_timer2'>timer2</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_timer'><a href="Concurrent/Channel.html#timer-class_method" title="Concurrent::Channel.timer (method)">timer</a></span>(<span class='int'>1</span>)
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_go'><a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">go</a></span> <span class='kw'>do</span>
  <span class='op'>~</span><span class='id identifier rubyid_timer2'>timer2</span>
  <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Timer 2 expired\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>

<span class='id identifier rubyid_stop2'>stop2</span> <span class='op'>=</span> <span class='id identifier rubyid_timer2'>timer2</span>.<span class='id identifier rubyid_stop'>stop</span> <span class='comment'># alias for `close`
</span><span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Timer 2 stopped\n</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_stop2'>stop2</span></code></pre>

<p>A <code>.ticker</code> is a specialized channel which triggers over and over again at a predefined interval, specified as a number of seconds between ticks. It is similar in concept to a <a href="Concurrent/TimerTask.html" title="Concurrent::TimerTask (class)"><code>TimerTask</code></a> but operates as a channel and can fully participate in all channel operations.</p>

<p>The following example creates a ticker which triggers every half-second. A goroutine iterates over the ticker using the <code>each</code> method, printing the tick at every interval. When the main thread stops (closes) the ticker the <code>each</code> call ends and the goroutine exits.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ticker'>ticker</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_ticker'><a href="Concurrent/Channel.html#ticker-class_method" title="Concurrent::Channel.ticker (method)">ticker</a></span>(<span class='float'>0.5</span>)
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_go'><a href="Concurrent/Channel.html#go-class_method" title="Concurrent::Channel.go (method)">go</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_ticker'>ticker</span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_tick'>tick</span><span class='op'>|</span>
    <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Tick at </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_tick'>tick</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_sleep'>sleep</span>(<span class='float'>1.6</span>)
<span class='id identifier rubyid_ticker'>ticker</span>.<span class='id identifier rubyid_stop'>stop</span> <span class='comment'># alias for `close`
</span><span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Ticker stopped\n</span><span class='tstring_end'>&quot;</span></span></code></pre>

<h2>Default Selection</h2>

<p>As with a Ruby <code>case</code> statement, a <a href="Concurrent/Channel.html#select-class_method" title="Concurrent::Channel.select (method)">Concurrent::Channel.select</a> statement will accept a <code>default</code> clause which will trigger if none of the other clauses trigger. Not surprisingly, the <code>default</code> clause must be the last clause in a <code>select</code> block.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_tick'>tick</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_tick'>tick</span>(<span class='float'>0.1</span>)  <span class='comment'># alias for `ticker`
</span><span class='id identifier rubyid_boom'>boom</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_after'>after</span>(<span class='float'>0.5</span>) <span class='comment'># alias for `timer`
</span>
<span class='id identifier rubyid_loop'>loop</span> <span class='kw'>do</span>
  <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Channel.html" title="Concurrent::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_select'><a href="Concurrent/Channel.html#select-class_method" title="Concurrent::Channel.select (method)">select</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_s'>s</span><span class='op'>|</span>
    <span class='id identifier rubyid_s'>s</span>.<span class='id identifier rubyid_take'>take</span>(<span class='id identifier rubyid_tick'>tick</span>) { <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>tick.\n</span><span class='tstring_end'>&quot;</span></span> }
    <span class='id identifier rubyid_s'>s</span>.<span class='id identifier rubyid_take'>take</span>(<span class='id identifier rubyid_boom'>boom</span>) <span class='kw'>do</span>
      <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>BOOM!\n</span><span class='tstring_end'>&quot;</span></span>
      <span class='id identifier rubyid_exit'>exit</span>
    <span class='kw'>end</span>
    <span class='id identifier rubyid_s'>s</span>.<span class='id identifier rubyid_default'>default</span> <span class='kw'>do</span>
      <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>    .\n</span><span class='tstring_end'>&quot;</span></span>
      <span class='id identifier rubyid_sleep'>sleep</span>(<span class='float'>0.05</span>)
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>The output of this code example is:</p>

<pre class="code ruby"><code class="ruby">.
.
<span class='id identifier rubyid_tick'>tick</span>.
.
.
<span class='id identifier rubyid_tick'>tick</span>.
.
.
<span class='id identifier rubyid_tick'>tick</span>.
.
.
<span class='id identifier rubyid_tick'>tick</span>.
.
.
<span class='id identifier rubyid_tick'>tick</span>.
<span class='id identifier rubyid_BOOM!'>BOOM!</span></code></pre>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>