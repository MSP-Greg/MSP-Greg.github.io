<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Basics &mdash; Concurrent RubyÂ master</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "promises.in",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Concurrent</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Basics&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<h1>Basics</h1>

<h2>Factory methods</h2>

<p>Future and Event are created indirectly with constructor methods in
FactoryMethods. They are not designed for inheritance but rather for
composition.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises/FactoryMethods.html" title="Concurrent::Promises::FactoryMethods (module)">FactoryMethods</a></span>.<span class='id identifier rubyid_instance_methods'>instance_methods</span>(<span class='kw'>false</span>).<span class='id identifier rubyid_sort'>sort</span></code></pre>

<p>The module can be included or extended where needed.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Class</span>.<span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises/FactoryMethods.html" title="Concurrent::Promises::FactoryMethods (module)">FactoryMethods</a></span>

  <span class='kw'>def</span> <span class='id identifier rubyid_a_method'>a_method</span>
    <span class='id identifier rubyid_resolvable_event'>resolvable_event</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>.<span class='id identifier rubyid_new'>new</span>.<span class='id identifier rubyid_a_method'>a_method</span>

<span class='id identifier rubyid_mod'>mod</span> <span class='op'>=</span> <span class='const'>Module</span>.<span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_extend'>extend</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises/FactoryMethods.html" title="Concurrent::Promises::FactoryMethods (module)">FactoryMethods</a></span>
<span class='kw'>end</span> <span class='comment'>#
</span><span class='id identifier rubyid_mod'>mod</span>.<span class='id identifier rubyid_resolvable_event'>resolvable_event</span></code></pre>

<p>The default executor can be changed by overriding <code>default_executor</code> method
inherited from <a href="Concurrent/Promises/FactoryMethods.html" title="Concurrent::Promises::FactoryMethods (module)"><code>Promises::FactoryMethods</code></a>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_mod'>mod</span> <span class='op'>=</span> <span class='const'>Module</span>.<span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_extend'>extend</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises/FactoryMethods.html" title="Concurrent::Promises::FactoryMethods (module)">FactoryMethods</a></span>
  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_default_executor'>default_executor</span>
    <span class='symbeg'>:</span><span class='id identifier rubyid_fast'>fast</span>
  <span class='kw'>end</span>
<span class='kw'>end</span> <span class='comment'>#
</span><span class='id identifier rubyid_mod'>mod</span>.<span class='id identifier rubyid_future'>future</span> { <span class='int'>1</span> }.<span class='id identifier rubyid_default_executor'>default_executor</span>
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span> { <span class='int'>1</span> }.<span class='id identifier rubyid_default_executor'>default_executor</span></code></pre>

<p>The module is already extended into <a href="Concurrent/Promises.html" title="Concurrent::Promises (module)"><code>Promises</code></a> for convenience.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_event'><a href="Concurrent/Promises/FactoryMethods.html#resolvable_event-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_event (method)">resolvable_event</a></span></code></pre>

<h2>Asynchronous task</h2>

<p>The most basic use-case of the framework is asynchronous processing. A task can
be processed asynchronously by using a <code>future</code> factory method. The block will
be executed on an internal thread pool.</p>

<p>Arguments of <code>future</code> are passed to the block and evaluation starts immediately.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span>(<span class='float'>0.1</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_duration'>duration</span><span class='op'>|</span>
  <span class='id identifier rubyid_sleep'>sleep</span> <span class='id identifier rubyid_duration'>duration</span>
  <span class='symbeg'>:</span><span class='id identifier rubyid_result'>result</span>
<span class='kw'>end</span>
<span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_value'>value</span></code></pre>

<p>Asks if the future is resolved, here it will be still in the middle of the
sleep call.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_resolved?'>resolved?</span></code></pre>

<p>Retrieving the value will block until the future is <strong>resolved</strong>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_value'>value</span>
<span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_resolved?'>resolved?</span></code></pre>

<p>If the task fails, we talk about the future being <strong>rejected</strong>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span> { <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span><span class='semicolon'>;</span> <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Boom</span><span class='tstring_end'>&#39;</span></span> }</code></pre>

<p>There is no result, the future was rejected with a reason.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_value'>value</span>
<span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_reason'>reason</span></code></pre>

<p>It can be forced to raise the reason for rejection when retrieving the value.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>begin</span>
  <span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_value!'>value!</span> 
<span class='kw'>rescue</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_e'>e</span> 
  <span class='id identifier rubyid_e'>e</span>
<span class='kw'>end</span></code></pre>

<p>Which is the same as <code>future.value! rescue $!</code> which will be used hereafter.</p>

<p>Or it can be used directly as argument for raise, since it implements exception
method.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_raise'>raise</span> <span class='id identifier rubyid_future'>future</span> <span class='kw'>rescue</span> <span class='gvar'>$!</span></code></pre>

<h2>States</h2>

<p>Let&#39;s define an inspection helper for methods.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_inspect_methods'>inspect_methods</span>(<span class='op'>*</span><span class='id identifier rubyid_methods'>methods</span><span class='comma'>,</span> <span class='label'>of:</span>)
  <span class='id identifier rubyid_methods'>methods</span>.<span class='id identifier rubyid_reduce'>reduce</span>({}) { <span class='op'>|</span><span class='id identifier rubyid_h'>h</span><span class='comma'>,</span> <span class='id identifier rubyid_m'>m</span><span class='op'>|</span> <span class='id identifier rubyid_h'>h</span>.<span class='id identifier rubyid_update'>update</span> <span class='id identifier rubyid_m'>m</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_of'>of</span>.<span class='id identifier rubyid_send'>send</span>(<span class='id identifier rubyid_m'>m</span>) }
<span class='kw'>end</span> <span class='comment'>#</span></code></pre>

<p>Event has a <code>pending</code> and a <code>resolved</code> state. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_event'>event</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_event'><a href="Concurrent/Promises/FactoryMethods.html#resolvable_event-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_event (method)">resolvable_event</a></span> <span class='comment'>#
</span><span class='id identifier rubyid_inspect_methods'>inspect_methods</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_state'>state</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_pending?'>pending?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_resolved?'>resolved?</span><span class='comma'>,</span> <span class='label'>of:</span> <span class='id identifier rubyid_event'>event</span>)

<span class='id identifier rubyid_event'>event</span>.<span class='id identifier rubyid_resolve'>resolve</span> <span class='comment'>#
</span><span class='id identifier rubyid_inspect_methods'>inspect_methods</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_state'>state</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_pending?'>pending?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_resolved?'>resolved?</span><span class='comma'>,</span> <span class='label'>of:</span> <span class='id identifier rubyid_event'>event</span>)</code></pre>

<p>Future&#39;s <code>resolved</code> state is further specified to be <code>fulfilled</code> or <code>rejected</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_future'><a href="Concurrent/Promises/FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span> <span class='comment'>#
</span><span class='id identifier rubyid_inspect_methods'>inspect_methods</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_state'>state</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_pending?'>pending?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_resolved?'>resolved?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_fulfilled?'>fulfilled?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_rejected?'>rejected?</span><span class='comma'>,</span> 
    <span class='label'>of:</span> <span class='id identifier rubyid_future'>future</span>)

<span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_fulfill'>fulfill</span> <span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span> <span class='comment'>#
</span><span class='id identifier rubyid_inspect_methods'>inspect_methods</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_state'>state</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_pending?'>pending?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_resolved?'>resolved?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_fulfilled?'>fulfilled?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_rejected?'>rejected?</span><span class='comma'>,</span>
    <span class='symbeg'>:</span><span class='id identifier rubyid_result'>result</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_reason'>reason</span><span class='comma'>,</span> <span class='label'>of:</span> <span class='id identifier rubyid_future'>future</span>)

<span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_rejected_future'><a href="Concurrent/Promises/FactoryMethods.html#rejected_future-instance_method" title="Concurrent::Promises::FactoryMethods#rejected_future (method)">rejected_future</a></span> <span class='const'>StandardError</span>.<span class='id identifier rubyid_new'>new</span> <span class='comment'>#
</span><span class='id identifier rubyid_inspect_methods'>inspect_methods</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_state'>state</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_pending?'>pending?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_resolved?'>resolved?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_fulfilled?'>fulfilled?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_rejected?'>rejected?</span><span class='comma'>,</span> 
    <span class='symbeg'>:</span><span class='id identifier rubyid_result'>result</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_reason'>reason</span><span class='comma'>,</span> <span class='label'>of:</span> <span class='id identifier rubyid_future'>future</span>)</code></pre>

<h2>Direct creation of resolved futures</h2>

<p>When an existing value has to be wrapped in a future it does not have to go
through evaluation as follows.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span> { <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span><span class='semicolon'>;</span> <span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span> }</code></pre>

<p>Instead, it can be created directly as already-resolved:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_fulfilled_future'><a href="Concurrent/Promises/FactoryMethods.html#fulfilled_future-instance_method" title="Concurrent::Promises::FactoryMethods#fulfilled_future (method)">fulfilled_future</a></span>(<span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span>)
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_rejected_future'><a href="Concurrent/Promises/FactoryMethods.html#rejected_future-instance_method" title="Concurrent::Promises::FactoryMethods#rejected_future (method)">rejected_future</a></span>(<span class='const'>StandardError</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Ups</span><span class='tstring_end'>&#39;</span></span>))
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolved_future'><a href="Concurrent/Promises/FactoryMethods.html#resolved_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolved_future (method)">resolved_future</a></span>(<span class='kw'>true</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='kw'>nil</span>)
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolved_future'><a href="Concurrent/Promises/FactoryMethods.html#resolved_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolved_future (method)">resolved_future</a></span>(<span class='kw'>false</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='const'>StandardError</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Ups</span><span class='tstring_end'>&#39;</span></span>))</code></pre>

<h2>Chaining</h2>

<p>A big advantage of promises is the ability to chain tasks together without blocking
the current thread.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_future'>future</span>(<span class='int'>2</span>) { <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span> <span class='id identifier rubyid_v'>v</span>.<span class='id identifier rubyid_succ'>succ</span> }.
    <span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>).
    <span class='id identifier rubyid_value!'>value!</span></code></pre>

<p>As <code>future</code> factory method takes an argument, so does the <code>then</code> method. Any
supplied arguments are passed to the block, and the library ensures that they
are visible to the block.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_future'>future</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>3</span><span class='tstring_end'>&#39;</span></span>) { <span class='op'>|</span><span class='id identifier rubyid_s'>s</span><span class='op'>|</span> <span class='id identifier rubyid_s'>s</span>.<span class='id identifier rubyid_to_i'>to_i</span> }.
    <span class='id identifier rubyid_then'>then</span>(<span class='int'>2</span>) { <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='comma'>,</span> <span class='id identifier rubyid_arg'>arg</span><span class='op'>|</span> <span class='id identifier rubyid_v'>v</span> <span class='op'>+</span> <span class='id identifier rubyid_arg'>arg</span> }.
    <span class='id identifier rubyid_value'>value</span>
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>3</span><span class='tstring_end'>&#39;</span></span>).
    <span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_to_i'>to_i</span>).
    <span class='id identifier rubyid_then'>then</span>(<span class='int'>2</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='symbeg'>:</span><span class='op'>+</span>).
    <span class='id identifier rubyid_value'>value</span>
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span>(<span class='int'>1</span>).
    <span class='id identifier rubyid_chain'>chain</span>(<span class='int'>2</span>) { <span class='op'>|</span><span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span><span class='comma'>,</span> <span class='id identifier rubyid_arg'>arg</span><span class='op'>|</span> <span class='id identifier rubyid_value'>value</span> <span class='op'>+</span> <span class='id identifier rubyid_arg'>arg</span> }.
    <span class='id identifier rubyid_value'>value</span></code></pre>

<p>Passing the arguments in (similarly as for a thread <code>Thread.new(arg) { |arg|
do_stuff arg }</code>) is <strong>required</strong>. Both of the following bad examples may break:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_arg'>arg</span> <span class='op'>=</span> <span class='int'>1</span>
<span class='const'>Thread</span>.<span class='id identifier rubyid_new'>new</span> { <span class='id identifier rubyid_do_stuff'>do_stuff</span> <span class='id identifier rubyid_arg'>arg</span> }
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span> { <span class='id identifier rubyid_do_stuff'>do_stuff</span> <span class='id identifier rubyid_arg'>arg</span> }</code></pre>

<p>Correct:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_arg'>arg</span> <span class='op'>=</span> <span class='int'>1</span>
<span class='const'>Thread</span>.<span class='id identifier rubyid_new'>new</span>(<span class='id identifier rubyid_arg'>arg</span>) { <span class='op'>|</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>|</span> <span class='id identifier rubyid_do_stuff'>do_stuff</span> <span class='id identifier rubyid_arg'>arg</span> }
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span>(<span class='id identifier rubyid_arg'>arg</span>) { <span class='op'>|</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>|</span> <span class='id identifier rubyid_do_stuff'>do_stuff</span> <span class='id identifier rubyid_arg'>arg</span> }</code></pre>

<h2>Branching, and zipping</h2>

<p>Besides chaining it can also be branched.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_head'>head</span>    <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_fulfilled_future'><a href="Concurrent/Promises/FactoryMethods.html#fulfilled_future-instance_method" title="Concurrent::Promises::FactoryMethods#fulfilled_future (method)">fulfilled_future</a></span> <span class='op'>-</span><span class='int'>1</span> <span class='comment'>#
</span><span class='id identifier rubyid_branch1'>branch1</span> <span class='op'>=</span> <span class='id identifier rubyid_head'>head</span>.<span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_abs'>abs</span>) <span class='comment'>#
</span><span class='id identifier rubyid_branch2'>branch2</span> <span class='op'>=</span> <span class='id identifier rubyid_head'>head</span>.<span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>).<span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>) <span class='comment'>#
</span>
<span class='id identifier rubyid_branch1'>branch1</span>.<span class='id identifier rubyid_value!'>value!</span>
<span class='id identifier rubyid_branch2'>branch2</span>.<span class='id identifier rubyid_value!'>value!</span></code></pre>

<p>It can be combined back to one future by zipping (<code>zip</code>, <code>&amp;</code>).</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_branch1'>branch1</span>.<span class='id identifier rubyid_zip'>zip</span>(<span class='id identifier rubyid_branch2'>branch2</span>).<span class='id identifier rubyid_value!'>value!</span>
(<span class='id identifier rubyid_branch1'>branch1</span> <span class='op'>&amp;</span> <span class='id identifier rubyid_branch2'>branch2</span>).
    <span class='id identifier rubyid_then'>then</span> { <span class='op'>|</span><span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span><span class='op'>|</span> <span class='id identifier rubyid_a'>a</span> <span class='op'>+</span> <span class='id identifier rubyid_b'>b</span> }.
    <span class='id identifier rubyid_value!'>value!</span>
(<span class='id identifier rubyid_branch1'>branch1</span> <span class='op'>&amp;</span> <span class='id identifier rubyid_branch2'>branch2</span>).
    <span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='op'>+</span>).
    <span class='id identifier rubyid_value!'>value!</span>
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_zip'>zip</span>(<span class='id identifier rubyid_branch1'>branch1</span><span class='comma'>,</span> <span class='id identifier rubyid_branch2'>branch2</span><span class='comma'>,</span> <span class='id identifier rubyid_branch1'>branch1</span>).
    <span class='id identifier rubyid_then'>then</span> { <span class='op'>|</span><span class='op'>*</span><span class='id identifier rubyid_values'>values</span><span class='op'>|</span> <span class='id identifier rubyid_values'>values</span>.<span class='id identifier rubyid_reduce'>reduce</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='op'>+</span>) }.
    <span class='id identifier rubyid_value!'>value!</span></code></pre>

<p>Instead of zipping only the first one can be taken, if needed.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_any'>any</span>(<span class='id identifier rubyid_branch1'>branch1</span><span class='comma'>,</span> <span class='id identifier rubyid_branch2'>branch2</span>).<span class='id identifier rubyid_value!'>value!</span>
(<span class='id identifier rubyid_branch1'>branch1</span> <span class='op'>|</span> <span class='id identifier rubyid_branch2'>branch2</span>).<span class='id identifier rubyid_value!'>value!</span></code></pre>

<h2>Blocking methods</h2>

<p>In these examples we have used blocking methods like <code>value</code> extensively for
their convenience, however in practice is better to avoid them and continue
chaining.</p>

<p>If they need to be used (e.g. when integrating with threads), <code>value!</code> is a
better option over <code>value</code> when rejections are not dealt with differently.
Otherwise the rejections are not handled and probably silently forgotten.</p>

<h2>Error handling</h2>

<p>When a task in the chain fails, the rejection propagates down the
chain without executing the tasks created with <code>then</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span>(<span class='const'><a href="Object.html" title="Object (class)">Object</a></span>.<span class='id identifier rubyid_new'>new</span>).
    <span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>).
    <span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>).
    <span class='id identifier rubyid_result'>result</span></code></pre>

<p>As <code>then</code> chained tasks execute only on fulfilled futures, there is a <code>rescue</code>
method which chains a task which is executed only when the future is rejected. 
It can be used to recover from rejection.</p>

<p>Using rescue to fulfill to 0 instead of the error.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span>(<span class='const'><a href="Object.html" title="Object (class)">Object</a></span>.<span class='id identifier rubyid_new'>new</span>).
    <span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>).
    <span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>).
    <span class='id identifier rubyid_rescue'>rescue</span> { <span class='op'>|</span><span class='id identifier rubyid_err'>err</span><span class='op'>|</span> <span class='int'>0</span> }.
    <span class='id identifier rubyid_result'>result</span></code></pre>

<p>Rescue not executed when there is no rejection.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span>(<span class='int'>1</span>).
    <span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>).
    <span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>).
    <span class='id identifier rubyid_rescue'>rescue</span> { <span class='op'>|</span><span class='id identifier rubyid_e'>e</span><span class='op'>|</span> <span class='int'>0</span> }. 
    <span class='id identifier rubyid_result'>result</span></code></pre>

<p>Tasks added with <code>chain</code> are always evaluated.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_fulfilled_future'>fulfilled_future</span>(<span class='int'>1</span>).
    <span class='id identifier rubyid_chain'>chain</span> { <span class='op'>|</span><span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span><span class='op'>|</span> <span class='id identifier rubyid_fulfilled'>fulfilled</span> <span class='op'>?</span> <span class='id identifier rubyid_value'>value</span> <span class='op'>:</span> <span class='id identifier rubyid_reason'>reason</span> }.
    <span class='id identifier rubyid_value!'>value!</span>
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_rejected_future'>rejected_future</span>(<span class='const'>StandardError</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Ups</span><span class='tstring_end'>&#39;</span></span>)).
    <span class='id identifier rubyid_chain'>chain</span> { <span class='op'>|</span><span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span><span class='op'>|</span> <span class='id identifier rubyid_fulfilled'>fulfilled</span> <span class='op'>?</span> <span class='id identifier rubyid_value'>value</span> <span class='op'>:</span> <span class='id identifier rubyid_reason'>reason</span> }.
    <span class='id identifier rubyid_value!'>value!</span></code></pre>

<p>Zip is rejected if any of the zipped futures is.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_rejected_zip'>rejected_zip</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_zip'>zip</span>(
    <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_fulfilled_future'><a href="Concurrent/Promises/FactoryMethods.html#fulfilled_future-instance_method" title="Concurrent::Promises::FactoryMethods#fulfilled_future (method)">fulfilled_future</a></span>(<span class='int'>1</span>)<span class='comma'>,</span>
    <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_rejected_future'><a href="Concurrent/Promises/FactoryMethods.html#rejected_future-instance_method" title="Concurrent::Promises::FactoryMethods#rejected_future (method)">rejected_future</a></span>(<span class='const'>StandardError</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Ups</span><span class='tstring_end'>&#39;</span></span>)))
<span class='id identifier rubyid_rejected_zip'>rejected_zip</span>.<span class='id identifier rubyid_result'>result</span>
<span class='id identifier rubyid_rejected_zip'>rejected_zip</span>.
    <span class='id identifier rubyid_rescue'>rescue</span> { <span class='op'>|</span><span class='id identifier rubyid_reason1'>reason1</span><span class='comma'>,</span> <span class='id identifier rubyid_reason2'>reason2</span><span class='op'>|</span> (<span class='id identifier rubyid_reason1'>reason1</span> <span class='op'>||</span> <span class='id identifier rubyid_reason2'>reason2</span>).<span class='id identifier rubyid_message'>message</span> }.
    <span class='id identifier rubyid_value'>value</span></code></pre>

<h2>Delayed futures</h2>

<p>Delayed futures will not evaluate until asked by <code>touch</code> or other method
requiring resolution. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_delay'><a href="Concurrent/Promises/FactoryMethods.html#delay-instance_method" title="Concurrent::Promises::FactoryMethods#delay (method)">delay</a></span> { <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span><span class='semicolon'>;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>lazy</span><span class='tstring_end'>&#39;</span></span> }
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> <span class='comment'>#
</span><span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_resolved?'>resolved?</span>
<span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_touch'>touch</span>
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.02</span> <span class='comment'>#
</span><span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_resolved?'>resolved?</span></code></pre>

<p>All blocking methods like <code>wait</code>, <code>value</code> call <code>touch</code> and trigger evaluation.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_delay'><a href="Concurrent/Promises/FactoryMethods.html#delay-instance_method" title="Concurrent::Promises::FactoryMethods#delay (method)">delay</a></span> { <span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span> }.<span class='id identifier rubyid_value'>value</span></code></pre>

<p>It propagates up through the chain, allowing whole or partial lazy chains.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_head'>head</span>    <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_delay'><a href="Concurrent/Promises/FactoryMethods.html#delay-instance_method" title="Concurrent::Promises::FactoryMethods#delay (method)">delay</a></span> { <span class='int'>1</span> } <span class='comment'>#
</span><span class='id identifier rubyid_branch1'>branch1</span> <span class='op'>=</span> <span class='id identifier rubyid_head'>head</span>.<span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>) <span class='comment'>#
</span><span class='id identifier rubyid_branch2'>branch2</span> <span class='op'>=</span> <span class='id identifier rubyid_head'>head</span>.<span class='id identifier rubyid_delay'>delay</span>.<span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>) <span class='comment'>#
</span><span class='id identifier rubyid_join'>join</span>    <span class='op'>=</span> <span class='id identifier rubyid_branch1'>branch1</span> <span class='op'>&amp;</span> <span class='id identifier rubyid_branch2'>branch2</span> <span class='comment'>#
</span>
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> <span class='comment'>#</span></code></pre>

<p>Nothing resolves.</p>

<pre class="code ruby"><code class="ruby">[<span class='id identifier rubyid_head'>head</span><span class='comma'>,</span> <span class='id identifier rubyid_branch1'>branch1</span><span class='comma'>,</span> <span class='id identifier rubyid_branch2'>branch2</span><span class='comma'>,</span> <span class='id identifier rubyid_join'>join</span>].<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_resolved?'>resolved?</span>)</code></pre>

<p>Force <code>branch1</code> evaluation.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_branch1'>branch1</span>.<span class='id identifier rubyid_value'>value</span>
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> <span class='comment'>#
</span>[<span class='id identifier rubyid_head'>head</span><span class='comma'>,</span> <span class='id identifier rubyid_branch1'>branch1</span><span class='comma'>,</span> <span class='id identifier rubyid_branch2'>branch2</span><span class='comma'>,</span> <span class='id identifier rubyid_join'>join</span>].<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_resolved?'>resolved?</span>)</code></pre>

<p>Force evaluation of both by calling <code>value</code> on <code>join</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_join'>join</span>.<span class='id identifier rubyid_value'>value</span>
[<span class='id identifier rubyid_head'>head</span><span class='comma'>,</span> <span class='id identifier rubyid_branch1'>branch1</span><span class='comma'>,</span> <span class='id identifier rubyid_branch2'>branch2</span><span class='comma'>,</span> <span class='id identifier rubyid_join'>join</span>].<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_resolved?'>resolved?</span>)</code></pre>

<h2>Flatting</h2>

<p>Sometimes it is needed to wait for an inner future. An apparent solution is to wait
inside the future <code>Concurrent::Promises.future { Concurrent::Promises.future { 1+1 }.value }.value</code>.
However, as mentioned before, <code>value</code> calls should be <strong>avoided</strong> to avoid
blocking threads. Therefore there is a <code>#flat</code> method which is a correct solution
in this situation and does not block any thread.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span> { <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span> { <span class='int'>1</span><span class='op'>+</span><span class='int'>1</span> } }.<span class='id identifier rubyid_flat'>flat</span>.<span class='id identifier rubyid_value!'>value!</span></code></pre>

<p>A more complicated example.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_future'>future</span> { <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span> { <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span> { <span class='int'>1</span> <span class='op'>+</span> <span class='int'>1</span> } } }.
    <span class='id identifier rubyid_flat'>flat</span>(<span class='int'>1</span>).
    <span class='id identifier rubyid_then'>then</span> { <span class='op'>|</span><span class='id identifier rubyid_future'>future</span><span class='op'>|</span> <span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>) }.
    <span class='id identifier rubyid_flat'>flat</span>(<span class='int'>1</span>).
    <span class='id identifier rubyid_value!'>value!</span></code></pre>

<h2>Scheduling</h2>

<p>Tasks can be planned to be executed with a time delay.</p>

<p>Schedule task to be executed in 0.1 seconds.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_scheduled'>scheduled</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_schedule'><a href="Concurrent/Promises/FactoryMethods.html#schedule-instance_method" title="Concurrent::Promises::FactoryMethods#schedule (method)">schedule</a></span>(<span class='float'>0.1</span>) { <span class='int'>1</span> }
<span class='id identifier rubyid_scheduled'>scheduled</span>.<span class='id identifier rubyid_resolved?'>resolved?</span></code></pre>

<p>Value will become available after 0.1 seconds. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_scheduled'>scheduled</span>.<span class='id identifier rubyid_value'>value</span></code></pre>

<p>It can be used in the chain as well, where the delay is counted from the moment
its parent resolves. Therefore, the following future will be resolved in 0.2 seconds.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_future'>future</span> { <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span><span class='semicolon'>;</span> <span class='symbeg'>:</span><span class='id identifier rubyid_result'>result</span> }.
    <span class='id identifier rubyid_schedule'>schedule</span>(<span class='float'>0.01</span>).
    <span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_to_s'>to_s</span>).
    <span class='id identifier rubyid_value!'>value!</span></code></pre>

<p>Time can be used as well.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_schedule'><a href="Concurrent/Promises/FactoryMethods.html#schedule-instance_method" title="Concurrent::Promises::FactoryMethods#schedule (method)">schedule</a></span>(<span class='const'>Time</span>.<span class='id identifier rubyid_now'>now</span> <span class='op'>+</span> <span class='int'>10</span>) { <span class='symbeg'>:</span><span class='id identifier rubyid_val'>val</span> }</code></pre>

<h2>Resolvable Future and Event:</h2>

<p>Sometimes it is required to resolve a future externally, in these cases
<code>resolvable_future</code> and <code>resolvable_event</code> factory methods can be used. See
<a href="Concurrent/Promises/ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)"><code>Promises::ResolvableFuture</code></a> and
<a href="Concurrent/Promises/ResolvableEvent.html" title="Concurrent::Promises::ResolvableEvent (class)"><code>Promises::ResolvableEvent</code></a>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_future'><a href="Concurrent/Promises/FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span></code></pre>

<p>The thread will be blocked until the future is resolved</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_thread'>thread</span> <span class='op'>=</span> <span class='const'>Thread</span>.<span class='id identifier rubyid_new'>new</span> { <span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_value'>value</span> } <span class='comment'>#
</span><span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_fulfill'>fulfill</span> <span class='int'>1</span>
<span class='id identifier rubyid_thread'>thread</span>.<span class='id identifier rubyid_value'>value</span></code></pre>

<p>A future can be resolved only once.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_fulfill'>fulfill</span> <span class='int'>1</span> <span class='kw'>rescue</span> <span class='gvar'>$!</span>
<span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_fulfill'>fulfill</span> <span class='int'>2</span><span class='comma'>,</span> <span class='kw'>false</span></code></pre>

<h2>How are promises executed?</h2>

<p>Promises use global pools to execute the tasks. Therefore each task may run on
different threads which implies that users have to be careful not to depend on
Thread-local variables (or they have to be set at the beginning of the task and
cleaned up at the end of the task).</p>

<p>Since the tasks are running on may different threads of the thread pool, it&#39;s
better to follow following rules:</p>

<ul>
<li>  Use only data passed via arguments or values of parent futures, to 
have better control over what are futures accessing.</li>
<li>  The data passed in and out of futures is easier to deal with if it is 
immutable or at least treated as such.</li>
<li>  Any mutable and mutated object accessed by more than one thread or future 
must be thread-safe, see <a href="Concurrent/Array.html" title="Concurrent::Array (class)"><code>Array</code></a>, <a href="Concurrent/Hash.html" title="Concurrent::Hash (class)"><code>Hash</code></a>, and 
<a href="Concurrent/Map.html" title="Concurrent::Map (class)"><code>Map</code></a>. (The value of a future may be consumed by many futures.)</li>
<li>  Futures can access outside objects, but they have to be thread-safe.</li>
</ul>

<blockquote>
<p><em>TODO: This part to be extended</em></p>
</blockquote>

<h1>Advanced</h1>

<h2>Callbacks</h2>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_queue'>queue</span>  <span class='op'>=</span> <span class='const'>Queue</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_delay'><a href="Concurrent/Promises/FactoryMethods.html#delay-instance_method" title="Concurrent::Promises::FactoryMethods#delay (method)">delay</a></span> { <span class='int'>1</span> <span class='op'>+</span> <span class='int'>1</span> }

<span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_on_fulfillment'>on_fulfillment</span> { <span class='id identifier rubyid_queue'>queue</span> <span class='op'>&lt;&lt;</span> <span class='int'>1</span> } <span class='comment'># evaluated asynchronously
</span><span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_on_fulfillment!'>on_fulfillment!</span> { <span class='id identifier rubyid_queue'>queue</span> <span class='op'>&lt;&lt;</span> <span class='int'>2</span> } <span class='comment'># evaluated on resolving thread
</span>
<span class='id identifier rubyid_queue'>queue</span>.<span class='id identifier rubyid_empty?'>empty?</span>
<span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_value'>value</span>
<span class='id identifier rubyid_queue'>queue</span>.<span class='id identifier rubyid_pop'>pop</span>
<span class='id identifier rubyid_queue'>queue</span>.<span class='id identifier rubyid_pop'>pop</span></code></pre>

<h2>Using executors</h2>

<p>Factory methods, chain, and callback methods all have other versions of them
which takes an executor argument.</p>

<p>It takes an instance of an executor, or a symbol which is a shortcut for the
two global pools in concurrent-ruby. <code>:fast</code> for short and non-blocking tasks
and <code>:io</code> for long-running and blocking tasks.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future_on'><a href="Concurrent/Promises/FactoryMethods.html#future_on-instance_method" title="Concurrent::Promises::FactoryMethods#future_on (method)">future_on</a></span>(<span class='symbeg'>:</span><span class='id identifier rubyid_fast'>fast</span>) { <span class='int'>2</span> }.
    <span class='id identifier rubyid_then_on'>then_on</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_io'>io</span>) { <span class='const'>File</span>.<span class='id identifier rubyid_read'>read</span> <span class='kw'>__FILE__</span> }.
    <span class='id identifier rubyid_value'>value</span>.<span class='id identifier rubyid_size'>size</span></code></pre>

<h2>Run (simulated process)</h2>

<p>Similar to flatting is running. When <code>run</code> is called on a future it will flat
indefinitely as long the future fulfils into a <a href="Concurrent/Future.html" title="Concurrent::Future (class)"><code>Future</code></a> value. It can be used
to simulate a thread-like processing without actually occupying the thread.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_count'>count</span> <span class='op'>=</span> <span class='id identifier rubyid_lambda'>lambda</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
  <span class='id identifier rubyid_v'>v</span> <span class='op'>+=</span> <span class='int'>1</span>
  <span class='id identifier rubyid_v'>v</span> <span class='op'>&lt;</span> <span class='int'>5</span> <span class='op'>?</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future_on'><a href="Concurrent/Promises/FactoryMethods.html#future_on-instance_method" title="Concurrent::Promises::FactoryMethods#future_on (method)">future_on</a></span>(<span class='symbeg'>:</span><span class='id identifier rubyid_fast'>fast</span><span class='comma'>,</span> <span class='id identifier rubyid_v'>v</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_count'>count</span>) <span class='op'>:</span> <span class='id identifier rubyid_v'>v</span>
<span class='kw'>end</span>
<span class='int'>400</span>.<span class='id identifier rubyid_times'>times</span>.
    <span class='id identifier rubyid_map'>map</span> { <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future_on'><a href="Concurrent/Promises/FactoryMethods.html#future_on-instance_method" title="Concurrent::Promises::FactoryMethods#future_on (method)">future_on</a></span>(<span class='symbeg'>:</span><span class='id identifier rubyid_fast'>fast</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_count'>count</span>).<span class='id identifier rubyid_run'><a href="Concurrent/Promises/Future.html#run-instance_method" title="Concurrent::Promises::Future#run (method)">run</a></span>.<span class='id identifier rubyid_value!'><a href="Concurrent/Promises/Future.html#value!-instance_method" title="Concurrent::Promises::Future#value! (method)">value!</a></span> }.
    <span class='id identifier rubyid_all?'>all?</span> { <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span> <span class='id identifier rubyid_v'>v</span> <span class='op'>==</span> <span class='int'>5</span> }</code></pre>

<p>Therefore the above example finished fine on the the <code>:fast</code> thread pool even
though it has much fewer threads than are simulated in the simulated process.</p>

<h1>Interoperability</h1>

<h2>Actors</h2>

<p>Create an actor which takes received numbers and returns the number squared. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor.html" title="Concurrent::Actor (module)">Actor</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor/Utils.html" title="Concurrent::Actor::Utils (module)">Utils</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor/Utils/AdHoc.html" title="Concurrent::Actor::Utils::AdHoc (class)">AdHoc</a></span>.<span class='id identifier rubyid_spawn'><a href="Concurrent/Actor/AbstractContext.html#spawn-class_method" title="Concurrent::Actor::AbstractContext.spawn (method)">spawn</a></span> <span class='symbeg'>:</span><span class='id identifier rubyid_square'>square</span> <span class='kw'>do</span>
  <span class='comment'>#=&gt; v { v ** 2 }
</span><span class='kw'>end</span></code></pre>

<p>Send result of <code>1+1</code> to the actor, and add 2 to the result sent back from the
actor.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
    <span class='id identifier rubyid_future'>future</span> { <span class='int'>1</span> <span class='op'>+</span> <span class='int'>1</span> }.
    <span class='id identifier rubyid_then_ask'>then_ask</span>(<span class='id identifier rubyid_actor'>actor</span>).
    <span class='id identifier rubyid_then'>then</span> { <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span> <span class='id identifier rubyid_v'>v</span> <span class='op'>+</span> <span class='int'>2</span> }.
    <span class='id identifier rubyid_value!'>value!</span></code></pre>

<p>So <code>(1 + 1)**2 + 2 = 6</code>.</p>

<p>The <code>ask</code> method returns future.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_ask'>ask</span>(<span class='int'>2</span>).<span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_succ'>succ</span>).<span class='id identifier rubyid_value!'>value!</span></code></pre>

<h2>Channel</h2>

<p>There is an implementation of channel as well. Let&#39;s start by creating a
channel with a capacity of 2 messages.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch1'>ch1</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises/Channel.html" title="Concurrent::Promises::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Promises/Channel.html#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> <span class='int'>2</span></code></pre>

<p>We push 3 messages, it can be observed that the last future representing the
push is not fulfilled since the capacity prevents it. When the work which fills
the channel depends on the futures created by push it can be used to create
backpressure â the filling work is delayed until the channel has space for
more messages.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pushes'>pushes</span> <span class='op'>=</span> <span class='int'>3</span>.<span class='id identifier rubyid_times'>times</span>.<span class='id identifier rubyid_map'>map</span> { <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_ch1'>ch1</span>.<span class='id identifier rubyid_push_op'>push_op</span> <span class='id identifier rubyid_i'>i</span> }
<span class='id identifier rubyid_ch1'>ch1</span>.<span class='id identifier rubyid_pop_op'>pop_op</span>.<span class='id identifier rubyid_value!'>value!</span>
<span class='id identifier rubyid_pushes'>pushes</span></code></pre>

<p>A selection over channels can be created with the <code>.select_channel</code> factory method. It
will be fulfilled with a first message available in any of the channels. It
returns a pair to be able to find out which channel had the message available.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch2'>ch2</span>    <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises/Channel.html" title="Concurrent::Promises::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Promises/Channel.html#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> <span class='int'>2</span>
<span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises/Channel.html" title="Concurrent::Promises::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_select_op'><a href="Concurrent/Promises/Channel.html#select_op-class_method" title="Concurrent::Promises::Channel.select_op (method)">select_op</a></span>([<span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span>])
<span class='id identifier rubyid_result'>result</span>.<span class='id identifier rubyid_value!'>value!</span>

<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span> { <span class='int'>1</span><span class='op'>+</span><span class='int'>1</span> }.<span class='id identifier rubyid_then_channel_push'>then_channel_push</span>(<span class='id identifier rubyid_ch1'>ch1</span>)
<span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> (
    <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_fulfilled_future'><a href="Concurrent/Promises/FactoryMethods.html#fulfilled_future-instance_method" title="Concurrent::Promises::FactoryMethods#fulfilled_future (method)">fulfilled_future</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>%02d</span><span class='tstring_end'>&#39;</span></span>) <span class='op'>&amp;</span>      
        <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises/Channel.html" title="Concurrent::Promises::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_select_op'><a href="Concurrent/Promises/Channel.html#select_op-class_method" title="Concurrent::Promises::Channel.select_op (method)">select_op</a></span>([<span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span>])).
    <span class='id identifier rubyid_then'>then</span> { <span class='op'>|</span><span class='id identifier rubyid_format'>format</span><span class='comma'>,</span> (<span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span>)<span class='op'>|</span> <span class='id identifier rubyid_format'>format</span> <span class='id identifier rubyid_format'>format</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span> } <span class='comment'>#
</span><span class='id identifier rubyid_result'>result</span>.<span class='id identifier rubyid_value!'>value!</span></code></pre>

<h2>ProcessingActor</h2>

<p>There is also a new implementation of actors based on the Channel and the
ability of promises to simulate processes. The actor runs as a process but also
does not occupy a thread per actor as the previously-described Concurrent::Actor
implementation. This implementation is close to Erlang actors, therefore OTP
can be ported for this actors (and it&#39;s planned).</p>

<p>The simplest actor is one which just computes without even receiving a
message.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/ProcessingActor.html" title="Concurrent::ProcessingActor (class)">ProcessingActor</a></span>.<span class='id identifier rubyid_act'><a href="Concurrent/ProcessingActor.html#act-class_method" title="Concurrent::ProcessingActor.act (method)">act</a></span>(<span class='id identifier rubyid_an_argument'>an_argument</span> <span class='op'>=</span> <span class='int'>2</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_actor'>actor</span><span class='comma'>,</span> <span class='id identifier rubyid_number'>number</span><span class='op'>|</span>
  <span class='id identifier rubyid_number'>number</span> <span class='op'>**</span> <span class='int'>3</span>
<span class='kw'>end</span>
<span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_termination'>termination</span>.<span class='id identifier rubyid_value!'>value!</span></code></pre>

<p>Let&#39;s receive some messages though.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_add_2_messages'>add_2_messages</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/ProcessingActor.html" title="Concurrent::ProcessingActor (class)">ProcessingActor</a></span>.<span class='id identifier rubyid_act'><a href="Concurrent/ProcessingActor.html#act-class_method" title="Concurrent::ProcessingActor.act (method)">act</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_actor'>actor</span><span class='op'>|</span>
  <span class='comment'># Receive two messages then terminate normally with the sum.
</span>  (<span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_receive'>receive</span> <span class='op'>&amp;</span> <span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_receive'>receive</span>).<span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span><span class='op'>|</span>
    <span class='id identifier rubyid_a'>a</span> <span class='op'>+</span> <span class='id identifier rubyid_b'>b</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
<span class='id identifier rubyid_add_2_messages'>add_2_messages</span>.<span class='id identifier rubyid_tell_op'>tell_op</span> <span class='int'>1</span>
<span class='id identifier rubyid_add_2_messages'>add_2_messages</span>.<span class='id identifier rubyid_termination'>termination</span>.<span class='id identifier rubyid_resolved?'>resolved?</span>
<span class='id identifier rubyid_add_2_messages'>add_2_messages</span>.<span class='id identifier rubyid_tell_op'>tell_op</span> <span class='int'>3</span>
<span class='id identifier rubyid_add_2_messages'>add_2_messages</span>.<span class='id identifier rubyid_termination'>termination</span>.<span class='id identifier rubyid_value!'>value!</span></code></pre>

<p>Actors can also be used to apply backpressure to a producer. Let&#39;s start by
defining an actor which a mailbox of size 2.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_slow_counter'>slow_counter</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span> (<span class='id identifier rubyid_actor'>actor</span><span class='comma'>,</span> <span class='id identifier rubyid_count'>count</span>) <span class='kw'>do</span>
  <span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_receive'>receive</span>.<span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_command'>command</span><span class='comma'>,</span> <span class='id identifier rubyid_number'>number</span><span class='op'>|</span>
    <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span>
    <span class='kw'>case</span> <span class='id identifier rubyid_command'>command</span>
    <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_add'>add</span>
      <span class='id identifier rubyid_slow_counter'>slow_counter</span>.<span class='id identifier rubyid_call'>call</span> <span class='id identifier rubyid_actor'>actor</span><span class='comma'>,</span> <span class='id identifier rubyid_count'>count</span> <span class='op'>+</span> <span class='id identifier rubyid_number'>number</span>
    <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_done'>done</span>
      <span class='comment'># terminate
</span>      <span class='id identifier rubyid_count'>count</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/ProcessingActor.html" title="Concurrent::ProcessingActor (class)">ProcessingActor</a></span>.<span class='id identifier rubyid_act_listening'><a href="Concurrent/ProcessingActor.html#act_listening-class_method" title="Concurrent::ProcessingActor.act_listening (method)">act_listening</a></span>( 
    <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises/Channel.html" title="Concurrent::Promises::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Promises/Channel.html#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span>(<span class='int'>2</span>)<span class='comma'>,</span> 
    <span class='int'>0</span><span class='comma'>,</span>
    <span class='op'>&amp;</span><span class='id identifier rubyid_slow_counter'>slow_counter</span>)</code></pre>

<p>Now we can create a producer which will push messages only when there is a
space available in the mailbox. We use promises to free a thread during waiting
on a free space in the mailbox.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_produce'>produce</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_receiver'>receiver</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span> <span class='kw'>do</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_i'>i</span> <span class='op'>&lt;</span> <span class='int'>10</span>
    <span class='id identifier rubyid_receiver'>receiver</span>.
        <span class='comment'># send a message to the actor, resolves only after the message is 
</span>        <span class='comment'># accepted by the actor&#39;s mailbox
</span>        <span class='id identifier rubyid_tell_op'>tell_op</span>([<span class='symbeg'>:</span><span class='id identifier rubyid_add'>add</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span>]).
        <span class='comment'># send incremented message when the above message is accepted 
</span>        <span class='id identifier rubyid_then'>then</span>(<span class='id identifier rubyid_i'>i</span><span class='op'>+</span><span class='int'>1</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_produce'>produce</span>)
  <span class='kw'>else</span>
    <span class='id identifier rubyid_receiver'>receiver</span>.<span class='id identifier rubyid_tell_op'>tell_op</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_done'>done</span>)
    <span class='comment'># do not continue 
</span>  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span>(<span class='id identifier rubyid_actor'>actor</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_produce'>produce</span>).<span class='id identifier rubyid_run'><a href="Concurrent/Promises/Future.html#run-instance_method" title="Concurrent::Promises::Future#run (method)">run</a></span>.<span class='id identifier rubyid_wait!'><a href="Concurrent/Promises/Future.html#wait!-instance_method" title="Concurrent::Promises::Future#wait! (method)">wait!</a></span>

<span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_termination'>termination</span>.<span class='id identifier rubyid_value!'>value!</span></code></pre>

<h1>Use-cases</h1>

<h2>Simple background processing</h2>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span> { <span class='id identifier rubyid_do_stuff'>do_stuff</span> }</code></pre>

<h2>Parallel background processing</h2>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_tasks'>tasks</span> <span class='op'>=</span> <span class='int'>4</span>.<span class='id identifier rubyid_times'>times</span>.<span class='id identifier rubyid_map'>map</span> { <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span>(<span class='id identifier rubyid_i'>i</span>) { <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span><span class='op'>*</span><span class='int'>2</span> } }
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_zip'>zip</span>(<span class='op'>*</span><span class='id identifier rubyid_tasks'>tasks</span>).<span class='id identifier rubyid_value!'>value!</span></code></pre>

<h2>Actor background processing</h2>

<p>Actors are mainly keep and isolate state, they should stay responsive not being
blocked by a longer running computations. It desirable to offload the work to
stateless promises.</p>

<p>Lets define an actor which will process jobs, while staying responsive, and
tracking the number of tasks being processed.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Computer</span> <span class='op'>&lt;</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor.html" title="Concurrent::Actor (module)">Actor</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor/RestartingContext.html" title="Concurrent::Actor::RestartingContext (class)">RestartingContext</a></span>
  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'><a href="Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">initialize</a></span>
    <span class='kw'>super</span>()
    <span class='ivar'>@jobs</span> <span class='op'>=</span> {}
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_message'>on_message</span>(<span class='id identifier rubyid_msg'>msg</span>)
    <span class='id identifier rubyid_command'>command</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span> <span class='op'>=</span> <span class='id identifier rubyid_msg'>msg</span>
    <span class='kw'>case</span> <span class='id identifier rubyid_command'>command</span>
    <span class='comment'># new job to process
</span>    <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_run'>run</span>
      <span class='id identifier rubyid_job'>job</span>        <span class='op'>=</span> <span class='id identifier rubyid_args'>args</span>[<span class='int'>0</span>]
      <span class='ivar'>@jobs</span>[<span class='id identifier rubyid_job'>job</span>] <span class='op'>=</span> <span class='id identifier rubyid_envelope'>envelope</span>.<span class='id identifier rubyid_future'>future</span>
      <span class='comment'># Process asynchronously and send message back when done.
</span>      <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span>(<span class='op'>&amp;</span><span class='id identifier rubyid_job'>job</span>).<span class='id identifier rubyid_chain'><a href="Concurrent/Promises/AbstractEventFuture.html#chain-instance_method" title="Concurrent::Promises::AbstractEventFuture#chain (method)">chain</a></span>(<span class='id identifier rubyid_job'>job</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span><span class='comma'>,</span> <span class='id identifier rubyid_job'>job</span><span class='op'>|</span>
        <span class='kw'>self</span>.<span class='id identifier rubyid_tell'>tell</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_done'>done</span><span class='comma'>,</span> <span class='id identifier rubyid_job'>job</span><span class='comma'>,</span> <span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span>]
      <span class='kw'>end</span>
      <span class='comment'># Do not make return value of this method to be answer of this message.
</span>      <span class='comment'># We are answering later in :done by resolving the future kept in @jobs.
</span>      <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor.html" title="Concurrent::Actor (module)">Actor</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor/Behaviour.html" title="Concurrent::Actor::Behaviour (module)">Behaviour</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor/Behaviour.html#MESSAGE_PROCESSED-constant" title="Concurrent::Actor::Behaviour::MESSAGE_PROCESSED (constant)">MESSAGE_PROCESSED</a></span>
    <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_done'>done</span>
      <span class='id identifier rubyid_job'>job</span><span class='comma'>,</span> <span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span> <span class='op'>=</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span>
      <span class='id identifier rubyid_future'>future</span>                        <span class='op'>=</span> <span class='ivar'>@jobs</span>.<span class='id identifier rubyid_delete'>delete</span> <span class='id identifier rubyid_job'>job</span>
      <span class='comment'># Answer the job&#39;s result.
</span>      <span class='id identifier rubyid_future'>future</span>.<span class='id identifier rubyid_resolve'>resolve</span> <span class='id identifier rubyid_fulfilled'>fulfilled</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span>
    <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_status'>status</span>
      { <span class='label'>running_jobs:</span> <span class='ivar'>@jobs</span>.<span class='id identifier rubyid_size'>size</span> }
    <span class='kw'>else</span>
      <span class='comment'># Continue to fail with unknown message.
</span>      <span class='id identifier rubyid_pass'>pass</span> 
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>Create the computer actor and send it 3 jobs.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_computer'>computer</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor.html" title="Concurrent::Actor (module)">Actor</a></span>.<span class='id identifier rubyid_spawn'><a href="Concurrent/Actor.html#spawn-class_method" title="Concurrent::Actor.spawn (method)">spawn</a></span> <span class='const'>Computer</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_computer'>computer</span>
<span class='id identifier rubyid_results'>results</span> <span class='op'>=</span> <span class='int'>3</span>.<span class='id identifier rubyid_times'>times</span>.<span class='id identifier rubyid_map'>map</span> { <span class='id identifier rubyid_computer'>computer</span>.<span class='id identifier rubyid_ask'>ask</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_run'>run</span><span class='comma'>,</span> <span class='tlambda'>-&gt;</span> <span class='tlambeg'>{</span> <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span><span class='semicolon'>;</span> <span class='symbeg'>:</span><span class='id identifier rubyid_result'>result</span> }] }
<span class='id identifier rubyid_computer'>computer</span>.<span class='id identifier rubyid_ask'>ask</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_status'>status</span>).<span class='id identifier rubyid_value!'>value!</span>
<span class='id identifier rubyid_results'>results</span>.<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_value!'>value!</span>)</code></pre>

<h2>Solving the Thread count limit by thread simulation</h2>

<p>Sometimes an application requires to process a lot of tasks concurrently. If
the number of concurrent tasks is high enough than it is not possible to create
a Thread for each of them. A partially satisfactory solution could be to use
Fibers, but that solution locks the application on MRI since other Ruby
implementations are using threads for each Fiber.</p>

<p>This library provides a <a href="Concurrent/Promises/Future.html#run-instance_method" title="Concurrent::Promises::Future#run (method)">Concurrent::Promises::Future#run</a> method on a future
to simulate threads without actually accepting one all the time. The run method
is similar to <a href="Concurrent/Promises/Future.html#flat-instance_method" title="Concurrent::Promises::Future#flat (method)">Concurrent::Promises::Future#flat</a> but it will keep flattening
until it&#39;s fulfilled with non future value, then the value is taken as a result
of the process simulated by <code>run</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_body'>body</span> <span class='op'>=</span> <span class='id identifier rubyid_lambda'>lambda</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
  <span class='comment'># Some computation step of the process    
</span>  <span class='id identifier rubyid_new_v'>new_v</span> <span class='op'>=</span> <span class='id identifier rubyid_v'>v</span> <span class='op'>+</span> <span class='int'>1</span>
  <span class='comment'># Is the process finished?
</span>  <span class='kw'>if</span> <span class='id identifier rubyid_new_v'>new_v</span> <span class='op'>&lt;</span> <span class='int'>5</span>
    <span class='comment'># Continue computing with new value, does not have to be recursive.
</span>    <span class='comment'># It just has to return a future.
</span>    <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span>(<span class='id identifier rubyid_new_v'>new_v</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_body'>body</span>)
  <span class='kw'>else</span>
    <span class='comment'># The process is finished, fulfill the final value with `new_v`.
</span>    <span class='id identifier rubyid_new_v'>new_v</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span>(<span class='int'>0</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_body'>body</span>).<span class='id identifier rubyid_run'><a href="Concurrent/Promises/Future.html#run-instance_method" title="Concurrent::Promises::Future#run (method)">run</a></span>.<span class='id identifier rubyid_value!'><a href="Concurrent/Promises/Future.html#value!-instance_method" title="Concurrent::Promises::Future#value! (method)">value!</a></span> <span class='comment'># =&gt; 5</span></code></pre>

<p>This solution works well an any Ruby implementation.</p>

<blockquote>
<p><em>TODO: More examples to be added.</em></p>
</blockquote>

<h2>Throttling concurrency</h2>

<p>By creating an actor managing the resource we can control how many threads is
accessing the resource. In this case one at the time.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_data'>data</span>      <span class='op'>=</span> <span class='const'><a href="Concurrent/Array.html" title="Concurrent::Array (class)">Array</a></span>.<span class='id identifier rubyid_new'>new</span>(<span class='int'>10</span>) { <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>*</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='id identifier rubyid_i'>i</span> }
<span class='const'>DB</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor.html" title="Concurrent::Actor (module)">Actor</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor/Utils.html" title="Concurrent::Actor::Utils (module)">Utils</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor/Utils/AdHoc.html" title="Concurrent::Actor::Utils::AdHoc (class)">AdHoc</a></span>.<span class='id identifier rubyid_spawn'><a href="Concurrent/Actor/AbstractContext.html#spawn-class_method" title="Concurrent::Actor::AbstractContext.spawn (method)">spawn</a></span> <span class='symbeg'>:</span><span class='id identifier rubyid_db'>db</span><span class='comma'>,</span> <span class='id identifier rubyid_data'>data</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_data'>data</span><span class='op'>|</span>
  <span class='id identifier rubyid_lambda'>lambda</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span>
    <span class='comment'># pretending that this queries a DB
</span>    <span class='id identifier rubyid_data'>data</span>[<span class='id identifier rubyid_message'>message</span>]
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_concurrent_jobs'>concurrent_jobs</span> <span class='op'>=</span> <span class='int'>11</span>.<span class='id identifier rubyid_times'>times</span>.<span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
  <span class='const'>DB</span>.
      <span class='comment'># ask the DB with the `v`, only one at the time, rest is parallel
</span>      <span class='id identifier rubyid_ask'>ask</span>(<span class='id identifier rubyid_v'>v</span>).
      <span class='comment'># get size of the string, rejects for 11
</span>      <span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_size'>size</span>).
      <span class='comment'># translate error to a value (message of the exception)
</span>      <span class='id identifier rubyid_rescue'>rescue</span> { <span class='op'>|</span><span class='id identifier rubyid_reason'>reason</span><span class='op'>|</span> <span class='id identifier rubyid_reason'>reason</span>.<span class='id identifier rubyid_message'>message</span> } 
<span class='kw'>end</span> <span class='comment'>#
</span>
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_zip'>zip</span>(<span class='op'>*</span><span class='id identifier rubyid_concurrent_jobs'>concurrent_jobs</span>).<span class='id identifier rubyid_value!'>value!</span></code></pre>

<p>Often there is more then one DB connections, then the pool can be used.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pool_size'>pool_size</span> <span class='op'>=</span> <span class='int'>5</span>

<span class='const'>DB_POOL</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor.html" title="Concurrent::Actor (module)">Actor</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor/Utils.html" title="Concurrent::Actor::Utils (module)">Utils</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor/Utils/Pool.html" title="Concurrent::Actor::Utils::Pool (class)">Pool</a></span>.<span class='id identifier rubyid_spawn!'><a href="Concurrent/Actor/AbstractContext.html#spawn!-class_method" title="Concurrent::Actor::AbstractContext.spawn! (method)">spawn!</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>DB-pool</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_pool_size'>pool_size</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_index'>index</span><span class='op'>|</span>
  <span class='comment'># DB connection constructor
</span>  <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor.html" title="Concurrent::Actor (module)">Actor</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor/Utils.html" title="Concurrent::Actor::Utils (module)">Utils</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Actor/Utils/AdHoc.html" title="Concurrent::Actor::Utils::AdHoc (class)">AdHoc</a></span>.<span class='id identifier rubyid_spawn'><a href="Concurrent/Actor/AbstractContext.html#spawn-class_method" title="Concurrent::Actor::AbstractContext.spawn (method)">spawn</a></span>(
      <span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>connection-</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_index'>index</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> 
      <span class='label'>args:</span> [<span class='id identifier rubyid_data'>data</span>]) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_data'>data</span><span class='op'>|</span>
    <span class='id identifier rubyid_lambda'>lambda</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span>
      <span class='comment'># pretending that this queries a DB
</span>      <span class='id identifier rubyid_data'>data</span>[<span class='id identifier rubyid_message'>message</span>]
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_concurrent_jobs'>concurrent_jobs</span> <span class='op'>=</span> <span class='int'>11</span>.<span class='id identifier rubyid_times'>times</span>.<span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span>
  <span class='const'>DB_POOL</span>.
      <span class='comment'># ask the DB with the `v`, only one at the time, rest is parallel
</span>      <span class='id identifier rubyid_ask'>ask</span>(<span class='id identifier rubyid_v'>v</span>).
      <span class='comment'># get size of the string, rejects for 11
</span>      <span class='id identifier rubyid_then'>then</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_size'>size</span>).
      <span class='comment'># translate error to a value (message of the exception)
</span>      <span class='id identifier rubyid_rescue'>rescue</span> { <span class='op'>|</span><span class='id identifier rubyid_reason'>reason</span><span class='op'>|</span> <span class='id identifier rubyid_reason'>reason</span>.<span class='id identifier rubyid_message'>message</span> } 
<span class='kw'>end</span> <span class='comment'>#
</span>
<span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_zip'>zip</span>(<span class='op'>*</span><span class='id identifier rubyid_concurrent_jobs'>concurrent_jobs</span>).<span class='id identifier rubyid_value!'>value!</span></code></pre>

<p>In other cases the DB adapter maintains its internal connection pool and we
just need to limit concurrent access to the DB&#39;s API to avoid the calls being
blocked.</p>

<p>Lets pretend that the <code>#[]</code> method on <code>DB_INTERNAL_POOL</code> is using the internal
pool of size 3. We create throttle with the same size</p>

<pre class="code ruby"><code class="ruby"><span class='const'>DB_INTERNAL_POOL</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Array.html" title="Concurrent::Array (class)">Array</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span> <span class='id identifier rubyid_data'>data</span> 

<span class='id identifier rubyid_max_tree'>max_tree</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Throttle.html" title="Concurrent::Throttle (class)">Throttle</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Throttle.html#new-class_method" title="Concurrent::Throttle.new (method)">new</a></span> <span class='int'>3</span>

<span class='id identifier rubyid_futures'>futures</span> <span class='op'>=</span> <span class='int'>11</span>.<span class='id identifier rubyid_times'>times</span>.<span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='id identifier rubyid_max_tree'>max_tree</span>.
      <span class='comment'># throttled tasks, at most 3 simultaneous calls of [] on the database
</span>      <span class='id identifier rubyid_future'>future</span> { <span class='const'>DB_INTERNAL_POOL</span>[<span class='id identifier rubyid_i'>i</span>] }.
      <span class='comment'># un-throttled tasks, unlimited concurrency
</span>      <span class='id identifier rubyid_then'>then</span> { <span class='op'>|</span><span class='id identifier rubyid_starts'>starts</span><span class='op'>|</span> <span class='id identifier rubyid_starts'>starts</span>.<span class='id identifier rubyid_size'>size</span> }.
      <span class='id identifier rubyid_rescue'>rescue</span> { <span class='op'>|</span><span class='id identifier rubyid_reason'>reason</span><span class='op'>|</span> <span class='id identifier rubyid_reason'>reason</span>.<span class='id identifier rubyid_message'>message</span> }
<span class='kw'>end</span> <span class='comment'>#
</span>
<span class='id identifier rubyid_futures'>futures</span>.<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_value!'>value!</span>)</code></pre>

<h2>Long stream of tasks, applying backpressure</h2>

<p>Let&#39;s assume that we are querying an API for data and the queries can be faster
than we are able to process them. This example shows how to use channel as a
buffer and how to apply backpressure to slow down the queries. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>json</span><span class='tstring_end'>&#39;</span></span> <span class='comment'>#
</span>
<span class='id identifier rubyid_channel'>channel</span>              <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises/Channel.html" title="Concurrent::Promises::Channel (class)">Channel</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Promises/Channel.html#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> <span class='int'>6</span>
<span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='id identifier rubyid_origin'>origin</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Cancellation.html" title="Concurrent::Cancellation (class)">Cancellation</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Cancellation.html#new-class_method" title="Concurrent::Cancellation.new (method)">new</a></span>

<span class='kw'>def</span> <span class='id identifier rubyid_query_random_text'>query_random_text</span>(<span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span>)
  <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span> <span class='kw'>do</span>
    <span class='comment'># for simplicity the query is omitted
</span>    <span class='comment'># url = &#39;some api&#39;
</span>    <span class='comment'># Net::HTTP.get(URI(url))
</span>    <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span>
    { <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>message</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> 
        <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Lorem ipsum rhoncus scelerisque vulputate diam inceptos</span><span class='tstring_end'>&#39;</span></span> 
    }.<span class='id identifier rubyid_to_json'>to_json</span>
  <span class='kw'>end</span>.<span class='id identifier rubyid_then_flat_event'>then_flat_event</span>(<span class='id identifier rubyid_cancellation'>cancellation</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_cancellation'>cancellation</span><span class='op'>|</span>
    <span class='comment'># The push to channel is fulfilled only after the message is successfully
</span>    <span class='comment'># published to the channel, therefore it will not continue querying until 
</span>    <span class='comment'># current message is pushed.
</span>    <span class='id identifier rubyid_cancellation'>cancellation</span>.<span class='id identifier rubyid_origin'>origin</span> <span class='op'>|</span> <span class='id identifier rubyid_channel'>channel</span>.<span class='id identifier rubyid_push_op'>push_op</span>(<span class='id identifier rubyid_value'>value</span>) 
    <span class='comment'># It could wait on the push indefinitely if the token is not checked
</span>    <span class='comment'># here with `or` (the pipe).        
</span>  <span class='kw'>end</span>.<span class='id identifier rubyid_then'>then</span>(<span class='id identifier rubyid_cancellation'>cancellation</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_cancellation'>cancellation</span><span class='op'>|</span>
    <span class='comment'># query again after the message is pushed to buffer
</span>    <span class='id identifier rubyid_query_random_text'>query_random_text</span>(<span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span>) <span class='kw'>unless</span> <span class='id identifier rubyid_cancellation'>cancellation</span>.<span class='id identifier rubyid_canceled?'>canceled?</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_words'>words</span>          <span class='op'>=</span> []
<span class='id identifier rubyid_words_throttle'>words_throttle</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Throttle.html" title="Concurrent::Throttle (class)">Throttle</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Throttle.html#new-class_method" title="Concurrent::Throttle.new (method)">new</a></span> <span class='int'>1</span>

<span class='kw'>def</span> <span class='id identifier rubyid_count_words_in_random_text'>count_words_in_random_text</span>(<span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_words'>words</span><span class='comma'>,</span> <span class='id identifier rubyid_words_throttle'>words_throttle</span>)
  <span class='id identifier rubyid_channel'>channel</span>.<span class='id identifier rubyid_pop_op'>pop_op</span>.<span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_response'>response</span><span class='op'>|</span>
    <span class='id identifier rubyid_string'>string</span> <span class='op'>=</span> <span class='const'>JSON</span>.<span class='id identifier rubyid_load'>load</span>(<span class='id identifier rubyid_response'>response</span>)[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>message</span><span class='tstring_end'>&#39;</span></span>]
    <span class='comment'># processing is slower than querying
</span>    <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.02</span>
    <span class='id identifier rubyid_words_count'>words_count</span> <span class='op'>=</span> <span class='id identifier rubyid_string'>string</span>.<span class='id identifier rubyid_scan'>scan</span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\w+</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_size'>size</span>
  <span class='kw'>end</span>.<span class='id identifier rubyid_then_on'>then_on</span>(<span class='id identifier rubyid_words_throttle'>words_throttle</span>.<span class='id identifier rubyid_on'>on</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_io'>io</span>)<span class='comma'>,</span> <span class='id identifier rubyid_words'>words</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_words_count'>words_count</span><span class='comma'>,</span> <span class='id identifier rubyid_words'>words</span><span class='op'>|</span>
    <span class='comment'># safe since throttled to only 1 task at a time
</span>    <span class='id identifier rubyid_words'>words</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_words_count'>words_count</span>
  <span class='kw'>end</span>.<span class='id identifier rubyid_then_on'>then_on</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_io'>io</span><span class='comma'>,</span> <span class='id identifier rubyid_cancellation'>cancellation</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid__'>_</span><span class='comma'>,</span> <span class='id identifier rubyid_cancellation'>cancellation</span><span class='op'>|</span>
    <span class='comment'># count words in next message
</span>    <span class='kw'>unless</span> <span class='id identifier rubyid_cancellation'>cancellation</span>.<span class='id identifier rubyid_canceled?'>canceled?</span>
      <span class='id identifier rubyid_count_words_in_random_text'>count_words_in_random_text</span>(<span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_words'>words</span><span class='comma'>,</span> <span class='id identifier rubyid_words_throttle'>words_throttle</span>)
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_query_processes'>query_processes</span> <span class='op'>=</span> <span class='int'>3</span>.<span class='id identifier rubyid_times'>times</span>.<span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span>
  <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span>(<span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_method'>method</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_query_random_text'>query_random_text</span>)).<span class='id identifier rubyid_run'><a href="Concurrent/Promises/Future.html#run-instance_method" title="Concurrent::Promises::Future#run (method)">run</a></span>
<span class='kw'>end</span>

<span class='id identifier rubyid_word_counter_processes'>word_counter_processes</span> <span class='op'>=</span> <span class='int'>2</span>.<span class='id identifier rubyid_times'>times</span>.<span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span>
  <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span>(<span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_words'>words</span><span class='comma'>,</span> <span class='id identifier rubyid_words_throttle'>words_throttle</span><span class='comma'>,</span> 
      <span class='op'>&amp;</span><span class='id identifier rubyid_method'>method</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_count_words_in_random_text'>count_words_in_random_text</span>)).<span class='id identifier rubyid_run'><a href="Concurrent/Promises/Future.html#run-instance_method" title="Concurrent::Promises::Future#run (method)">run</a></span>
<span class='kw'>end</span>

<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.05</span> <span class='comment'>#</span></code></pre>

<p>Let it run for a while, then cancel it, and ensure that the runs were all fulfilled
(therefore ended) after the cancellation. Finally, print the result.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_origin'>origin</span>.<span class='id identifier rubyid_resolve'>resolve</span>
<span class='id identifier rubyid_query_processes'>query_processes</span>.<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_wait!'>wait!</span>) 
<span class='id identifier rubyid_word_counter_processes'>word_counter_processes</span>.<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_wait!'>wait!</span>)
<span class='id identifier rubyid_words'>words</span></code></pre>

<p>Compared to using threads directly, this is highly configurable and composable
solution.</p>

<h2>Periodic task</h2>

<p>A periodically executed task can be creating by combining <code>schedule</code>, <code>run</code> and <a href="Concurrent/Cancellation.html" title="Concurrent::Cancellation (class)"><code>Cancellation</code></a>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_repeating_scheduled_task'>repeating_scheduled_task</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_interval'>interval</span><span class='comma'>,</span> <span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='id identifier rubyid_task'>task</span> <span class='kw'>do</span>
  <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.
      <span class='comment'># Schedule the task.
</span>      <span class='id identifier rubyid_schedule'>schedule</span>(<span class='id identifier rubyid_interval'>interval</span><span class='comma'>,</span> <span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_task'>task</span>).
      <span class='comment'># If successful schedule again. 
</span>      <span class='comment'># Alternatively use chain to schedule always.
</span>      <span class='id identifier rubyid_then'>then</span> { <span class='id identifier rubyid_repeating_scheduled_task'>repeating_scheduled_task</span>.<span class='id identifier rubyid_call'>call</span>(<span class='id identifier rubyid_interval'>interval</span><span class='comma'>,</span> <span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='id identifier rubyid_task'>task</span>) }
<span class='kw'>end</span>

<span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='id identifier rubyid_origin'>origin</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Cancellation.html" title="Concurrent::Cancellation (class)">Cancellation</a></span>.<span class='id identifier rubyid_new'><a href="Concurrent/Cancellation.html#new-class_method" title="Concurrent::Cancellation.new (method)">new</a></span>

<span class='id identifier rubyid_task'>task</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_cancellation'>cancellation</span> <span class='kw'>do</span>
  <span class='int'>5</span>.<span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_cancellation'>cancellation</span>.<span class='id identifier rubyid_check!'>check!</span>
    <span class='id identifier rubyid_do_stuff'>do_stuff</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='const'><a href="Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="Concurrent/Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="Concurrent/Promises/FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span>(<span class='float'>0.1</span><span class='comma'>,</span> <span class='id identifier rubyid_cancellation'>cancellation</span><span class='comma'>,</span> <span class='id identifier rubyid_task'>task</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_repeating_scheduled_task'>repeating_scheduled_task</span>).<span class='id identifier rubyid_run'><a href="Concurrent/Promises/Future.html#run-instance_method" title="Concurrent::Promises::Future#run (method)">run</a></span>
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.03</span> <span class='comment'>#
</span><span class='id identifier rubyid_origin'>origin</span>.<span class='id identifier rubyid_resolve'>resolve</span>
<span class='id identifier rubyid_result'>result</span>.<span class='id identifier rubyid_result'>result</span></code></pre>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>