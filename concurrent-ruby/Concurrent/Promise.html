<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen' content='yes'>
<meta name='mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: Concurrent::Promise &mdash; Concurrent RubyÂ master</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Concurrent::Promise",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../'>Concurrent</a> &raquo; 
      <a href='../_index.html#alpha_P'>Index (P)</a> &raquo; 
        <a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>Promise&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: Concurrent::Promise</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Super Chains via Extension / Inclusion / Inheritance</td></tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Class Chain:</div>
        <div class='box_22'>
          self,
          <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a>,
          <a href="Synchronization/LockableObject.html" title="Concurrent::Synchronization::LockableObject (class)"><code>Synchronization::LockableObject</code></a>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Instance Chain:</div>
        <div class='box_22'>
          self,
          <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a>,
          <a href="Concern/Observable.html" title="Concurrent::Concern::Observable (module)"><code>Concern::Observable</code></a>,
          <a href="Concern/Obligation.html" title="Concurrent::Concern::Obligation (module)"><code>Concern::Obligation</code></a>,
          <a href="Concern/Dereferenceable.html" title="Concurrent::Concern::Dereferenceable (module)"><code>Concern::Dereferenceable</code></a>,
          <a href="Synchronization/LockableObject.html" title="Concurrent::Synchronization::LockableObject (class)"><code>Synchronization::LockableObject</code></a>
        </div>
      </td>
    </tr>
    <tr>
      <td id='t2_inherits' class='box_2 o'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'><a href="IVar.html" title="Concurrent::IVar (class)">Concurrent::IVar</a></span>
        <ul class='fullTree'>
          <li><a href="../Object.html" title="Object (class)"><code>::Object</code></a></li>
          <li class='next'><a href="Synchronization/LockableObject.html" title="Concurrent::Synchronization::LockableObject (class)">Concurrent::Synchronization::LockableObject</a></li>
          <li class='next'><a href="IVar.html" title="Concurrent::IVar (class)">Concurrent::IVar</a></li>
          <li class='next'>Concurrent::Promise</li>
        </ul>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L190'>lib/concurrent-ruby/concurrent/promise.rb</a>      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    <p><a href="Promises.html" title="Concurrent::Promises (module)"><code>Promises</code></a> are inspired by the JavaScript <a href="http://wiki.commonjs.org/wiki/Promises/A" target="_parent" title="Promises/A">Promises/A</a>
and <a href="http://promises-aplus.github.io/promises-spec/" target="_parent" title="Promises/A+">Promises/A+</a> specifications.</p>

<blockquote>
<p>A promise represents the eventual value returned from the single
completion of an operation.</p>
</blockquote>

<p><a href="Promises.html" title="Concurrent::Promises (module)"><code>Promises</code></a> are similar to futures and share many of the same behaviours.
<a href="Promises.html" title="Concurrent::Promises (module)"><code>Promises</code></a> are far more robust, however. <a href="Promises.html" title="Concurrent::Promises (module)"><code>Promises</code></a> can be chained in a tree
structure where each promise may have zero or more children. <a href="Promises.html" title="Concurrent::Promises (module)"><code>Promises</code></a> are
chained using the <a href="#then-instance_method" title="Concurrent::Promise#then (method)">#then</a> method. The result of a call to <a href="#then-instance_method" title="Concurrent::Promise#then (method)">#then</a> is always
another promise. <a href="Promises.html" title="Concurrent::Promises (module)"><code>Promises</code></a> are resolved asynchronously (with respect to the
main thread) but in a strict order: parents are guaranteed to be resolved
before their children, children before their younger siblings. The <a href="#then-instance_method" title="Concurrent::Promise#then (method)">#then</a>
method takes two parameters: an optional block to be executed upon parent
resolution and an optional callable to be executed upon parent failure. The
result of each promise is passed to each of its children upon resolution.
When a promise is rejected all its children will be summarily rejected and
will receive the reason.</p>

<p><a href="Promises.html" title="Concurrent::Promises (module)"><code>Promises</code></a> have several possible states: <em>:unscheduled</em>, <em>:pending</em>,
<em>:processing</em>, <em>:rejected</em>, or <em>:fulfilled</em>. These are also aggregated as
<code>#incomplete?</code> and <code>#complete?</code>. When a <code>Promise</code> is created it is set to
<em>:unscheduled</em>. Once the <a href="#execute-instance_method" title="Concurrent::Promise#execute (method)">#execute</a> method is called the state becomes
<em>:pending</em>. Once a job is pulled from the thread pool&#39;s queue and is given
to a thread for processing (often immediately upon <code>#post</code>) the state
becomes <em>:processing</em>. The future will remain in this state until processing
is complete. A future that is in the <em>:unscheduled</em>, <em>:pending</em>, or
<em>:processing</em> is considered <code>#incomplete?</code>. A <code>#complete?</code> <code>Promise</code> is either
<em>:rejected</em>, indicating that an exception was thrown during processing, or
<em>:fulfilled</em>, indicating success. If a <code>Promise</code> is <em>:fulfilled</em> its <code>#value</code>
will be updated to reflect the result of the operation. If <em>:rejected</em> the
<code>reason</code> will be updated with a reference to the thrown exception. The
predicate methods <code>#unscheduled?</code>, <code>#pending?</code>, <code>#rejected?</code>, and
<code>#fulfilled?</code> can be called at any time to obtain the state of the <code>Promise</code>,
as can the <code>#state</code> method, which returns a symbol.</p>

<p>Retrieving the value of a promise is done through the <code>value</code> (alias:
<code>deref</code>) method. Obtaining the value of a promise is a potentially blocking
operation. When a promise is <em>rejected</em> a call to <code>value</code> will return <code>nil</code>
immediately. When a promise is <em>fulfilled</em> a call to <code>value</code> will
immediately return the current value. When a promise is <em>pending</em> a call to
<code>value</code> will block until the promise is either <em>rejected</em> or <em>fulfilled</em>. A
<em>timeout</em> value can be passed to <code>value</code> to limit how long the call will
block. If <code>nil</code> the call will block indefinitely. If <code>0</code> the call will not
block. Any other integer or float value will indicate the maximum number of
seconds to block.</p>

<p><a href="Promises.html" title="Concurrent::Promises (module)"><code>Promises</code></a> run on the global thread pool.</p>

<h2>Copy Options</h2>

<p><a href="../Object.html" title="Object (class)"><code>::Object</code></a> references in Ruby are mutable. This can lead to serious
problems when the <code>#value</code> of an object is a mutable reference. Which
is always the case unless the value is a <code>Fixnum</code>, <code>Symbol</code>, or similar
&quot;primitive&quot; data type. Each instance can be configured with a few
options that can help protect the program from potentially dangerous
operations. Each of these options can be optionally set when the object
instance is created:</p>

<ul>
<li><code>:dup_on_deref</code> When true the object will call the <code>#dup</code> method on
the <code>value</code> object every time the <code>#value</code> method is called
(default: false)</li>
<li><code>:freeze_on_deref</code> When true the object will call the <code>#freeze</code>
method on the <code>value</code> object every time the <code>#value</code> method is called
(default: false)</li>
<li><code>:copy_on_deref</code> When given a <code>Proc</code> object the <code>Proc</code> will be run
every time   the <code>#value</code> method is called. The <code>Proc</code> will be given
the current <code>value</code> as its only argument and the result returned by
the block will be the return   value of the <code>#value</code> call. When <code>nil</code>
this option will be ignored (default: nil)</li>
</ul>

<p>When multiple deref options are set the order of operations is strictly defined.
The order of deref operations is:</p>

<ul>
<li><code>:copy_on_deref</code></li>
<li><code>:dup_on_deref</code></li>
<li><code>:freeze_on_deref</code></li>
</ul>

<p>Because of this ordering there is no need to <code>#freeze</code> an object created by a
provided <code>:copy_on_deref</code> block. Simply set <code>:freeze_on_deref</code> to <code>true</code>.
Setting both <code>:dup_on_deref</code> to <code>true</code> and <code>:freeze_on_deref</code> to <code>true</code> is
as close to the behavior of a &quot;pure&quot; functional language (like Erlang, Clojure,
or Haskell) as we are likely to get in Ruby.</p>

<h5>Examples</h5>

<p>Start by requiring promises</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>concurrent/promise</span><span class='tstring_end'>&#39;</span></span></code></pre>

<p>Then create one</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Promise</span>.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span> <span class='kw'>do</span>
      <span class='comment'># do something
</span>      <span class='int'>42</span>
    <span class='kw'>end</span></code></pre>

<p>Promises can be chained using the <a href="#then-instance_method" title="Concurrent::Promise#then (method)">#then</a> method. The <a href="#then-instance_method" title="Concurrent::Promise#then (method)">#then</a> method accepts a
block and an executor, to be executed on fulfillment, and a callable argument to be executed
on rejection. The result of the each promise is passed as the block argument
to chained promises.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Promise</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>{<span class='int'>10</span>}.<span class='id identifier rubyid_then'><a href="#then-instance_method" title="Concurrent::Promise#then (method)">then</a></span>{<span class='op'>|</span><span class='id identifier rubyid_x'>x</span><span class='op'>|</span> <span class='id identifier rubyid_x'>x</span> <span class='op'>*</span> <span class='int'>2</span>}.<span class='id identifier rubyid_then'><a href="#then-instance_method" title="Concurrent::Promise#then (method)">then</a></span>{<span class='op'>|</span><span class='id identifier rubyid_result'>result</span><span class='op'>|</span> <span class='id identifier rubyid_result'>result</span> <span class='op'>-</span> <span class='int'>10</span> }.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span></code></pre>

<p>And so on, and so on, and so on...</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Promise</span>.<span class='id identifier rubyid_fulfill'><a href="#fulfill-class_method" title="Concurrent::Promise.fulfill (method)">fulfill</a></span>(<span class='int'>20</span>).
    <span class='id identifier rubyid_then'><a href="#then-instance_method" title="Concurrent::Promise#then (method)">then</a></span>{<span class='op'>|</span><span class='id identifier rubyid_result'>result</span><span class='op'>|</span> <span class='id identifier rubyid_result'>result</span> <span class='op'>-</span> <span class='int'>10</span> }.
    <span class='id identifier rubyid_then'><a href="#then-instance_method" title="Concurrent::Promise#then (method)">then</a></span>{<span class='op'>|</span><span class='id identifier rubyid_result'>result</span><span class='op'>|</span> <span class='id identifier rubyid_result'>result</span> <span class='op'>*</span> <span class='int'>3</span> }.
    <span class='id identifier rubyid_then'><a href="#then-instance_method" title="Concurrent::Promise#then (method)">then</a></span>(<span class='label'>executor:</span> <span class='id identifier rubyid_different_executor'>different_executor</span>){<span class='op'>|</span><span class='id identifier rubyid_result'>result</span><span class='op'>|</span> <span class='id identifier rubyid_result'>result</span> <span class='op'>%</span> <span class='int'>5</span> }.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span></code></pre>

<p>The initial state of a newly created Promise depends on the state of its parent:</p>

<ul>
<li>if parent is <em>unscheduled</em> the child will be <em>unscheduled</em></li>
<li>if parent is <em>pending</em> the child will be <em>pending</em></li>
<li>if parent is <em>fulfilled</em> the child will be <em>pending</em></li>
<li>if parent is <em>rejected</em> the child will be <em>pending</em> (but will ultimately be <em>rejected</em>)</li>
</ul>

<p>Promises are executed asynchronously from the main thread. By the time a
child Promise finishes initialization it may be in a different state than its
parent (by the time a child is created its parent may have completed
execution and changed state). Despite being asynchronous, however, the order
of execution of Promise objects in a chain (or tree) is strictly defined.</p>

<p>There are multiple ways to create and execute a new <code>Promise</code>. Both ways
provide identical behavior:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'>### create, operate, then execute
</span><span class='id identifier rubyid_p1'>p1</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Promise</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>{ <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello World!</span><span class='tstring_end'>&quot;</span></span> }
<span class='id identifier rubyid_p1'>p1</span>.<span class='id identifier rubyid_state'>state</span> <span class='comment'>#=&gt; :unscheduled
</span><span class='id identifier rubyid_p1'>p1</span>.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span>

<span class='comment'>### create and immediately execute
</span><span class='id identifier rubyid_p2'>p2</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Promise</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>{ <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello World!</span><span class='tstring_end'>&quot;</span></span> }.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span>

<span class='comment'>### execute during creation
</span><span class='id identifier rubyid_p3'>p3</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Promise</span>.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span>{ <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello World!</span><span class='tstring_end'>&quot;</span></span> }</code></pre>

<p>Once the <a href="#execute-class_method" title="Concurrent::Promise.execute (method)">.execute</a> method is called a <code>Promise</code> becomes <code>pending</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Promise</span>.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span>{ <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello, world!</span><span class='tstring_end'>&quot;</span></span> }
<span class='id identifier rubyid_p'>p</span>.<span class='id identifier rubyid_state'>state</span>    <span class='comment'>#=&gt; :pending
</span><span class='id identifier rubyid_p'>p</span>.<span class='id identifier rubyid_pending?'>pending?</span> <span class='comment'>#=&gt; true</span></code></pre>

<p>Wait a little bit, and the promise will resolve and provide a value:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Promise</span>.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span>{ <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello, world!</span><span class='tstring_end'>&quot;</span></span> }
<span class='id identifier rubyid_sleep'>sleep</span>(<span class='float'>0.1</span>)

<span class='id identifier rubyid_p'>p</span>.<span class='id identifier rubyid_state'>state</span>      <span class='comment'>#=&gt; :fulfilled
</span><span class='id identifier rubyid_p'>p</span>.<span class='id identifier rubyid_fulfilled?'>fulfilled?</span> <span class='comment'>#=&gt; true
</span><span class='id identifier rubyid_p'>p</span>.<span class='id identifier rubyid_value'>value</span>      <span class='comment'>#=&gt; &quot;Hello, world!&quot;</span></code></pre>

<p>If an exception occurs, the promise will be rejected and will provide
a reason for the rejection:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Promise</span>.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span>{ <span class='id identifier rubyid_raise'>raise</span> <span class='const'>StandardError</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Here comes the Boom!</span><span class='tstring_end'>&quot;</span></span>) }
<span class='id identifier rubyid_sleep'>sleep</span>(<span class='float'>0.1</span>)

<span class='id identifier rubyid_p'>p</span>.<span class='id identifier rubyid_state'>state</span>     <span class='comment'>#=&gt; :rejected
</span><span class='id identifier rubyid_p'>p</span>.<span class='id identifier rubyid_rejected?'>rejected?</span> <span class='comment'>#=&gt; true
</span><span class='id identifier rubyid_p'>p</span>.<span class='id identifier rubyid_reason'>reason</span>    <span class='comment'>#=&gt; &quot;#&lt;StandardError: Here comes the Boom!&gt;&quot;</span></code></pre>

<h6>Rejection</h6>

<p>When a promise is rejected all its children will be rejected and will
receive the rejection <code>reason</code> as the rejection callable parameter:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Promise</span>.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span> { <span class='const'>Thread</span>.<span class='id identifier rubyid_pass'>pass</span><span class='semicolon'>;</span> <span class='id identifier rubyid_raise'>raise</span> <span class='const'>StandardError</span> }

<span class='id identifier rubyid_c1'>c1</span> <span class='op'>=</span> <span class='id identifier rubyid_p'>p</span>.<span class='id identifier rubyid_then'><a href="#then-instance_method" title="Concurrent::Promise#then (method)">then</a></span>(<span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_reason'>reason</span> <span class='tlambeg'>{</span> <span class='int'>42</span> })
<span class='id identifier rubyid_c2'>c2</span> <span class='op'>=</span> <span class='id identifier rubyid_p'>p</span>.<span class='id identifier rubyid_then'><a href="#then-instance_method" title="Concurrent::Promise#then (method)">then</a></span>(<span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_reason'>reason</span> <span class='tlambeg'>{</span> <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Boom!</span><span class='tstring_end'>&#39;</span></span> })

<span class='id identifier rubyid_c1'>c1</span>.<span class='id identifier rubyid_wait'>wait</span>.<span class='id identifier rubyid_state'>state</span>  <span class='comment'>#=&gt; :fulfilled
</span><span class='id identifier rubyid_c1'>c1</span>.<span class='id identifier rubyid_value'>value</span>       <span class='comment'>#=&gt; 42
</span><span class='id identifier rubyid_c2'>c2</span>.<span class='id identifier rubyid_wait'>wait</span>.<span class='id identifier rubyid_state'>state</span>  <span class='comment'>#=&gt; :rejected
</span><span class='id identifier rubyid_c2'>c2</span>.<span class='id identifier rubyid_reason'>reason</span>      <span class='comment'>#=&gt; #&lt;RuntimeError: Boom!&gt;</span></code></pre>

<p>Once a promise is rejected it will continue to accept children that will
receive immediately rejection (they will be executed asynchronously).</p>

<h6>Aliases</h6>

<p>The <a href="#then-instance_method" title="Concurrent::Promise#then (method)">#then</a> method is the most generic alias: it accepts a block to be
executed upon parent fulfillment and a callable to be executed upon parent
rejection. At least one of them should be passed. The default block is <code>{
|result| result }</code> that fulfills the child with the parent value. The
default callable is <code>{ |reason| raise reason }</code> that rejects the child with
the parent reason.</p>

<ul>
<li><code>on_success { |result| ... }</code> is the same as <code>then {|result| ... }</code></li>
<li><code>rescue { |reason| ... }</code> is the same as <code>then(Proc.new { |reason| ... } )</code></li>
<li><a href="#rescue-instance_method" title="Concurrent::Promise#rescue (method)">#rescue</a> is aliased by <a href="#catch-instance_method" title="Concurrent::Promise#catch (method)">#catch</a> and <a href="#on_error-instance_method" title="Concurrent::Promise#on_error (method)">#on_error</a></li>
</ul>

  </div>
</div>
</div>
<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#all%3F-class_method" title=".all? (class method)">.<strong>all?</strong>(*promises)  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Aggregates a collection of promises and executes the <a href="#then-instance_method" title="Concurrent::Promise#then (method)">#then</a> condition if all aggregated promises succeed.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#any%3F-class_method" title=".any? (class method)">.<strong>any?</strong>(*promises)  &#x21d2; Promise </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Aggregates a collection of promises and executes the <a href="#then-instance_method" title="Concurrent::Promise#then (method)">#then</a> condition if any aggregated promises succeed.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#execute-class_method" title=".execute (class method)">.<strong>execute</strong>(opts = {}, &amp;block)  &#x21d2; Promise </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Create a new <code>Promise</code> object with the given block, execute it, and return the <code>:pending</code> object.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#fulfill-class_method" title=".fulfill (class method)">.<strong>fulfill</strong>(value, opts = {})  &#x21d2; Promise </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Create a new <code>Promise</code> and fulfill it immediately.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#new-class_method" title=".new (class method)">.<strong>new</strong>(opts = {}) { ... } &#x21d2; Promise </a>
    </span>
    <span class='note title constructor'>constructor</span>
    <div class='summary_desc'>
      <div class='inline'><p>Initialize a new <code>Promise</code> with the provided options.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#reject-class_method" title=".reject (class method)">.<strong>reject</strong>(reason, opts = {})  &#x21d2; Promise </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Create a new <code>Promise</code> and reject it immediately.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#zip-class_method" title="zip (class method)">.<strong>zip</strong>(*promises)  &#x21d2; Promise&lt;Array&gt; </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Builds a promise that produces the result of promises in an <a href="Array.html" title="Concurrent::Array (class)"><code>Array</code></a> and fails if any of them fails.</p></div>
    </div>
  </li>
</ul>

<h3 class='inherited'><a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr class='i_ds'>
      <td><a class='i_m ' href="IVar.html#new-class_method" title="Concurrent::IVar.new (method)">.new</a></td>
      <td><div class='inline'><p>Create a new <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> in the <code>:pending</code> state with the (optional) initial value.</p></div></td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_attribute_summary'>Instance Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature ro priv nodoc'>
      <a href="#root%3F-instance_method" title="#root? (instance method)">#<strong>root?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <span class='note title private'>private</span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
</ul>

<h3 class='inherited'><a href="Concern/Obligation.html" title="Concurrent::Concern::Obligation (module)"><code>Concern::Obligation</code></a> - Included</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr class='i_ds'>
      <td><a class='i_m ro' href="Concern/Obligation.html#complete%3F-instance_method" title="Concurrent::Concern::Obligation#complete? (method)">#complete?</a></td>
      <td><div class='inline'><p>Has the obligation completed processing?</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ro' href="Concern/Obligation.html#fulfilled%3F-instance_method" title="Concurrent::Concern::Obligation#fulfilled? (method)">#fulfilled?</a></td>
      <td><div class='inline'><p>Has the obligation been fulfilled?</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ro' href="Concern/Obligation.html#incomplete%3F-instance_method" title="Concurrent::Concern::Obligation#incomplete? (method)">#incomplete?</a></td>
      <td><div class='inline'><p>Is the obligation still awaiting completion of processing?</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ro' href="Concern/Obligation.html#pending%3F-instance_method" title="Concurrent::Concern::Obligation#pending? (method)">#pending?</a></td>
      <td><div class='inline'><p>Is obligation completion still pending?</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ro' href="Concern/Obligation.html#realized%3F-instance_method" title="Concurrent::Concern::Obligation#realized? (method)">#realized?</a></td>
      <td><div class='inline'><p>Alias for <a href="Concern/Obligation.html#fulfilled%3F-instance_method" title="Concurrent::Concern::Obligation#fulfilled? (method)">Concern::Obligation#fulfilled?</a>.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ro' href="Concern/Obligation.html#rejected%3F-instance_method" title="Concurrent::Concern::Obligation#rejected? (method)">#rejected?</a></td>
      <td><div class='inline'><p>Has the obligation been rejected?</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m rw' href="Concern/Obligation.html#state-instance_method" title="Concurrent::Concern::Obligation#state (method)">#state</a></td>
      <td><div class='inline'><p>The current state of the obligation.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ro' href="Concern/Obligation.html#unscheduled%3F-instance_method" title="Concurrent::Concern::Obligation#unscheduled? (method)">#unscheduled?</a></td>
      <td><div class='inline'><p>Is the obligation still unscheduled?</p></div></td>
    </tr>
    <tr>
      <td colspan='2'>
        <a class='i_m rw priv' href="Concern/Obligation.html#state=-instance_method" title="Concurrent::Concern::Obligation#state= (method)">#state=</a>
      </td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="Concern/Dereferenceable.html" title="Concurrent::Concern::Dereferenceable (module)"><code>Concern::Dereferenceable</code></a> - Included</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr class='i_ds'>
      <td><a class='i_m ro' href="Concern/Dereferenceable.html#value-instance_method" title="Concurrent::Concern::Dereferenceable#value (method)">#value</a></td>
      <td><div class='inline'><p>Return the value this object represents after applying the options specified by the <code>#set_deref_options</code> method.</p></div></td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- instance_attribute_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#catch-instance_method" title="#catch (instance method)">#<strong>catch</strong>(&amp;block)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#rescue-instance_method" title="Concurrent::Promise#rescue (method)">#rescue</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#execute-instance_method" title="#execute (instance method)">#<strong>execute</strong>  &#x21d2; Promise </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Execute an <code>:unscheduled</code> <code>Promise</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#fail-instance_method" title="#fail (instance method)">#<strong>fail</strong>(reason = StandardError.new)  &#x21d2; IVar </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p><a href="Set.html" title="Concurrent::Set (class)"><code>Set</code></a> the <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> to failed due to some error and wake or notify all threads waiting on it.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#flat_map-instance_method" title="#flat_map (instance method)">#<strong>flat_map</strong>(&amp;block)  &#x21d2; Promise </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Yield the successful result to the block that returns a promise.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#on_error-instance_method" title="#on_error (instance method)">#<strong>on_error</strong>(&amp;block)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#rescue-instance_method" title="Concurrent::Promise#rescue (method)">#rescue</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#on_success-instance_method" title="#on_success (instance method)">#<strong>on_success</strong> { ... } &#x21d2; Promise </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Chain onto this promise an action to be undertaken on success (fulfillment).</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#rescue-instance_method" title="#rescue (instance method)">#<strong>rescue</strong> { ... } &#x21d2; Promise </a>
      (also: #catch, #on_error)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Chain onto this promise an action to be undertaken on failure (rejection).</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#set-instance_method" title="#set (instance method)">#<strong>set</strong>(value = NULL) { ... } &#x21d2; IVar </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p><a href="Set.html" title="Concurrent::Set (class)"><code>Set</code></a> the <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> to a value and wake or notify all threads waiting on it.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#then-instance_method" title="#then (instance method)">#<strong>then</strong>(rescuer, executor, &amp;block)  &#x21d2; Promise </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Chain a new promise off the current promise.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#zip-instance_method" title="#zip (instance method)">#<strong>zip</strong>(*promises)  &#x21d2; Promise&lt;Array&gt; </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Builds a promise that produces the result of self and others in an <a href="Array.html" title="Concurrent::Array (class)"><code>Array</code></a> and fails if any of them fails.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#complete-instance_method" title="#complete (instance method)">#<strong>complete</strong>(success, value, reason)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#notify_child-instance_method" title="#notify_child (instance method)">#<strong>notify_child</strong>(child)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#on_fulfill-instance_method" title="#on_fulfill (instance method)">#<strong>on_fulfill</strong>(result)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#on_reject-instance_method" title="#on_reject (instance method)">#<strong>on_reject</strong>(reason)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#realize-instance_method" title="#realize (instance method)">#<strong>realize</strong>(task)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#set_pending-instance_method" title="#set_pending (instance method)">#<strong>set_pending</strong>  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#set_state!-instance_method" title="#set_state! (instance method)">#<strong>set_state!</strong>(success, value, reason)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#synchronized_set_state!-instance_method" title="#synchronized_set_state! (instance method)">#<strong>synchronized_set_state!</strong>(success, value, reason)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
</ul>

<h3 class='inherited'><a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr class='i_ds'>
      <td><a class='i_m ' href="IVar.html#add_observer-instance_method" title="Concurrent::IVar#add_observer (method)">#add_observer</a></td>
      <td><div class='inline'><p>Add an observer on this object that will receive notification on update.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="IVar.html#fail-instance_method" title="Concurrent::IVar#fail (method)">#fail</a></td>
      <td><div class='inline'><p><a href="Set.html" title="Concurrent::Set (class)"><code>Set</code></a> the <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> to failed due to some error and wake or notify all threads waiting on it.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="IVar.html#set-instance_method" title="Concurrent::IVar#set (method)">#set</a></td>
      <td><div class='inline'><p><a href="Set.html" title="Concurrent::Set (class)"><code>Set</code></a> the <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> to a value and wake or notify all threads waiting on it.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="IVar.html#try_set-instance_method" title="Concurrent::IVar#try_set (method)">#try_set</a></td>
      <td><div class='inline'><p>Attempt to set the <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> with the given value or block.</p></div></td>
    </tr>
    <tr>
      <td colspan='2'>
        <a class='i_m priv' href="IVar.html#complete-instance_method" title="Concurrent::IVar#complete (method)">#complete</a>,
        <a class='i_m priv' href="IVar.html#complete_without_notification-instance_method" title="Concurrent::IVar#complete_without_notification (method)">#complete_without_notification</a>,
        <a class='i_m priv' href="IVar.html#notify_observers-instance_method" title="Concurrent::IVar#notify_observers (method)">#notify_observers</a>,
        <a class='i_m priv' href="IVar.html#ns_complete_without_notification-instance_method" title="Concurrent::IVar#ns_complete_without_notification (method)">#ns_complete_without_notification</a>,
        <a class='i_m priv' href="IVar.html#ns_initialize-instance_method" title="Concurrent::IVar#ns_initialize (method)">#ns_initialize</a>,
        <a class='i_m priv' href="IVar.html#safe_execute-instance_method" title="Concurrent::IVar#safe_execute (method)">#safe_execute</a>,
        <a class='i_m priv nodoc' href="IVar.html#check_for_block_or_value!-instance_method" title="Concurrent::IVar#check_for_block_or_value! (method)">#check_for_block_or_value!</a>
      </td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="Concern/Observable.html" title="Concurrent::Concern::Observable (module)"><code>Concern::Observable</code></a> - Included</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Observable.html#add_observer-instance_method" title="Concurrent::Concern::Observable#add_observer (method)">#add_observer</a></td>
      <td><div class='inline'><p>Adds an observer to this set.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Observable.html#count_observers-instance_method" title="Concurrent::Concern::Observable#count_observers (method)">#count_observers</a></td>
      <td><div class='inline'><p>Return the number of observers associated with this object.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Observable.html#delete_observer-instance_method" title="Concurrent::Concern::Observable#delete_observer (method)">#delete_observer</a></td>
      <td><div class='inline'><p>Remove <code>observer</code> as an observer on this object so that it will no longer receive notifications.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Observable.html#delete_observers-instance_method" title="Concurrent::Concern::Observable#delete_observers (method)">#delete_observers</a></td>
      <td><div class='inline'><p>Remove all observers associated with this object.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Observable.html#with_observer-instance_method" title="Concurrent::Concern::Observable#with_observer (method)">#with_observer</a></td>
      <td><div class='inline'><p>As <code>#add_observer</code> but can be used for chaining.</p></div></td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="Concern/Obligation.html" title="Concurrent::Concern::Obligation (module)"><code>Concern::Obligation</code></a> - Included</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="Concern/Obligation.html#exception-instance_method" title="Concurrent::Concern::Obligation#exception (method)">#exception</a>,
      </td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Obligation.html#no_error!-instance_method" title="Concurrent::Concern::Obligation#no_error! (method)">#no_error!</a></td>
      <td><div class='inline'><p>Alias for <a href="Concern/Obligation.html#wait!-instance_method" title="Concurrent::Concern::Obligation#wait! (method)">Concern::Obligation#wait!</a>.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Obligation.html#reason-instance_method" title="Concurrent::Concern::Obligation#reason (method)">#reason</a></td>
      <td><div class='inline'><p>If an exception was raised during processing this will return the exception object.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Obligation.html#value-instance_method" title="Concurrent::Concern::Obligation#value (method)">#value</a></td>
      <td><div class='inline'><p>The current value of the obligation.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Obligation.html#value!-instance_method" title="Concurrent::Concern::Obligation#value! (method)">#value!</a></td>
      <td><div class='inline'><p>The current value of the obligation.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Obligation.html#wait-instance_method" title="Concurrent::Concern::Obligation#wait (method)">#wait</a></td>
      <td><div class='inline'><p>Wait until obligation is complete or the timeout has been reached.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Obligation.html#wait!-instance_method" title="Concurrent::Concern::Obligation#wait! (method)">#wait!</a></td>
      <td><div class='inline'><p>Wait until obligation is complete or the timeout is reached.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m priv' href="Concern/Obligation.html#compare_and_set_state-instance_method" title="Concurrent::Concern::Obligation#compare_and_set_state (method)">#compare_and_set_state</a></td>
      <td><div class='inline'><p>Atomic compare and set operation State is set to <code>next_state</code> only if <code>current state == expected_current</code>.</p></div></td>
    </tr>
    <tr>
      <td colspan='2'>
        <a class='i_m priv' href="Concern/Obligation.html#event-instance_method" title="Concurrent::Concern::Obligation#event (method)">#event</a>,
        <a class='i_m priv' href="Concern/Obligation.html#get_arguments_from-instance_method" title="Concurrent::Concern::Obligation#get_arguments_from (method)">#get_arguments_from</a>,
      </td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m priv' href="Concern/Obligation.html#if_state-instance_method" title="Concurrent::Concern::Obligation#if_state (method)">#if_state</a></td>
      <td><div class='inline'><p>Executes the block within mutex if current state is included in expected_states.</p></div></td>
    </tr>
    <tr>
      <td colspan='2'>
        <a class='i_m priv' href="Concern/Obligation.html#init_obligation-instance_method" title="Concurrent::Concern::Obligation#init_obligation (method)">#init_obligation</a>,
      </td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m priv' href="Concern/Obligation.html#ns_check_state%3F-instance_method" title="Concurrent::Concern::Obligation#ns_check_state? (method)">#ns_check_state?</a></td>
      <td><div class='inline'><p>Am I in the current state?</p></div></td>
    </tr>
    <tr>
      <td colspan='2'>
        <a class='i_m priv' href="Concern/Obligation.html#ns_set_state-instance_method" title="Concurrent::Concern::Obligation#ns_set_state (method)">#ns_set_state</a>,
        <a class='i_m priv' href="Concern/Obligation.html#set_state-instance_method" title="Concurrent::Concern::Obligation#set_state (method)">#set_state</a>
      </td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="Concern/Dereferenceable.html" title="Concurrent::Concern::Dereferenceable (module)"><code>Concern::Dereferenceable</code></a> - Included</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Dereferenceable.html#deref-instance_method" title="Concurrent::Concern::Dereferenceable#deref (method)">#deref</a></td>
      <td><div class='inline'><p>Alias for <a href="Concern/Dereferenceable.html#value-instance_method" title="Concurrent::Concern::Dereferenceable#value (method)">Concern::Dereferenceable#value</a>.</p></div></td>
    </tr>
    <tr>
      <td colspan='2'>
        <a class='i_m priv' href="Concern/Dereferenceable.html#apply_deref_options-instance_method" title="Concurrent::Concern::Dereferenceable#apply_deref_options (method)">#apply_deref_options</a>,
      </td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m priv' href="Concern/Dereferenceable.html#ns_set_deref_options-instance_method" title="Concurrent::Concern::Dereferenceable#ns_set_deref_options (method)">#ns_set_deref_options</a></td>
      <td><div class='inline'><p><a href="Set.html" title="Concurrent::Set (class)"><code>Set</code></a> the options which define the operations <code>#value</code> performs before returning data to the caller (dereferencing).</p></div></td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="Synchronization/LockableObject.html" title="Concurrent::Synchronization::LockableObject (class)"><code>Synchronization::LockableObject</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="Synchronization/LockableObject.html#new_condition-instance_method" title="Concurrent::Synchronization::LockableObject#new_condition (method)">#new_condition</a>
      </td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- instance_method_summary -->
<h2 id='Constructor_Details' class='y_details'>Constructor Details</h2>

  <section class='method_details first' id="new-class_method">
  <h3 class='signature  first'>
    .<strong>new</strong>(opts = {}) { ... } &#x21d2; <code>Promise</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Initialize a new <code>Promise</code> with the provided options.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>opts</span>
    <span class='type'>(<a href="Hash.html" title="Concurrent::Hash (class)">Hash</a>)</span>
    <em class='default'>(defaults to: <tt>{}</tt>)</em>
&mdash;    <div class='inline'>
<p>the options used to define the behavior at update and deref and to specify the executor on which to perform actions</p>
</div>
  </li>
</ul>
    <p class='tag_title'>Options Hash (<tt>opts</tt>):</p>
    <ul class='option'>
        <li>
          <span class='name'>:executor</span>
          <span class='type'>(<code>Executor</code>)</span>
            &mdash; <div class='inline'>
<p>when set use the given <code>Executor</code> instance. Three special values are also supported: <code>:io</code> returns the global pool for long, blocking (IO) tasks, <code>:fast</code> returns the global pool for short, fast operations, and <code>:immediate</code> returns the global <a href="ImmediateExecutor.html" title="Concurrent::ImmediateExecutor (class)"><code>ImmediateExecutor</code></a> object.</p>
</div>        </li>
        <li>
          <span class='name'>:dup_on_deref</span>
          <span class='type'>(<code>Boolean</code>)</span>
          <span class='default'> &mdash; default:
              <tt>false</tt>          </span>
            &mdash; <div class='inline'>
<p>Call <code>#dup</code> before returning the data from <code>#value</code></p>
</div>        </li>
        <li>
          <span class='name'>:freeze_on_deref</span>
          <span class='type'>(<code>Boolean</code>)</span>
          <span class='default'> &mdash; default:
              <tt>false</tt>          </span>
            &mdash; <div class='inline'>
<p>Call <code>#freeze</code> before returning the data from <code>#value</code></p>
</div>        </li>
        <li>
          <span class='name'>:copy_on_deref</span>
          <span class='type'>(<code>Proc</code>)</span>
          <span class='default'> &mdash; default:
              <tt>nil</tt>          </span>
            &mdash; <div class='inline'>
<p>When calling the <code>#value</code> method, call the given proc passing the internal value as the sole argument then return the new value returned from the proc.</p>
</div>        </li>
    </ul>
<p class='tag_title'>Yields:</p>
<ul class='yield'>
  <li>
    <span class='type'></span>
    <div class='inline'>
<p>The block operation to be performed asynchronously.</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<code>ArgumentError</code>)</span>
&mdash;    <div class='inline'>
<p>if no block is given</p>
</div>
  </li>
</ul>
  <p class='tag_title'>See Also:</p>
  <ul class='see'>
      <li><a href="http://wiki.commonjs.org/wiki/Promises/A" target="_parent" title="http://wiki.commonjs.org/wiki/Promises/A">http://wiki.commonjs.org/wiki/Promises/A</a></li>
          <li><a href="http://promises-aplus.github.io/promises-spec/" target="_parent" title="http://promises-aplus.github.io/promises-spec/">http://promises-aplus.github.io/promises-spec/</a></li>
      </ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L210-L213'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='210' data-end='213'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 210</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_initialize'><a href="../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">initialize</a></span>(<span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> {}<span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>)
  <span class='id identifier rubyid_opts'>opts</span>.<span class='id identifier rubyid_delete_if'>delete_if</span> { <span class='op'>|</span><span class='id identifier rubyid_k'>k</span><span class='comma'>,</span> <span class='id identifier rubyid_v'>v</span><span class='op'>|</span> <span class='id identifier rubyid_v'>v</span>.<span class='id identifier rubyid_nil?'>nil?</span> }
  <span class='kw'>super</span>(<span class='const'><a href="../Concurrent.html#NULL-constant" title="Concurrent::NULL (constant)">NULL</a></span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>.<span class='id identifier rubyid_merge'>merge</span>(<span class='label'>__promise_body_from_block__:</span> <span class='id identifier rubyid_block'>block</span>)<span class='comma'>,</span> <span class='op'>&amp;</span><span class='kw'>nil</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Class Method Details</h2>
<section class='method_details first' id="all?-class_method">
  <h3 class='signature  first'>
    .<strong>all?</strong>(*promises)  &#x21d2; <code>Boolean</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Aggregates a collection of promises and executes the <a href="#then-instance_method" title="Concurrent::Promise#then (method)">#then</a> condition if all aggregated promises succeed. Executes the <a href="#rescue-instance_method" title="Concurrent::Promise#rescue (method)">#rescue</a> handler with a <a href="../Concurrent.html#PromiseExecutionError-constant" title="Concurrent::PromiseExecutionError (constant)">PromiseExecutionError</a> if any of the aggregated promises fail. Upon execution will execute any of the aggregate promises that were not already executed.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L464-L466'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='464' data-end='466'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 464</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_all?'>all?</span>(<span class='op'>*</span><span class='id identifier rubyid_promises'>promises</span>)
  <span class='id identifier rubyid_aggregate'>aggregate</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_all?'>all?</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_promises'>promises</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="any?-class_method">
  <h3 class='signature '>
    .<strong>any?</strong>(*promises)  &#x21d2; <code>Promise</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Aggregates a collection of promises and executes the <a href="#then-instance_method" title="Concurrent::Promise#then (method)">#then</a> condition if any aggregated promises succeed. Executes the <a href="#rescue-instance_method" title="Concurrent::Promise#rescue (method)">#rescue</a> handler with a <a href="../Concurrent.html#PromiseExecutionError-constant" title="Concurrent::PromiseExecutionError (constant)">PromiseExecutionError</a> if any of the aggregated promises fail. Upon execution will execute any of the aggregate promises that were not already executed.</p>

<p>The returned promise will not yet have been executed. Additional <a href="#then-instance_method" title="Concurrent::Promise#then (method)">#then</a> and <a href="#rescue-instance_method" title="Concurrent::Promise#rescue (method)">#rescue</a> handlers may still be provided. Once the returned promise is execute the aggregate promises will be also be executed (if they have not been executed already). The results of the aggregate promises will be checked upon completion. The necessary <a href="#then-instance_method" title="Concurrent::Promise#then (method)">#then</a> and <a href="#rescue-instance_method" title="Concurrent::Promise#rescue (method)">#rescue</a> blocks on the aggregating promise will then be executed as appropriate. If the <a href="#rescue-instance_method" title="Concurrent::Promise#rescue (method)">#rescue</a> handlers are executed the raises exception will be <a href="../Concurrent.html#PromiseExecutionError-constant" title="Concurrent::PromiseExecutionError (constant)">PromiseExecutionError</a>.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>promises</span>
    <span class='type'>(<a href="Array.html" title="Concurrent::Array (class)">Array</a>)</span>
&mdash;    <div class='inline'>
<p>Zero or more promises to aggregate</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Promise</code>)</span>
&mdash;    <div class='inline'>
<p>an unscheduled (not executed) promise that aggregates the promises given as arguments</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L475-L477'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='475' data-end='477'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 475</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_any?'>any?</span>(<span class='op'>*</span><span class='id identifier rubyid_promises'>promises</span>)
  <span class='id identifier rubyid_aggregate'>aggregate</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_any?'>any?</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_promises'>promises</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="execute-class_method">
  <h3 class='signature '>
    .<strong>execute</strong>(opts = {}, &amp;block)  &#x21d2; <code>Promise</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Create a new <code>Promise</code> object with the given block, execute it, and return the <code>:pending</code> object.</p>

  </div>
</div>
<div class='tags'>
    <div class='examples'>
    <p class='tag_title'>Examples:</p>
      <pre class='example code ruby'><code><span class='id identifier rubyid_promise'>promise</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Promise</span>.<span class='id identifier rubyid_execute'>execute</span>{ <span class='id identifier rubyid_sleep'>sleep</span>(<span class='int'>1</span>)<span class='semicolon'>;</span> <span class='int'>42</span> }
<span class='id identifier rubyid_promise'>promise</span>.<span class='id identifier rubyid_state'>state</span> <span class='comment'>#=&gt; :pending</span></code></pre>
  </div>
<p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>opts</span>
    <span class='type'>(<a href="Hash.html" title="Concurrent::Hash (class)">Hash</a>)</span>
    <em class='default'>(defaults to: <tt>{}</tt>)</em>
&mdash;    <div class='inline'>
<p>the options used to define the behavior at update and deref and to specify the executor on which to perform actions</p>
</div>
  </li>
</ul>
    <p class='tag_title'>Options Hash (<tt>opts</tt>):</p>
    <ul class='option'>
        <li>
          <span class='name'>:executor</span>
          <span class='type'>(<code>Executor</code>)</span>
            &mdash; <div class='inline'>
<p>when set use the given <code>Executor</code> instance. Three special values are also supported: <code>:io</code> returns the global pool for long, blocking (IO) tasks, <code>:fast</code> returns the global pool for short, fast operations, and <code>:immediate</code> returns the global <a href="ImmediateExecutor.html" title="Concurrent::ImmediateExecutor (class)"><code>ImmediateExecutor</code></a> object.</p>
</div>        </li>
        <li>
          <span class='name'>:dup_on_deref</span>
          <span class='type'>(<code>Boolean</code>)</span>
          <span class='default'> &mdash; default:
              <tt>false</tt>          </span>
            &mdash; <div class='inline'>
<p>Call <code>#dup</code> before returning the data from <code>#value</code></p>
</div>        </li>
        <li>
          <span class='name'>:freeze_on_deref</span>
          <span class='type'>(<code>Boolean</code>)</span>
          <span class='default'> &mdash; default:
              <tt>false</tt>          </span>
            &mdash; <div class='inline'>
<p>Call <code>#freeze</code> before returning the data from <code>#value</code></p>
</div>        </li>
        <li>
          <span class='name'>:copy_on_deref</span>
          <span class='type'>(<code>Proc</code>)</span>
          <span class='default'> &mdash; default:
              <tt>nil</tt>          </span>
            &mdash; <div class='inline'>
<p>When calling the <code>#value</code> method, call the given proc passing the internal value as the sole argument then return the new value returned from the proc.</p>
</div>        </li>
        <li>
          <span class='name'>:parent</span>
          <span class='type'>(<code>Promise</code>)</span>
            &mdash; <div class='inline'>
<p>the parent <code>Promise</code> when building a chain/tree</p>
</div>        </li>
        <li>
          <span class='name'>:on_fulfill</span>
          <span class='type'>(<code>Proc</code>)</span>
            &mdash; <div class='inline'>
<p>fulfillment handler</p>
</div>        </li>
        <li>
          <span class='name'>:on_reject</span>
          <span class='type'>(<code>Proc</code>)</span>
            &mdash; <div class='inline'>
<p>rejection handler</p>
</div>        </li>
        <li>
          <span class='name'>:args</span>
          <span class='type'>(<code>object</code>, <a href="Array.html" title="Concurrent::Array (class)">Array</a>)</span>
            &mdash; <div class='inline'>
<p>zero or more arguments to be passed the task block on execution</p>
</div>        </li>
    </ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Promise</code>)</span>
&mdash;    <div class='inline'>
<p>the newly created <code>Promise</code> in the <code>:pending</code> state</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<code>ArgumentError</code>)</span>
&mdash;    <div class='inline'>
<p>if no block is given</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L296-L298'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='296' data-end='298'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 296</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_execute'>execute</span>(<span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> {}<span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>)
  <span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>(<span class='id identifier rubyid_opts'>opts</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>).<span class='id identifier rubyid_execute'>execute</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="fulfill-class_method">
  <h3 class='signature '>
    .<strong>fulfill</strong>(value, opts = {})  &#x21d2; <code>Promise</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Create a new <code>Promise</code> and fulfill it immediately.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>opts</span>
    <span class='type'>(<a href="Hash.html" title="Concurrent::Hash (class)">Hash</a>)</span>
    <em class='default'>(defaults to: <tt>{}</tt>)</em>
&mdash;    <div class='inline'>
<p>the options used to define the behavior at update and deref and to specify the executor on which to perform actions</p>
</div>
  </li>
</ul>
    <p class='tag_title'>Options Hash (<tt>opts</tt>):</p>
    <ul class='option'>
        <li>
          <span class='name'>:executor</span>
          <span class='type'>(<code>Executor</code>)</span>
            &mdash; <div class='inline'>
<p>when set use the given <code>Executor</code> instance. Three special values are also supported: <code>:io</code> returns the global pool for long, blocking (IO) tasks, <code>:fast</code> returns the global pool for short, fast operations, and <code>:immediate</code> returns the global <a href="ImmediateExecutor.html" title="Concurrent::ImmediateExecutor (class)"><code>ImmediateExecutor</code></a> object.</p>
</div>        </li>
        <li>
          <span class='name'>:dup_on_deref</span>
          <span class='type'>(<code>Boolean</code>)</span>
          <span class='default'> &mdash; default:
              <tt>false</tt>          </span>
            &mdash; <div class='inline'>
<p>Call <code>#dup</code> before returning the data from <code>#value</code></p>
</div>        </li>
        <li>
          <span class='name'>:freeze_on_deref</span>
          <span class='type'>(<code>Boolean</code>)</span>
          <span class='default'> &mdash; default:
              <tt>false</tt>          </span>
            &mdash; <div class='inline'>
<p>Call <code>#freeze</code> before returning the data from <code>#value</code></p>
</div>        </li>
        <li>
          <span class='name'>:copy_on_deref</span>
          <span class='type'>(<code>Proc</code>)</span>
          <span class='default'> &mdash; default:
              <tt>nil</tt>          </span>
            &mdash; <div class='inline'>
<p>When calling the <code>#value</code> method, call the given proc passing the internal value as the sole argument then return the new value returned from the proc.</p>
</div>        </li>
        <li>
          <span class='name'>:parent</span>
          <span class='type'>(<code>Promise</code>)</span>
            &mdash; <div class='inline'>
<p>the parent <code>Promise</code> when building a chain/tree</p>
</div>        </li>
        <li>
          <span class='name'>:on_fulfill</span>
          <span class='type'>(<code>Proc</code>)</span>
            &mdash; <div class='inline'>
<p>fulfillment handler</p>
</div>        </li>
        <li>
          <span class='name'>:on_reject</span>
          <span class='type'>(<code>Proc</code>)</span>
            &mdash; <div class='inline'>
<p>rejection handler</p>
</div>        </li>
        <li>
          <span class='name'>:args</span>
          <span class='type'>(<code>object</code>, <a href="Array.html" title="Concurrent::Array (class)">Array</a>)</span>
            &mdash; <div class='inline'>
<p>zero or more arguments to be passed the task block on execution</p>
</div>        </li>
    </ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Promise</code>)</span>
&mdash;    <div class='inline'>
<p>the newly created <code>Promise</code></p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<code>ArgumentError</code>)</span>
&mdash;    <div class='inline'>
<p>if no block is given</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L224-L226'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='224' data-end='226'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 224</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_fulfill'>fulfill</span>(<span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> {})
  <span class='const'>Promise</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>(<span class='id identifier rubyid_opts'>opts</span>).<span class='id identifier rubyid_tap'>tap</span> { <span class='op'>|</span><span class='id identifier rubyid_p'>p</span><span class='op'>|</span> <span class='id identifier rubyid_p'>p</span>.<span class='id identifier rubyid_send'>send</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_synchronized_set_state!'><a href="#synchronized_set_state!-instance_method" title="Concurrent::Promise#synchronized_set_state! (method)">synchronized_set_state!</a></span><span class='comma'>,</span> <span class='kw'>true</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='kw'>nil</span>) }
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="reject-class_method">
  <h3 class='signature '>
    .<strong>reject</strong>(reason, opts = {})  &#x21d2; <code>Promise</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Create a new <code>Promise</code> and reject it immediately.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>opts</span>
    <span class='type'>(<a href="Hash.html" title="Concurrent::Hash (class)">Hash</a>)</span>
    <em class='default'>(defaults to: <tt>{}</tt>)</em>
&mdash;    <div class='inline'>
<p>the options used to define the behavior at update and deref and to specify the executor on which to perform actions</p>
</div>
  </li>
</ul>
    <p class='tag_title'>Options Hash (<tt>opts</tt>):</p>
    <ul class='option'>
        <li>
          <span class='name'>:executor</span>
          <span class='type'>(<code>Executor</code>)</span>
            &mdash; <div class='inline'>
<p>when set use the given <code>Executor</code> instance. Three special values are also supported: <code>:io</code> returns the global pool for long, blocking (IO) tasks, <code>:fast</code> returns the global pool for short, fast operations, and <code>:immediate</code> returns the global <a href="ImmediateExecutor.html" title="Concurrent::ImmediateExecutor (class)"><code>ImmediateExecutor</code></a> object.</p>
</div>        </li>
        <li>
          <span class='name'>:dup_on_deref</span>
          <span class='type'>(<code>Boolean</code>)</span>
          <span class='default'> &mdash; default:
              <tt>false</tt>          </span>
            &mdash; <div class='inline'>
<p>Call <code>#dup</code> before returning the data from <code>#value</code></p>
</div>        </li>
        <li>
          <span class='name'>:freeze_on_deref</span>
          <span class='type'>(<code>Boolean</code>)</span>
          <span class='default'> &mdash; default:
              <tt>false</tt>          </span>
            &mdash; <div class='inline'>
<p>Call <code>#freeze</code> before returning the data from <code>#value</code></p>
</div>        </li>
        <li>
          <span class='name'>:copy_on_deref</span>
          <span class='type'>(<code>Proc</code>)</span>
          <span class='default'> &mdash; default:
              <tt>nil</tt>          </span>
            &mdash; <div class='inline'>
<p>When calling the <code>#value</code> method, call the given proc passing the internal value as the sole argument then return the new value returned from the proc.</p>
</div>        </li>
        <li>
          <span class='name'>:parent</span>
          <span class='type'>(<code>Promise</code>)</span>
            &mdash; <div class='inline'>
<p>the parent <code>Promise</code> when building a chain/tree</p>
</div>        </li>
        <li>
          <span class='name'>:on_fulfill</span>
          <span class='type'>(<code>Proc</code>)</span>
            &mdash; <div class='inline'>
<p>fulfillment handler</p>
</div>        </li>
        <li>
          <span class='name'>:on_reject</span>
          <span class='type'>(<code>Proc</code>)</span>
            &mdash; <div class='inline'>
<p>rejection handler</p>
</div>        </li>
        <li>
          <span class='name'>:args</span>
          <span class='type'>(<code>object</code>, <a href="Array.html" title="Concurrent::Array (class)">Array</a>)</span>
            &mdash; <div class='inline'>
<p>zero or more arguments to be passed the task block on execution</p>
</div>        </li>
    </ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Promise</code>)</span>
&mdash;    <div class='inline'>
<p>the newly created <code>Promise</code></p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<code>ArgumentError</code>)</span>
&mdash;    <div class='inline'>
<p>if no block is given</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L237-L239'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='237' data-end='239'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 237</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_reject'>reject</span>(<span class='id identifier rubyid_reason'>reason</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> {})
  <span class='const'>Promise</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>(<span class='id identifier rubyid_opts'>opts</span>).<span class='id identifier rubyid_tap'>tap</span> { <span class='op'>|</span><span class='id identifier rubyid_p'>p</span><span class='op'>|</span> <span class='id identifier rubyid_p'>p</span>.<span class='id identifier rubyid_send'>send</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_synchronized_set_state!'><a href="#synchronized_set_state!-instance_method" title="Concurrent::Promise#synchronized_set_state! (method)">synchronized_set_state!</a></span><span class='comma'>,</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span>) }
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="zip-class_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>.<strong>zip</strong>(*promises)  &#x21d2; <code>Promise</code>&lt;<a href="Array.html" title="Concurrent::Array (class)">Array</a>&gt; </span>
      <span class='overload'>.<strong>zip</strong>(*promises, opts)  &#x21d2; <code>Promise</code>&lt;<a href="Array.html" title="Concurrent::Array (class)">Array</a>&gt; </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Builds a promise that produces the result of promises in an <a href="Array.html" title="Concurrent::Array (class)"><code>Array</code></a> and fails if any of them fails.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L409-L425'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='409' data-end='425'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 409</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_zip'>zip</span>(<span class='op'>*</span><span class='id identifier rubyid_promises'>promises</span>)
  <span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> <span class='id identifier rubyid_promises'>promises</span>.<span class='id identifier rubyid_last'>last</span>.<span class='id identifier rubyid_is_a?'>is_a?</span>(<span class='op'>::</span><span class='const'><a href="Hash.html" title="Concurrent::Hash (class)">Hash</a></span>) <span class='op'>?</span> <span class='id identifier rubyid_promises'>promises</span>.<span class='id identifier rubyid_pop'>pop</span>.<span class='id identifier rubyid_dup'>dup</span> <span class='op'>:</span> {}
  <span class='id identifier rubyid_opts'>opts</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_executor'><a href="../Concurrent.html#executor-class_method" title="Concurrent.executor (method)">executor</a></span>] <span class='op'>||=</span> <span class='const'><a href="ImmediateExecutor.html" title="Concurrent::ImmediateExecutor (class)">ImmediateExecutor</a></span>.<span class='id identifier rubyid_new'><a href="ImmediateExecutor.html#new-class_method" title="Concurrent::ImmediateExecutor.new (method)">new</a></span>
  <span class='id identifier rubyid_zero'>zero</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='op'>!</span><span class='id identifier rubyid_opts'>opts</span>.<span class='id identifier rubyid_key?'>key?</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span>) <span class='op'>||</span> <span class='id identifier rubyid_opts'>opts</span>.<span class='id identifier rubyid_delete'>delete</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span>)
    <span class='id identifier rubyid_fulfill'><a href="#fulfill-class_method" title="Concurrent::Promise.fulfill (method)">fulfill</a></span>([]<span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>)
  <span class='kw'>else</span>
    <span class='const'>Promise</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>(<span class='id identifier rubyid_opts'>opts</span>) { [] }
  <span class='kw'>end</span>

  <span class='id identifier rubyid_promises'>promises</span>.<span class='id identifier rubyid_reduce'>reduce</span>(<span class='id identifier rubyid_zero'>zero</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_p1'>p1</span><span class='comma'>,</span> <span class='id identifier rubyid_p2'>p2</span><span class='op'>|</span>
    <span class='id identifier rubyid_p1'>p1</span>.<span class='id identifier rubyid_flat_map'><a href="#flat_map-instance_method" title="Concurrent::Promise#flat_map (method)">flat_map</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_results'>results</span><span class='op'>|</span>
      <span class='id identifier rubyid_p2'>p2</span>.<span class='id identifier rubyid_then'><a href="#then-instance_method" title="Concurrent::Promise#then (method)">then</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_next_result'>next_result</span><span class='op'>|</span>
        <span class='id identifier rubyid_results'>results</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_next_result'>next_result</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Attribute Details</h2>
<section class='method_details first' id="root?-instance_method">
  <h3 class='signature ro priv  nodoc first'>
    #<strong>root?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>, <span class='priv'>private</span>)</span>
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L528-L530'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='528' data-end='530'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 528</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_root?'>root?</span> <span class='comment'># :nodoc:
</span>  <span class='ivar'>@parent</span>.<span class='id identifier rubyid_nil?'>nil?</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="catch-instance_method">
  <h3 class='signature  first'>
    #<strong>catch</strong>(&amp;block)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#rescue-instance_method" title="Concurrent::Promise#rescue (method)">#rescue</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L364-L364'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='364' data-end='364'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 364</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_catch'>catch</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='kw'>rescue</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="complete-instance_method">
  <h3 class='signature priv'>
    #<strong>complete</strong>(success, value, reason)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L551-L559'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='551' data-end='559'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 551</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_complete'>complete</span>(<span class='id identifier rubyid_success'>success</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span>)
  <span class='id identifier rubyid_children_to_notify'>children_to_notify</span> <span class='op'>=</span> <span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_set_state!'><a href="#set_state!-instance_method" title="Concurrent::Promise#set_state! (method)">set_state!</a></span>(<span class='id identifier rubyid_success'>success</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span>)
    <span class='ivar'>@children</span>.<span class='id identifier rubyid_dup'>dup</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_children_to_notify'>children_to_notify</span>.<span class='id identifier rubyid_each'>each</span> { <span class='op'>|</span><span class='id identifier rubyid_child'>child</span><span class='op'>|</span> <span class='id identifier rubyid_notify_child'><a href="#notify_child-instance_method" title="Concurrent::Promise#notify_child (method)">notify_child</a></span>(<span class='id identifier rubyid_child'>child</span>) }
  <span class='id identifier rubyid_observers'>observers</span>.<span class='id identifier rubyid_notify_and_delete_observers'>notify_and_delete_observers</span>{ [<span class='const'>Time</span>.<span class='id identifier rubyid_now'>now</span><span class='comma'>,</span> <span class='kw'>self</span>.<span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span>] }
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="execute-instance_method">
  <h3 class='signature '>
    #<strong>execute</strong>  &#x21d2; <code>Promise</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Execute an <code>:unscheduled</code> <code>Promise</code>. Immediately sets the state to <code>:pending</code> and passes the block to a new thread/thread pool for eventual execution. Does nothing if the <code>Promise</code> is in any state other than <code>:unscheduled</code>.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Promise</code>)</span>
&mdash;    <div class='inline'>
<p>a reference to <code>self</code></p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L246-L257'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='246' data-end='257'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 246</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_execute'>execute</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_root?'><a href="#root%3F-instance_method" title="Concurrent::Promise#root? (method)">root?</a></span>
    <span class='kw'>if</span> <span class='id identifier rubyid_compare_and_set_state'>compare_and_set_state</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_pending'>pending</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_unscheduled'>unscheduled</span>)
      <span class='id identifier rubyid_set_pending'><a href="#set_pending-instance_method" title="Concurrent::Promise#set_pending (method)">set_pending</a></span>
      <span class='id identifier rubyid_realize'><a href="#realize-instance_method" title="Concurrent::Promise#realize (method)">realize</a></span>(<span class='ivar'>@promise_body</span>)
    <span class='kw'>end</span>
  <span class='kw'>else</span>
    <span class='id identifier rubyid_compare_and_set_state'>compare_and_set_state</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_pending'>pending</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_unscheduled'>unscheduled</span>)
    <span class='ivar'>@parent</span>.<span class='id identifier rubyid_execute'>execute</span>
  <span class='kw'>end</span>
  <span class='kw'>self</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="fail-instance_method">
  <h3 class='signature '>
    #<strong>fail</strong>(reason = StandardError.new)  &#x21d2; <a href="IVar.html" title="Concurrent::IVar (class)">IVar</a> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p><a href="Set.html" title="Concurrent::Set (class)"><code>Set</code></a> the <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> to failed due to some error and wake or notify all threads waiting on it.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>reason</span>
    <span class='type'>(<a href="../Object.html" title="Object (class)">Object</a>)</span>
    <em class='default'>(defaults to: <tt>StandardError.new</tt>)</em>
&mdash;    <div class='inline'>
<p>for the failure</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="IVar.html" title="Concurrent::IVar (class)">IVar</a>)</span>
&mdash;    <div class='inline'>
<p>self</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<a href="MultipleAssignmentError.html" title="Concurrent::MultipleAssignmentError (class)">Concurrent::MultipleAssignmentError</a>)</span>
&mdash;    <div class='inline'>
<p>if the <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> has already been set or otherwise completed</p>
</div>
  </li>
  <li>
    <span class='type'>(<a href="../Concurrent.html#PromiseExecutionError-constant" title="Concurrent::PromiseExecutionError (constant)">Concurrent::PromiseExecutionError</a>)</span>
&mdash;    <div class='inline'>
<p>if not the root promise</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L278-L280'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='278' data-end='280'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 278</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_fail'>fail</span>(<span class='id identifier rubyid_reason'>reason</span> <span class='op'>=</span> <span class='const'>StandardError</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>)
  <span class='id identifier rubyid_set'><a href="#set-instance_method" title="Concurrent::Promise#set (method)">set</a></span> { <span class='id identifier rubyid_raise'>raise</span> <span class='id identifier rubyid_reason'>reason</span> }
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="flat_map-instance_method">
  <h3 class='signature '>
    #<strong>flat_map</strong>(&amp;block)  &#x21d2; <code>Promise</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Yield the successful result to the block that returns a promise. If that promise is also successful the result is the result of the yielded promise. If either part fails the whole also fails.</p>

  </div>
</div>
<div class='tags'>
    <div class='examples'>
    <p class='tag_title'>Examples:</p>
      <pre class='example code ruby'><code><span class='const'>Promise</span>.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span> { <span class='int'>1</span> }.<span class='id identifier rubyid_flat_map'>flat_map</span> { <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span> <span class='const'>Promise</span>.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span> { <span class='id identifier rubyid_v'>v</span> <span class='op'>+</span> <span class='int'>2</span> } }.<span class='id identifier rubyid_value!'>value!</span> <span class='comment'>#=&gt; 3</span></code></pre>
  </div>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L375-L394'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='375' data-end='394'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 375</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_flat_map'>flat_map</span>(<span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>)
  <span class='id identifier rubyid_child'>child</span> <span class='op'>=</span> <span class='const'>Promise</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>(
    <span class='label'>parent:</span> <span class='kw'>self</span><span class='comma'>,</span>
    <span class='label'>executor:</span> <span class='const'><a href="ImmediateExecutor.html" title="Concurrent::ImmediateExecutor (class)">ImmediateExecutor</a></span>.<span class='id identifier rubyid_new'><a href="ImmediateExecutor.html#new-class_method" title="Concurrent::ImmediateExecutor.new (method)">new</a></span><span class='comma'>,</span>
  )

  <span class='id identifier rubyid_on_error'><a href="#on_error-instance_method" title="Concurrent::Promise#on_error (method)">on_error</a></span> { <span class='op'>|</span><span class='id identifier rubyid_e'>e</span><span class='op'>|</span> <span class='id identifier rubyid_child'>child</span>.<span class='id identifier rubyid_on_reject'><a href="#on_reject-instance_method" title="Concurrent::Promise#on_reject (method)">on_reject</a></span>(<span class='id identifier rubyid_e'>e</span>) }
  <span class='id identifier rubyid_on_success'><a href="#on_success-instance_method" title="Concurrent::Promise#on_success (method)">on_success</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_result1'>result1</span><span class='op'>|</span>
    <span class='kw'>begin</span>
      <span class='id identifier rubyid_inner'>inner</span> <span class='op'>=</span> <span class='id identifier rubyid_block'>block</span>.<span class='id identifier rubyid_call'>call</span>(<span class='id identifier rubyid_result1'>result1</span>)
      <span class='id identifier rubyid_inner'>inner</span>.<span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span>
      <span class='id identifier rubyid_inner'>inner</span>.<span class='id identifier rubyid_on_success'><a href="#on_success-instance_method" title="Concurrent::Promise#on_success (method)">on_success</a></span> { <span class='op'>|</span><span class='id identifier rubyid_result2'>result2</span><span class='op'>|</span> <span class='id identifier rubyid_child'>child</span>.<span class='id identifier rubyid_on_fulfill'><a href="#on_fulfill-instance_method" title="Concurrent::Promise#on_fulfill (method)">on_fulfill</a></span>(<span class='id identifier rubyid_result2'>result2</span>) }
      <span class='id identifier rubyid_inner'>inner</span>.<span class='id identifier rubyid_on_error'><a href="#on_error-instance_method" title="Concurrent::Promise#on_error (method)">on_error</a></span> { <span class='op'>|</span><span class='id identifier rubyid_e'>e</span><span class='op'>|</span> <span class='id identifier rubyid_child'>child</span>.<span class='id identifier rubyid_on_reject'><a href="#on_reject-instance_method" title="Concurrent::Promise#on_reject (method)">on_reject</a></span>(<span class='id identifier rubyid_e'>e</span>) }
    <span class='kw'>rescue</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_e'>e</span>
      <span class='id identifier rubyid_child'>child</span>.<span class='id identifier rubyid_on_reject'><a href="#on_reject-instance_method" title="Concurrent::Promise#on_reject (method)">on_reject</a></span>(<span class='id identifier rubyid_e'>e</span>)
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_child'>child</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="notify_child-instance_method">
  <h3 class='signature priv'>
    #<strong>notify_child</strong>(child)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L545-L548'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='545' data-end='548'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 545</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_notify_child'>notify_child</span>(<span class='id identifier rubyid_child'>child</span>)
  <span class='id identifier rubyid_if_state'>if_state</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_fulfilled'>fulfilled</span>) { <span class='id identifier rubyid_child'>child</span>.<span class='id identifier rubyid_on_fulfill'><a href="#on_fulfill-instance_method" title="Concurrent::Promise#on_fulfill (method)">on_fulfill</a></span>(<span class='id identifier rubyid_apply_deref_options'>apply_deref_options</span>(<span class='ivar'>@value</span>)) }
  <span class='id identifier rubyid_if_state'>if_state</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_rejected'>rejected</span>) { <span class='id identifier rubyid_child'>child</span>.<span class='id identifier rubyid_on_reject'><a href="#on_reject-instance_method" title="Concurrent::Promise#on_reject (method)">on_reject</a></span>(<span class='ivar'>@reason</span>) }
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="on_error-instance_method">
  <h3 class='signature '>
    #<strong>on_error</strong>(&amp;block)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#rescue-instance_method" title="Concurrent::Promise#rescue (method)">#rescue</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L365-L365'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='365' data-end='365'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 365</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_error'>on_error</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='kw'>rescue</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="on_fulfill-instance_method">
  <h3 class='signature priv'>
    #<strong>on_fulfill</strong>(result)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L533-L536'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='533' data-end='536'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 533</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_on_fulfill'>on_fulfill</span>(<span class='id identifier rubyid_result'>result</span>)
  <span class='id identifier rubyid_realize'><a href="#realize-instance_method" title="Concurrent::Promise#realize (method)">realize</a></span> <span class='const'>Proc</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span> { <span class='ivar'>@on_fulfill</span>.<span class='id identifier rubyid_call'>call</span>(<span class='id identifier rubyid_result'>result</span>) }
  <span class='kw'>nil</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="on_reject-instance_method">
  <h3 class='signature priv'>
    #<strong>on_reject</strong>(reason)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L539-L542'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='539' data-end='542'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 539</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_on_reject'>on_reject</span>(<span class='id identifier rubyid_reason'>reason</span>)
  <span class='id identifier rubyid_realize'><a href="#realize-instance_method" title="Concurrent::Promise#realize (method)">realize</a></span> <span class='const'>Proc</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span> { <span class='ivar'>@on_reject</span>.<span class='id identifier rubyid_call'>call</span>(<span class='id identifier rubyid_reason'>reason</span>) }
  <span class='kw'>nil</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="on_success-instance_method">
  <h3 class='signature '>
    #<strong>on_success</strong> { ... } &#x21d2; <code>Promise</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Chain onto this promise an action to be undertaken on success (fulfillment).</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Yields:</p>
<ul class='yield'>
  <li>
    <span class='type'></span>
    <div class='inline'>
<p>The block to execute</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Promise</code>)</span>
&mdash;    <div class='inline'>
<p>self</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<code>ArgumentError</code>)</span>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L349-L352'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='349' data-end='352'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 349</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_on_success'>on_success</span>(<span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>)
  <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>no block given</span><span class='tstring_end'>&#39;</span></span>) <span class='kw'>unless</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='kw'>self</span>.<span class='id identifier rubyid_then'><a href="#then-instance_method" title="Concurrent::Promise#then (method)">then</a></span>(<span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="realize-instance_method">
  <h3 class='signature priv'>
    #<strong>realize</strong>(task)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L562-L567'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='562' data-end='567'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 562</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_realize'>realize</span>(<span class='id identifier rubyid_task'>task</span>)
  <span class='ivar'>@executor</span>.<span class='id identifier rubyid_post'>post</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_success'>success</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span> <span class='op'>=</span> <span class='const'><a href="SafeTaskExecutor.html" title="Concurrent::SafeTaskExecutor (class)">SafeTaskExecutor</a></span>.<span class='id identifier rubyid_new'><a href="SafeTaskExecutor.html#new-class_method" title="Concurrent::SafeTaskExecutor.new (method)">new</a></span>(<span class='id identifier rubyid_task'>task</span><span class='comma'>,</span> <span class='label'>rescue_exception:</span> <span class='kw'>true</span>).<span class='id identifier rubyid_execute'><a href="SafeTaskExecutor.html#execute-instance_method" title="Concurrent::SafeTaskExecutor#execute (method)">execute</a></span>(<span class='op'>*</span><span class='ivar'>@args</span>)
    <span class='id identifier rubyid_complete'><a href="#complete-instance_method" title="Concurrent::Promise#complete (method)">complete</a></span>(<span class='id identifier rubyid_success'>success</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span>)
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="rescue-instance_method">
  <h3 class='signature '>
    #<strong>rescue</strong> { ... } &#x21d2; <code>Promise</code> 
    <span class='aliases'>Also known as: <span class='names'>#catch, #on_error</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Chain onto this promise an action to be undertaken on failure (rejection).</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Yields:</p>
<ul class='yield'>
  <li>
    <span class='type'></span>
    <div class='inline'>
<p>The block to execute</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Promise</code>)</span>
&mdash;    <div class='inline'>
<p>self</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L360-L362'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='360' data-end='362'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 360</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>rescue</span>(<span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>)
  <span class='kw'>self</span>.<span class='id identifier rubyid_then'><a href="#then-instance_method" title="Concurrent::Promise#then (method)">then</a></span>(<span class='id identifier rubyid_block'>block</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="set-instance_method">
  <h3 class='signature '>
    #<strong>set</strong>(value = NULL) { ... } &#x21d2; <a href="IVar.html" title="Concurrent::IVar (class)">IVar</a> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p><a href="Set.html" title="Concurrent::Set (class)"><code>Set</code></a> the <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> to a value and wake or notify all threads waiting on it.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>value</span>
    <span class='type'>(<a href="../Object.html" title="Object (class)">Object</a>)</span>
    <em class='default'>(defaults to: <tt>NULL</tt>)</em>
&mdash;    <div class='inline'>
<p>the value to store in the <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a></p>
</div>
  </li>
</ul>
<p class='tag_title'>Yields:</p>
<ul class='yield'>
  <li>
    <span class='type'></span>
    <div class='inline'>
<p>A block operation to use for setting the value</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="IVar.html" title="Concurrent::IVar (class)">IVar</a>)</span>
&mdash;    <div class='inline'>
<p>self</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<code>ArgumentError</code>)</span>
&mdash;    <div class='inline'>
<p>if both a value and a block are given</p>
</div>
  </li>
  <li>
    <span class='type'>(<a href="MultipleAssignmentError.html" title="Concurrent::MultipleAssignmentError (class)">Concurrent::MultipleAssignmentError</a>)</span>
&mdash;    <div class='inline'>
<p>if the <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> has already been set or otherwise completed</p>
</div>
  </li>
  <li>
    <span class='type'>(<a href="../Concurrent.html#PromiseExecutionError-constant" title="Concurrent::PromiseExecutionError (constant)">Concurrent::PromiseExecutionError</a>)</span>
&mdash;    <div class='inline'>
<p>if not the root promise</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L262-L273'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='262' data-end='273'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 262</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_set'>set</span>(<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html#NULL-constant" title="Concurrent::NULL (constant)">NULL</a></span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>)
  <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../Concurrent.html#PromiseExecutionError-constant" title="Concurrent::PromiseExecutionError (constant)">PromiseExecutionError</a></span>.<span class='id identifier rubyid_new'><a href="../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>supported only on root promise</span><span class='tstring_end'>&#39;</span></span>) <span class='kw'>unless</span> <span class='id identifier rubyid_root?'><a href="#root%3F-instance_method" title="Concurrent::Promise#root? (method)">root?</a></span>
  <span class='id identifier rubyid_check_for_block_or_value!'>check_for_block_or_value!</span>(<span class='id identifier rubyid_block_given?'>block_given?</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span>)
  <span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='kw'>if</span> <span class='ivar'>@state</span> <span class='op'>!=</span> <span class='symbeg'>:</span><span class='id identifier rubyid_unscheduled'>unscheduled</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="MultipleAssignmentError.html" title="Concurrent::MultipleAssignmentError (class)">MultipleAssignmentError</a></span>
    <span class='kw'>else</span>
      <span class='ivar'>@promise_body</span> <span class='op'>=</span> <span class='id identifier rubyid_block'>block</span> <span class='op'>||</span> <span class='const'>Proc</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span> { <span class='op'>|</span><span class='id identifier rubyid_result'>result</span><span class='op'>|</span> <span class='id identifier rubyid_value'>value</span> }
    <span class='kw'>end</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_execute'><a href="#execute-class_method" title="Concurrent::Promise.execute (method)">execute</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="set_pending-instance_method">
  <h3 class='signature priv'>
    #<strong>set_pending</strong>   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L520-L525'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='520' data-end='525'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 520</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_set_pending'>set_pending</span>
  <span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='ivar'>@state</span> <span class='op'>=</span> <span class='symbeg'>:</span><span class='id identifier rubyid_pending'>pending</span>
    <span class='ivar'>@children</span>.<span class='id identifier rubyid_each'>each</span> { <span class='op'>|</span><span class='id identifier rubyid_c'>c</span><span class='op'>|</span> <span class='id identifier rubyid_c'>c</span>.<span class='id identifier rubyid_set_pending'>set_pending</span> }
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="set_state!-instance_method">
  <h3 class='signature priv'>
    #<strong>set_state!</strong>(success, value, reason)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L570-L573'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='570' data-end='573'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 570</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_set_state!'>set_state!</span>(<span class='id identifier rubyid_success'>success</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span>)
  <span class='id identifier rubyid_set_state'>set_state</span>(<span class='id identifier rubyid_success'>success</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span>)
  <span class='id identifier rubyid_event'>event</span>.<span class='id identifier rubyid_set'><a href="#set-instance_method" title="Concurrent::Promise#set (method)">set</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="synchronized_set_state!-instance_method">
  <h3 class='signature priv'>
    #<strong>synchronized_set_state!</strong>(success, value, reason)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L576-L578'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='576' data-end='578'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 576</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_synchronized_set_state!'>synchronized_set_state!</span>(<span class='id identifier rubyid_success'>success</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span>)
  <span class='id identifier rubyid_synchronize'>synchronize</span> { <span class='id identifier rubyid_set_state!'><a href="#set_state!-instance_method" title="Concurrent::Promise#set_state! (method)">set_state!</a></span>(<span class='id identifier rubyid_success'>success</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_reason'>reason</span>) }
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="then-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>then</strong>(rescuer, executor, &amp;block)  &#x21d2; <code>Promise</code> </span>
      <span class='overload'>#<strong>then</strong>(rescuer, executor: executor, &amp;block)  &#x21d2; <code>Promise</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Chain a new promise off the current promise.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Yields:</p>
<ul class='yield'>
  <li>
    <span class='type'></span>
    <div class='inline'>
<p>The block operation to be performed asynchronously.</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Promise</code>)</span>
&mdash;    <div class='inline'>
<p>the new promise</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<code>ArgumentError</code>)</span>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L314-L341'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='314' data-end='341'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 314</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>then</span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span>)
  <span class='kw'>if</span> <span class='id identifier rubyid_args'>args</span>.<span class='id identifier rubyid_last'>last</span>.<span class='id identifier rubyid_is_a?'>is_a?</span>(<span class='op'>::</span><span class='const'><a href="Hash.html" title="Concurrent::Hash (class)">Hash</a></span>)
    <span class='id identifier rubyid_executor'><a href="../Concurrent.html#executor-class_method" title="Concurrent.executor (method)">executor</a></span> <span class='op'>=</span> <span class='id identifier rubyid_args'>args</span>.<span class='id identifier rubyid_pop'>pop</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_executor'><a href="../Concurrent.html#executor-class_method" title="Concurrent.executor (method)">executor</a></span>]
    <span class='id identifier rubyid_rescuer'>rescuer</span> <span class='op'>=</span> <span class='id identifier rubyid_args'>args</span>.<span class='id identifier rubyid_first'>first</span>
  <span class='kw'>else</span>
    <span class='id identifier rubyid_rescuer'>rescuer</span><span class='comma'>,</span> <span class='id identifier rubyid_executor'><a href="../Concurrent.html#executor-class_method" title="Concurrent.executor (method)">executor</a></span> <span class='op'>=</span> <span class='id identifier rubyid_args'>args</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_executor'><a href="../Concurrent.html#executor-class_method" title="Concurrent.executor (method)">executor</a></span> <span class='op'>||=</span> <span class='ivar'>@executor</span>

  <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rescuers and block are both missing</span><span class='tstring_end'>&#39;</span></span>) <span class='kw'>if</span> <span class='id identifier rubyid_rescuer'>rescuer</span>.<span class='id identifier rubyid_nil?'>nil?</span> <span class='op'>&amp;&amp;</span> <span class='op'>!</span><span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='id identifier rubyid_block'>block</span> <span class='op'>=</span> <span class='const'>Proc</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span> { <span class='op'>|</span><span class='id identifier rubyid_result'>result</span><span class='op'>|</span> <span class='id identifier rubyid_result'>result</span> } <span class='kw'>unless</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='id identifier rubyid_child'>child</span> <span class='op'>=</span> <span class='const'>Promise</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promise.new (method)">new</a></span>(
    <span class='label'>parent:</span> <span class='kw'>self</span><span class='comma'>,</span>
    <span class='label'>executor:</span> <span class='id identifier rubyid_executor'><a href="../Concurrent.html#executor-class_method" title="Concurrent.executor (method)">executor</a></span><span class='comma'>,</span>
    <span class='label'>on_fulfill:</span> <span class='id identifier rubyid_block'>block</span><span class='comma'>,</span>
    <span class='label'>on_reject:</span> <span class='id identifier rubyid_rescuer'>rescuer</span>
  )

  <span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_child'>child</span>.<span class='id identifier rubyid_state'>state</span> <span class='op'>=</span> <span class='symbeg'>:</span><span class='id identifier rubyid_pending'>pending</span> <span class='kw'>if</span> <span class='ivar'>@state</span> <span class='op'>==</span> <span class='symbeg'>:</span><span class='id identifier rubyid_pending'>pending</span>
    <span class='id identifier rubyid_child'>child</span>.<span class='id identifier rubyid_on_fulfill'><a href="#on_fulfill-instance_method" title="Concurrent::Promise#on_fulfill (method)">on_fulfill</a></span>(<span class='id identifier rubyid_apply_deref_options'>apply_deref_options</span>(<span class='ivar'>@value</span>)) <span class='kw'>if</span> <span class='ivar'>@state</span> <span class='op'>==</span> <span class='symbeg'>:</span><span class='id identifier rubyid_fulfilled'>fulfilled</span>
    <span class='id identifier rubyid_child'>child</span>.<span class='id identifier rubyid_on_reject'><a href="#on_reject-instance_method" title="Concurrent::Promise#on_reject (method)">on_reject</a></span>(<span class='ivar'>@reason</span>) <span class='kw'>if</span> <span class='ivar'>@state</span> <span class='op'>==</span> <span class='symbeg'>:</span><span class='id identifier rubyid_rejected'>rejected</span>
    <span class='ivar'>@children</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_child'>child</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_child'>child</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="zip-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>zip</strong>(*promises)  &#x21d2; <code>Promise</code>&lt;<a href="Array.html" title="Concurrent::Array (class)">Array</a>&gt; </span>
      <span class='overload'>#<strong>zip</strong>(*promises, opts)  &#x21d2; <code>Promise</code>&lt;<a href="Array.html" title="Concurrent::Array (class)">Array</a>&gt; </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Builds a promise that produces the result of self and others in an <a href="Array.html" title="Concurrent::Array (class)"><code>Array</code></a> and fails if any of them fails.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/promise.rb#L440-L442'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='440' data-end='442'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/promise.rb', line 440</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_zip'>zip</span>(<span class='op'>*</span><span class='id identifier rubyid_others'>others</span>)
  <span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span>.<span class='id identifier rubyid_zip'>zip</span>(<span class='kw'>self</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_others'>others</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>