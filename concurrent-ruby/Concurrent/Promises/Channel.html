<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen' content='yes'>
<meta name='mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: Concurrent::Promises::Channel &mdash; Concurrent RubyÂ master</title>

<link rel='stylesheet'  type='text/css' href='../../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Concurrent::Promises::Channel",
    relpath = '../../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../../'>Concurrent</a> &raquo; 
      <a href='../../_index.html#alpha_C'>Index (C)</a> &raquo; 
        <a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a> &raquo; 
        <a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>Channel&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: Concurrent::Promises::Channel</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Super Chains via Extension / Inclusion / Inheritance</td></tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Class Chain:</div>
        <div class='box_22'>
          self,
          <a href="../Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a>,
          <a href="../Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)"><code>Synchronization::AbstractObject</code></a>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Instance Chain:</div>
        <div class='box_22'>
          self,
          <a href="../Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a>,
          <a href="../Synchronization/Volatile.html" title="Concurrent::Synchronization::Volatile (module)"><code>Synchronization::Volatile</code></a>,
          <a href="../Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)"><code>Synchronization::AbstractObject</code></a>
        </div>
      </td>
    </tr>
    <tr>
      <td id='t2_inherits' class='box_2 o'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'><a href="../Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)">Concurrent::Synchronization::Object</a></span>
        <ul class='fullTree'>
          <li><a href="../../Object.html" title="Object (class)"><code>::Object</code></a></li>
          <li class='next'><a href="../Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)">Concurrent::Synchronization::AbstractObject</a></li>
          <li class='next'><a href="../Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)">Concurrent::Synchronization::Object</a></li>
          <li class='next'>Concurrent::Promises::Channel</li>
        </ul>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L17'>lib/concurrent-ruby-edge/concurrent/edge/channel.rb</a>      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'>
<p>**Edge Features** are under active development and may change frequently.</p>
<ul><li>
<p>Deprecations are not added before incompatible changes.</p>
</li><li>
<p><a href="../Edge.html" title="Concurrent::Edge (module)"><code>Edge</code></a> version: <em>major</em> is always 0, <em>minor</em> bump means incompatible change, <em>patch</em> bump means compatible change.</p>
</li><li>
<p><a href="../Edge.html" title="Concurrent::Edge (module)"><code>Edge</code></a> features may also lack tests and documentation.</p>
</li><li>
<p>Features developed in <code>concurrent-ruby-edge</code> are expected to move to <code>concurrent-ruby</code> when finalised.</p>
</li></ul>
</div>
  </div>


<p>A first in first out channel that accepts messages with push family of methods and returns messages with pop family of methods. Pop and push operations can be represented as futures, see <a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">#pop_op</a> and <a href="#push_op-instance_method" title="Concurrent::Promises::Channel#push_op (method)">#push_op</a>. The capacity of the channel can be limited to support back pressure, use capacity option in <a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">Concurrent#initialize</a>. <a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">#pop</a> method blocks ans <a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">#pop_op</a> returns pending future if there is no message in the channel. If the capacity is limited the <a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">#push</a> method blocks and <a href="#push_op-instance_method" title="Concurrent::Promises::Channel#push_op (method)">#push_op</a> returns pending future.</p>

<p><h4>Examples</h4>

<p>Let&#39;s start by creating a channel with a capacity of 2 messages.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span> <span class='op'>=</span> <span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'>Channel</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> <span class='int'>2</span>
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Channel:0x000002 capacity taken 0 of 2&gt;</span></code></pre>

<p>We push 3 messages, 
then it can be observed that the last thread pushing is sleeping 
since the channel is full. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_threads'>threads</span> <span class='op'>=</span> <span class='const'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span>.<span class='id identifier rubyid_new'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span>(<span class='int'>3</span>) { <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='const'>Thread</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> { <span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='label'>message:</span> <span class='id identifier rubyid_i'>i</span> } } 
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> <span class='comment'># let the threads run
</span><span class='id identifier rubyid_threads'>threads</span>
<span class='comment'>### =&gt; [#&lt;Thread:0x000003@channel.in.md:14 dead&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000004@channel.in.md:14 dead&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000005@channel.in.md:14 sleep_forever&gt;]</span></code></pre>

<p>When message is popped the last thread continues and finishes as well.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_pop'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">pop</a></span>                                   <span class='comment'># =&gt; {:message=&gt;1}
</span><span class='id identifier rubyid_threads'>threads</span>.<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_join'>join</span>)
<span class='comment'>### =&gt; [#&lt;Thread:0x000003@channel.in.md:14 dead&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000004@channel.in.md:14 dead&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000005@channel.in.md:14 dead&gt;]</span></code></pre>

<p>Same principle applies to popping as well.
There are now 2 messages int he channel.
Lets create 3 threads trying to pop a message, 
one will be blocked until new messages is pushed.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_threads'>threads</span> <span class='op'>=</span> <span class='const'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span>.<span class='id identifier rubyid_new'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span>(<span class='int'>3</span>) { <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='const'>Thread</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> { <span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_pop'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">pop</a></span> } } 
<span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> <span class='comment'># let the threads run
</span><span class='id identifier rubyid_threads'>threads</span> 
<span class='comment'>### =&gt; [#&lt;Thread:0x000006@channel.in.md:32 dead&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000007@channel.in.md:32 dead&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000008@channel.in.md:32 sleep_forever&gt;]
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='label'>message:</span> <span class='int'>3</span>
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Channel:0x000002 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_threads'>threads</span>.<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span>)
<span class='comment'>### =&gt; [{:message=&gt;0}, {:message=&gt;2}, {:message=&gt;3}]</span></code></pre>

<h5>Promises integration</h5>

<p>However this channel is implemented to <strong>integrate with promises</strong>
therefore all operations can be represented as futures.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span> <span class='op'>=</span> <span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'>Channel</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> <span class='int'>2</span>
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Channel:0x000009 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_push_operations'>push_operations</span> <span class='op'>=</span> <span class='const'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span>.<span class='id identifier rubyid_new'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span>(<span class='int'>3</span>) { <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_push_op'><a href="#push_op-instance_method" title="Concurrent::Promises::Channel#push_op (method)">push_op</a></span> <span class='label'>message:</span> <span class='id identifier rubyid_i'>i</span> }
<span class='comment'>### =&gt; [#&lt;Concurrent::Promises::Future:0x00000a fulfilled with #&lt;Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2&gt;&gt;,
</span><span class='comment'>###     #&lt;Concurrent::Promises::Future:0x00000b fulfilled with #&lt;Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2&gt;&gt;,
</span><span class='comment'>###     #&lt;Concurrent::Promises::ResolvableFuture:0x00000c pending&gt;]</span></code></pre>

<blockquote>
<p>We do not have to sleep here letting the futures execute as Threads.
Since there is capacity for 2 messages the Promises are immediately resolved 
without ever allocating a Thread to execute. 
Push and pop operations are often more efficient.
The remaining pending push operation will also never require another thread,
instead it will resolve when a message is popped from the channel
making a space for a new message.    </p>
</blockquote>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_pop_op'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">pop_op</a></span>.<span class='id identifier rubyid_value!'>value!</span>                         <span class='comment'># =&gt; {:message=&gt;0}
</span><span class='id identifier rubyid_push_operations'>push_operations</span>.<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_value!'>value!</span>)
<span class='comment'>### =&gt; [#&lt;Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2&gt;,
</span><span class='comment'>###     #&lt;Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2&gt;,
</span><span class='comment'>###     #&lt;Concurrent::Promises::Channel:0x000009 capacity taken 2 of 2&gt;]
</span>
<span class='id identifier rubyid_pop_operations'>pop_operations</span> <span class='op'>=</span> <span class='const'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span>.<span class='id identifier rubyid_new'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span>(<span class='int'>3</span>) { <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_pop_op'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">pop_op</a></span> }
<span class='comment'>### =&gt; [#&lt;Concurrent::Promises::ResolvableFuture:0x00000d fulfilled with {:message=&gt;1}&gt;,
</span><span class='comment'>###     #&lt;Concurrent::Promises::ResolvableFuture:0x00000e fulfilled with {:message=&gt;2}&gt;,
</span><span class='comment'>###     #&lt;Concurrent::Promises::ResolvableFuture:0x00000f pending&gt;]
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='label'>message:</span> <span class='int'>3</span> <span class='comment'># (push|pop) can be freely mixed with (push_o|pop_op)
</span><span class='id identifier rubyid_pop_operations'>pop_operations</span>.<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span>) 
<span class='comment'>### =&gt; [{:message=&gt;1}, {:message=&gt;2}, {:message=&gt;3}]</span></code></pre>

<h5>Selecting over channels</h5>

<p>A selection over channels can be created with the <code>.select_channel</code> factory method. It
will be fulfilled with a first message available in any of the channels. It
returns a pair to be able to find out which channel had the message available.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch1'>ch1</span>    <span class='op'>=</span> <span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'>Channel</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> <span class='int'>2</span>
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Channel:0x000010 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_ch2'>ch2</span>    <span class='op'>=</span> <span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'>Channel</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> <span class='int'>2</span>
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Channel:0x000011 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_ch1'>ch1</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='int'>1</span> 
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Channel:0x000010 capacity taken 1 of 2&gt;
</span><span class='id identifier rubyid_ch2'>ch2</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='int'>2</span> 
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Channel:0x000011 capacity taken 1 of 2&gt;
</span>
<span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'>Channel</span>.<span class='id identifier rubyid_select'><a href="#select-class_method" title="Concurrent::Promises::Channel.select (method)">select</a></span>([<span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span>])
<span class='comment'>### =&gt; [#&lt;Concurrent::Promises::Channel:0x000010 capacity taken 0 of 2&gt;, 1]
</span><span class='id identifier rubyid_ch1'>ch1</span>.<span class='id identifier rubyid_select'><a href="#select-class_method" title="Concurrent::Promises::Channel.select (method)">select</a></span>(<span class='id identifier rubyid_ch2'>ch2</span>)
<span class='comment'>### =&gt; [#&lt;Concurrent::Promises::Channel:0x000011 capacity taken 0 of 2&gt;, 2]
</span>
<span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span> { <span class='int'>3</span> <span class='op'>+</span> <span class='int'>4</span> }.<span class='id identifier rubyid_then_channel_push'>then_channel_push</span>(<span class='id identifier rubyid_ch1'>ch1</span>)
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Future:0x000012 pending&gt;
</span><span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'>Channel</span>. 
    <span class='comment'># or `ch1.select_op(ch2)` would be equivalent
</span>    <span class='id identifier rubyid_select_op'><a href="#select_op-class_method" title="Concurrent::Promises::Channel.select_op (method)">select_op</a></span>([<span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span>]).
    <span class='id identifier rubyid_then'>then</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>got number %03d from ch%d</span><span class='tstring_end'>&#39;</span></span>) { <span class='op'>|</span>(<span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span>)<span class='comma'>,</span> <span class='id identifier rubyid_format'>format</span><span class='op'>|</span> 
      <span class='id identifier rubyid_format'>format</span> <span class='id identifier rubyid_format'>format</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> [<span class='id identifier rubyid_ch1'>ch1</span><span class='comma'>,</span> <span class='id identifier rubyid_ch2'>ch2</span>].<span class='id identifier rubyid_index'>index</span>(<span class='id identifier rubyid_channel'>channel</span>).<span class='id identifier rubyid_succ'>succ</span>
    }.<span class='id identifier rubyid_value!'>value!</span>                             <span class='comment'># =&gt; &quot;got number 007 from ch1&quot;</span></code></pre>

<h5><code>try_</code> variants</h5>

<p>All blocking operations (<a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">#pop</a>, <a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">#push</a>, <a href="#select-instance_method" title="Concurrent::Promises::Channel#select (method)">#select</a>) have non-blocking variant
with <code>try_</code> prefix. 
They always return immediately and indicate either success or failure.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span>
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Channel:0x000009 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_try_push'><a href="#try_push-instance_method" title="Concurrent::Promises::Channel#try_push (method)">try_push</a></span> <span class='int'>1</span>                            <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_try_push'><a href="#try_push-instance_method" title="Concurrent::Promises::Channel#try_push (method)">try_push</a></span> <span class='int'>2</span>                            <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_try_push'><a href="#try_push-instance_method" title="Concurrent::Promises::Channel#try_push (method)">try_push</a></span> <span class='int'>3</span>                            <span class='comment'># =&gt; false
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_try_pop'><a href="#try_pop-instance_method" title="Concurrent::Promises::Channel#try_pop (method)">try_pop</a></span>                               <span class='comment'># =&gt; 1
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_try_pop'><a href="#try_pop-instance_method" title="Concurrent::Promises::Channel#try_pop (method)">try_pop</a></span>                               <span class='comment'># =&gt; 2
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_try_pop'><a href="#try_pop-instance_method" title="Concurrent::Promises::Channel#try_pop (method)">try_pop</a></span>                               <span class='comment'># =&gt; nil</span></code></pre>

<h5>Timeouts</h5>

<p>All blocking operations (<a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">#pop</a>, <a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">#push</a>, <a href="#select-instance_method" title="Concurrent::Promises::Channel#select (method)">#select</a>) have a timeout option.
Similar to <code>try_</code> variants it will indicate success or timing out, 
when the timeout option is used.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ch'>ch</span>
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Channel:0x000009 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='int'>1</span><span class='comma'>,</span> <span class='float'>0.01</span>                          <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='int'>2</span><span class='comma'>,</span> <span class='float'>0.01</span>                          <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='int'>3</span><span class='comma'>,</span> <span class='float'>0.01</span>                          <span class='comment'># =&gt; false
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_pop'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">pop</a></span> <span class='float'>0.01</span>                              <span class='comment'># =&gt; 1
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_pop'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">pop</a></span> <span class='float'>0.01</span>                              <span class='comment'># =&gt; 2
</span><span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_pop'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">pop</a></span> <span class='float'>0.01</span>                              <span class='comment'># =&gt; nil</span></code></pre>

<h5>Backpressure</h5>

<p>Most importantly the channel can be used to create systems with backpressure.
A self adjusting system where the producers will slow down 
if the consumers are not keeping up.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> <span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'>Channel</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> <span class='int'>2</span>
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Channel:0x000013 capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_log'>log</span>     <span class='op'>=</span> <span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span>.<span class='id identifier rubyid_new'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span>          <span class='comment'># =&gt; []
</span>
<span class='id identifier rubyid_producers'>producers</span> <span class='op'>=</span> <span class='const'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span>.<span class='id identifier rubyid_new'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span> <span class='int'>2</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'>Thread</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span>(<span class='id identifier rubyid_i'>i</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
    <span class='int'>4</span>.<span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_j'>j</span><span class='op'>|</span>
      <span class='id identifier rubyid_log'>log</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>producer %d pushing %d</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='id identifier rubyid_j'>j</span>      
      <span class='id identifier rubyid_channel'>channel</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> [<span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='id identifier rubyid_j'>j</span>]      
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
<span class='comment'>### =&gt; [#&lt;Thread:0x000014@channel.in.md:133 run&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000015@channel.in.md:133 run&gt;]
</span>
<span class='id identifier rubyid_consumers'>consumers</span> <span class='op'>=</span> <span class='const'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span>.<span class='id identifier rubyid_new'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span> <span class='int'>4</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'>Thread</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span>(<span class='id identifier rubyid_i'>i</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_consumer'>consumer</span><span class='op'>|</span>
    <span class='int'>2</span>.<span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_j'>j</span><span class='op'>|</span>
      <span class='id identifier rubyid_from'>from</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span>.<span class='id identifier rubyid_pop'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">pop</a></span>
      <span class='id identifier rubyid_log'>log</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>consumer %d got %d. payload %d from producer %d</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> 
                      <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_j'>j</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_from'>from</span>       
      <span class='id identifier rubyid_do_stuff'>do_stuff</span>      
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
<span class='comment'>### =&gt; [#&lt;Thread:0x000016@channel.in.md:142 run&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000017@channel.in.md:142 run&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000018@channel.in.md:142 run&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000019@channel.in.md:142 run&gt;]
</span>
<span class='comment'>### wait for all to finish
</span><span class='id identifier rubyid_producers'>producers</span>.<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_join'>join</span>)
<span class='comment'>### =&gt; [#&lt;Thread:0x000014@channel.in.md:133 dead&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000015@channel.in.md:133 dead&gt;]
</span><span class='id identifier rubyid_consumers'>consumers</span>.<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_join'>join</span>)
<span class='comment'>### =&gt; [#&lt;Thread:0x000016@channel.in.md:142 dead&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000017@channel.in.md:142 dead&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000018@channel.in.md:142 dead&gt;,
</span><span class='comment'>###     #&lt;Thread:0x000019@channel.in.md:142 dead&gt;]
</span><span class='comment'>### investigate log
</span><span class='id identifier rubyid_log'>log</span>
<span class='comment'>### =&gt; [&quot;producer 0 pushing 0&quot;,
</span><span class='comment'>###     &quot;producer 0 pushing 1&quot;,
</span><span class='comment'>###     &quot;producer 0 pushing 2&quot;,
</span><span class='comment'>###     &quot;producer 1 pushing 0&quot;,
</span><span class='comment'>###     &quot;consumer 0 got 0. payload 0 from producer 0&quot;,
</span><span class='comment'>###     &quot;producer 0 pushing 3&quot;,
</span><span class='comment'>###     &quot;consumer 1 got 0. payload 1 from producer 0&quot;,
</span><span class='comment'>###     &quot;consumer 2 got 0. payload 2 from producer 0&quot;,
</span><span class='comment'>###     &quot;consumer 3 got 0. payload 0 from producer 1&quot;,
</span><span class='comment'>###     &quot;producer 1 pushing 1&quot;,
</span><span class='comment'>###     &quot;producer 1 pushing 2&quot;,
</span><span class='comment'>###     &quot;consumer 1 got 1. payload 3 from producer 0&quot;,
</span><span class='comment'>###     &quot;producer 1 pushing 3&quot;,
</span><span class='comment'>###     &quot;consumer 2 got 1. payload 1 from producer 1&quot;,
</span><span class='comment'>###     &quot;consumer 3 got 1. payload 2 from producer 1&quot;,
</span><span class='comment'>###     &quot;consumer 0 got 1. payload 3 from producer 1&quot;]</span></code></pre>

<p>The producers are much faster than consumers 
(since they <code>do_stuff</code> which takes some time)<br>
but as it can be seen from the log they fill the channel 
and then they slow down 
until there is space available in the channel.</p>

<p>If permanent allocation of threads to the producers and consumers has to be avoided,
the threads can be replaced with promises
that run a thread pool.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> <span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'>Channel</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> <span class='int'>2</span>
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Channel:0x00001a capacity taken 0 of 2&gt;
</span><span class='id identifier rubyid_log'>log</span>     <span class='op'>=</span> <span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span>.<span class='id identifier rubyid_new'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span>          <span class='comment'># =&gt; []
</span>
<span class='kw'>def</span> <span class='id identifier rubyid_produce'>produce</span>(<span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_producer'>producer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span>)
  <span class='id identifier rubyid_log'>log</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>producer %d pushing %d</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_producer'>producer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span>      
  <span class='id identifier rubyid_channel'>channel</span>.<span class='id identifier rubyid_push_op'><a href="#push_op-instance_method" title="Concurrent::Promises::Channel#push_op (method)">push_op</a></span>([<span class='id identifier rubyid_producer'>producer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span>]).<span class='id identifier rubyid_then'>then</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_i'>i</span> <span class='op'>+</span> <span class='int'>1</span> <span class='op'>&lt;</span> <span class='int'>4</span> <span class='op'>?</span> <span class='id identifier rubyid_produce'>produce</span>(<span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_producer'>producer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span> <span class='op'>+</span> <span class='int'>1</span>) <span class='op'>:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_done'>done</span>    
  <span class='kw'>end</span>      
<span class='kw'>end</span>                                      <span class='comment'># =&gt; :produce
</span>
<span class='kw'>def</span> <span class='id identifier rubyid_consume'>consume</span>(<span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span>)
  <span class='id identifier rubyid_channel'>channel</span>.<span class='id identifier rubyid_pop_op'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">pop_op</a></span>.<span class='id identifier rubyid_then'>then</span>(<span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span>) <span class='kw'>do</span> <span class='op'>|</span>(<span class='id identifier rubyid_from'>from</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span>)<span class='comma'>,</span> <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
    <span class='id identifier rubyid_log'>log</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>consumer %d got %d. payload %d from producer %d</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> 
                    <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_from'>from</span>       
    <span class='id identifier rubyid_do_stuff'>do_stuff</span>
    <span class='id identifier rubyid_i'>i</span> <span class='op'>+</span> <span class='int'>1</span> <span class='op'>&lt;</span> <span class='int'>2</span> <span class='op'>?</span> <span class='id identifier rubyid_consume'>consume</span>(<span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_consumer'>consumer</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span> <span class='op'>+</span> <span class='int'>1</span>) <span class='op'>:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_done'>done</span>       
  <span class='kw'>end</span>
<span class='kw'>end</span>                                      <span class='comment'># =&gt; :consume
</span>
<span class='id identifier rubyid_producers'>producers</span> <span class='op'>=</span> <span class='const'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span>.<span class='id identifier rubyid_new'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span> <span class='int'>2</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span>(<span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span>) { <span class='op'>|</span><span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='op'>|</span> <span class='id identifier rubyid_produce'>produce</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='int'>0</span> }.<span class='id identifier rubyid_run'>run</span>
<span class='kw'>end</span>
<span class='comment'>### =&gt; [#&lt;Concurrent::Promises::Future:0x00001b pending&gt;,
</span><span class='comment'>###     #&lt;Concurrent::Promises::Future:0x00001c pending&gt;]
</span>
<span class='id identifier rubyid_consumers'>consumers</span> <span class='op'>=</span> <span class='const'><a href="../Array.html" title="Concurrent::Array (class)">Array</a></span>.<span class='id identifier rubyid_new'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span> <span class='int'>4</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_future'><a href="FactoryMethods.html#future-instance_method" title="Concurrent::Promises::FactoryMethods#future (method)">future</a></span>(<span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_log'>log</span><span class='comma'>,</span> <span class='id identifier rubyid_i'>i</span>) { <span class='op'>|</span><span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='op'>|</span> <span class='id identifier rubyid_consume'>consume</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='int'>0</span> }.<span class='id identifier rubyid_run'>run</span>
<span class='kw'>end</span>
<span class='comment'>### =&gt; [#&lt;Concurrent::Promises::Future:0x00001d pending&gt;,
</span><span class='comment'>###     #&lt;Concurrent::Promises::Future:0x00001e pending&gt;,
</span><span class='comment'>###     #&lt;Concurrent::Promises::Future:0x00001f pending&gt;,
</span><span class='comment'>###     #&lt;Concurrent::Promises::Future:0x000020 pending&gt;]
</span>
<span class='comment'>### wait for all to finish
</span><span class='id identifier rubyid_producers'>producers</span>.<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_value!'>value!</span>)                  <span class='comment'># =&gt; [:done, :done]
</span><span class='id identifier rubyid_consumers'>consumers</span>.<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_value!'>value!</span>)                  <span class='comment'># =&gt; [:done, :done, :done, :done]
</span><span class='comment'>### investigate log
</span><span class='id identifier rubyid_log'>log</span>
<span class='comment'>### =&gt; [&quot;producer 0 pushing 0&quot;,
</span><span class='comment'>###     &quot;producer 1 pushing 0&quot;,
</span><span class='comment'>###     &quot;producer 1 pushing 1&quot;,
</span><span class='comment'>###     &quot;consumer 1 got 0. payload 0 from producer 1&quot;,
</span><span class='comment'>###     &quot;consumer 2 got 0. payload 1 from producer 1&quot;,
</span><span class='comment'>###     &quot;producer 0 pushing 1&quot;,
</span><span class='comment'>###     &quot;producer 0 pushing 2&quot;,
</span><span class='comment'>###     &quot;producer 0 pushing 3&quot;,
</span><span class='comment'>###     &quot;producer 1 pushing 2&quot;,
</span><span class='comment'>###     &quot;consumer 0 got 0. payload 0 from producer 0&quot;,
</span><span class='comment'>###     &quot;consumer 3 got 0. payload 1 from producer 0&quot;,
</span><span class='comment'>###     &quot;producer 1 pushing 3&quot;,
</span><span class='comment'>###     &quot;consumer 2 got 1. payload 2 from producer 0&quot;,
</span><span class='comment'>###     &quot;consumer 1 got 1. payload 3 from producer 0&quot;,
</span><span class='comment'>###     &quot;consumer 3 got 1. payload 3 from producer 1&quot;,
</span><span class='comment'>###     &quot;consumer 0 got 1. payload 2 from producer 1&quot;]</span></code></pre>

<h5>Synchronization of workers by passing a value</h5>

<p>If the capacity of the channel is zero 
then any push operation will succeed only 
when there is a matching pop operation
which can take the message.
The operations have to be paired to succeed. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> <span class='const'><a href="../../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'>Channel</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> <span class='int'>0</span>
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::Channel:0x000021 capacity taken 0 of 0&gt;
</span><span class='id identifier rubyid_thread'>thread</span> <span class='op'>=</span> <span class='const'>Thread</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span> { <span class='id identifier rubyid_channel'>channel</span>.<span class='id identifier rubyid_pop'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">pop</a></span> }<span class='semicolon'>;</span> <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.01</span> 
<span class='comment'>### allow the thread to go to sleep
</span><span class='id identifier rubyid_thread'>thread</span>
<span class='comment'>### =&gt; #&lt;Thread:0x000022@channel.in.md:214 sleep_forever&gt;
</span><span class='comment'>### succeeds because there is matching pop operation waiting in the thread 
</span><span class='id identifier rubyid_channel'>channel</span>.<span class='id identifier rubyid_try_push'><a href="#try_push-instance_method" title="Concurrent::Promises::Channel#try_push (method)">try_push</a></span>(<span class='symbeg'>:</span><span class='id identifier rubyid_v1'>v1</span>)                    <span class='comment'># =&gt; true
</span><span class='comment'>### remains pending, since there is no matching operation 
</span><span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='op'>=</span> <span class='id identifier rubyid_channel'>channel</span>.<span class='id identifier rubyid_push_op'><a href="#push_op-instance_method" title="Concurrent::Promises::Channel#push_op (method)">push_op</a></span>(<span class='symbeg'>:</span><span class='id identifier rubyid_v2'>v2</span>)
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::ResolvableFuture:0x000023 pending&gt;
</span><span class='id identifier rubyid_thread'>thread</span>.<span class='id identifier rubyid_value'>value</span>                             <span class='comment'># =&gt; :v1
</span><span class='comment'>### the push operation resolves as a pairing pop is called
</span><span class='id identifier rubyid_channel'>channel</span>.<span class='id identifier rubyid_pop'><a href="#pop-instance_method" title="Concurrent::Promises::Channel#pop (method)">pop</a></span>                              <span class='comment'># =&gt; :v2
</span><span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span>
<span class='comment'>### =&gt; #&lt;Concurrent::Promises::ResolvableFuture:0x000023 fulfilled with #&lt;Concurrent::Promises::Channel:0x000021 capacity taken 0 of 0&gt;&gt;</span></code></pre>
</p>

  </div>
</div>
<div class='tags'>
  
</div>
</div>
<h2 id='t2_cnst' class='h2_sum'>Constant Summary</h2>
<div>
<ul class='constants summary full'>
  <li>
    <span id='ANY-constant' class='summary_signature'>ANY =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>An object which matches anything (with <code>#===</code>)</p>

  </div>
</div>
<div class='tags'>
  
</div>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L52-L60'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 52</a>    <pre class='code ruby'><span class='const'><a href="../../Object.html" title="Object (class)">Object</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span>.<span class='id identifier rubyid_tap'>tap</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_any'>any</span><span class='op'>|</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_any'>any</span>.<span class='op'>===</span>(<span class='id identifier rubyid_other'>other</span>)
    <span class='kw'>true</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_any'>any</span>.<span class='id identifier rubyid_to_s'><a href="#to_s-instance_method" title="Concurrent::Promises::Channel#to_s (method)">to_s</a></span>
    <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>ANY</span><span class='tstring_end'>&#39;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
  </li>
  <li>
    <span id='NOTHING-constant' class='summary_signature priv'>NOTHING =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L48-L48'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 48</a>    <pre class='code ruby'><span class='const'><a href="../../Object.html" title="Object (class)">Object</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span></pre>
  </li>
  <li>
    <span id='UNLIMITED_CAPACITY-constant' class='summary_signature'>UNLIMITED_CAPACITY =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>Default capacity of the <code>Channel</code>, makes it accept unlimited number of messages.</p>

  </div>
</div>
<div class='tags'>
  
</div>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L35-L35'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 35</a>    <pre class='code ruby'><span class='op'>::</span><span class='const'><a href="../../Object.html" title="Object (class)">Object</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Promises::Channel.new (method)">new</a></span></pre>
  </li>
</ul>
</div>

<h2 class='h2_sum' id='class_Attribute_summary'>Class Attribute Summary</h2>
<div class='div_sum'>

<h3 class='inherited'><a href="../Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ro' href="../Synchronization/Object.html#safe_initialization%3F-class_method" title="Concurrent::Synchronization::Object.safe_initialization? (method)">.safe_initialization?</a>
      </td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- class_attribute_summary -->

<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#new-class_method" title=".new (class method)">.<strong>new</strong>(capacity = UNLIMITED_CAPACITY)  &#x21d2; Channel </a>
    </span>
    <span class='note title constructor'>constructor</span>
    <div class='summary_desc'>
      <div class='inline'><p>Create channel.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#select-class_method" title=".select (class method)">.<strong>select</strong>(channels, timeout = nil)  &#x21d2; ::Array(Channel, Object)<sup>?</sup> </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#select_matching-class_method" title=".select_matching (class method)">.<strong>select_matching</strong>(matcher, channels, timeout = nil)  &#x21d2; ::Array(Channel, Object)<sup>?</sup> </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#select_op-class_method" title=".select_op (class method)">.<strong>select_op</strong>(channels, probe = Promises.resolvable_future)  &#x21d2; Future(::Array(Channel, Object)) </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#select_op_matching-class_method" title=".select_op_matching (class method)">.<strong>select_op_matching</strong>(matcher, channels, probe = Promises.resolvable_future)  &#x21d2; Future(::Array(Channel, Object)) </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#try_select-class_method" title=".try_select (class method)">.<strong>try_select</strong>(channels)  &#x21d2; ::Array(Channel, Object) </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#try_select_matching-class_method" title=".try_select_matching (class method)">.<strong>try_select_matching</strong>(matcher, channels)  &#x21d2; ::Array(Channel, Object) </a>
    </span>
  </li>
</ul>

<h3 class='inherited'><a href="../Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="../Synchronization/Object.html#atomic_attribute%3F-class_method" title="Concurrent::Synchronization::Object.atomic_attribute? (method)">.atomic_attribute?</a>,
        <a class='i_m ' href="../Synchronization/Object.html#atomic_attributes-class_method" title="Concurrent::Synchronization::Object.atomic_attributes (method)">.atomic_attributes</a>,
      </td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="../Synchronization/Object.html#attr_atomic-class_method" title="Concurrent::Synchronization::Object.attr_atomic (method)">.attr_atomic</a></td>
      <td><div class='inline'><p>Creates methods for reading and writing to a instance variable with volatile (Java) semantic as <code>.attr_volatile</code> does.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="../Synchronization/Object.html#attr_volatile-class_method" title="Concurrent::Synchronization::Object.attr_volatile (method)">.attr_volatile</a></td>
      <td><div class='inline'><p>Creates methods for reading and writing (as <code>attr_accessor</code> does) to a instance variable with volatile (Java) semantic.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="../Synchronization/Object.html#ensure_safe_initialization_when_final_fields_are_present-class_method" title="Concurrent::Synchronization::Object.ensure_safe_initialization_when_final_fields_are_present (method)">.ensure_safe_initialization_when_final_fields_are_present</a></td>
      <td><div class='inline'><p>For testing purposes, quite slow.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="../Synchronization/Object.html#new-class_method" title="Concurrent::Synchronization::Object.new (method)">.new</a></td>
      <td><div class='inline'><p>Has to be called by children.</p></div></td>
    </tr>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="../Synchronization/Object.html#safe_initialization!-class_method" title="Concurrent::Synchronization::Object.safe_initialization! (method)">.safe_initialization!</a>,
        <a class='i_m priv' href="../Synchronization/Object.html#define_initialize_atomic_fields-class_method" title="Concurrent::Synchronization::Object.define_initialize_atomic_fields (method)">.define_initialize_atomic_fields</a>
      </td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="../Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)"><code>Synchronization::AbstractObject</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="../Synchronization/AbstractObject.html#attr_volatile-class_method" title="Concurrent::Synchronization::AbstractObject.attr_volatile (method)">.attr_volatile</a>,
        <a class='i_m ' href="../Synchronization/AbstractObject.html#new-class_method" title="Concurrent::Synchronization::AbstractObject.new (method)">.new</a>
      </td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#capacity-instance_method" title="#capacity (instance method)">#<strong>capacity</strong>  &#x21d2; Integer </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#inspect-instance_method" title="#inspect (instance method)">#<strong>inspect</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#to_s-instance_method" title="Concurrent::Promises::Channel#to_s (method)">#to_s</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#peek-instance_method" title="#peek (instance method)">#<strong>peek</strong>(no_value = nil)  &#x21d2; Object, no_value </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Behaves as <a href="#try_pop-instance_method" title="Concurrent::Promises::Channel#try_pop (method)">#try_pop</a> but it does not remove the message from the channel.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#peek_matching-instance_method" title="#peek_matching (instance method)">#<strong>peek_matching</strong>(matcher, no_value = nil)  &#x21d2; Object, no_value </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Behaves as <a href="#try_pop-instance_method" title="Concurrent::Promises::Channel#try_pop (method)">#try_pop</a> but it does not remove the message from the channel.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#pop-instance_method" title="#pop (instance method)">#<strong>pop</strong>(timeout = nil, timeout_value = nil)  &#x21d2; Object<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Blocks current thread until a message is available in the channel for popping.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#pop_matching-instance_method" title="#pop_matching (instance method)">#<strong>pop_matching</strong>(matcher, timeout = nil, timeout_value = nil)  &#x21d2; Object<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Blocks current thread until a message is available in the channel for popping.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#pop_op-instance_method" title="#pop_op (instance method)">#<strong>pop_op</strong>(probe = Promises.resolvable_future)  &#x21d2; Future(Object) </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns a future witch will become fulfilled with a value from the channel when one is available.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#pop_op_matching-instance_method" title="#pop_op_matching (instance method)">#<strong>pop_op_matching</strong>(matcher, probe = Promises.resolvable_future)  &#x21d2; Future(Object) </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns a future witch will become fulfilled with a value from the channel when one is available.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#push-instance_method" title="#push (instance method)">#<strong>push</strong>(message, timeout = nil)  &#x21d2; self, ... </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Blocks current thread until the message is pushed into the channel.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#push_op-instance_method" title="#push_op (instance method)">#<strong>push_op</strong>(message)  &#x21d2; ResolvableFuture(self) </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns future which will fulfill when the message is pushed to the channel.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#select-instance_method" title="#select (instance method)">#<strong>select</strong>(channels, timeout = nil)  &#x21d2; ::Array(Channel, Object)<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>As <a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a> but does not return future, it block current thread instead until there is a message available in the receiver or in any of the channels.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#select_matching-instance_method" title="#select_matching (instance method)">#<strong>select_matching</strong>(matcher, channels, timeout = nil)  &#x21d2; ::Array(Channel, Object)<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>As <a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a> but does not return future, it block current thread instead until there is a message available in the receiver or in any of the channels.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#select_op-instance_method" title="#select_op (instance method)">#<strong>select_op</strong>(channels, probe = Promises.resolvable_future)  &#x21d2; ResolvableFuture(::Array(Channel, Object)) </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>When message is available in the receiver or any of the provided channels the future is fulfilled with a channel message pair.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#select_op_matching-instance_method" title="#select_op_matching (instance method)">#<strong>select_op_matching</strong>(matcher, channels, probe = Promises.resolvable_future)  &#x21d2; ResolvableFuture(::Array(Channel, Object)) </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>When message is available in the receiver or any of the provided channels the future is fulfilled with a channel message pair.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#size-instance_method" title="#size (instance method)">#<strong>size</strong>  &#x21d2; Integer </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#to_s-instance_method" title="#to_s (instance method)">#<strong>to_s</strong>  &#x21d2; String </a>
      (also: #inspect)
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#try_pop-instance_method" title="#try_pop (instance method)">#<strong>try_pop</strong>(no_value = nil)  &#x21d2; Object, no_value </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Pop a message from the channel if there is one available.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#try_pop_matching-instance_method" title="#try_pop_matching (instance method)">#<strong>try_pop_matching</strong>(matcher, no_value = nil)  &#x21d2; Object, no_value </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Pop a message from the channel if there is one available.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#try_push-instance_method" title="#try_push (instance method)">#<strong>try_push</strong>(message)  &#x21d2; true, false </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Push the message into the channel if there is space available.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#try_select-instance_method" title="#try_select (instance method)">#<strong>try_select</strong>(channels)  &#x21d2; ::Array(Channel, Object)<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>If message is available in the receiver or any of the provided channels the channel message pair is returned.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#try_select_matching-instance_method" title="#try_select_matching (instance method)">#<strong>try_select_matching</strong>(matcher, channels)  &#x21d2; ::Array(Channel, Object)<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>If message is available in the receiver or any of the provided channels the channel message pair is returned.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#ns_consume_pending_push-instance_method" title="#ns_consume_pending_push (instance method)">#<strong>ns_consume_pending_push</strong>(matcher, remove = true)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#ns_pop_op-instance_method" title="#ns_pop_op (instance method)">#<strong>ns_pop_op</strong>(matcher, probe, include_channel)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#ns_shift_message-instance_method" title="#ns_shift_message (instance method)">#<strong>ns_shift_message</strong>(matcher, remove = true)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#ns_try_push-instance_method" title="#ns_try_push (instance method)">#<strong>ns_try_push</strong>(message)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#partial_select_op-instance_method" title="#partial_select_op (instance method)">#<strong>partial_select_op</strong>(matcher, probe)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
</ul>

<h3 class='inherited'><a href="../Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m priv' href="../Synchronization/Object.html#__initialize_atomic_fields__-instance_method" title="Concurrent::Synchronization::Object#__initialize_atomic_fields__ (method)">#__initialize_atomic_fields__</a>
      </td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="../Synchronization/Volatile.html" title="Concurrent::Synchronization::Volatile (module)"><code>Synchronization::Volatile</code></a> - Included</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="../Synchronization/Volatile.html#full_memory_barrier-instance_method" title="Concurrent::Synchronization::Volatile#full_memory_barrier (method)">#full_memory_barrier</a>
      </td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="../Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)"><code>Synchronization::AbstractObject</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m priv' href="../Synchronization/AbstractObject.html#full_memory_barrier-instance_method" title="Concurrent::Synchronization::AbstractObject#full_memory_barrier (method)">#full_memory_barrier</a>
      </td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- instance_method_summary -->
<h2 id='Constructor_Details' class='y_details'>Constructor Details</h2>

  <section class='method_details first' id="new-class_method">
  <h3 class='signature  first'>
    .<strong>new</strong>(capacity = UNLIMITED_CAPACITY)  &#x21d2; <code>Channel</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Create channel.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>capacity</span>
    <span class='type'>(<code>Integer</code>, <a href="#UNLIMITED_CAPACITY-constant" title="Concurrent::Promises::Channel::UNLIMITED_CAPACITY (constant)">UNLIMITED_CAPACITY</a>)</span>
    <em class='default'>(defaults to: <tt>UNLIMITED_CAPACITY</tt>)</em>
&mdash;    <div class='inline'>
<p>the maximum number of messages which can be stored in the channel.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L64-L72'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='64' data-end='72'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 64</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_initialize'><a href="../../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">initialize</a></span>(<span class='id identifier rubyid_capacity'><a href="#capacity-instance_method" title="Concurrent::Promises::Channel#capacity (method)">capacity</a></span> <span class='op'>=</span> <span class='const'><a href="#UNLIMITED_CAPACITY-constant" title="Concurrent::Promises::Channel::UNLIMITED_CAPACITY (constant)">UNLIMITED_CAPACITY</a></span>)
  <span class='kw'>super</span>()
  <span class='ivar'>@Capacity</span> <span class='op'>=</span> <span class='id identifier rubyid_capacity'><a href="#capacity-instance_method" title="Concurrent::Promises::Channel#capacity (method)">capacity</a></span>
  <span class='ivar'>@Mutex</span>    <span class='op'>=</span> <span class='const'>Mutex</span>.<span class='id identifier rubyid_new'>new</span>
  <span class='comment'># TODO (pitr-ch 28-Jan-2019): consider linked lists or other data structures for following attributes, things are being deleted from the middle
</span>  <span class='ivar'>@Probes</span>      <span class='op'>=</span> []
  <span class='ivar'>@Messages</span>    <span class='op'>=</span> []
  <span class='ivar'>@PendingPush</span> <span class='op'>=</span> []
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Class Method Details</h2>
<section class='method_details first' id="select-class_method">
  <h3 class='signature  first'>
    .<strong>select</strong>(channels, timeout = nil)  &#x21d2; <code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>)<sup>?</sup> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
    <p class='tag_title'>See Also:</p>
  <ul class='see'>
      <li><a href="#select-instance_method" title="Concurrent::Promises::Channel#select (method)">#select</a></li>
      </ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L322-L324'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='322' data-end='324'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 322</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_select'>select</span>(<span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='id identifier rubyid_channels'>channels</span>.<span class='id identifier rubyid_first'>first</span>.<span class='id identifier rubyid_select'>select</span>(<span class='id identifier rubyid_channels'>channels</span>[<span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span>]<span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="select_matching-class_method">
  <h3 class='signature '>
    .<strong>select_matching</strong>(matcher, channels, timeout = nil)  &#x21d2; <code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>)<sup>?</sup> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
    <p class='tag_title'>See Also:</p>
  <ul class='see'>
      <li><a href="#select_matching-instance_method" title="Concurrent::Promises::Channel#select_matching (method)">#select_matching</a></li>
      </ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L340-L342'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='340' data-end='342'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 340</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_select_matching'>select_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='id identifier rubyid_channels'>channels</span>.<span class='id identifier rubyid_first'>first</span>.<span class='id identifier rubyid_select_matching'>select_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span>[<span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span>]<span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="select_op-class_method">
  <h3 class='signature '>
    .<strong>select_op</strong>(channels, probe = Promises.resolvable_future)  &#x21d2; <a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a>(<code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>)) 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
    <p class='tag_title'>See Also:</p>
  <ul class='see'>
      <li><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></li>
      </ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L316-L318'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='316' data-end='318'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 316</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_select_op'>select_op</span>(<span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_future'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span>)
  <span class='id identifier rubyid_channels'>channels</span>.<span class='id identifier rubyid_first'>first</span>.<span class='id identifier rubyid_select_op'>select_op</span>(<span class='id identifier rubyid_channels'>channels</span>[<span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span>]<span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="select_op_matching-class_method">
  <h3 class='signature '>
    .<strong>select_op_matching</strong>(matcher, channels, probe = Promises.resolvable_future)  &#x21d2; <a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a>(<code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>)) 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
    <p class='tag_title'>See Also:</p>
  <ul class='see'>
      <li><a href="#select_op_matching-instance_method" title="Concurrent::Promises::Channel#select_op_matching (method)">#select_op_matching</a></li>
      </ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L334-L336'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='334' data-end='336'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 334</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_select_op_matching'>select_op_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_future'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span>)
  <span class='id identifier rubyid_channels'>channels</span>.<span class='id identifier rubyid_first'>first</span>.<span class='id identifier rubyid_select_op_matching'>select_op_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span>[<span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span>]<span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="try_select-class_method">
  <h3 class='signature '>
    .<strong>try_select</strong>(channels)  &#x21d2; <code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>) 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
    <p class='tag_title'>See Also:</p>
  <ul class='see'>
      <li><a href="#try_select-instance_method" title="Concurrent::Promises::Channel#try_select (method)">#try_select</a></li>
      </ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L310-L312'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='310' data-end='312'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 310</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_try_select'>try_select</span>(<span class='id identifier rubyid_channels'>channels</span>)
  <span class='id identifier rubyid_channels'>channels</span>.<span class='id identifier rubyid_first'>first</span>.<span class='id identifier rubyid_try_select'>try_select</span>(<span class='id identifier rubyid_channels'>channels</span>[<span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span>])
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="try_select_matching-class_method">
  <h3 class='signature '>
    .<strong>try_select_matching</strong>(matcher, channels)  &#x21d2; <code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>) 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
    <p class='tag_title'>See Also:</p>
  <ul class='see'>
      <li><a href="#try_select_matching-instance_method" title="Concurrent::Promises::Channel#try_select_matching (method)">#try_select_matching</a></li>
      </ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L328-L330'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='328' data-end='330'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 328</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_try_select_matching'>try_select_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span>)
  <span class='id identifier rubyid_channels'>channels</span>.<span class='id identifier rubyid_first'>first</span>.<span class='id identifier rubyid_try_select_matching'>try_select_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span>[<span class='int'>1</span><span class='op'>..</span><span class='op'>-</span><span class='int'>1</span>])
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="capacity-instance_method">
  <h3 class='signature  first'>
    #<strong>capacity</strong>  &#x21d2; <code>Integer</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Integer</code>)</span>
&mdash;    <div class='inline'>
<p>Maximum capacity of the <code>Channel</code>.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L295-L297'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='295' data-end='297'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 295</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_capacity'>capacity</span>
  <span class='ivar'>@Capacity</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="inspect-instance_method">
  <h3 class='signature '>
    #<strong>inspect</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#to_s-instance_method" title="Concurrent::Promises::Channel#to_s (method)">#to_s</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L304-L304'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='304' data-end='304'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 304</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_inspect'>inspect</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_to_s'><a href="#to_s-instance_method" title="Concurrent::Promises::Channel#to_s (method)">to_s</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="ns_consume_pending_push-instance_method">
  <h3 class='signature priv'>
    #<strong>ns_consume_pending_push</strong>(matcher, remove = true)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L397-L415'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='397' data-end='415'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 397</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_ns_consume_pending_push'>ns_consume_pending_push</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_remove'>remove</span> <span class='op'>=</span> <span class='kw'>true</span>)
  <span class='id identifier rubyid_i'>i</span> <span class='op'>=</span> <span class='int'>0</span>
  <span class='kw'>while</span> <span class='kw'>true</span>
    <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_pushed'>pushed</span> <span class='op'>=</span> <span class='ivar'>@PendingPush</span>[<span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='int'>2</span>]
    <span class='kw'>return</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span> <span class='kw'>unless</span> <span class='id identifier rubyid_pushed'>pushed</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_matcher'>matcher</span> <span class='op'>===</span> <span class='id identifier rubyid_message'>message</span>
      <span class='id identifier rubyid_resolved'>resolved</span>           <span class='op'>=</span> <span class='id identifier rubyid_pushed'>pushed</span>.<span class='id identifier rubyid_resolved?'>resolved?</span>
      <span class='ivar'>@PendingPush</span>[<span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='int'>2</span>] <span class='op'>=</span> [] <span class='kw'>if</span> <span class='id identifier rubyid_remove'>remove</span> <span class='op'>||</span> <span class='id identifier rubyid_resolved'>resolved</span>
      <span class='comment'># can fail if timed-out, so try without error
</span>      <span class='kw'>if</span> <span class='id identifier rubyid_remove'>remove</span> <span class='op'>?</span> <span class='id identifier rubyid_pushed'>pushed</span>.<span class='id identifier rubyid_fulfill'>fulfill</span>(<span class='kw'>self</span><span class='comma'>,</span> <span class='kw'>false</span>) <span class='op'>:</span> <span class='op'>!</span><span class='id identifier rubyid_resolved'>resolved</span>
        <span class='comment'># pushed fulfilled so actually push the message
</span>        <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_i'>i</span> <span class='op'>+=</span> <span class='int'>2</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="ns_pop_op-instance_method">
  <h3 class='signature priv'>
    #<strong>ns_pop_op</strong>(matcher, probe, include_channel)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L352-L395'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='352' data-end='395'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 352</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_ns_pop_op'>ns_pop_op</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span><span class='comma'>,</span> <span class='id identifier rubyid_include_channel'>include_channel</span>)
  <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_shift_message'><a href="#ns_shift_message-instance_method" title="Concurrent::Promises::Channel#ns_shift_message (method)">ns_shift_message</a></span> <span class='id identifier rubyid_matcher'>matcher</span>

  <span class='comment'># got message from buffer
</span>  <span class='kw'>if</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span>
    <span class='kw'>if</span> <span class='id identifier rubyid_probe'>probe</span>.<span class='id identifier rubyid_fulfill'>fulfill</span>(<span class='id identifier rubyid_include_channel'>include_channel</span> <span class='op'>?</span> [<span class='kw'>self</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span>] <span class='op'>:</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='kw'>false</span>)
      <span class='id identifier rubyid_new_message'>new_message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_consume_pending_push'><a href="#ns_consume_pending_push-instance_method" title="Concurrent::Promises::Channel#ns_consume_pending_push (method)">ns_consume_pending_push</a></span> <span class='const'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span>
      <span class='ivar'>@Messages</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='id identifier rubyid_new_message'>new_message</span> <span class='kw'>unless</span> <span class='id identifier rubyid_new_message'>new_message</span> <span class='op'>==</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span>
    <span class='kw'>else</span>
      <span class='ivar'>@Messages</span>.<span class='id identifier rubyid_unshift'>unshift</span> <span class='id identifier rubyid_message'>message</span>
    <span class='kw'>end</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_probe'>probe</span>
  <span class='kw'>end</span>

  <span class='comment'># no message in buffer, try to pair with a pending push
</span>  <span class='id identifier rubyid_i'>i</span> <span class='op'>=</span> <span class='int'>0</span>
  <span class='kw'>while</span> <span class='kw'>true</span>
    <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_pushed'>pushed</span> <span class='op'>=</span> <span class='ivar'>@PendingPush</span>[<span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='int'>2</span>]
    <span class='kw'>break</span> <span class='kw'>if</span> <span class='id identifier rubyid_pushed'>pushed</span>.<span class='id identifier rubyid_nil?'>nil?</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_matcher'>matcher</span> <span class='op'>===</span> <span class='id identifier rubyid_message'>message</span>
      <span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_include_channel'>include_channel</span> <span class='op'>?</span> [<span class='kw'>self</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span>] <span class='op'>:</span> <span class='id identifier rubyid_message'>message</span>
      <span class='kw'>if</span> <span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span><span class='op'>::</span><span class='const'><a href="Resolvable.html" title="Concurrent::Promises::Resolvable (module)">Resolvable</a></span>.<span class='id identifier rubyid_atomic_resolution'><a href="Resolvable.html#atomic_resolution-class_method" title="Concurrent::Promises::Resolvable.atomic_resolution (method)">atomic_resolution</a></span>(<span class='id identifier rubyid_probe'>probe</span>  <span class='op'>=&gt;</span> [<span class='kw'>true</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='kw'>nil</span>]<span class='comma'>,</span>
                                                <span class='id identifier rubyid_pushed'>pushed</span> <span class='op'>=&gt;</span> [<span class='kw'>true</span><span class='comma'>,</span> <span class='kw'>self</span><span class='comma'>,</span> <span class='kw'>nil</span>])
        <span class='ivar'>@PendingPush</span>[<span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='int'>2</span>] <span class='op'>=</span> []
        <span class='kw'>return</span> <span class='id identifier rubyid_probe'>probe</span>
      <span class='kw'>end</span>

      <span class='kw'>if</span> <span class='id identifier rubyid_probe'>probe</span>.<span class='id identifier rubyid_resolved?'>resolved?</span>
        <span class='kw'>return</span> <span class='id identifier rubyid_probe'>probe</span>
      <span class='kw'>end</span>

      <span class='comment'># so pushed.resolved? has to be true, remove the push
</span>      <span class='ivar'>@PendingPush</span>[<span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='int'>2</span>] <span class='op'>=</span> []
    <span class='kw'>end</span>

    <span class='id identifier rubyid_i'>i</span> <span class='op'>+=</span> <span class='int'>2</span>
  <span class='kw'>end</span>

  <span class='comment'># no push to pair with
</span>  <span class='comment'># TODO (pitr-ch 11-Jan-2019): clear up probes when timed out, use callback
</span>  <span class='ivar'>@Probes</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='id identifier rubyid_probe'>probe</span><span class='comma'>,</span> <span class='id identifier rubyid_include_channel'>include_channel</span><span class='comma'>,</span> <span class='id identifier rubyid_matcher'>matcher</span> <span class='kw'>if</span> <span class='id identifier rubyid_probe'>probe</span>.<span class='id identifier rubyid_pending?'>pending?</span>
  <span class='kw'>return</span> <span class='id identifier rubyid_probe'>probe</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="ns_shift_message-instance_method">
  <h3 class='signature priv'>
    #<strong>ns_shift_message</strong>(matcher, remove = true)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L437-L450'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='437' data-end='450'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 437</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_ns_shift_message'>ns_shift_message</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_remove'>remove</span> <span class='op'>=</span> <span class='kw'>true</span>)
  <span class='id identifier rubyid_i'>i</span> <span class='op'>=</span> <span class='int'>0</span>
  <span class='kw'>while</span> <span class='kw'>true</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='ivar'>@Messages</span>.<span class='id identifier rubyid_fetch'>fetch</span>(<span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span>)
    <span class='kw'>return</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span> <span class='kw'>if</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>==</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span>

    <span class='kw'>if</span> <span class='id identifier rubyid_matcher'>matcher</span> <span class='op'>===</span> <span class='id identifier rubyid_message'>message</span>
      <span class='ivar'>@Messages</span>.<span class='id identifier rubyid_delete_at'>delete_at</span> <span class='id identifier rubyid_i'>i</span> <span class='kw'>if</span> <span class='id identifier rubyid_remove'>remove</span>
      <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_i'>i</span> <span class='op'>+=</span> <span class='int'>1</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="ns_try_push-instance_method">
  <h3 class='signature priv'>
    #<strong>ns_try_push</strong>(message)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L417-L435'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='417' data-end='435'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 417</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_ns_try_push'>ns_try_push</span>(<span class='id identifier rubyid_message'>message</span>)
  <span class='id identifier rubyid_i'>i</span> <span class='op'>=</span> <span class='int'>0</span>
  <span class='kw'>while</span> <span class='kw'>true</span>
    <span class='id identifier rubyid_probe'>probe</span><span class='comma'>,</span> <span class='id identifier rubyid_include_channel'>include_channel</span><span class='comma'>,</span> <span class='id identifier rubyid_matcher'>matcher</span> <span class='op'>=</span> <span class='ivar'>@Probes</span>[<span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='int'>3</span>]
    <span class='kw'>break</span> <span class='kw'>unless</span> <span class='id identifier rubyid_probe'>probe</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_matcher'>matcher</span> <span class='op'>===</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_probe'>probe</span>.<span class='id identifier rubyid_fulfill'>fulfill</span>(<span class='id identifier rubyid_include_channel'>include_channel</span> <span class='op'>?</span> [<span class='kw'>self</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span>] <span class='op'>:</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='kw'>false</span>)
      <span class='ivar'>@Probes</span>[<span class='id identifier rubyid_i'>i</span><span class='comma'>,</span> <span class='int'>3</span>] <span class='op'>=</span> []
      <span class='kw'>return</span> <span class='kw'>true</span>
    <span class='kw'>end</span>
    <span class='id identifier rubyid_i'>i</span> <span class='op'>+=</span> <span class='int'>3</span>
  <span class='kw'>end</span>

  <span class='kw'>if</span> <span class='ivar'>@Capacity</span> <span class='op'>&gt;</span> <span class='ivar'>@Messages</span>.<span class='id identifier rubyid_size'><a href="#size-instance_method" title="Concurrent::Promises::Channel#size (method)">size</a></span>
    <span class='ivar'>@Messages</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='id identifier rubyid_message'>message</span>
    <span class='kw'>true</span>
  <span class='kw'>else</span>
    <span class='kw'>false</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="partial_select_op-instance_method">
  <h3 class='signature priv'>
    #<strong>partial_select_op</strong>(matcher, probe)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L346-L348'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='346' data-end='348'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 346</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_partial_select_op'>partial_select_op</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span>)
  <span class='ivar'>@Mutex</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> { <span class='id identifier rubyid_ns_pop_op'><a href="#ns_pop_op-instance_method" title="Concurrent::Promises::Channel#ns_pop_op (method)">ns_pop_op</a></span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span><span class='comma'>,</span> <span class='kw'>true</span>) }
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="peek-instance_method">
  <h3 class='signature '>
    #<strong>peek</strong>(no_value = nil)  &#x21d2; <a href="../../Object.html" title="Object (class)">Object</a>, <code>no_value</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Behaves as <a href="#try_pop-instance_method" title="Concurrent::Promises::Channel#try_pop (method)">#try_pop</a> but it does not remove the message from the channel</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>no_value</span>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>)</span>
    <em class='default'>(defaults to: <tt>nil</tt>)</em>
&mdash;    <div class='inline'>
<p>returned when there is no message available</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>, <code>no_value</code>)</span>
&mdash;    <div class='inline'>
<p>message or nil when there is no message</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L209-L211'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='209' data-end='211'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 209</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_peek'>peek</span>(<span class='id identifier rubyid_no_value'>no_value</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='id identifier rubyid_peek_matching'><a href="#peek_matching-instance_method" title="Concurrent::Promises::Channel#peek_matching (method)">peek_matching</a></span> <span class='const'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span><span class='comma'>,</span> <span class='id identifier rubyid_no_value'>no_value</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="peek_matching-instance_method">
  <h3 class='signature '>
    #<strong>peek_matching</strong>(matcher, no_value = nil)  &#x21d2; <a href="../../Object.html" title="Object (class)">Object</a>, <code>no_value</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Behaves as <a href="#try_pop-instance_method" title="Concurrent::Promises::Channel#try_pop (method)">#try_pop</a> but it does not remove the message from the channel</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>no_value</span>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>)</span>
    <em class='default'>(defaults to: <tt>nil</tt>)</em>
&mdash;    <div class='inline'>
<p>returned when there is no message available</p>
</div>
  </li>
  <li>
    <span class='name'>matcher</span>
    <span class='type'>(#===)</span>
&mdash;    <div class='inline'>
<p>only consider message which matches <code>matcher === a_message</code></p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>, <code>no_value</code>)</span>
&mdash;    <div class='inline'>
<p>message or nil when there is no message</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L215-L222'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='215' data-end='222'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 215</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_peek_matching'>peek_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_no_value'>no_value</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='ivar'>@Mutex</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_shift_message'><a href="#ns_shift_message-instance_method" title="Concurrent::Promises::Channel#ns_shift_message (method)">ns_shift_message</a></span> <span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='kw'>false</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span> <span class='kw'>if</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_consume_pending_push'><a href="#ns_consume_pending_push-instance_method" title="Concurrent::Promises::Channel#ns_consume_pending_push (method)">ns_consume_pending_push</a></span> <span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='kw'>false</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span> <span class='op'>?</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>:</span> <span class='id identifier rubyid_no_value'>no_value</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="pop-instance_method">
  <h3 class='signature '>
    #<strong>pop</strong>(timeout = nil, timeout_value = nil)  &#x21d2; <a href="../../Object.html" title="Object (class)">Object</a><sup>?</sup> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'>
<p>This function potentially blocks current thread until it can continue. Be careful it can deadlock.</p>
</div>
  </div>


<p>Blocks current thread until a message is available in the channel for popping.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>timeout</span>
    <span class='type'>(<code>Numeric</code>)</span>
    <em class='default'>(defaults to: <tt>nil</tt>)</em>
&mdash;    <div class='inline'>
<p>the maximum time in second to wait.</p>
</div>
  </li>
  <li>
    <span class='name'>timeout_value</span>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>)</span>
    <em class='default'>(defaults to: <tt>nil</tt>)</em>
&mdash;    <div class='inline'>
<p>a value returned by the method when it times out</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>, <code>nil</code>)</span>
&mdash;    <div class='inline'>
<p>message or nil when timed out</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L177-L179'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='177' data-end='179'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 177</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_pop'>pop</span>(<span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout_value'>timeout_value</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='id identifier rubyid_pop_matching'><a href="#pop_matching-instance_method" title="Concurrent::Promises::Channel#pop_matching (method)">pop_matching</a></span> <span class='const'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout_value'>timeout_value</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="pop_matching-instance_method">
  <h3 class='signature '>
    #<strong>pop_matching</strong>(matcher, timeout = nil, timeout_value = nil)  &#x21d2; <a href="../../Object.html" title="Object (class)">Object</a><sup>?</sup> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'>
<p>This function potentially blocks current thread until it can continue. Be careful it can deadlock.</p>
</div>
  </div>


<p>Blocks current thread until a message is available in the channel for popping.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>timeout</span>
    <span class='type'>(<code>Numeric</code>)</span>
    <em class='default'>(defaults to: <tt>nil</tt>)</em>
&mdash;    <div class='inline'>
<p>the maximum time in second to wait.</p>
</div>
  </li>
  <li>
    <span class='name'>timeout_value</span>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>)</span>
    <em class='default'>(defaults to: <tt>nil</tt>)</em>
&mdash;    <div class='inline'>
<p>a value returned by the method when it times out</p>
</div>
  </li>
  <li>
    <span class='name'>matcher</span>
    <span class='type'>(#===)</span>
&mdash;    <div class='inline'>
<p>only consider message which matches <code>matcher === a_message</code></p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>, <code>nil</code>)</span>
&mdash;    <div class='inline'>
<p>message or nil when timed out</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L183-L203'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='183' data-end='203'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 183</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_pop_matching'>pop_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout_value'>timeout_value</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='comment'># TODO (pitr-ch 27-Jan-2019): should it try to match pending pushes if it fails to match in the buffer? Maybe only if the size is zero. It could be surprising if it&#39;s used as a throttle it might be expected that it will not pop if buffer is full of messages which di not match, it might it expected it will block until the message is added to the buffer
</span>  <span class='comment'># that it returns even if the buffer is full. User might expect that it has to be in the buffer first.
</span>  <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='ivar'>@Mutex</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_shift_message'><a href="#ns_shift_message-instance_method" title="Concurrent::Promises::Channel#ns_shift_message (method)">ns_shift_message</a></span> <span class='id identifier rubyid_matcher'>matcher</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>==</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span>
      <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_consume_pending_push'><a href="#ns_consume_pending_push-instance_method" title="Concurrent::Promises::Channel#ns_consume_pending_push (method)">ns_consume_pending_push</a></span> <span class='id identifier rubyid_matcher'>matcher</span>
      <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span> <span class='kw'>if</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span>
    <span class='kw'>else</span>
      <span class='id identifier rubyid_new_message'>new_message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_consume_pending_push'><a href="#ns_consume_pending_push-instance_method" title="Concurrent::Promises::Channel#ns_consume_pending_push (method)">ns_consume_pending_push</a></span> <span class='const'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span>
      <span class='ivar'>@Messages</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='id identifier rubyid_new_message'>new_message</span> <span class='kw'>unless</span> <span class='id identifier rubyid_new_message'>new_message</span> <span class='op'>==</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span>
      <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_future'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span>
    <span class='ivar'>@Probes</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='id identifier rubyid_probe'>probe</span><span class='comma'>,</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='id identifier rubyid_matcher'>matcher</span>
    <span class='id identifier rubyid_probe'>probe</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_probe'>probe</span>.<span class='id identifier rubyid_value!'>value!</span>(<span class='id identifier rubyid_timeout'>timeout</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout_value'>timeout_value</span><span class='comma'>,</span> [<span class='kw'>true</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout_value'>timeout_value</span><span class='comma'>,</span> <span class='kw'>nil</span>])
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="pop_op-instance_method">
  <h3 class='signature '>
    #<strong>pop_op</strong>(probe = Promises.resolvable_future)  &#x21d2; <a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a>(<a href="../../Object.html" title="Object (class)">Object</a>) 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns a future witch will become fulfilled with a value from the channel when one is available. If it is later waited on the operation with a timeout e.g.âchannel.pop_op.wait(1)` it will not prevent the channel to fulfill the operation later after the timeout. The operation has to be either processed later â`ruby pop_op = channel.pop_op if pop_op.wait(1)</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'>pop_op</span>.<span class='id identifier rubyid_value'>value</span></code></pre>

<p>else</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'>pop_op</span>.<span class='id identifier rubyid_then'>then</span> { <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> }</code></pre>

<p>end ââ or the operation can be prevented from completion after timing out by using <code>channel.pop_op.wait(1, [true, nil, nil])</code>. It will fulfill the operation on timeout preventing channel from doing the operation, e.g. popping a message.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>probe</span>
    <span class='type'>(<a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a>)</span>
    <em class='default'>(defaults to: <tt>Promises.resolvable_future</tt>)</em>
&mdash;    <div class='inline'>
<p>the future which will be fulfilled with a channel value</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a>(<a href="../../Object.html" title="Object (class)">Object</a>))</span>
&mdash;    <div class='inline'>
<p>the probe, its value will be the message when available.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L160-L162'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='160' data-end='162'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 160</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_pop_op'>pop_op</span>(<span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_future'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span>)
  <span class='ivar'>@Mutex</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> { <span class='id identifier rubyid_ns_pop_op'><a href="#ns_pop_op-instance_method" title="Concurrent::Promises::Channel#ns_pop_op (method)">ns_pop_op</a></span>(<span class='const'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span><span class='comma'>,</span> <span class='kw'>false</span>) }
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="pop_op_matching-instance_method">
  <h3 class='signature '>
    #<strong>pop_op_matching</strong>(matcher, probe = Promises.resolvable_future)  &#x21d2; <a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a>(<a href="../../Object.html" title="Object (class)">Object</a>) 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns a future witch will become fulfilled with a value from the channel when one is available. If it is later waited on the operation with a timeout e.g.âchannel.pop_op.wait(1)` it will not prevent the channel to fulfill the operation later after the timeout. The operation has to be either processed later â`ruby pop_op = channel.pop_op if pop_op.wait(1)</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">pop_op</a></span>.<span class='id identifier rubyid_value'>value</span></code></pre>

<p>else</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">pop_op</a></span>.<span class='id identifier rubyid_then'>then</span> { <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> }</code></pre>

<p>end ââ or the operation can be prevented from completion after timing out by using <code>channel.pop_op.wait(1, [true, nil, nil])</code>. It will fulfill the operation on timeout preventing channel from doing the operation, e.g. popping a message.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>probe</span>
    <span class='type'>(<a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a>)</span>
    <em class='default'>(defaults to: <tt>Promises.resolvable_future</tt>)</em>
&mdash;    <div class='inline'>
<p>the future which will be fulfilled with a channel value</p>
</div>
  </li>
  <li>
    <span class='name'>matcher</span>
    <span class='type'>(#===)</span>
&mdash;    <div class='inline'>
<p>only consider message which matches <code>matcher === a_message</code></p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="Future.html" title="Concurrent::Promises::Future (class)">Future</a>(<a href="../../Object.html" title="Object (class)">Object</a>))</span>
&mdash;    <div class='inline'>
<p>the probe, its value will be the message when available.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L166-L168'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='166' data-end='168'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 166</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_pop_op_matching'>pop_op_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_future'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span>)
  <span class='ivar'>@Mutex</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> { <span class='id identifier rubyid_ns_pop_op'><a href="#ns_pop_op-instance_method" title="Concurrent::Promises::Channel#ns_pop_op (method)">ns_pop_op</a></span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span><span class='comma'>,</span> <span class='kw'>false</span>) }
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="push-instance_method">
  <h3 class='signature '>
    #<strong>push</strong>(message, timeout = nil)  &#x21d2; <code>self</code>, ... 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'>
<p>This function potentially blocks current thread until it can continue. Be careful it can deadlock.</p>
</div>
  </div>


<p>Blocks current thread until the message is pushed into the channel.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>message</span>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>)</span>
  </li>
  <li>
    <span class='name'>timeout</span>
    <span class='type'>(<code>Numeric</code>)</span>
    <em class='default'>(defaults to: <tt>nil</tt>)</em>
&mdash;    <div class='inline'>
<p>the maximum time in second to wait.</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>self</code>, <code>true</code>, <code>false</code>)</span>
&mdash;    <div class='inline'>
<p>self implies timeout was not used, true implies timeout was used and it was pushed, false implies it was not pushed within timeout.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L120-L132'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='120' data-end='132'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 120</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_push'>push</span>(<span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='id identifier rubyid_pushed_op'>pushed_op</span> <span class='op'>=</span> <span class='ivar'>@Mutex</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>?</span> <span class='kw'>true</span> <span class='op'>:</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='id identifier rubyid_ns_try_push'><a href="#ns_try_push-instance_method" title="Concurrent::Promises::Channel#ns_try_push (method)">ns_try_push</a></span>(<span class='id identifier rubyid_message'>message</span>)

    <span class='id identifier rubyid_pushed'>pushed</span> <span class='op'>=</span> <span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_future'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span>
    <span class='comment'># TODO (pitr-ch 06-Jan-2019): clear timed out pushes in @PendingPush, null messages
</span>    <span class='ivar'>@PendingPush</span>.<span class='id identifier rubyid_push'>push</span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_pushed'>pushed</span>
    <span class='id identifier rubyid_pushed'>pushed</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='id identifier rubyid_pushed_op'>pushed_op</span>.<span class='id identifier rubyid_wait!'>wait!</span>(<span class='id identifier rubyid_timeout'>timeout</span><span class='comma'>,</span> [<span class='kw'>true</span><span class='comma'>,</span> <span class='kw'>self</span><span class='comma'>,</span> <span class='kw'>nil</span>])
  <span class='id identifier rubyid_result'>result</span> <span class='op'>==</span> <span class='id identifier rubyid_pushed_op'>pushed_op</span> <span class='op'>?</span> <span class='kw'>self</span> <span class='op'>:</span> <span class='id identifier rubyid_result'>result</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="push_op-instance_method">
  <h3 class='signature '>
    #<strong>push_op</strong>(message)  &#x21d2; <a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a>(<code>self</code>) 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns future which will fulfill when the message is pushed to the channel. If it is later waited on the operation with a timeout e.g.âchannel.pop_op.wait(1)` it will not prevent the channel to fulfill the operation later after the timeout. The operation has to be either processed later â`ruby pop_op = channel.pop_op if pop_op.wait(1)</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">pop_op</a></span>.<span class='id identifier rubyid_value'>value</span></code></pre>

<p>else</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">pop_op</a></span>.<span class='id identifier rubyid_then'>then</span> { <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> }</code></pre>

<p>end ââ or the operation can be prevented from completion after timing out by using <code>channel.pop_op.wait(1, [true, nil, nil])</code>. It will fulfill the operation on timeout preventing channel from doing the operation, e.g. popping a message.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>message</span>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>)</span>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L101-L111'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='101' data-end='111'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 101</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_push_op'>push_op</span>(<span class='id identifier rubyid_message'>message</span>)
  <span class='ivar'>@Mutex</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_ns_try_push'><a href="#ns_try_push-instance_method" title="Concurrent::Promises::Channel#ns_try_push (method)">ns_try_push</a></span>(<span class='id identifier rubyid_message'>message</span>)
      <span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_fulfilled_future'><a href="FactoryMethods.html#fulfilled_future-instance_method" title="Concurrent::Promises::FactoryMethods#fulfilled_future (method)">fulfilled_future</a></span> <span class='kw'>self</span>
    <span class='kw'>else</span>
      <span class='id identifier rubyid_pushed'>pushed</span> <span class='op'>=</span> <span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_future'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span>
      <span class='ivar'>@PendingPush</span>.<span class='id identifier rubyid_push'><a href="#push-instance_method" title="Concurrent::Promises::Channel#push (method)">push</a></span> <span class='id identifier rubyid_message'>message</span><span class='comma'>,</span> <span class='id identifier rubyid_pushed'>pushed</span>
      <span class='kw'>return</span> <span class='id identifier rubyid_pushed'>pushed</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="select-instance_method">
  <h3 class='signature '>
    #<strong>select</strong>(channels, timeout = nil)  &#x21d2; <code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>)<sup>?</sup> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'>
<p>This function potentially blocks current thread until it can continue. Be careful it can deadlock.</p>
</div>
  </div>


<p>As <a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a> but does not return future, it block current thread instead until there is a message available in the receiver or in any of the channels.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>channels</span>
    <span class='type'>(<code>Channel</code>, <code>::Array</code>&lt;<code>Channel</code>&gt;)</span>
  </li>
  <li>
    <span class='name'>timeout</span>
    <span class='type'>(<code>Numeric</code>)</span>
    <em class='default'>(defaults to: <tt>nil</tt>)</em>
&mdash;    <div class='inline'>
<p>the maximum time in second to wait.</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>), <code>nil</code>)</span>
&mdash;    <div class='inline'>
<p>message or nil when timed out</p>
</div>
  </li>
</ul>
  <p class='tag_title'>See Also:</p>
  <ul class='see'>
      <li><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></li>
      </ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L278-L280'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='278' data-end='280'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 278</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_select'>select</span>(<span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='id identifier rubyid_select_matching'><a href="#select_matching-class_method" title="Concurrent::Promises::Channel.select_matching (method)">select_matching</a></span> <span class='const'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="select_matching-instance_method">
  <h3 class='signature '>
    #<strong>select_matching</strong>(matcher, channels, timeout = nil)  &#x21d2; <code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>)<sup>?</sup> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'>
<p>This function potentially blocks current thread until it can continue. Be careful it can deadlock.</p>
</div>
  </div>


<p>As <a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a> but does not return future, it block current thread instead until there is a message available in the receiver or in any of the channels.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>channels</span>
    <span class='type'>(<code>Channel</code>, <code>::Array</code>&lt;<code>Channel</code>&gt;)</span>
  </li>
  <li>
    <span class='name'>timeout</span>
    <span class='type'>(<code>Numeric</code>)</span>
    <em class='default'>(defaults to: <tt>nil</tt>)</em>
&mdash;    <div class='inline'>
<p>the maximum time in second to wait.</p>
</div>
  </li>
  <li>
    <span class='name'>matcher</span>
    <span class='type'>(#===)</span>
&mdash;    <div class='inline'>
<p>only consider message which matches <code>matcher === a_message</code></p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>), <code>nil</code>)</span>
&mdash;    <div class='inline'>
<p>message or nil when timed out</p>
</div>
  </li>
</ul>
  <p class='tag_title'>See Also:</p>
  <ul class='see'>
      <li><a href="#select_op-instance_method" title="Concurrent::Promises::Channel#select_op (method)">#select_op</a></li>
      </ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L284-L287'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='284' data-end='287'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 284</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_select_matching'>select_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='id identifier rubyid_select_op_matching'><a href="#select_op_matching-class_method" title="Concurrent::Promises::Channel.select_op_matching (method)">select_op_matching</a></span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span>)
  <span class='id identifier rubyid_probe'>probe</span>.<span class='id identifier rubyid_value!'>value!</span>(<span class='id identifier rubyid_timeout'>timeout</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> [<span class='kw'>true</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='kw'>nil</span>])
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="select_op-instance_method">
  <h3 class='signature '>
    #<strong>select_op</strong>(channels, probe = Promises.resolvable_future)  &#x21d2; <a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a>(<code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>)) 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>When message is available in the receiver or any of the provided channels the future is fulfilled with a channel message pair. The returned channel is the origin of the message. If it is later waited on the operation with a timeout e.g.âchannel.pop_op.wait(1)` it will not prevent the channel to fulfill the operation later after the timeout. The operation has to be either processed later â`ruby pop_op = channel.pop_op if pop_op.wait(1)</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">pop_op</a></span>.<span class='id identifier rubyid_value'>value</span></code></pre>

<p>else</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">pop_op</a></span>.<span class='id identifier rubyid_then'>then</span> { <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> }</code></pre>

<p>end ââ or the operation can be prevented from completion after timing out by using <code>channel.pop_op.wait(1, [true, nil, nil])</code>. It will fulfill the operation on timeout preventing channel from doing the operation, e.g. popping a message.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>channels</span>
    <span class='type'>(<code>Channel</code>, <code>::Array</code>&lt;<code>Channel</code>&gt;)</span>
  </li>
  <li>
    <span class='name'>probe</span>
    <span class='type'>(<a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a>)</span>
    <em class='default'>(defaults to: <tt>Promises.resolvable_future</tt>)</em>
&mdash;    <div class='inline'>
<p>the future which will be fulfilled with the message</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a>(<code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>)))</span>
&mdash;    <div class='inline'>
<p>a future which is fulfilled with pair [channel, message] when one of the channels is available for reading</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L257-L259'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='257' data-end='259'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 257</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_select_op'>select_op</span>(<span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_future'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span>)
  <span class='id identifier rubyid_select_op_matching'><a href="#select_op_matching-class_method" title="Concurrent::Promises::Channel.select_op_matching (method)">select_op_matching</a></span> <span class='const'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="select_op_matching-instance_method">
  <h3 class='signature '>
    #<strong>select_op_matching</strong>(matcher, channels, probe = Promises.resolvable_future)  &#x21d2; <a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a>(<code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>)) 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>When message is available in the receiver or any of the provided channels the future is fulfilled with a channel message pair. The returned channel is the origin of the message. If it is later waited on the operation with a timeout e.g.âchannel.pop_op.wait(1)` it will not prevent the channel to fulfill the operation later after the timeout. The operation has to be either processed later â`ruby pop_op = channel.pop_op if pop_op.wait(1)</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_process_message'>process_message</span> <span class='id identifier rubyid_pop_op'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">pop_op</a></span>.<span class='id identifier rubyid_value'>value</span></code></pre>

<p>else</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pop_op'><a href="#pop_op-instance_method" title="Concurrent::Promises::Channel#pop_op (method)">pop_op</a></span>.<span class='id identifier rubyid_then'>then</span> { <span class='op'>|</span><span class='id identifier rubyid_message'>message</span><span class='op'>|</span> <span class='id identifier rubyid_log_unprocessed_message'>log_unprocessed_message</span> <span class='id identifier rubyid_message'>message</span> }</code></pre>

<p>end ââ or the operation can be prevented from completion after timing out by using <code>channel.pop_op.wait(1, [true, nil, nil])</code>. It will fulfill the operation on timeout preventing channel from doing the operation, e.g. popping a message.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>channels</span>
    <span class='type'>(<code>Channel</code>, <code>::Array</code>&lt;<code>Channel</code>&gt;)</span>
  </li>
  <li>
    <span class='name'>probe</span>
    <span class='type'>(<a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a>)</span>
    <em class='default'>(defaults to: <tt>Promises.resolvable_future</tt>)</em>
&mdash;    <div class='inline'>
<p>the future which will be fulfilled with the message</p>
</div>
  </li>
  <li>
    <span class='name'>matcher</span>
    <span class='type'>(#===)</span>
&mdash;    <div class='inline'>
<p>only consider message which matches <code>matcher === a_message</code></p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="ResolvableFuture.html" title="Concurrent::Promises::ResolvableFuture (class)">ResolvableFuture</a>(<code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>)))</span>
&mdash;    <div class='inline'>
<p>a future which is fulfilled with pair [channel, message] when one of the channels is available for reading</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L263-L266'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='263' data-end='266'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 263</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_select_op_matching'>select_op_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> <span class='op'>=</span> <span class='const'><a href="../Promises.html" title="Concurrent::Promises (module)">Promises</a></span>.<span class='id identifier rubyid_resolvable_future'><a href="FactoryMethods.html#resolvable_future-instance_method" title="Concurrent::Promises::FactoryMethods#resolvable_future (method)">resolvable_future</a></span>)
  [<span class='kw'>self</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_channels'>channels</span>].<span class='id identifier rubyid_each'>each</span> { <span class='op'>|</span><span class='id identifier rubyid_ch'>ch</span><span class='op'>|</span> <span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_partial_select_op'><a href="#partial_select_op-instance_method" title="Concurrent::Promises::Channel#partial_select_op (method)">partial_select_op</a></span> <span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_probe'>probe</span> }
  <span class='id identifier rubyid_probe'>probe</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="size-instance_method">
  <h3 class='signature '>
    #<strong>size</strong>  &#x21d2; <code>Integer</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Integer</code>)</span>
&mdash;    <div class='inline'>
<p>The number of messages currently stored in the channel.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L290-L292'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='290' data-end='292'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 290</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_size'>size</span>
  <span class='ivar'>@Mutex</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> { <span class='ivar'>@Messages</span>.<span class='id identifier rubyid_size'>size</span> }
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="to_s-instance_method">
  <h3 class='signature '>
    #<strong>to_s</strong>  &#x21d2; <code>String</code> 
    <span class='aliases'>Also known as: <span class='names'>#inspect</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>String</code>)</span>
&mdash;    <div class='inline'>
<p>Short string representation.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L300-L302'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='300' data-end='302'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 300</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_to_s'>to_s</span>
  <span class='id identifier rubyid_format'>format</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>%s capacity taken %s of %s&gt;</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='kw'>super</span>[<span class='int'>0</span><span class='op'>..</span><span class='op'>-</span><span class='int'>2</span>]<span class='comma'>,</span> <span class='id identifier rubyid_size'><a href="#size-instance_method" title="Concurrent::Promises::Channel#size (method)">size</a></span><span class='comma'>,</span> <span class='ivar'>@Capacity</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="try_pop-instance_method">
  <h3 class='signature '>
    #<strong>try_pop</strong>(no_value = nil)  &#x21d2; <a href="../../Object.html" title="Object (class)">Object</a>, <code>no_value</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Pop a message from the channel if there is one available.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>no_value</span>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>)</span>
    <em class='default'>(defaults to: <tt>nil</tt>)</em>
&mdash;    <div class='inline'>
<p>returned when there is no message available</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>, <code>no_value</code>)</span>
&mdash;    <div class='inline'>
<p>message or nil when there is no message</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L138-L140'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='138' data-end='140'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 138</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_try_pop'>try_pop</span>(<span class='id identifier rubyid_no_value'>no_value</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='id identifier rubyid_try_pop_matching'><a href="#try_pop_matching-instance_method" title="Concurrent::Promises::Channel#try_pop_matching (method)">try_pop_matching</a></span> <span class='const'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span><span class='comma'>,</span> <span class='id identifier rubyid_no_value'>no_value</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="try_pop_matching-instance_method">
  <h3 class='signature '>
    #<strong>try_pop_matching</strong>(matcher, no_value = nil)  &#x21d2; <a href="../../Object.html" title="Object (class)">Object</a>, <code>no_value</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Pop a message from the channel if there is one available.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>no_value</span>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>)</span>
    <em class='default'>(defaults to: <tt>nil</tt>)</em>
&mdash;    <div class='inline'>
<p>returned when there is no message available</p>
</div>
  </li>
  <li>
    <span class='name'>matcher</span>
    <span class='type'>(#===)</span>
&mdash;    <div class='inline'>
<p>only consider message which matches <code>matcher === a_message</code></p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>, <code>no_value</code>)</span>
&mdash;    <div class='inline'>
<p>message or nil when there is no message</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L145-L152'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='145' data-end='152'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 145</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_try_pop_matching'>try_pop_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_no_value'>no_value</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='ivar'>@Mutex</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_shift_message'><a href="#ns_shift_message-instance_method" title="Concurrent::Promises::Channel#ns_shift_message (method)">ns_shift_message</a></span> <span class='id identifier rubyid_matcher'>matcher</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span> <span class='kw'>if</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ns_consume_pending_push'><a href="#ns_consume_pending_push-instance_method" title="Concurrent::Promises::Channel#ns_consume_pending_push (method)">ns_consume_pending_push</a></span> <span class='id identifier rubyid_matcher'>matcher</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span> <span class='op'>?</span> <span class='id identifier rubyid_message'>message</span> <span class='op'>:</span> <span class='id identifier rubyid_no_value'>no_value</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="try_push-instance_method">
  <h3 class='signature '>
    #<strong>try_push</strong>(message)  &#x21d2; <code>true</code>, <code>false</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Push the message into the channel if there is space available.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>message</span>
    <span class='type'>(<a href="../../Object.html" title="Object (class)">Object</a>)</span>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L77-L79'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='77' data-end='79'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 77</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_try_push'>try_push</span>(<span class='id identifier rubyid_message'>message</span>)
  <span class='ivar'>@Mutex</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> { <span class='id identifier rubyid_ns_try_push'><a href="#ns_try_push-instance_method" title="Concurrent::Promises::Channel#ns_try_push (method)">ns_try_push</a></span>(<span class='id identifier rubyid_message'>message</span>) }
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="try_select-instance_method">
  <h3 class='signature '>
    #<strong>try_select</strong>(channels)  &#x21d2; <code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>)<sup>?</sup> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>If message is available in the receiver or any of the provided channels the channel message pair is returned. If there is no message nil is returned. The returned channel is the origin of the message.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>channels</span>
    <span class='type'>(<code>Channel</code>, <code>::Array</code>&lt;<code>Channel</code>&gt;)</span>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>), <code>nil</code>)</span>
&mdash;    <div class='inline'>
<p>pair [channel, message] if one of the channels is available for reading</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L232-L234'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='232' data-end='234'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 232</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_try_select'>try_select</span>(<span class='id identifier rubyid_channels'>channels</span>)
  <span class='id identifier rubyid_try_select_matching'><a href="#try_select_matching-class_method" title="Concurrent::Promises::Channel.try_select_matching (method)">try_select_matching</a></span> <span class='const'><a href="#ANY-constant" title="Concurrent::Promises::Channel::ANY (constant)">ANY</a></span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="try_select_matching-instance_method">
  <h3 class='signature '>
    #<strong>try_select_matching</strong>(matcher, channels)  &#x21d2; <code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>)<sup>?</sup> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>If message is available in the receiver or any of the provided channels the channel message pair is returned. If there is no message nil is returned. The returned channel is the origin of the message.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>channels</span>
    <span class='type'>(<code>Channel</code>, <code>::Array</code>&lt;<code>Channel</code>&gt;)</span>
  </li>
  <li>
    <span class='name'>matcher</span>
    <span class='type'>(#===)</span>
&mdash;    <div class='inline'>
<p>only consider message which matches <code>matcher === a_message</code></p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>::Array</code>(<code>Channel</code>, <a href="../../Object.html" title="Object (class)">Object</a>), <code>nil</code>)</span>
&mdash;    <div class='inline'>
<p>pair [channel, message] if one of the channels is available for reading</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/channel.rb#L238-L245'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='238' data-end='245'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/channel.rb', line 238</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_try_select_matching'>try_select_matching</span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='id identifier rubyid_channels'>channels</span>)
  <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='kw'>nil</span>
  <span class='id identifier rubyid_channel'>channel</span> <span class='op'>=</span> [<span class='kw'>self</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_channels'>channels</span>].<span class='id identifier rubyid_find'>find</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ch'>ch</span><span class='op'>|</span>
    <span class='id identifier rubyid_message'>message</span> <span class='op'>=</span> <span class='id identifier rubyid_ch'>ch</span>.<span class='id identifier rubyid_try_pop_matching'><a href="#try_pop_matching-instance_method" title="Concurrent::Promises::Channel#try_pop_matching (method)">try_pop_matching</a></span>(<span class='id identifier rubyid_matcher'>matcher</span><span class='comma'>,</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span>)
    <span class='id identifier rubyid_message'>message</span> <span class='op'>!=</span> <span class='const'><a href="#NOTHING-constant" title="Concurrent::Promises::Channel::NOTHING (constant)">NOTHING</a></span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_channel'>channel</span> <span class='op'>?</span> [<span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_message'>message</span>] <span class='op'>:</span> <span class='kw'>nil</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>