<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Module: Concurrent::ErlangActor &mdash; Concurrent RubyÂ master</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Concurrent::ErlangActor",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../'>Concurrent</a> &raquo; 
      <a href='../_index.html#alpha_E'>Index (E)</a> &raquo; 
        <a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>ErlangActor&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='module'>
<h1>Module: Concurrent::ErlangActor</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Namespace Children</td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Modules:</div>
      <div class='box_11'>
          <a href="ErlangActor/EnvironmentConstants.html" title="Concurrent::ErlangActor::EnvironmentConstants (module)"><code>EnvironmentConstants</code></a>,
        <a href="ErlangActor/FunctionShortcuts.html" title="Concurrent::ErlangActor::FunctionShortcuts (module)"><code>FunctionShortcuts</code></a>,
        <a href="ErlangActor/Functions.html" title="Concurrent::ErlangActor::Functions (module)"><code>Functions</code></a>,
        <a href="ErlangActor/HasFrom.html" title="Concurrent::ErlangActor::HasFrom (module)"><code>HasFrom</code></a>,
        <a href="ErlangActor/HasReason.html" title="Concurrent::ErlangActor::HasReason (module)"><code>HasReason</code></a>,
        <a href="ErlangActor/HasReference.html" title="Concurrent::ErlangActor::HasReference (module)"><code>HasReference</code></a>      </div>
    </td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Classes:</div>
      <div class='box_11'>
          <a href="ErlangActor/AbstractActor.html" title="Concurrent::ErlangActor::AbstractActor (class)"><code>AbstractActor</code></a>,
        <a href="ErlangActor/AbstractSignal.html" title="Concurrent::ErlangActor::AbstractSignal (class)"><code>AbstractSignal</code></a>,
        <a href="ErlangActor/Ask.html" title="Concurrent::ErlangActor::Ask (class)"><code>Ask</code></a>,
        <a href="ErlangActor/DeMonitor.html" title="Concurrent::ErlangActor::DeMonitor (class)"><code>DeMonitor</code></a>,
        <a href="ErlangActor/Down.html" title="Concurrent::ErlangActor::Down (class)"><code>Down</code></a>,
        <a href="ErlangActor/DownSignal.html" title="Concurrent::ErlangActor::DownSignal (class)"><code>DownSignal</code></a>,
        <a href="ErlangActor/Environment.html" title="Concurrent::ErlangActor::Environment (class)"><code>Environment</code></a>,
        <a href="ErlangActor/Error.html" title="Concurrent::ErlangActor::Error (class)"><code>Error</code></a>,
        <a href="ErlangActor/Kill.html" title="Concurrent::ErlangActor::Kill (class)"><code>Kill</code></a>,
        <a href="ErlangActor/Link.html" title="Concurrent::ErlangActor::Link (class)"><code>Link</code></a>,
        <a href="ErlangActor/Monitor.html" title="Concurrent::ErlangActor::Monitor (class)"><code>Monitor</code></a>,
        <a href="ErlangActor/NoActor.html" title="Concurrent::ErlangActor::NoActor (class)"><code>NoActor</code></a>,
        <a href="ErlangActor/NoReply.html" title="Concurrent::ErlangActor::NoReply (class)"><code>NoReply</code></a>,
        <a href="ErlangActor/OnPool.html" title="Concurrent::ErlangActor::OnPool (class)"><code>OnPool</code></a>,
        <a href="ErlangActor/OnThread.html" title="Concurrent::ErlangActor::OnThread (class)"><code>OnThread</code></a>,
        <a href="ErlangActor/Pid.html" title="Concurrent::ErlangActor::Pid (class)"><code>Pid</code></a>,
        <a href="ErlangActor/Reference.html" title="Concurrent::ErlangActor::Reference (class)"><code>Reference</code></a>,
        <a href="ErlangActor/Run.html" title="Concurrent::ErlangActor::Run (class)"><code>Run</code></a>,
        <a href="ErlangActor/Terminate_.html" title="Concurrent::ErlangActor::Terminate (class)"><code>Terminate</code></a>,
        <a href="ErlangActor/Terminated.html" title="Concurrent::ErlangActor::Terminated (class)"><code>Terminated</code></a>,
        <a href="ErlangActor/Token.html" title="Concurrent::ErlangActor::Token (class)"><code>Token</code></a>,
        <a href="ErlangActor/UnLink.html" title="Concurrent::ErlangActor::UnLink (class)"><code>UnLink</code></a>      </div>
    </td></tr>
    <tr><td class='box_h' colspan='2'>Super Chains via Extension / Inclusion / Inheritance</td></tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Class Chain:</div>
        <div class='box_22'>
          self,
          <a href="Concern/Logging.html" title="Concurrent::Concern::Logging (module)"><code>Concern::Logging</code></a>,
          <a href="ErlangActor/FunctionShortcuts.html" title="Concurrent::ErlangActor::FunctionShortcuts (module)"><code>FunctionShortcuts</code></a>,
          <a href="ErlangActor/Functions.html" title="Concurrent::ErlangActor::Functions (module)"><code>Functions</code></a>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Instance Chain:</div>
        <div class='box_22'>
          self,
          <a href="ErlangActor/EnvironmentConstants.html" title="Concurrent::ErlangActor::EnvironmentConstants (module)"><code>EnvironmentConstants</code></a>
        </div>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb#L15'>lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb</a>      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'>
<p>**Edge Features** are under active development and may change frequently.</p>
<ul><li>
<p>Deprecations are not added before incompatible changes.</p>
</li><li>
<p><a href="Edge.html" title="Concurrent::Edge (module)"><code>Edge</code></a> version: <em>major</em> is always 0, <em>minor</em> bump means incompatible change, <em>patch</em> bump means compatible change.</p>
</li><li>
<p><a href="Edge.html" title="Concurrent::Edge (module)"><code>Edge</code></a> features may also lack tests and documentation.</p>
</li><li>
<p>Features developed in <code>concurrent-ruby-edge</code> are expected to move to <code>concurrent-ruby</code> when finalised.</p>
</li></ul>
</div>
  </div>


<p>This module provides actor abstraction that has same behaviour as Erlang actor.</p>

<p>==== Examples</p>

<p>The simplest example is to use the actor as an asynchronous execution.
Although, <code>Promises.future { 1 + 1 }</code> is better suited for that purpose.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.spawn(type: :on_thread, name: &#39;addition&#39;) { 1 + 1 }
=== =&gt; #&lt;Concurrent::ErlangActor::Pid:0x000002 addition running&gt;
actor.terminated.value!                  # =&gt; 2</span></code></pre>

<p>Let&#39;s send some messages and maintain some internal state 
which is what actors are good for.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.spawn(type: :on_thread, name: &#39;sum&#39;) do
  sum = 0 # internal state
  # receive and sum the messages until the actor gets :done
  while true
    message = receive
    break if message == :done
    # if the message is asked and not only told, 
    # reply with the current sum (has no effect if actor was not asked)
    reply sum += message   
  end
  # The final value of the actor
  sum
end
=== =&gt; #&lt;Concurrent::ErlangActor::Pid:0x000003 sum running&gt;</span></code></pre>

<p>The actor can be either told a message asynchronously, 
or asked. The ask method will block until actor replies.</p>

<pre class="code ruby"><code class="ruby"><span class='op'>===</span> <span class='id identifier rubyid_tell'>tell</span> <span class='id identifier rubyid_returns'>returns</span> <span class='id identifier rubyid_immediately'>immediately</span> <span class='id identifier rubyid_returning'>returning</span> <span class='id identifier rubyid_the'>the</span> <span class='id identifier rubyid_actor'>actor</span> 
<span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_tell'>tell</span>(<span class='int'>1</span>).<span class='id identifier rubyid_tell'>tell</span>(<span class='int'>1</span>)
<span class='op'>===</span> <span class='op'>=&gt;</span> <span class='comment'>#&lt;Concurrent::ErlangActor::Pid:0x000003 sum running&gt;
</span><span class='op'>===</span> <span class='id identifier rubyid_blocks'>blocks</span><span class='comma'>,</span> <span class='id identifier rubyid_waiting'>waiting</span> <span class='kw'>for</span> <span class='id identifier rubyid_the'>the</span> <span class='id identifier rubyid_answer'>answer</span> 
<span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_ask'>ask</span> <span class='int'>10</span>                             <span class='comment'># =&gt; 12
</span><span class='op'>===</span> <span class='id identifier rubyid_stop'>stop</span> <span class='id identifier rubyid_the'>the</span> <span class='id identifier rubyid_actor'>actor</span>
<span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_tell'>tell</span> <span class='symbeg'>:</span><span class='id identifier rubyid_done'>done</span>
<span class='op'>===</span> <span class='op'>=&gt;</span> <span class='comment'>#&lt;Concurrent::ErlangActor::Pid:0x000003 sum running&gt;
</span><span class='op'>===</span> <span class='const'>The</span> <span class='id identifier rubyid_final'>final</span> <span class='id identifier rubyid_value'>value</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_the'>the</span> <span class='id identifier rubyid_actor'>actor</span> 
<span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_terminated'>terminated</span>.<span class='id identifier rubyid_value!'>value!</span>                  <span class='comment'># =&gt; 12</span></code></pre>

<p>===== Actor types</p>

<p>There are two types of actors. 
The type is specified when calling spawn as a first argument, 
<code>Concurrent::ErlangActor.spawn(type: :on_thread, ...</code> or 
<code>Concurrent::ErlangActor.spawn(type: :on_pool, ...</code>.</p>

<p>The main difference is in how receive method returns.</p>

<ul>
<li><p><code>:on_thread</code> it blocks the thread until message is available, 
then it returns or calls the provided block first. </p></li>
<li><p>However, <code>:on_pool</code> it has to free up the thread on the receive 
call back to the pool. Therefore the call to receive ends the 
execution of current scope. The receive has to be given block
or blocks that act as a continuations and are called 
when there is message available.</p></li>
</ul>

<p>Let&#39;s have a look at how the bodies of actors differ between the types:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ping'>ping</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.spawn(type: :on_thread) { reply receive }
=== =&gt; #&lt;Concurrent::ErlangActor::Pid:0x000004 running&gt;
ping.ask 42                              # =&gt; 42</span></code></pre>

<p>It first calls receive, which blocks the thread of the actor. 
When it returns the received message is passed an an argument to reply,
which replies the same value back to the ask method. 
Then the actor terminates normally, because there is nothing else to do.</p>

<p>However when running on pool a block with code which should be evaluated 
after the message is received has to be provided. </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ping'>ping</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.spawn(type: :on_pool) { receive { |m| reply m } }
=== =&gt; #&lt;Concurrent::ErlangActor::Pid:0x000005 running&gt;
ping.ask 42                              # =&gt; 42</span></code></pre>

<p>It starts by calling receive which will remember the given block for later
execution when a message is available and stops executing the current scope.
Later when a message becomes available the previously provided block is given
the message and called. The result of the block is the final value of the 
normally terminated actor.</p>

<p>The direct blocking style of <code>:on_thread</code> is simpler to write and more straight
forward however it has limitations. Each <code>:on_thread</code> actor creates a Thread 
taking time and resources. 
There is also a limited number of threads the Ruby process can create 
so you may hit the limit and fail to create more threads and therefore actors.  </p>

<p>Since the <code>:on_pool</code> actor runs on a poll of threads, its creations 
is faster and cheaper and it does not create new threads. 
Therefore there is no limit (only RAM) on how many actors can be created.</p>

<p>To simplify, if you need only few actors <code>:on_thread</code> is fine. 
However if you will be creating hundreds of actors or 
they will be short-lived <code>:on_pool</code> should be used.      </p>

<p>===== Receiving messages</p>

<p>Simplest message receive.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.spawn(type: :on_thread) { receive }
=== =&gt; #&lt;Concurrent::ErlangActor::Pid:0x000006 running&gt;
actor.tell :m
=== =&gt; #&lt;Concurrent::ErlangActor::Pid:0x000006 running&gt;
actor.terminated.value!                  # =&gt; :m</span></code></pre>

<p>which also works for actor on pool, 
because if no block is given it will use a default block <code>{ |v| v }</code> </p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.spawn(type: :on_pool) { receive { |v| v } }
=== =&gt; #&lt;Concurrent::ErlangActor::Pid:0x000007 running&gt;
=== can simply be following
actor = &lt;code&gt;ErlangActor&lt;</span><span class='regexp_end'>/code</span></span><span class='op'>&gt;</span>.<span class='id identifier rubyid_spawn'>spawn</span>(<span class='label'>type:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_pool'>on_pool</span>) { <span class='id identifier rubyid_receive'>receive</span> }
<span class='op'>===</span> <span class='op'>=&gt;</span> <span class='comment'>#&lt;Concurrent::ErlangActor::Pid:0x000008 running&gt;
</span><span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_tell'>tell</span> <span class='symbeg'>:</span><span class='id identifier rubyid_m'>m</span>
<span class='op'>===</span> <span class='op'>=&gt;</span> <span class='comment'>#&lt;Concurrent::ErlangActor::Pid:0x000008 running&gt;
</span><span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_terminated'>terminated</span>.<span class='id identifier rubyid_value!'>value!</span>                  <span class='comment'># =&gt; :m</span></code></pre>

<p>The received message type can be limited.</p>

<pre class="code ruby"><code class="ruby"><span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.
  spawn(type: :on_thread) { receive(Numeric).succ }.
  tell(&#39;junk&#39;). # ignored message
  tell(42).
  terminated.value!                      # =&gt; 43</span></code></pre>

<p>On pool it requires a block.</p>

<pre class="code ruby"><code class="ruby"><span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.
  spawn(type: :on_pool) { receive(Numeric) { |v| v.succ } }.
  tell(&#39;junk&#39;). # ignored message
  tell(42).
  terminated.value!                      # =&gt; 43</span></code></pre>

<p>By the way, the body written for on pool actor will work for on thread actor 
as well. </p>

<pre class="code ruby"><code class="ruby"><span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.
  spawn(type: :on_thread) { receive(Numeric) { |v| v.succ } }.
  tell(&#39;junk&#39;). # ignored message
  tell(42).
  terminated.value!                      # =&gt; 43</span></code></pre>

<p>The <code>receive</code> method can be also used to dispatch based on the received message.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.spawn(type: :on_thread) do
  while true
    receive(on(Symbol) { |s| reply s.to_s },
            on(And[Numeric, -&gt; v { v &gt;= 0 }]) { |v| reply v.succ },
            # put last works as else
            on(ANY) do |v| 
              reply :bad_message
              terminate [:bad_message, v]
            end)            
  end 
end
=== =&gt; #&lt;Concurrent::ErlangActor::Pid:0x000009 running&gt;
actor.ask 1                              # =&gt; 2
actor.ask 2                              # =&gt; 3
actor.ask :value                         # =&gt; &quot;value&quot;
=== this malformed message will terminate the actor
actor.ask -1                             # =&gt; :bad_message
=== the actor is no longer alive, so ask fails
actor.ask &quot;junk&quot; rescue $!
=== =&gt; #&lt;Concurrent::ErlangActor::NoActor: #&lt;Concurrent::ErlangActor::Pid:0x000009 terminated because of [:bad_message, -1]&gt;&gt;
actor.terminated.result                  # =&gt; [false, nil, [:bad_message, -1]]</span></code></pre>

<p>And a same thing for the actor on pool. 
Since it cannot loop it will call the body method repeatedly.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>module</span> <span class='const'>Behaviour</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_body'>body</span>
    <span class='id identifier rubyid_receive'>receive</span>(<span class='id identifier rubyid_on'>on</span>(<span class='const'>Symbol</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_s'>s</span><span class='op'>|</span> 
              <span class='id identifier rubyid_reply'>reply</span> <span class='id identifier rubyid_s'>s</span>.<span class='id identifier rubyid_to_s'>to_s</span> 
              <span class='id identifier rubyid_body'>body</span> <span class='comment'># call again  
</span>            <span class='kw'>end</span><span class='comma'>,</span>
            <span class='id identifier rubyid_on'>on</span>(<span class='const'><a href="ErlangActor/EnvironmentConstants/And.html" title="Concurrent::ErlangActor::EnvironmentConstants::And (class)">And</a></span>[<span class='const'>Numeric</span><span class='comma'>,</span> <span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_v'>v</span> <span class='tlambeg'>{</span> <span class='id identifier rubyid_v'>v</span> <span class='op'>&gt;=</span> <span class='int'>0</span> }]) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span> 
              <span class='id identifier rubyid_reply'>reply</span> <span class='id identifier rubyid_v'>v</span>.<span class='id identifier rubyid_succ'>succ</span>
              <span class='id identifier rubyid_body'>body</span> <span class='comment'># call again 
</span>            <span class='kw'>end</span><span class='comma'>,</span>
            <span class='comment'># put last works as else
</span>            <span class='id identifier rubyid_on'>on</span>(<span class='const'><a href="ErlangActor/EnvironmentConstants.html#ANY-constant" title="Concurrent::ErlangActor::EnvironmentConstants::ANY (constant)">ANY</a></span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span> 
              <span class='id identifier rubyid_reply'>reply</span> <span class='symbeg'>:</span><span class='id identifier rubyid_bad_message'>bad_message</span>
              <span class='id identifier rubyid_terminate'>terminate</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_bad_message'>bad_message</span><span class='comma'>,</span> <span class='id identifier rubyid_v'>v</span>]
            <span class='kw'>end</span>)  
  <span class='kw'>end</span>
<span class='kw'>end</span>                                      <span class='comment'># =&gt; :body
</span>
<span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.spawn(type: :on_pool, environment: Behaviour) { body }
=== =&gt; #&lt;Concurrent::ErlangActor::Pid:0x00000a running&gt;
actor.ask 1                              # =&gt; 2
actor.ask 2                              # =&gt; 3
actor.ask :value                         # =&gt; &quot;value&quot;
=== this malformed message will terminate the actor
actor.ask -1                             # =&gt; :bad_message
=== the actor is no longer alive, so ask fails
actor.ask &quot;junk&quot; rescue $!
=== =&gt; #&lt;Concurrent::ErlangActor::NoActor: #&lt;Concurrent::ErlangActor::Pid:0x00000a terminated because of [:bad_message, -1]&gt;&gt;
actor.terminated.result                  # =&gt; [false, nil, [:bad_message, -1]]</span></code></pre>

<p>Since the behavior is stable in this case we can simplify with the <code>:keep</code> option
that will keep the receive rules until another receive is called
replacing the kept rules.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.spawn(type: :on_pool) do
  receive(on(Symbol) { |s| reply s.to_s },
          on(And[Numeric, -&gt; v { v &gt;= 0 }]) { |v| reply v.succ },
          # put last works as else
          on(ANY) do |v| 
            reply :bad_message
            terminate [:bad_message, v]
          end,
          keep: true)            
end
=== =&gt; #&lt;Concurrent::ErlangActor::Pid:0x00000b running&gt;
actor.ask 1                              # =&gt; 2
actor.ask 2                              # =&gt; 3
actor.ask :value                         # =&gt; &quot;value&quot;
=== this malformed message will terminate the actor
actor.ask -1                             # =&gt; :bad_message
=== the actor is no longer alive, so ask fails
actor.ask &quot;junk&quot; rescue $!
=== =&gt; #&lt;Concurrent::ErlangActor::NoActor: #&lt;Concurrent::ErlangActor::Pid:0x00000b terminated because of [:bad_message, -1]&gt;&gt;
actor.terminated.result                  # =&gt; [false, nil, [:bad_message, -1]]</span></code></pre>

<p>===== Erlang behaviour</p>

<p>The actor matches Erlang processes in behaviour. 
Therefore it supports the usual Erlang actor linking, monitoring, exit behaviour, etc.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>ErlangActor</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.spawn(type: :on_thread) do
  spawn(link: true) do # equivalent of spawn_link in Erlang
    terminate :err # equivalent of exit in Erlang    
  end
  trap # equivalent of process_flag(trap_exit, true) 
  receive  
end
=== =&gt; #&lt;Concurrent::ErlangActor::Pid:0x00000c running&gt;
actor.terminated.value!
=== =&gt; #&lt;Concurrent::ErlangActor::Terminated:0x00000d
===     @from=
===      #&lt;Concurrent::ErlangActor::Pid:0x00000e terminated because of err&gt;,
===     @reason=:err&gt;</span></code></pre>

<p>The methods have same or very similar name to be easily found. 
The one exception from the original Erlang naming is exit.
To avoid clashing with <code>Kernel#exit</code> it&#39;s called <code>terminate</code>. </p>

<p>Until there is more information available here, the chapters listed below from 
a book <a href="https://learnyousomeerlang.com">learn you some Erlang</a> 
are excellent source of information. 
The Ruby ErlangActor implementation has same behaviour. </p>

<ul>
<li>  <a href="https://learnyousomeerlang.com/errors-and-processes#links" target="_parent" title="Links">Links</a></li>
<li>  <a href="https://learnyousomeerlang.com/errors-and-processes#its-a-trap">It&#39;s a trap</a></li>
<li>  <a href="https://learnyousomeerlang.com/errors-and-processes#monitors" target="_parent" title="Monitors">Monitors</a></li>
</ul>

<p>If anything behaves differently than in Erlang, please file an issue.</p>

<p>===== Chapters or points to be added</p>

<ul>
<li>  More erlang behaviour examples.</li>
<li>  The mailbox can be bounded in size, 
then the tell and ask will block until there is space available in the mailbox.
Useful for building systems with backpressure.</li>
<li>  <code>#tell_op</code> and <code>ask_op</code> method examples, integration with promises.</li>
<li>  Best practice: always use timeout, 
and do something if the message does not arrive, don&#39;t leave the actor stuck.</li>
<li>  Best practice: drop and log unrecognized messages, 
or be even more defensive and terminate.</li>
<li>  Environment definition for actors.</li>
</ul>
</p>

  </div>
</div>
<div class='tags'>
  
</div>
</div>
<h2 id='t2_cnst' class='h2_sum'>Constant Summary</h2>
<div>
<ul class='constants summary full'>
  <li>
    <span id='JUMP-constant' class='summary_signature priv'>JUMP =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb#L567-L567'># File 'lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb', line 567</a>    <pre class='code ruby'><span class='const'><a href="ErlangActor/Token.html" title="Concurrent::ErlangActor::Token (class)">Token</a></span>.<span class='id identifier rubyid_new'><a href="ErlangActor/Token.html#new-class_method" title="Concurrent::ErlangActor::Token.new (method)">new</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>JUMP</span><span class='tstring_end'>&#39;</span></span></pre>
  </li>
  <li>
    <span id='KLASS_MAP-constant' class='summary_signature priv'>KLASS_MAP =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb#L1541-L1546'># File 'lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb', line 1541</a>    <pre class='code ruby'>{
    <span class='label'>on_thread:</span> <span class='const'><a href="ErlangActor/OnThread.html" title="Concurrent::ErlangActor::OnThread (class)">OnThread</a></span><span class='comma'>,</span>
    <span class='label'>on_pool:</span>   <span class='const'><a href="ErlangActor/OnPool.html" title="Concurrent::ErlangActor::OnPool (class)">OnPool</a></span><span class='comma'>,</span>
    <span class='const'><a href="ErlangActor/OnThread.html" title="Concurrent::ErlangActor::OnThread (class)">OnThread</a></span>   <span class='op'>=&gt;</span> <span class='const'><a href="ErlangActor/OnThread.html" title="Concurrent::ErlangActor::OnThread (class)">OnThread</a></span><span class='comma'>,</span>
    <span class='const'><a href="ErlangActor/OnPool.html" title="Concurrent::ErlangActor::OnPool (class)">OnPool</a></span>     <span class='op'>=&gt;</span> <span class='const'><a href="ErlangActor/OnPool.html" title="Concurrent::ErlangActor::OnPool (class)">OnPool</a></span><span class='comma'>,</span>
}</pre>
  </li>
  <li>
    <span id='NOTHING-constant' class='summary_signature priv'>NOTHING =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb#L570-L570'># File 'lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb', line 570</a>    <pre class='code ruby'><span class='const'><a href="ErlangActor/Token.html" title="Concurrent::ErlangActor::Token (class)">Token</a></span>.<span class='id identifier rubyid_new'><a href="ErlangActor/Token.html#new-class_method" title="Concurrent::ErlangActor::Token.new (method)">new</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>NOTHING</span><span class='tstring_end'>&#39;</span></span></pre>
  </li>
  <li>
    <span id='RECEIVE-constant' class='summary_signature priv'>RECEIVE =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb#L569-L569'># File 'lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb', line 569</a>    <pre class='code ruby'><span class='const'><a href="ErlangActor/Token.html" title="Concurrent::ErlangActor::Token (class)">Token</a></span>.<span class='id identifier rubyid_new'><a href="ErlangActor/Token.html#new-class_method" title="Concurrent::ErlangActor::Token.new (method)">new</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>RECEIVE</span><span class='tstring_end'>&#39;</span></span></pre>
  </li>
  <li>
    <span id='TERMINATE-constant' class='summary_signature priv'>TERMINATE =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb#L568-L568'># File 'lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb', line 568</a>    <pre class='code ruby'><span class='const'><a href="ErlangActor/Token.html" title="Concurrent::ErlangActor::Token (class)">Token</a></span>.<span class='id identifier rubyid_new'><a href="ErlangActor/Token.html#new-class_method" title="Concurrent::ErlangActor::Token.new (method)">new</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>TERMINATE</span><span class='tstring_end'>&#39;</span></span></pre>
  </li>
</ul>
  <h3 class='inherited'><a href="ErlangActor/EnvironmentConstants.html" title="Concurrent::ErlangActor::EnvironmentConstants (module)"><code>EnvironmentConstants</code></a> - Included</h3>
  <p  class='inherited'>
    <a href="ErlangActor/EnvironmentConstants.html#ANY-constant" title="Concurrent::ErlangActor::EnvironmentConstants::ANY (constant)">ANY</a>, 
    <a href="ErlangActor/EnvironmentConstants.html#TIMEOUT-constant" title="Concurrent::ErlangActor::EnvironmentConstants::TIMEOUT (constant)">TIMEOUT</a>
  </p>
</div>

<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature priv'>
      <a href="#create-class_method" title=".create (class method)">.<strong>create</strong>(type, channel, environment, name, executor)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
</ul>

<h3 class='inherited'><a href="Concern/Logging.html" title="Concurrent::Concern::Logging (module)"><code>Concern::Logging</code></a> - Extended</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Concern/Logging.html#log-instance_method" title="Concurrent::Concern::Logging#log (method)">log</a></td>
      <td><div class='inline'><p>Logs through <a href="../Concurrent.html#global_logger-class_method" title="Concurrent.global_logger (method)">global_logger</a>, it can be overridden by setting @logger.</p></div></td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="ErlangActor/FunctionShortcuts.html" title="Concurrent::ErlangActor::FunctionShortcuts (module)"><code>FunctionShortcuts</code></a> - Extended</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr class='i_ds'>
      <td><a class='i_m ' href="ErlangActor/FunctionShortcuts.html#spawn-instance_method" title="Concurrent::ErlangActor::FunctionShortcuts#spawn (method)">spawn</a></td>
      <td><div class='inline'><p>Optionally included shortcut method for <a href="ErlangActor/Functions.html#spawn_actor-instance_method" title="Concurrent::ErlangActor::Functions#spawn_actor (method)">Functions#spawn_actor</a></p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="ErlangActor/FunctionShortcuts.html#terminate-instance_method" title="Concurrent::ErlangActor::FunctionShortcuts#terminate (method)">terminate</a></td>
      <td><div class='inline'><p>Optionally included shortcut method for <a href="ErlangActor/Functions.html#terminate_actor-instance_method" title="Concurrent::ErlangActor::Functions#terminate_actor (method)">Functions#terminate_actor</a></p></div></td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="ErlangActor/Functions.html" title="Concurrent::ErlangActor::Functions (module)"><code>Functions</code></a> - Extended</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="ErlangActor/Functions.html#default_actor_executor-instance_method" title="Concurrent::ErlangActor::Functions#default_actor_executor (method)">default_actor_executor</a>,
        <a class='i_m ' href="ErlangActor/Functions.html#default_executor-instance_method" title="Concurrent::ErlangActor::Functions#default_executor (method)">default_executor</a>,
      </td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="ErlangActor/Functions.html#spawn_actor-instance_method" title="Concurrent::ErlangActor::Functions#spawn_actor (method)">spawn_actor</a></td>
      <td><div class='inline'><p>Creates an actor.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="ErlangActor/Functions.html#terminate_actor-instance_method" title="Concurrent::ErlangActor::Functions#terminate_actor (method)">terminate_actor</a></td>
      <td><div class='inline'><p>Same as <a href="ErlangActor/Environment.html#terminate-instance_method" title="Concurrent::ErlangActor::Environment#terminate (method)">Environment#terminate</a>, but it requires pid.</p></div></td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- class_method_summary -->
<h2 class='y_details'>Class Method Details</h2>
<section class='method_details first' id="create-class_method">
  <h3 class='signature priv first'>
    .<strong>create</strong>(type, channel, environment, name, executor)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb#L1535-L1539'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1535' data-end='1539'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby-edge/concurrent/edge/erlang_actor.rb', line 1535</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_create'>create</span>(<span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_environment'>environment</span><span class='comma'>,</span> <span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_executor'><a href="../Concurrent.html#executor-class_method" title="Concurrent.executor (method)">executor</a></span>)
  <span class='id identifier rubyid_actor'>actor</span> <span class='op'>=</span> <span class='const'><a href="#KLASS_MAP-constant" title="Concurrent::ErlangActor::KLASS_MAP (constant)">KLASS_MAP</a></span>.<span class='id identifier rubyid_fetch'>fetch</span>(<span class='id identifier rubyid_type'>type</span>).<span class='id identifier rubyid_new'>new</span>(<span class='id identifier rubyid_channel'>channel</span><span class='comma'>,</span> <span class='id identifier rubyid_environment'>environment</span><span class='comma'>,</span> <span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_executor'><a href="../Concurrent.html#executor-class_method" title="Concurrent.executor (method)">executor</a></span>)
<span class='kw'>ensure</span>
  <span class='id identifier rubyid_log'>log</span> <span class='const'><a href="Concern.html" title="Concurrent::Concern (module)">Concern</a></span><span class='op'>::</span><span class='const'><a href="Concern/Logging.html" title="Concurrent::Concern::Logging (module)">Logging</a></span><span class='op'>::</span><span class='const'>DEBUG</span><span class='comma'>,</span> <span class='id identifier rubyid_actor'>actor</span>.<span class='id identifier rubyid_pid'>pid</span><span class='comma'>,</span> <span class='label'>created:</span> <span class='id identifier rubyid_caller'>caller</span>[<span class='int'>1</span>] <span class='kw'>if</span> <span class='id identifier rubyid_actor'>actor</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>