<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: Concurrent::TVar &mdash; Concurrent RubyÂ master</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Concurrent::TVar",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../'>Concurrent</a> &raquo; 
      <a href='../_index.html#alpha_T'>Index (T)</a> &raquo; 
        <a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>TVar&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: Concurrent::TVar</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Super Chains via Extension / Inclusion / Inheritance</td></tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Class Chain:</div>
        <div class='box_22'>
          self,
          <a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a>,
          <a href="Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)"><code>Synchronization::AbstractObject</code></a>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Instance Chain:</div>
        <div class='box_22'>
          self,
          <a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a>,
          <a href="Synchronization/Volatile.html" title="Concurrent::Synchronization::Volatile (module)"><code>Synchronization::Volatile</code></a>,
          <a href="Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)"><code>Synchronization::AbstractObject</code></a>
        </div>
      </td>
    </tr>
    <tr>
      <td id='t2_inherits' class='box_2 o'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'><a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)">Concurrent::Synchronization::Object</a></span>
        <ul class='fullTree'>
          <li><a href="../Object.html" title="Object (class)"><code>::Object</code></a></li>
          <li class='next'><a href="Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)">Concurrent::Synchronization::AbstractObject</a></li>
          <li class='next'><a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)">Concurrent::Synchronization::Object</a></li>
          <li class='next'>Concurrent::TVar</li>
        </ul>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/tvar.rb#L12'>lib/concurrent-ruby/concurrent/tvar.rb</a>      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p>A <code>TVar</code> is a transactional variable - a single-element container that is used as part of a transaction - see <code>Concurrent::atomically</code>.</p>

<p>## Thread-safe Variable Classes</p>

<p>Each of the thread-safe variable classes is designed to solve a different problem. In general:</p>
<ul><li>
<p>*<a href="Agent.html" title="Concurrent::Agent (class)"><code>Agent</code></a>:* Shared, mutable variable providing independent, uncoordinated, <strong>asynchronous</strong> change of individual values. Best used when the value will undergo frequent, complex updates. Suitable when the result of an update does not need to be known immediately.</p>
</li><li>
<p>*<a href="Atom.html" title="Concurrent::Atom (class)"><code>Atom</code></a>:* Shared, mutable variable providing independent, uncoordinated, <strong>synchronous</strong> change of individual values. Best used when the value will undergo frequent reads but only occasional, though complex, updates. Suitable when the result of an update must be known immediately.</p>
</li><li>
<p>*<a href="AtomicReference.html" title="Concurrent::AtomicReference (class)"><code>AtomicReference</code></a>:* A simple object reference that can be updated atomically. Updates are synchronous but fast. Best used when updates a simple set operations. Not suitable when updates are complex. <a href="AtomicBoolean.html" title="Concurrent::AtomicBoolean (class)"><code>AtomicBoolean</code></a> and <a href="AtomicFixnum.html" title="Concurrent::AtomicFixnum (class)"><code>AtomicFixnum</code></a> are similar but optimized for the given data type.</p>
</li><li>
<p>*<a href="Exchanger.html" title="Concurrent::Exchanger (class)"><code>Exchanger</code></a>:* Shared, stateless synchronization point. Used when two or more threads need to exchange data. The threads will pair then block on each other until the exchange is complete.</p>
</li><li>
<p>*<a href="MVar.html" title="Concurrent::MVar (class)"><code>MVar</code></a>:* Shared synchronization point. Used when one thread must give a value to another, which must take the value. The threads will block on each other until the exchange is complete.</p>
</li><li>
<p>*<a href="ThreadLocalVar.html" title="Concurrent::ThreadLocalVar (class)"><code>ThreadLocalVar</code></a>:* Shared, mutable, isolated variable which holds a different value for each thread which has access. Often used as an instance variable in objects which must maintain different state for different threads.</p>
</li><li>
<p>*<code>TVar</code>:* Shared, mutable variables which provide <strong>coordinated</strong>, <strong>synchronous</strong>, change of <strong>many</strong> stated. Used when multiple value must change together, in an all-or-nothing transaction.</p>
</li></ul>

<p><code>TVar</code> and <a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a> implement a software transactional memory. A <code>TVar</code> is a
single item container that always contains exactly one value. The <a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a>
method allows you to modify a set of <code>TVar</code> objects with the guarantee that all
of the updates are collectively atomic - they either all happen or none of them
do - consistent - a <code>TVar</code> will never enter an illegal state - and isolated -
atomic blocks never interfere with each other when they are running. You may
recognise these properties from database transactions.</p>

<p>There are some very important and unusual semantics that you must be aware of:</p>

<ul>
<li><p>Most importantly, the block that you pass to <a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a> may be executed more
than once. In most cases your code should be free of side-effects, except for
via <code>TVar</code>.</p></li>
<li><p>If an exception escapes an <a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a> block it will abort the transaction.</p></li>
<li><p>It is undefined behaviour to use <code>callcc</code> or <code>Fiber</code> with <a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a>.</p></li>
<li><p>If you create a new thread within an <a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a>, it will not be part of
the transaction. Creating a thread counts as a side-effect.</p></li>
</ul>

<p>We implement nested transactions by flattening.</p>

<p>We only support strong isolation if you use the API correctly. In order words,
we do not support strong isolation.</p>

<p>Our implementation uses a very simple algorithm that locks each <code>TVar</code> when it
is first read or written. If it cannot lock a <code>TVar</code> it aborts and retries.
There is no contention manager so competing transactions may retry eternally.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>concurrent</span><span class='tstring_end'>&#39;</span></span>

<span class='id identifier rubyid_v1'>v1</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>TVar</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.new(0)
v2 = &lt;code&gt;TVar&lt;</span><span class='regexp_end'>/code</span></span><span class='op'>&gt;</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::TVar.new (method)">new</a></span>(<span class='int'>0</span>)

<span class='int'>2</span>.<span class='id identifier rubyid_times'>times</span>.<span class='id identifier rubyid_map'>map</span>{
  <span class='const'>Thread</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::TVar.new (method)">new</a></span> <span class='kw'>do</span>
    <span class='kw'>while</span> <span class='kw'>true</span>
      <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='id identifier rubyid_atomically'><a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a></span> <span class='kw'>do</span>
        <span class='id identifier rubyid_t1'>t1</span> <span class='op'>=</span> <span class='id identifier rubyid_v1'>v1</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span>
        <span class='id identifier rubyid_t2'>t2</span> <span class='op'>=</span> <span class='id identifier rubyid_v2'>v2</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span>
        <span class='id identifier rubyid_raise'>raise</span> [<span class='id identifier rubyid_t1'>t1</span><span class='comma'>,</span> <span class='id identifier rubyid_t2'>t2</span>].<span class='id identifier rubyid_inspect'>inspect</span> <span class='kw'>if</span> <span class='id identifier rubyid_t1'>t1</span> <span class='op'>!=</span> <span class='id identifier rubyid_t2'>t2</span> <span class='comment'># detect zombie transactions
</span>      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='const'>Thread</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::TVar.new (method)">new</a></span> <span class='kw'>do</span>
    <span class='int'>100_000</span>.<span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span>
      <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='id identifier rubyid_atomically'><a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a></span> <span class='kw'>do</span>
        <span class='id identifier rubyid_v1'>v1</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>+=</span> <span class='int'>1</span>
        <span class='id identifier rubyid_v2'>v2</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>+=</span> <span class='int'>1</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
}.<span class='id identifier rubyid_each'>each</span> { <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span> <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_t'>t</span>.<span class='id identifier rubyid_join'>join</span> }</code></pre>

<p>However, the inconsistent reads are detected correctly at commit time. This
means the script below will always print <code>[2000000, 200000]</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>concurrent</span><span class='tstring_end'>&#39;</span></span>

<span class='id identifier rubyid_v1'>v1</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='id identifier rubyid_code'>code</span><span class='op'>&gt;</span><span class='const'>TVar</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>code&gt;.new(0)
v2 = &lt;code&gt;TVar&lt;</span><span class='regexp_end'>/code</span></span><span class='op'>&gt;</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::TVar.new (method)">new</a></span>(<span class='int'>0</span>)

<span class='int'>2</span>.<span class='id identifier rubyid_times'>times</span>.<span class='id identifier rubyid_map'>map</span>{
  <span class='const'>Thread</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::TVar.new (method)">new</a></span> <span class='kw'>do</span>
    <span class='kw'>while</span> <span class='kw'>true</span>
      <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='id identifier rubyid_atomically'><a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a></span> <span class='kw'>do</span>
        <span class='id identifier rubyid_t1'>t1</span> <span class='op'>=</span> <span class='id identifier rubyid_v1'>v1</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span>
        <span class='id identifier rubyid_t2'>t2</span> <span class='op'>=</span> <span class='id identifier rubyid_v2'>v2</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='const'>Thread</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::TVar.new (method)">new</a></span> <span class='kw'>do</span>
    <span class='int'>100_000</span>.<span class='id identifier rubyid_times'>times</span> <span class='kw'>do</span>
      <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='id identifier rubyid_atomically'><a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a></span> <span class='kw'>do</span>
        <span class='id identifier rubyid_v1'>v1</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>+=</span> <span class='int'>1</span>
        <span class='id identifier rubyid_v2'>v2</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>+=</span> <span class='int'>1</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
}.<span class='id identifier rubyid_each'>each</span> { <span class='op'>|</span><span class='id identifier rubyid_t'>t</span><span class='op'>|</span> <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_t'>t</span>.<span class='id identifier rubyid_join'>join</span> }

<span class='id identifier rubyid_p'>p</span> [<span class='id identifier rubyid_v1'>v1</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span><span class='comma'>,</span> <span class='id identifier rubyid_v2'>v2</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span>]</code></pre>

<p>This is called a lack of <em>opacity</em>. In the future we will look at more advanced
algorithms, contention management and using existing Java implementations when
in JRuby.</p>

<p>=== Motivation</p>

<p>Consider an application that transfers money between bank accounts. We want to
transfer money from one account to another. It is very important that we don&#39;t
lose any money! But it is also important that we can handle many account
transfers at the same time, so we run them concurrently, and probably also in
parallel.</p>

<p>This code shows us transferring ten pounds from one account to another.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> {<span class='const'>BankAccount</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::TVar.new (method)">new</a></span>}(<span class='int'>100_000</span>)
<span class='id identifier rubyid_b'>b</span> <span class='op'>=</span> {<span class='const'>BankAccount</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::TVar.new (method)">new</a></span>}(<span class='int'>100</span>)

<span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>-=</span> <span class='int'>10</span>
<span class='id identifier rubyid_b'>b</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>+=</span> <span class='int'>10</span></code></pre>

<p>Before we even start to talk about to talk about concurrency and parallelism, is
this code safe? What happens if after removing money from account a, we get an
exception? It&#39;s a slightly contrived example, but if the account totals were
very large, adding to them could involve the stack allocation of a <code>BigNum</code>, and
so could cause out of memory exceptions.  In that case the money would have
disappeared from account a, but not appeared in account b. Disaster!</p>

<p>So what do we really need to do?</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> {<span class='const'>BankAccount</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::TVar.new (method)">new</a></span>}(<span class='int'>100_000</span>)
<span class='id identifier rubyid_b'>b</span> <span class='op'>=</span> {<span class='const'>BankAccount</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::TVar.new (method)">new</a></span>}(<span class='int'>100</span>)

<span class='id identifier rubyid_original_a'>original_a</span> <span class='op'>=</span> <span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span>
<span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>-=</span> <span class='int'>10</span>

<span class='kw'>begin</span>
  <span class='id identifier rubyid_b'>b</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>+=</span> <span class='int'>10</span>
<span class='kw'>rescue</span> <span class='id identifier rubyid_e'>e</span> <span class='op'>=&gt;</span>
  <span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>=</span> <span class='id identifier rubyid_original_a'>original_a</span>
  <span class='id identifier rubyid_raise'>raise</span> <span class='id identifier rubyid_e'>e</span>
<span class='kw'>end</span></code></pre>

<p>This rescues any exceptions raised when setting b and will roll back the change
we have already made to b. We&#39;ll keep this rescue code in mind, but we&#39;ll leave
it out of future examples for simplicity.</p>

<p>That might have made the code work when it only runs sequentially. Lets start to
consider some concurrency. It&#39;s obvious that we want to make the transfer of
money mutually exclusive with any other transfers - in order words it is a
critical section.</p>

<p>The usual solution to this would be to use a lock.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_lock'>lock</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>-=</span> <span class='int'>10</span>
  <span class='id identifier rubyid_b'>b</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>+=</span> <span class='int'>10</span>
<span class='kw'>end</span></code></pre>

<p>That should work. Except we said we&#39;d like these transfer to run concurrently,
and in parallel. With a single lock like that we&#39;ll only let one transfer take
place at a time. Perhaps we need more locks? We could have one per account:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_lock'>lock</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_b'>b</span>.<span class='id identifier rubyid_lock'>lock</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>-=</span> <span class='int'>10</span>
    <span class='id identifier rubyid_b'>b</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>+=</span> <span class='int'>10</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>However this is vulnerable to deadlock. If we tried to transfer from a to b, at
the same time as from b to a, it&#39;s possible that the first transfer locks a, the
second transfer locks b, and then they both sit there waiting forever to get the
other lock. Perhaps we can solve that by applying a total ordering to the locks
and always acquire them in the same order?</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_locks_needed'>locks_needed</span> <span class='op'>=</span> [<span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_lock'>lock</span><span class='comma'>,</span> <span class='id identifier rubyid_b'>b</span>.<span class='id identifier rubyid_lock'>lock</span>]
<span class='id identifier rubyid_locks_in_order'>locks_in_order</span> <span class='op'>=</span> <span class='id identifier rubyid_locks_needed'>locks_needed</span>.<span class='id identifier rubyid_sort'>sort</span>{ <span class='op'>|</span><span class='id identifier rubyid_x'>x</span><span class='comma'>,</span> <span class='id identifier rubyid_y'>y</span><span class='op'>|</span> <span class='id identifier rubyid_x'>x</span>.<span class='id identifier rubyid_number'>number</span> <span class='op'>&lt;=&gt;</span> <span class='id identifier rubyid_y'>y</span>.<span class='id identifier rubyid_number'>number</span> }

<span class='id identifier rubyid_locks_in_order'>locks_in_order</span>[<span class='int'>0</span>].<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_locks_in_order'>locks_in_order</span>[<span class='int'>1</span>].<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>-=</span> <span class='int'>10</span>
    <span class='id identifier rubyid_b'>b</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>+=</span> <span class='int'>10</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>That might work. But we need to know exactly what locks we&#39;re going to need
before we start. If there were conditions in side the transfer this might be
more complicated. We also need to remember the rescue code we had above to deal
with exceptions. This is getting out of hand - and it&#39;s where <code>TVar</code> comes in.</p>

<p>We&#39;ll model the accounts as <code>TVar</code> - transactional variable, and instead of
locks we&#39;ll use <code>Concurrent::atomically</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> {<span class='const'>TVar</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::TVar.new (method)">new</a></span>}(<span class='int'>100_000</span>)
<span class='id identifier rubyid_b'>b</span> <span class='op'>=</span> {<span class='const'>TVar</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::TVar.new (method)">new</a></span>}(<span class='int'>100</span>)

{<span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span>.<span class='id identifier rubyid_atomically'><a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a></span>} <span class='kw'>do</span>
  <span class='id identifier rubyid_a'>a</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>-=</span> <span class='int'>10</span>
  <span class='id identifier rubyid_b'>b</span>.<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span> <span class='op'>+=</span> <span class='int'>10</span>
<span class='kw'>end</span></code></pre>

<p>That short piece of code effectively solves all the concerns we identified
above. How it does it is described in the reference above. You just need to be
happy that any two <a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a> blocks (we call them transactions) that use an
overlapping set of <code>TVar</code> objects will appear to have happened as if there was a
big global lock on them, and that if any exception is raised in the block, it
will be as if the block never happened. But also keep in mind the important
points we detailed right at the start of the article about side effects and
repeated execution.</p>

  </div>
</div>
</div>
<h2 class='h2_sum' id='class_Attribute_summary'>Class Attribute Summary</h2>
<div class='div_sum'>

<h3 class='inherited'><a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ro' href="Synchronization/Object.html#safe_initialization%3F-class_method" title="Concurrent::Synchronization::Object.safe_initialization? (method)">.safe_initialization?</a>
      </td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- class_attribute_summary -->

<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#new-class_method" title=".new (class method)">.<strong>new</strong>(value)  &#x21d2; TVar </a>
    </span>
    <span class='note title constructor'>constructor</span>
    <div class='summary_desc'>
      <div class='inline'><p>Create a new <code>TVar</code> with an initial value.</p></div>
    </div>
  </li>
</ul>

<h3 class='inherited'><a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="Synchronization/Object.html#atomic_attribute%3F-class_method" title="Concurrent::Synchronization::Object.atomic_attribute? (method)">.atomic_attribute?</a>,
        <a class='i_m ' href="Synchronization/Object.html#atomic_attributes-class_method" title="Concurrent::Synchronization::Object.atomic_attributes (method)">.atomic_attributes</a>,
      </td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Synchronization/Object.html#attr_atomic-class_method" title="Concurrent::Synchronization::Object.attr_atomic (method)">.attr_atomic</a></td>
      <td><div class='inline'><p>Creates methods for reading and writing to a instance variable with volatile (Java) semantic as <code>.attr_volatile</code> does.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Synchronization/Object.html#attr_volatile-class_method" title="Concurrent::Synchronization::Object.attr_volatile (method)">.attr_volatile</a></td>
      <td><div class='inline'><p>Creates methods for reading and writing (as <code>attr_accessor</code> does) to a instance variable with volatile (Java) semantic.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Synchronization/Object.html#ensure_safe_initialization_when_final_fields_are_present-class_method" title="Concurrent::Synchronization::Object.ensure_safe_initialization_when_final_fields_are_present (method)">.ensure_safe_initialization_when_final_fields_are_present</a></td>
      <td><div class='inline'><p>For testing purposes, quite slow.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Synchronization/Object.html#new-class_method" title="Concurrent::Synchronization::Object.new (method)">.new</a></td>
      <td><div class='inline'><p>Has to be called by children.</p></div></td>
    </tr>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="Synchronization/Object.html#safe_initialization!-class_method" title="Concurrent::Synchronization::Object.safe_initialization! (method)">.safe_initialization!</a>,
        <a class='i_m priv' href="Synchronization/Object.html#define_initialize_atomic_fields-class_method" title="Concurrent::Synchronization::Object.define_initialize_atomic_fields (method)">.define_initialize_atomic_fields</a>
      </td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)"><code>Synchronization::AbstractObject</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="Synchronization/AbstractObject.html#attr_volatile-class_method" title="Concurrent::Synchronization::AbstractObject.attr_volatile (method)">.attr_volatile</a>,
        <a class='i_m ' href="Synchronization/AbstractObject.html#new-class_method" title="Concurrent::Synchronization::AbstractObject.new (method)">.new</a>
      </td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_attribute_summary'>Instance Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature rw'>
      <a href="#value-instance_method" title="#value (instance method)">#<strong>value</strong>  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Get the value of a <code>TVar</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#value=-instance_method" title="#value= (instance method)">#<strong>value=</strong>(value)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p><a href="Set.html" title="Concurrent::Set (class)"><code>Set</code></a> the value of a <code>TVar</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw priv nodoc'>
      <a href="#unsafe_value-instance_method" title="#unsafe_value (instance method)">#<strong>unsafe_value</strong>  </a>
    </span>
    <span class='note title rw'>rw</span>
    <span class='note title private'>private</span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
  <li>
    <span class='summary_signature rw priv nodoc'>
      <a href="#unsafe_value=-instance_method" title="#unsafe_value= (instance method)">#<strong>unsafe_value=</strong>(value)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <span class='note title private'>private</span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
</ul>
</div>  <!-- instance_attribute_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature priv nodoc'>
      <a href="#unsafe_lock-instance_method" title="#unsafe_lock (instance method)">#<strong>unsafe_lock</strong>  </a>
    </span>
    <span class='note title private'>private</span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
</ul>

<h3 class='inherited'><a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m priv' href="Synchronization/Object.html#__initialize_atomic_fields__-instance_method" title="Concurrent::Synchronization::Object#__initialize_atomic_fields__ (method)">#__initialize_atomic_fields__</a>
      </td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="Synchronization/Volatile.html" title="Concurrent::Synchronization::Volatile (module)"><code>Synchronization::Volatile</code></a> - Included</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="Synchronization/Volatile.html#full_memory_barrier-instance_method" title="Concurrent::Synchronization::Volatile#full_memory_barrier (method)">#full_memory_barrier</a>
      </td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)"><code>Synchronization::AbstractObject</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m priv' href="Synchronization/AbstractObject.html#full_memory_barrier-instance_method" title="Concurrent::Synchronization::AbstractObject#full_memory_barrier (method)">#full_memory_barrier</a>
      </td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- instance_method_summary -->
<h2 id='Constructor_Details' class='y_details'>Constructor Details</h2>

  <section class='method_details first' id="new-class_method">
  <h3 class='signature  first'>
    .<strong>new</strong>(value)  &#x21d2; <code>TVar</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Create a new <code>TVar</code> with an initial value.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/tvar.rb#L16-L19'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='16' data-end='19'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/tvar.rb', line 16</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_initialize'><a href="../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">initialize</a></span>(<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span>)
  <span class='ivar'>@value</span> <span class='op'>=</span> <span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span>
  <span class='ivar'>@lock</span> <span class='op'>=</span> <span class='const'>Mutex</span>.<span class='id identifier rubyid_new'>new</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Attribute Details</h2>
<section class='method_details first' id="unsafe_value-instance_method">
  <h3 class='signature rw priv  nodoc first'>
    #<strong>unsafe_value</strong>   <span class="extras">(<span class='rw'>rw</span>, <span class='priv'>private</span>)</span>
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/tvar.rb#L36-L38'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='36' data-end='38'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/tvar.rb', line 36</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_unsafe_value'>unsafe_value</span> <span class='comment'># :nodoc:
</span>  <span class='ivar'>@value</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="unsafe_value=-instance_method">
  <h3 class='signature rw priv  nodoc'>
    #<strong>unsafe_value=</strong>(value)   <span class="extras">(<span class='rw'>rw</span>, <span class='priv'>private</span>)</span>
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/tvar.rb#L41-L43'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='41' data-end='43'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/tvar.rb', line 41</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_unsafe_value='>unsafe_value=</span>(<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span>) <span class='comment'># :nodoc:
</span>  <span class='ivar'>@value</span> <span class='op'>=</span> <span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="value-instance_method">
  <h3 class='signature rw'>
    #<strong>value</strong>   <span class="extras">(<span class='rw'>rw</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Get the value of a <code>TVar</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/tvar.rb#L22-L26'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='22' data-end='26'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/tvar.rb', line 22</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_value'>value</span>
  <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='id identifier rubyid_atomically'><a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a></span> <span class='kw'>do</span>
    <span class='const'><a href="Transaction.html" title="Concurrent::Transaction (class)">Transaction</a></span><span class='op'>::</span><span class='id identifier rubyid_current'><a href="Transaction.html#current-class_method" title="Concurrent::Transaction.current (method)">current</a></span>.<span class='id identifier rubyid_read'>read</span>(<span class='kw'>self</span>)
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="value=-instance_method">
  <h3 class='signature rw'>
    #<strong>value=</strong>(value)   <span class="extras">(<span class='rw'>rw</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p><a href="Set.html" title="Concurrent::Set (class)"><code>Set</code></a> the value of a <code>TVar</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/tvar.rb#L29-L33'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='29' data-end='33'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/tvar.rb', line 29</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_value='>value=</span>(<span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span>)
  <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='id identifier rubyid_atomically'><a href="../Concurrent.html#atomically-class_method" title="Concurrent.atomically (method)">atomically</a></span> <span class='kw'>do</span>
    <span class='const'><a href="Transaction.html" title="Concurrent::Transaction (class)">Transaction</a></span><span class='op'>::</span><span class='id identifier rubyid_current'><a href="Transaction.html#current-class_method" title="Concurrent::Transaction.current (method)">current</a></span>.<span class='id identifier rubyid_write'>write</span>(<span class='kw'>self</span><span class='comma'>,</span> <span class='id identifier rubyid_value'><a href="#value-instance_method" title="Concurrent::TVar#value (method)">value</a></span>)
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="unsafe_lock-instance_method">
  <h3 class='signature priv  nodoc first'>
    #<strong>unsafe_lock</strong>   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/tvar.rb#L46-L48'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='46' data-end='48'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/tvar.rb', line 46</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_unsafe_lock'>unsafe_lock</span> <span class='comment'># :nodoc:
</span>  <span class='ivar'>@lock</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>