<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Module: Concurrent::Async &mdash; Concurrent Ruby master</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Concurrent::Async",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../'>Concurrent</a> &raquo; 
      <a href='../_index.html#alpha_A'>Index (A)</a> &raquo; 
        <a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>Async&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='module'>
<h1>Module: Concurrent::Async</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Namespace Children</td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Modules:</div>
      <div class='box_11'>
          <a href="Async/ClassMethods.html" title="Concurrent::Async::ClassMethods (module)"><code>ClassMethods</code></a>      </div>
    </td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Classes:</div>
      <div class='box_11'>
          <a href="Async/AsyncDelegator.html" title="Concurrent::Async::AsyncDelegator (class)"><code>AsyncDelegator</code></a>,
        <a href="Async/AwaitDelegator.html" title="Concurrent::Async::AwaitDelegator (class)"><code>AwaitDelegator</code></a>      </div>
    </td></tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/async.rb#L217'>lib/concurrent-ruby/concurrent/async.rb</a>      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p>A mixin module that provides simple asynchronous behavior to a class, turning it into a simple actor. Loosely based on Erlang’s <a href="../file._3Ca.html" title="href=&quot;http://www.erlang.org/doc/man/gen_server.html&quot;&gt;www.erlang.org/doc/man/gen_server.html&lt;/a&gt; gen_server">href="http://www.erlang.org/doc/man/gen_server.html">www.erlang.org/doc/man/gen_server.html</a> gen_server</a>, but without supervision or linking.</p>

<p>A more feature-rich <a href="Actor.html" title="Concurrent::Actor (module)"><code>Actor</code></a> is also available when the capabilities of <code>Async</code> are too limited.</p>

<p>“‘cucumber Feature:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>As</span> <span class='id identifier rubyid_a'>a</span> <span class='id identifier rubyid_stateful'>stateful</span><span class='comma'>,</span> <span class='id identifier rubyid_plain'>plain</span> <span class='id identifier rubyid_old'>old</span> <span class='const'>Ruby</span> <span class='kw'>class</span>
<span class='const'>I</span> <span class='id identifier rubyid_want'>want</span> <span class='id identifier rubyid_safe'>safe</span><span class='comma'>,</span> <span class='id identifier rubyid_asynchronous'>asynchronous</span> <span class='id identifier rubyid_behavior'>behavior</span>
<span class='const'>So</span> <span class='id identifier rubyid_my'>my</span> <span class='id identifier rubyid_long'>long</span><span class='op'>-</span><span class='id identifier rubyid_running'>running</span> <span class='id identifier rubyid_methods'>methods</span> <span class='id identifier rubyid_don'>don</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>t block the main thread</span></code></pre>

<p>“‘</p>

<p>The <code>Async</code> module is a way to mix simple yet powerful asynchronous capabilities into any plain old Ruby object or class, turning each object into a simple Actor. Method calls are processed on a background thread. The caller is free to perform other actions while processing occurs in the background.</p>

<p>Method calls to the asynchronous object are made via two proxy methods: <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> (alias <a href="#cast-instance_method" title="Concurrent::Async#cast (method)">#cast</a>) and <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a> (alias <a href="#call-instance_method" title="Concurrent::Async#call (method)">#call</a>). These proxy methods post the method call to the object’s background thread and return a “future” which will eventually contain the result of the method call.</p>

<p>This behavior is loosely patterned after Erlang’s <code>gen_server</code> behavior. When an Erlang module implements the <code>gen_server</code> behavior it becomes inherently asynchronous. The <code>start</code> or <code>start_link</code> function spawns a process (similar to a thread but much more lightweight and efficient) and returns the ID of the process. Using the process ID, other processes can send messages to the <code>gen_server</code> via the <a href="#cast-instance_method" title="Concurrent::Async#cast (method)">#cast</a> and <a href="#call-instance_method" title="Concurrent::Async#call (method)">#call</a> methods. Unlike Erlang’s <code>gen_server</code>, however, <code>Async</code> classes do not support linking or supervision trees.</p>

<h3 id="label-Basic+Usage">Basic Usage</h3>

<p>When this module is mixed into a class, objects of the class become inherently asynchronous. Each object gets its own background thread on which to post asynchronous method calls. Asynchronous method calls are executed in the background one at a time in the order they are received.</p>

<p>To create an asynchronous class, simply mix in the <code>Async</code> module:</p>

<p>“‘ class Hello</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_include'>include</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Async</span>

<span class='kw'>def</span> <span class='id identifier rubyid_hello'>hello</span>(<span class='id identifier rubyid_name'>name</span>)
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello, </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>!</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span></code></pre>

<p>end “‘</p>

<p>Mixing this module into a class provides each object two proxy methods: <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> and <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a>. These methods are thread safe with respect to the enclosing object. The former proxy allows methods to be called asynchronously by posting to the object’s internal thread. The latter proxy allows a method to be called synchronously but does so safely with respect to any pending asynchronous method calls and ensures proper ordering. Both methods return a <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> which can be inspected for the result of the proxied method call. Calling a method with <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> will return a <code>:pending</code> <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a> whereas <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a> will return a <code>:complete</code> <a href="IVar.html" title="Concurrent::IVar (class)"><code>IVar</code></a>.</p>

<p>“‘ class Echo</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_include'>include</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Async</span>

<span class='kw'>def</span> <span class='id identifier rubyid_echo'>echo</span>(<span class='id identifier rubyid_msg'>msg</span>)
  <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_msg'>msg</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span></code></pre>

<p>end</p>

<p>horn = <code>Echo.new</code> horn.echo(‘zero’)      # synchronous, not thread-safe</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># returns the actual return value of the method</span></code></pre>

<p>horn.async.echo(‘one’) # asynchronous, non-blocking, thread-safe</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># returns an IVar in the :pending state</span></code></pre>

<p>horn.await.echo(‘two’) # synchronous, blocking, thread-safe</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># returns an IVar in the :complete state</span></code></pre>

<p>“‘</p>

<h3 id="label-Let+It+Fail">Let It Fail</h3>

<p>The <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> and <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a> proxy methods have built-in error protection based on Erlang’s famous “let it fail” philosophy. Instance methods should not be programmed defensively. When an exception is raised by a delegated method the proxy will rescue the exception, expose it to the caller as the <code>reason</code> attribute of the returned future, then process the next method call.</p>

<h3 id="label-Calling+Methods+Internally">Calling Methods Internally</h3>

<p>External method calls should <strong>always</strong> use the <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> and <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a> proxy methods. When one method calls another method, the <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> proxy should rarely be used and the <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a> proxy should <strong>never</strong> be used.</p>

<p>When an object calls one of its own methods using the <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a> proxy the second call will be enqueued <strong>behind</strong> the currently running method call. Any attempt to wait on the result will fail as the second call will never run until after the current call completes.</p>

<p>Calling a method using the <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a> proxy from within a method that was itself called using <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> or <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a> will irreversibly deadlock the object. Do <strong>not</strong> do this, ever.</p>

<h3 id="label-Instance+Variables+and+Attribute+Accessors">Instance Variables and Attribute Accessors</h3>

<p>Instance variables do not need to be thread-safe so long as they are private. Asynchronous method calls are processed in the order they are received and are processed one at a time. Therefore private instance variables can only be accessed by one thread at a time. This is inherently thread-safe.</p>

<p>When using private instance variables within asynchronous methods, the best practice is to read the instance variable into a local variable at the start of the method then update the instance variable at the <strong>end</strong> of the method. This way, should an exception be raised during method execution the internal state of the object will not have been changed.</p>

<h4 id="label-Reader+Attributes">Reader Attributes</h4>

<p>The use of <code>attr_reader</code> is discouraged. Internal state exposed externally, when necessary, should be done through accessor methods. The instance variables exposed by these methods <strong>must</strong> be thread-safe, or they must be called using the <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> and <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a> proxy methods. These two approaches are subtly different.</p>

<p>When internal state is accessed via the <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> and <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a> proxy methods, the returned value represents the object’s state *at the time the call is processed*, which may <strong>not</strong> be the state of the object at the time the call is made.</p>

<p>To get the state *at the current* time, irrespective of an enqueued method calls, a reader method must be called directly. This is inherently unsafe unless the instance variable is itself thread-safe, preferably using one of the thread-safe classes within this library. Because the thread-safe classes within this library are internally-locking or non-locking, they can be safely used from within asynchronous methods without causing deadlocks.</p>

<p>Generally speaking, the best practice is to <strong>not</strong> expose internal state via reader methods. The best practice is to simply use the method’s return value.</p>

<h4 id="label-Writer+Attributes">Writer Attributes</h4>

<p>Writer attributes should never be used with asynchronous classes. Changing the state externally, even when done in the thread-safe way, is not logically consistent. Changes to state need to be timed with respect to all asynchronous method calls which my be in-process or enqueued. The only safe practice is to pass all necessary data to each method as arguments and let the method update the internal state as necessary.</p>

<h3 id="label-Class+Constants-2C+Variables-2C+and+Methods">Class Constants, Variables, and Methods</h3>

<h4 id="label-Class+Constants">Class Constants</h4>

<p>Class constants do not need to be thread-safe. Since they are read-only and immutable they may be safely read both externally and from within asynchronous methods.</p>

<h4 id="label-Class+Variables">Class Variables</h4>

<p>Class variables should be avoided. Class variables represent shared state. Shared state is anathema to concurrency. Should there be a need to share state using class variables they <strong>must</strong> be thread-safe, preferably using the thread-safe classes within this library. When updating class variables, never assign a new value/object to the variable itself. Assignment is not thread-safe in Ruby. Instead, use the thread-safe update functions of the variable itself to change the value.</p>

<p>The best practice is to <strong>never</strong> use class variables with <code>Async</code> classes.</p>

<h4 id="label-Class+Methods">Class Methods</h4>

<p>Class methods which are pure functions are safe. Class methods which modify class variables should be avoided, for all the reasons listed above.</p>

<h3 id="label-An+Important+Note+About+Thread+Safe+Guarantees">An Important Note About Thread Safe Guarantees</h3>

<p>&gt; Thread safe guarantees can only be made when asynchronous method calls &gt; are not mixed with direct method calls. Use only direct method calls &gt; when the object is used exclusively on a single thread. Use only &gt; <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> and <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a> when the object is shared between threads. Once you &gt; call a method using <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> or <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a>, you should no longer call methods &gt; directly on the object. Use <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> and <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a> exclusively from then on.</p>

  </div>
</div>
<div class='tags'>
    <div class='examples'>
    <p class='tag_title'>Examples:</p>
      <pre class='example code "#{object.source_type}"'><code><span class='kw'>class</span> <span class='const'>Echo</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>Async</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_echo'>echo</span>(<span class='id identifier rubyid_msg'>msg</span>)
    <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_msg'>msg</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_horn'>horn</span> <span class='op'>=</span> <span class='const'>Echo</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Async.new (method)">new</a></span>
<span class='id identifier rubyid_horn'>horn</span>.<span class='id identifier rubyid_echo'>echo</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>zero</span><span class='tstring_end'>&#39;</span></span>)      <span class='comment'># synchronous, not thread-safe
</span>                       <span class='comment'># returns the actual return value of the method
</span>
<span class='id identifier rubyid_horn'>horn</span>.<span class='id identifier rubyid_async'><a href="#async-instance_method" title="Concurrent::Async#async (method)">async</a></span>.<span class='id identifier rubyid_echo'>echo</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>one</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># asynchronous, non-blocking, thread-safe
</span>                       <span class='comment'># returns an IVar in the :pending state
</span>
<span class='id identifier rubyid_horn'>horn</span>.<span class='id identifier rubyid_await'><a href="#await-instance_method" title="Concurrent::Async#await (method)">await</a></span>.<span class='id identifier rubyid_echo'>echo</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>two</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># synchronous, blocking, thread-safe
</span>                       <span class='comment'># returns an IVar in the :complete state</span></code></pre>
  </div>
  <p class='tag_title'>See Also:</p>
  <ul class='see'>
      <li><a href="Actor.html" title="Concurrent::Actor (module)"><code>Actor</code></a></li>
          <li><a href="https://en.wikipedia.org/wiki/Actor_model" target="_parent" title="&quot;Actor Model&quot; at Wikipedia">"Actor Model" at Wikipedia</a></li>
          <li><a href="http://www.erlang.org/doc/man/gen_server.html" target="_parent" title="Erlang gen_server">Erlang gen_server</a></li>
          <li><a href="http://c2.com/cgi/wiki?LetItCrash" target="_parent" title="&quot;Let It Crash&quot; at http://c2.com/">"Let It Crash" at http://c2.com/</a></li>
      </ul>

</div>
</div>
<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#new-class_method" title=".new (class method)">.<strong>new</strong>(*args, &amp;block)  &#x21d2; Object </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Instantiate a new object and ensure proper initialization of the synchronization mechanisms.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#included-class_method" title=".included (class method)">.<strong>included</strong>(base)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#validate_argc-class_method" title=".validate_argc (class method)">.<strong>validate_argc</strong>(obj, method, *args)  </a>
    </span>
    <span class='note title private'>private</span>
    <div class='summary_desc'>
      <div class='inline'><p>Check for the presence of a method on an object and determine if a given set of arguments matches the required arity.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#async-instance_method" title="#async (instance method)">#<strong>async</strong>  &#x21d2; Concurrent::IVar </a>
      (also: #cast)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Causes the chained method call to be performed asynchronously on the object’s thread.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#await-instance_method" title="#await (instance method)">#<strong>await</strong>  &#x21d2; Concurrent::IVar </a>
      (also: #call)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Causes the chained method call to be performed synchronously on the current thread.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#call-instance_method" title="#call (instance method)">#<strong>call</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#cast-instance_method" title="#cast (instance method)">#<strong>cast</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#init_synchronization-instance_method" title="#init_synchronization (instance method)">#<strong>init_synchronization</strong>  </a>
    </span>
    <span class='note title private'>private</span>
    <div class='summary_desc'>
      <div class='inline'><p>Initialize the internal serializer and other stnchronization mechanisms.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- instance_method_summary -->
<h2 class='y_details'>Class Method Details</h2>
<section class='method_details first' id="included-class_method">
  <h3 class='signature priv first'>
    .<strong>included</strong>(base)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/async.rb#L262-L266'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='262' data-end='266'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/async.rb', line 262</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_included'>included</span>(<span class='id identifier rubyid_base'>base</span>)
  <span class='id identifier rubyid_base'>base</span>.<span class='id identifier rubyid_singleton_class'>singleton_class</span>.<span class='id identifier rubyid_send'>send</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_alias_method'>alias_method</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_original_new'>original_new</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Async.new (method)">new</a></span>)
  <span class='id identifier rubyid_base'>base</span>.<span class='id identifier rubyid_extend'>extend</span>(<span class='const'><a href="Async/ClassMethods.html" title="Concurrent::Async::ClassMethods (module)">ClassMethods</a></span>)
  <span class='kw'>super</span>(<span class='id identifier rubyid_base'>base</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="new-class_method">
  <h3 class='signature '>
    .<strong>new</strong>(*args, &amp;block)  &#x21d2; <a href="../Object.html" title="Object (class)">Object</a> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Instantiate a new object and ensure proper initialization of the synchronization mechanisms.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>args</span>
    <span class='type'>(<a href="Array.html" title="Concurrent::Array (class)">Array</a>&lt;<a href="../Object.html" title="Object (class)">Object</a>&gt;)</span>
&mdash;    <div class='inline'>
<p>Zero or more arguments to be passed to the object’s initializer.</p>
</div>
  </li>
  <li>
    <span class='name'>block</span>
    <span class='type'>(<code>Proc</code>)</span>
&mdash;    <div class='inline'>
<p>Optional block to pass to the object’s initializer.</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="../Object.html" title="Object (class)">Object</a>)</span>
&mdash;    <div class='inline'>
<p>A properly initialized object of the asynchronous class.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[ <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/async.rb#L219-L219'>GitHub</a> ]</span>

</section>

<section class='method_details' id="validate_argc-class_method">
  <h3 class='signature priv'>
    .<strong>validate_argc</strong>(obj, method, *args)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'>
<p>This check is imperfect because of the way Ruby reports the arity of methods with a variable number of arguments. It is possible to determine if too few arguments are given but impossible to determine if too many arguments are given. This check may also fail to recognize dynamic behavior of the object, such as methods simulated with <code>method_missing</code>.</p>
</div>
  </div>


<p>Check for the presence of a method on an object and determine if a given set of arguments matches the required arity.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Parameters:</p>
<ul class='param'>
  <li>
    <span class='name'>obj</span>
    <span class='type'>(<a href="../Object.html" title="Object (class)">Object</a>)</span>
&mdash;    <div class='inline'>
<p>the object to check against</p>
</div>
  </li>
  <li>
    <span class='name'>method</span>
    <span class='type'>(<code>Symbol</code>)</span>
&mdash;    <div class='inline'>
<p>the method to check the object for</p>
</div>
  </li>
  <li>
    <span class='name'>args</span>
    <span class='type'>(<a href="Array.html" title="Concurrent::Array (class)">Array</a>)</span>
&mdash;    <div class='inline'>
<p>zero or more arguments for the arity check</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<code>NameError</code>)</span>
&mdash;    <div class='inline'>
<p>the object does not respond to <code>method</code> method</p>
</div>
  </li>
  <li>
    <span class='type'>(<code>ArgumentError</code>)</span>
&mdash;    <div class='inline'>
<p>the given <code>args</code> do not match the arity of <code>method</code></p>
</div>
  </li>
</ul>
  <p class='tag_title'>See Also:</p>
  <ul class='see'>
      <li><a href="http://www.ruby-doc.org/core-2.1.1/Method.html#method-i-arity" target="_parent" title="{Method#arity}">{Method#arity}</a></li>
          <li><a href="http://ruby-doc.org/core-2.1.0/Object.html#method-i-respond_to-3F" target="_parent" title="{Object#respond_to?}">{Object#respond_to?}</a></li>
          <li><a href="http://www.ruby-doc.org/core-2.1.0/BasicObject.html#method-i-method_missing" target="_parent" title="{BasicObject#method_missing}">{BasicObject#method_missing}</a></li>
      </ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/async.rb#L250-L259'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='250' data-end='259'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/async.rb', line 250</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_validate_argc'>validate_argc</span>(<span class='id identifier rubyid_obj'>obj</span><span class='comma'>,</span> <span class='id identifier rubyid_method'>method</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span>)
  <span class='id identifier rubyid_argc'>argc</span> <span class='op'>=</span> <span class='id identifier rubyid_args'>args</span>.<span class='id identifier rubyid_length'>length</span>
  <span class='id identifier rubyid_arity'>arity</span> <span class='op'>=</span> <span class='id identifier rubyid_obj'>obj</span>.<span class='id identifier rubyid_method'>method</span>(<span class='id identifier rubyid_method'>method</span>).<span class='id identifier rubyid_arity'>arity</span>

  <span class='kw'>if</span> <span class='id identifier rubyid_arity'>arity</span> <span class='op'>&gt;=</span> <span class='int'>0</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_argc'>argc</span> <span class='op'>!=</span> <span class='id identifier rubyid_arity'>arity</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Async.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>wrong number of arguments (</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_argc'>argc</span><span class='embexpr_end'>}</span><span class='tstring_content'> for </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_arity'>arity</span><span class='embexpr_end'>}</span><span class='tstring_content'>)</span><span class='tstring_end'>&quot;</span></span>)
  <span class='kw'>elsif</span> <span class='id identifier rubyid_arity'>arity</span> <span class='op'>&lt;</span> <span class='int'>0</span> <span class='op'>&amp;&amp;</span> (<span class='id identifier rubyid_arity'>arity</span> <span class='op'>=</span> (<span class='id identifier rubyid_arity'>arity</span> <span class='op'>+</span> <span class='int'>1</span>).<span class='id identifier rubyid_abs'>abs</span>) <span class='op'>&gt;</span> <span class='id identifier rubyid_argc'>argc</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::Async.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>wrong number of arguments (</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_argc'>argc</span><span class='embexpr_end'>}</span><span class='tstring_content'> for </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_arity'>arity</span><span class='embexpr_end'>}</span><span class='tstring_content'>..*)</span><span class='tstring_end'>&quot;</span></span>)
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="async-instance_method">
  <h3 class='signature  first'>
    #<strong>async</strong>  &#x21d2; <a href="IVar.html" title="Concurrent::IVar (class)">Concurrent::IVar</a> 
    <span class='aliases'>Also known as: <span class='names'>#cast</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'>
<p>The method call is guaranteed to be thread safe with respect to all other method calls against the same object that are called with either <code>async</code> or <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a>. The mutable nature of Ruby references (and object orientation in general) prevent any other thread safety guarantees. Do NOT mix direct method calls with delegated method calls. Use <strong>only</strong> delegated method calls when sharing the object between threads.</p>
</div>
  </div>


<p>Causes the chained method call to be performed asynchronously on the object’s thread. The delegated method will return a future in the <code>:pending</code> state and the method call will have been scheduled on the object’s thread. The final disposition of the method call can be obtained by inspecting the returned future.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="IVar.html" title="Concurrent::IVar (class)">Concurrent::IVar</a>)</span>
&mdash;    <div class='inline'>
<p>the pending result of the asynchronous operation</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<code>NameError</code>)</span>
&mdash;    <div class='inline'>
<p>the object does not respond to the requested method</p>
</div>
  </li>
  <li>
    <span class='type'>(<code>ArgumentError</code>)</span>
&mdash;    <div class='inline'>
<p>the given <code>args</code> do not match the arity of the requested method</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/async.rb#L412-L414'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='412' data-end='414'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/async.rb', line 412</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_async'>async</span>
  <span class='ivar'>@__async_delegator__</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="await-instance_method">
  <h3 class='signature '>
    #<strong>await</strong>  &#x21d2; <a href="IVar.html" title="Concurrent::IVar (class)">Concurrent::IVar</a> 
    <span class='aliases'>Also known as: <span class='names'>#call</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'>
<p>The method call is guaranteed to be thread safe with respect to all other method calls against the same object that are called with either <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a> or <code>await</code>. The mutable nature of Ruby references (and object orientation in general) prevent any other thread safety guarantees. Do NOT mix direct method calls with delegated method calls. Use <strong>only</strong> delegated method calls when sharing the object between threads.</p>
</div>
  </div>


<p>Causes the chained method call to be performed synchronously on the current thread. The delegated will return a future in either the <code>:fulfilled</code> or <code>:rejected</code> state and the delegated method will have completed. The final disposition of the delegated method can be obtained by inspecting the returned future.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="IVar.html" title="Concurrent::IVar (class)">Concurrent::IVar</a>)</span>
&mdash;    <div class='inline'>
<p>the completed result of the synchronous operation</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<code>NameError</code>)</span>
&mdash;    <div class='inline'>
<p>the object does not respond to the requested method</p>
</div>
  </li>
  <li>
    <span class='type'>(<code>ArgumentError</code>)</span>
&mdash;    <div class='inline'>
<p>the given <code>args</code> do not match the arity of the requested method</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/async.rb#L430-L432'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='430' data-end='432'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/async.rb', line 430</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_await'>await</span>
  <span class='ivar'>@__await_delegator__</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="call-instance_method">
  <h3 class='signature '>
    #<strong>call</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#await-instance_method" title="Concurrent::Async#await (method)">#await</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/async.rb#L433-L433'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='433' data-end='433'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/async.rb', line 433</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_call'>call</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_await'><a href="#await-instance_method" title="Concurrent::Async#await (method)">await</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="cast-instance_method">
  <h3 class='signature '>
    #<strong>cast</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#async-instance_method" title="Concurrent::Async#async (method)">#async</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/async.rb#L415-L415'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='415' data-end='415'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/async.rb', line 415</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_cast'>cast</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_async'><a href="#async-instance_method" title="Concurrent::Async#async (method)">async</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="init_synchronization-instance_method">
  <h3 class='signature priv'>
    #<strong>init_synchronization</strong>   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'>
<p>This method <strong>must</strong> be called immediately upon object construction. This is the only way thread-safe initialization can be guaranteed.</p>
</div>
  </div>


<p>Initialize the internal serializer and other stnchronization mechanisms.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/async.rb#L441-L447'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='441' data-end='447'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/async.rb', line 441</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_init_synchronization'>init_synchronization</span>
  <span class='kw'>return</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='kw'>defined?</span>(<span class='ivar'>@__async_initialized__</span>) <span class='op'>&amp;&amp;</span> <span class='ivar'>@__async_initialized__</span>
  <span class='ivar'>@__async_initialized__</span> <span class='op'>=</span> <span class='kw'>true</span>
  <span class='ivar'>@__async_delegator__</span> <span class='op'>=</span> <span class='const'><a href="Async/AsyncDelegator.html" title="Concurrent::Async::AsyncDelegator (class)">AsyncDelegator</a></span>.<span class='id identifier rubyid_new'><a href="Async/AsyncDelegator.html#new-class_method" title="Concurrent::Async::AsyncDelegator.new (method)">new</a></span>(<span class='kw'>self</span>)
  <span class='ivar'>@__await_delegator__</span> <span class='op'>=</span> <span class='const'><a href="Async/AwaitDelegator.html" title="Concurrent::Async::AwaitDelegator (class)">AwaitDelegator</a></span>.<span class='id identifier rubyid_new'><a href="Async/AwaitDelegator.html#new-class_method" title="Concurrent::Async::AwaitDelegator.new (method)">new</a></span>(<span class='ivar'>@__async_delegator__</span>)
  <span class='kw'>self</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>