<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: Concurrent::ReentrantReadWriteLock &mdash; Concurrent Ruby master</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Concurrent::ReentrantReadWriteLock",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../'>Concurrent</a> &raquo; 
      <a href='../_index.html#alpha_R'>Index (R)</a> &raquo; 
        <a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>ReentrantReadWriteLock&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: Concurrent::ReentrantReadWriteLock</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Super Chains via Extension / Inclusion / Inheritance</td></tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Class Chain:</div>
        <div class='box_22'>
          self,
          <a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a>,
          <a href="Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)"><code>Synchronization::AbstractObject</code></a>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Instance Chain:</div>
        <div class='box_22'>
          self,
          <a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a>,
          <a href="Synchronization/Volatile.html" title="Concurrent::Synchronization::Volatile (module)"><code>Synchronization::Volatile</code></a>,
          <a href="Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)"><code>Synchronization::AbstractObject</code></a>
        </div>
      </td>
    </tr>
    <tr>
      <td id='t2_inherits' class='box_2 o'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'><a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)">Concurrent::Synchronization::Object</a></span>
        <ul class='fullTree'>
          <li><a href="../Object.html" title="Object (class)"><code>::Object</code></a></li>
          <li class='next'><a href="Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)">Concurrent::Synchronization::AbstractObject</a></li>
          <li class='next'><a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)">Concurrent::Synchronization::Object</a></li>
          <li class='next'>Concurrent::ReentrantReadWriteLock</li>
        </ul>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L53'>lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb</a>      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p>Re-entrant read-write lock implementation</p>

<p>Allows any number of concurrent readers, but only one concurrent writer (And while the “write” lock is taken, no read locks can be obtained either. Hence, the write lock can also be called an “exclusive” lock.)</p>

<p>If another thread has taken a read lock, any thread which wants a write lock will block until all the readers release their locks. However, once a thread starts waiting to obtain a write lock, any additional readers that come along will also wait (so writers are not starved).</p>

<p>A thread can acquire both a read and write lock at the same time. A thread can also acquire a read lock OR a write lock more than once. Only when the read (or write) lock is released as many times as it was acquired, will the thread actually let it go, allowing other threads which might have been waiting to proceed. Therefore the lock can be upgraded by first acquiring read lock and then write lock and that the lock can be downgraded by first having both read and write lock a releasing just the write lock.</p>

<p>If both read and write locks are acquired by the same thread, it is not strictly necessary to release them in the same order they were acquired. In other words, the following code is legal:</p>

<p>This implementation was inspired by <code>java.util.concurrent.ReentrantReadWriteLock</code>.</p>

  </div>
</div>
<div class='tags'>
    <div class='examples'>
    <p class='tag_title'>Examples:</p>
      <pre class='example code "#{object.source_type}"'><code><span class='id identifier rubyid_lock'>lock</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>ReentrantReadWriteLock</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::ReentrantReadWriteLock.new (method)">new</a></span>
<span class='id identifier rubyid_lock'>lock</span>.<span class='id identifier rubyid_acquire_write_lock'><a href="#acquire_write_lock-instance_method" title="Concurrent::ReentrantReadWriteLock#acquire_write_lock (method)">acquire_write_lock</a></span>
<span class='id identifier rubyid_lock'>lock</span>.<span class='id identifier rubyid_acquire_read_lock'><a href="#acquire_read_lock-instance_method" title="Concurrent::ReentrantReadWriteLock#acquire_read_lock (method)">acquire_read_lock</a></span>
<span class='id identifier rubyid_lock'>lock</span>.<span class='id identifier rubyid_release_write_lock'><a href="#release_write_lock-instance_method" title="Concurrent::ReentrantReadWriteLock#release_write_lock (method)">release_write_lock</a></span>
<span class='comment'># At this point, the current thread is holding only a read lock, not a write
</span><span class='comment'># lock. So other threads can take read locks, but not a write lock.
</span><span class='id identifier rubyid_lock'>lock</span>.<span class='id identifier rubyid_release_read_lock'><a href="#release_read_lock-instance_method" title="Concurrent::ReentrantReadWriteLock#release_read_lock (method)">release_read_lock</a></span>
<span class='comment'># Now the current thread is not holding either a read or write lock, so
</span><span class='comment'># another thread could potentially acquire a write lock.</span></code></pre>
      <pre class='example code "#{object.source_type}"'><code><span class='id identifier rubyid_lock'>lock</span> <span class='op'>=</span> <span class='const'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span><span class='op'>::</span><span class='const'>ReentrantReadWriteLock</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::ReentrantReadWriteLock.new (method)">new</a></span>
<span class='id identifier rubyid_lock'>lock</span>.<span class='id identifier rubyid_with_read_lock'><a href="#with_read_lock-instance_method" title="Concurrent::ReentrantReadWriteLock#with_read_lock (method)">with_read_lock</a></span>  { <span class='id identifier rubyid_data'>data</span>.<span class='id identifier rubyid_retrieve'>retrieve</span> }
<span class='id identifier rubyid_lock'>lock</span>.<span class='id identifier rubyid_with_write_lock'><a href="#with_write_lock-instance_method" title="Concurrent::ReentrantReadWriteLock#with_write_lock (method)">with_write_lock</a></span> { <span class='id identifier rubyid_data'>data</span>.<span class='id identifier rubyid_modify!'>modify!</span> }</code></pre>
  </div>
  <p class='tag_title'>See Also:</p>
  <ul class='see'>
      <li><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html" target="_parent" title="java.util.concurrent.ReentrantReadWriteLock">java.util.concurrent.ReentrantReadWriteLock</a></li>
      </ul>

</div>
</div>
<h2 id='t2_cnst' class='h2_sum'>Constant Summary</h2>
<div>
<ul class='constants summary full'>
  <li>
    <span id='MAX_READERS-constant' class='summary_signature priv'>MAX_READERS =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L94-L94'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 94</a>    <pre class='code ruby'><span class='const'><a href="#WAITING_WRITER-constant" title="Concurrent::ReentrantReadWriteLock::WAITING_WRITER (constant)">WAITING_WRITER</a></span> <span class='op'>-</span> <span class='int'>1</span></pre>
  </li>
  <li>
    <span id='MAX_WRITERS-constant' class='summary_signature priv'>MAX_WRITERS =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L96-L96'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 96</a>    <pre class='code ruby'><span class='const'><a href="#RUNNING_WRITER-constant" title="Concurrent::ReentrantReadWriteLock::RUNNING_WRITER (constant)">RUNNING_WRITER</a></span> <span class='op'>-</span> <span class='const'><a href="#MAX_READERS-constant" title="Concurrent::ReentrantReadWriteLock::MAX_READERS (constant)">MAX_READERS</a></span> <span class='op'>-</span> <span class='int'>1</span></pre>
  </li>
  <li>
    <span id='READER_BITS-constant' class='summary_signature priv'>READER_BITS =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L84-L84'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 84</a>    <pre class='code ruby'><span class='int'>15</span></pre>
  </li>
  <li>
    <span id='READ_LOCK_MASK-constant' class='summary_signature priv'>READ_LOCK_MASK =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L102-L102'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 102</a>    <pre class='code ruby'><span class='const'><a href="#WRITE_LOCK_HELD-constant" title="Concurrent::ReentrantReadWriteLock::WRITE_LOCK_HELD (constant)">WRITE_LOCK_HELD</a></span> <span class='op'>-</span> <span class='int'>1</span></pre>
  </li>
  <li>
    <span id='RUNNING_WRITER-constant' class='summary_signature priv'>RUNNING_WRITER =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L92-L92'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 92</a>    <pre class='code ruby'><span class='int'>1</span> <span class='op'>&lt;&lt;</span> (<span class='const'><a href="#READER_BITS-constant" title="Concurrent::ReentrantReadWriteLock::READER_BITS (constant)">READER_BITS</a></span> <span class='op'>+</span> <span class='const'><a href="#WRITER_BITS-constant" title="Concurrent::ReentrantReadWriteLock::WRITER_BITS (constant)">WRITER_BITS</a></span>)</pre>
  </li>
  <li>
    <span id='WAITING_WRITER-constant' class='summary_signature priv'>WAITING_WRITER =</span>
    <span class='note title private'>private</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>Used with @Counter:</p>

  </div>
</div>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L90-L90'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 90</a>    <pre class='code ruby'><span class='int'>1</span> <span class='op'>&lt;&lt;</span> <span class='const'><a href="#READER_BITS-constant" title="Concurrent::ReentrantReadWriteLock::READER_BITS (constant)">READER_BITS</a></span></pre>
  </li>
  <li>
    <span id='WRITER_BITS-constant' class='summary_signature priv'>WRITER_BITS =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L86-L86'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 86</a>    <pre class='code ruby'><span class='int'>14</span></pre>
  </li>
  <li>
    <span id='WRITE_LOCK_HELD-constant' class='summary_signature priv'>WRITE_LOCK_HELD =</span>
    <span class='note title private'>private</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>Used with @HeldCount:</p>

  </div>
</div>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L100-L100'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 100</a>    <pre class='code ruby'><span class='int'>1</span> <span class='op'>&lt;&lt;</span> <span class='const'><a href="#READER_BITS-constant" title="Concurrent::ReentrantReadWriteLock::READER_BITS (constant)">READER_BITS</a></span></pre>
  </li>
  <li>
    <span id='WRITE_LOCK_MASK-constant' class='summary_signature priv'>WRITE_LOCK_MASK =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L104-L104'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 104</a>    <pre class='code ruby'><span class='const'><a href="#MAX_WRITERS-constant" title="Concurrent::ReentrantReadWriteLock::MAX_WRITERS (constant)">MAX_WRITERS</a></span></pre>
  </li>
</ul>
</div>

<h2 class='h2_sum' id='class_Attribute_summary'>Class Attribute Summary</h2>
<div class='div_sum'>

<h3 class='inherited'><a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ro' href="Synchronization/Object.html#safe_initialization%3F-class_method" title="Concurrent::Synchronization::Object.safe_initialization? (method)">.safe_initialization?</a>
      </td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- class_attribute_summary -->

<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#new-class_method" title=".new (class method)">.<strong>new</strong>  &#x21d2; ReentrantReadWriteLock </a>
    </span>
    <span class='note title constructor'>constructor</span>
    <div class='summary_desc'>
      <div class='inline'><p>Create a new <code>ReentrantReadWriteLock</code> in the unlocked state.</p></div>
    </div>
  </li>
</ul>

<h3 class='inherited'><a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="Synchronization/Object.html#atomic_attribute%3F-class_method" title="Concurrent::Synchronization::Object.atomic_attribute? (method)">.atomic_attribute?</a>,
        <a class='i_m ' href="Synchronization/Object.html#atomic_attributes-class_method" title="Concurrent::Synchronization::Object.atomic_attributes (method)">.atomic_attributes</a>,
      </td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Synchronization/Object.html#attr_atomic-class_method" title="Concurrent::Synchronization::Object.attr_atomic (method)">.attr_atomic</a></td>
      <td><div class='inline'><p>Creates methods for reading and writing to a instance variable with volatile (Java) semantic as <code>.attr_volatile</code> does.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Synchronization/Object.html#attr_volatile-class_method" title="Concurrent::Synchronization::Object.attr_volatile (method)">.attr_volatile</a></td>
      <td><div class='inline'><p>Creates methods for reading and writing (as <code>attr_accessor</code> does) to a instance variable with volatile (Java) semantic.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Synchronization/Object.html#ensure_safe_initialization_when_final_fields_are_present-class_method" title="Concurrent::Synchronization::Object.ensure_safe_initialization_when_final_fields_are_present (method)">.ensure_safe_initialization_when_final_fields_are_present</a></td>
      <td><div class='inline'><p>For testing purposes, quite slow.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="Synchronization/Object.html#new-class_method" title="Concurrent::Synchronization::Object.new (method)">.new</a></td>
      <td><div class='inline'><p>Has to be called by children.</p></div></td>
    </tr>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="Synchronization/Object.html#safe_initialization!-class_method" title="Concurrent::Synchronization::Object.safe_initialization! (method)">.safe_initialization!</a>,
        <a class='i_m priv' href="Synchronization/Object.html#define_initialize_atomic_fields-class_method" title="Concurrent::Synchronization::Object.define_initialize_atomic_fields (method)">.define_initialize_atomic_fields</a>
      </td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)"><code>Synchronization::AbstractObject</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="Synchronization/AbstractObject.html#attr_volatile-class_method" title="Concurrent::Synchronization::AbstractObject.attr_volatile (method)">.attr_volatile</a>,
        <a class='i_m ' href="Synchronization/AbstractObject.html#new-class_method" title="Concurrent::Synchronization::AbstractObject.new (method)">.new</a>
      </td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#acquire_read_lock-instance_method" title="#acquire_read_lock (instance method)">#<strong>acquire_read_lock</strong>  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Acquire a read lock.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#acquire_write_lock-instance_method" title="#acquire_write_lock (instance method)">#<strong>acquire_write_lock</strong>  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Acquire a write lock.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#release_read_lock-instance_method" title="#release_read_lock (instance method)">#<strong>release_read_lock</strong>  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Release a previously acquired read lock.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#release_write_lock-instance_method" title="#release_write_lock (instance method)">#<strong>release_write_lock</strong>  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Release a previously acquired write lock.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#try_read_lock-instance_method" title="#try_read_lock (instance method)">#<strong>try_read_lock</strong>  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Try to acquire a read lock and return true if we succeed.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#try_write_lock-instance_method" title="#try_write_lock (instance method)">#<strong>try_write_lock</strong>  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Try to acquire a write lock and return true if we succeed.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#with_read_lock-instance_method" title="#with_read_lock (instance method)">#<strong>with_read_lock</strong> { ... } &#x21d2; Object </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Execute a block operation within a read lock.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#with_write_lock-instance_method" title="#with_write_lock (instance method)">#<strong>with_write_lock</strong> { ... } &#x21d2; Object </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Execute a block operation within a write lock.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#max_readers%3F-instance_method" title="#max_readers? (instance method)">#<strong>max_readers?</strong>(c = @Counter.value)  &#x21d2; Boolean </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#max_writers%3F-instance_method" title="#max_writers? (instance method)">#<strong>max_writers?</strong>(c = @Counter.value)  &#x21d2; Boolean </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#running_readers-instance_method" title="#running_readers (instance method)">#<strong>running_readers</strong>(c = @Counter.value)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#running_readers%3F-instance_method" title="#running_readers? (instance method)">#<strong>running_readers?</strong>(c = @Counter.value)  &#x21d2; Boolean </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#running_writer%3F-instance_method" title="#running_writer? (instance method)">#<strong>running_writer?</strong>(c = @Counter.value)  &#x21d2; Boolean </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#waiting_or_running_writer%3F-instance_method" title="#waiting_or_running_writer? (instance method)">#<strong>waiting_or_running_writer?</strong>(c = @Counter.value)  &#x21d2; Boolean </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#waiting_writers-instance_method" title="#waiting_writers (instance method)">#<strong>waiting_writers</strong>(c = @Counter.value)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
</ul>

<h3 class='inherited'><a href="Synchronization/Object.html" title="Concurrent::Synchronization::Object (class)"><code>Synchronization::Object</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m priv' href="Synchronization/Object.html#__initialize_atomic_fields__-instance_method" title="Concurrent::Synchronization::Object#__initialize_atomic_fields__ (method)">#__initialize_atomic_fields__</a>
      </td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="Synchronization/Volatile.html" title="Concurrent::Synchronization::Volatile (module)"><code>Synchronization::Volatile</code></a> - Included</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m ' href="Synchronization/Volatile.html#full_memory_barrier-instance_method" title="Concurrent::Synchronization::Volatile#full_memory_barrier (method)">#full_memory_barrier</a>
      </td>
    </tr>
  </tbody>
</table></div>

<h3 class='inherited'><a href="Synchronization/AbstractObject.html" title="Concurrent::Synchronization::AbstractObject (class)"><code>Synchronization::AbstractObject</code></a> - Inherited</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr>
      <td colspan='2'>
        <a class='i_m priv' href="Synchronization/AbstractObject.html#full_memory_barrier-instance_method" title="Concurrent::Synchronization::AbstractObject#full_memory_barrier (method)">#full_memory_barrier</a>
      </td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- instance_method_summary -->
<h2 id='Constructor_Details' class='y_details'>Constructor Details</h2>

  <section class='method_details first' id="new-class_method">
  <h3 class='signature  first'>
    .<strong>new</strong>  &#x21d2; <code>ReentrantReadWriteLock</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Create a new <code>ReentrantReadWriteLock</code> in the unlocked state.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L109-L115'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='109' data-end='115'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 109</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_initialize'><a href="../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">initialize</a></span>
  <span class='kw'>super</span>()
  <span class='ivar'>@Counter</span>    <span class='op'>=</span> <span class='const'><a href="AtomicFixnum.html" title="Concurrent::AtomicFixnum (class)">AtomicFixnum</a></span>.<span class='id identifier rubyid_new'><a href="AtomicFixnum.html#new-class_method" title="Concurrent::AtomicFixnum.new (method)">new</a></span>(<span class='int'>0</span>)       <span class='comment'># single integer which represents lock state
</span>  <span class='ivar'>@ReadQueue</span>  <span class='op'>=</span> <span class='const'><a href="Synchronization.html" title="Concurrent::Synchronization (module)">Synchronization</a></span><span class='op'>::</span><span class='const'><a href="Synchronization/Lock.html" title="Concurrent::Synchronization::Lock (class)">Lock</a></span>.<span class='id identifier rubyid_new'><a href="Synchronization.html#initialize-instance_method" title="Concurrent::Synchronization#initialize (method)">new</a></span> <span class='comment'># used to queue waiting readers
</span>  <span class='ivar'>@WriteQueue</span> <span class='op'>=</span> <span class='const'><a href="Synchronization.html" title="Concurrent::Synchronization (module)">Synchronization</a></span><span class='op'>::</span><span class='const'><a href="Synchronization/Lock.html" title="Concurrent::Synchronization::Lock (class)">Lock</a></span>.<span class='id identifier rubyid_new'><a href="Synchronization.html#initialize-instance_method" title="Concurrent::Synchronization#initialize (method)">new</a></span> <span class='comment'># used to queue waiting writers
</span>  <span class='ivar'>@HeldCount</span>  <span class='op'>=</span> <span class='const'><a href="LockLocalVar.html" title="Concurrent::LockLocalVar (class)">LockLocalVar</a></span>.<span class='id identifier rubyid_new'><a href="../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span>(<span class='int'>0</span>) <span class='comment'># indicates # of R &amp; W locks held by this thread
</span><span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="acquire_read_lock-instance_method">
  <h3 class='signature  first'>
    #<strong>acquire_read_lock</strong>  &#x21d2; <code>Boolean</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Acquire a read lock. If a write lock is held by another thread, will block until it is released.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Boolean</code>)</span>
&mdash;    <div class='inline'>
<p>true if the lock is successfully acquired</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<a href="../Concurrent.html#ResourceLimitError-constant" title="Concurrent::ResourceLimitError (constant)">Concurrent::ResourceLimitError</a>)</span>
&mdash;    <div class='inline'>
<p>if the maximum number of readers is exceeded.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L162-L209'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='162' data-end='209'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 162</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_acquire_read_lock'>acquire_read_lock</span>
  <span class='kw'>if</span> (<span class='id identifier rubyid_held'>held</span> <span class='op'>=</span> <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span>) <span class='op'>&gt;</span> <span class='int'>0</span>
    <span class='comment'># If we already have a lock, there&#39;s no need to wait
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>&amp;</span> <span class='const'><a href="#READ_LOCK_MASK-constant" title="Concurrent::ReentrantReadWriteLock::READ_LOCK_MASK (constant)">READ_LOCK_MASK</a></span> <span class='op'>==</span> <span class='int'>0</span>
      <span class='comment'># But we do need to update the counter, if we were holding a write
</span>      <span class='comment'>#   lock but not a read lock
</span>      <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_update'>update</span> { <span class='op'>|</span><span class='id identifier rubyid_c'>c</span><span class='op'>|</span> <span class='id identifier rubyid_c'>c</span> <span class='op'>+</span> <span class='int'>1</span> }
    <span class='kw'>end</span>
    <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>+</span> <span class='int'>1</span>
    <span class='kw'>return</span> <span class='kw'>true</span>
  <span class='kw'>end</span>

  <span class='kw'>while</span> <span class='kw'>true</span>
    <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../Concurrent.html#ResourceLimitError-constant" title="Concurrent::ResourceLimitError (constant)">ResourceLimitError</a></span>.<span class='id identifier rubyid_new'><a href="../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Too many reader threads</span><span class='tstring_end'>&#39;</span></span>) <span class='kw'>if</span> <span class='id identifier rubyid_max_readers?'><a href="#max_readers%3F-instance_method" title="Concurrent::ReentrantReadWriteLock#max_readers? (method)">max_readers?</a></span>(<span class='id identifier rubyid_c'>c</span>)

    <span class='comment'># If a writer is waiting OR running when we first queue up, we need to wait
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_waiting_or_running_writer?'><a href="#waiting_or_running_writer%3F-instance_method" title="Concurrent::ReentrantReadWriteLock#waiting_or_running_writer? (method)">waiting_or_running_writer?</a></span>(<span class='id identifier rubyid_c'>c</span>)
      <span class='comment'># Before going to sleep, check again with the ReadQueue mutex held
</span>      <span class='ivar'>@ReadQueue</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
        <span class='ivar'>@ReadQueue</span>.<span class='id identifier rubyid_ns_wait'>ns_wait</span> <span class='kw'>if</span> <span class='id identifier rubyid_waiting_or_running_writer?'><a href="#waiting_or_running_writer%3F-instance_method" title="Concurrent::ReentrantReadWriteLock#waiting_or_running_writer? (method)">waiting_or_running_writer?</a></span>
      <span class='kw'>end</span>
      <span class='comment'># Note: the above &#39;synchronize&#39; block could have used #wait_until,
</span>      <span class='comment'>#   but that waits repeatedly in a loop, checking the wait condition
</span>      <span class='comment'>#   each time it wakes up (to protect against spurious wakeups)
</span>      <span class='comment'># But we are already in a loop, which is only broken when we successfully
</span>      <span class='comment'>#   acquire the lock! So we don&#39;t care about spurious wakeups, and would
</span>      <span class='comment'>#   rather not pay the extra overhead of using #wait_until
</span>
      <span class='comment'># After a reader has waited once, they are allowed to &quot;barge&quot; ahead of waiting writers
</span>      <span class='comment'># But if a writer is *running*, the reader still needs to wait (naturally)
</span>      <span class='kw'>while</span> <span class='kw'>true</span>
        <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>
        <span class='kw'>if</span> <span class='id identifier rubyid_running_writer?'><a href="#running_writer%3F-instance_method" title="Concurrent::ReentrantReadWriteLock#running_writer? (method)">running_writer?</a></span>(<span class='id identifier rubyid_c'>c</span>)
          <span class='ivar'>@ReadQueue</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
            <span class='ivar'>@ReadQueue</span>.<span class='id identifier rubyid_ns_wait'>ns_wait</span> <span class='kw'>if</span> <span class='id identifier rubyid_running_writer?'><a href="#running_writer%3F-instance_method" title="Concurrent::ReentrantReadWriteLock#running_writer? (method)">running_writer?</a></span>
          <span class='kw'>end</span>
        <span class='kw'>elsif</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_compare_and_set'>compare_and_set</span>(<span class='id identifier rubyid_c'>c</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span><span class='op'>+</span><span class='int'>1</span>)
          <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>+</span> <span class='int'>1</span>
          <span class='kw'>return</span> <span class='kw'>true</span>
        <span class='kw'>end</span>
      <span class='kw'>end</span>
    <span class='kw'>elsif</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_compare_and_set'>compare_and_set</span>(<span class='id identifier rubyid_c'>c</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span><span class='op'>+</span><span class='int'>1</span>)
      <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>+</span> <span class='int'>1</span>
      <span class='kw'>return</span> <span class='kw'>true</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="acquire_write_lock-instance_method">
  <h3 class='signature '>
    #<strong>acquire_write_lock</strong>  &#x21d2; <code>Boolean</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Acquire a write lock. Will block and wait for all active readers and writers.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Boolean</code>)</span>
&mdash;    <div class='inline'>
<p>true if the lock is successfully acquired</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<a href="../Concurrent.html#ResourceLimitError-constant" title="Concurrent::ResourceLimitError (constant)">Concurrent::ResourceLimitError</a>)</span>
&mdash;    <div class='inline'>
<p>if the maximum number of writers is exceeded.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L257-L304'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='257' data-end='304'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 257</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_acquire_write_lock'>acquire_write_lock</span>
  <span class='kw'>if</span> (<span class='id identifier rubyid_held'>held</span> <span class='op'>=</span> <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span>) <span class='op'>&gt;=</span> <span class='const'><a href="#WRITE_LOCK_HELD-constant" title="Concurrent::ReentrantReadWriteLock::WRITE_LOCK_HELD (constant)">WRITE_LOCK_HELD</a></span>
    <span class='comment'># if we already have a write (exclusive) lock, there&#39;s no need to wait
</span>    <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>+</span> <span class='const'><a href="#WRITE_LOCK_HELD-constant" title="Concurrent::ReentrantReadWriteLock::WRITE_LOCK_HELD (constant)">WRITE_LOCK_HELD</a></span>
    <span class='kw'>return</span> <span class='kw'>true</span>
  <span class='kw'>end</span>

  <span class='kw'>while</span> <span class='kw'>true</span>
    <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../Concurrent.html#ResourceLimitError-constant" title="Concurrent::ResourceLimitError (constant)">ResourceLimitError</a></span>.<span class='id identifier rubyid_new'><a href="../Concurrent.html#initialize-instance_method" title="Concurrent#initialize (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Too many writer threads</span><span class='tstring_end'>&#39;</span></span>) <span class='kw'>if</span> <span class='id identifier rubyid_max_writers?'><a href="#max_writers%3F-instance_method" title="Concurrent::ReentrantReadWriteLock#max_writers? (method)">max_writers?</a></span>(<span class='id identifier rubyid_c'>c</span>)

    <span class='comment'># To go ahead and take the lock without waiting, there must be no writer
</span>    <span class='comment'>#   running right now, AND no writers who came before us still waiting to
</span>    <span class='comment'>#   acquire the lock
</span>    <span class='comment'># Additionally, if any read locks have been taken, we must hold all of them
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>&gt;</span> <span class='int'>0</span> <span class='op'>&amp;&amp;</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_compare_and_set'>compare_and_set</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span><span class='op'>+</span><span class='const'><a href="#RUNNING_WRITER-constant" title="Concurrent::ReentrantReadWriteLock::RUNNING_WRITER (constant)">RUNNING_WRITER</a></span>)
      <span class='comment'># If we are the only one reader and successfully swap the RUNNING_WRITER bit on, then we can go ahead
</span>      <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>+</span> <span class='const'><a href="#WRITE_LOCK_HELD-constant" title="Concurrent::ReentrantReadWriteLock::WRITE_LOCK_HELD (constant)">WRITE_LOCK_HELD</a></span>
      <span class='kw'>return</span> <span class='kw'>true</span>
    <span class='kw'>elsif</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_compare_and_set'>compare_and_set</span>(<span class='id identifier rubyid_c'>c</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span><span class='op'>+</span><span class='const'><a href="#WAITING_WRITER-constant" title="Concurrent::ReentrantReadWriteLock::WAITING_WRITER (constant)">WAITING_WRITER</a></span>)
      <span class='kw'>while</span> <span class='kw'>true</span>
        <span class='comment'># Now we have successfully incremented, so no more readers will be able to increment
</span>        <span class='comment'>#   (they will wait instead)
</span>        <span class='comment'># However, readers OR writers could decrement right here
</span>        <span class='ivar'>@WriteQueue</span>.<span class='id identifier rubyid_synchronize'>synchronize</span> <span class='kw'>do</span>
          <span class='comment'># So we have to do another check inside the synchronized section
</span>          <span class='comment'># If a writer OR another reader is running, then go to sleep
</span>          <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>
          <span class='ivar'>@WriteQueue</span>.<span class='id identifier rubyid_ns_wait'>ns_wait</span> <span class='kw'>if</span> <span class='id identifier rubyid_running_writer?'><a href="#running_writer%3F-instance_method" title="Concurrent::ReentrantReadWriteLock#running_writer? (method)">running_writer?</a></span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>||</span> <span class='id identifier rubyid_running_readers'><a href="#running_readers-instance_method" title="Concurrent::ReentrantReadWriteLock#running_readers (method)">running_readers</a></span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>!=</span> <span class='id identifier rubyid_held'>held</span>
        <span class='kw'>end</span>
        <span class='comment'># Note: if you are thinking of replacing the above &#39;synchronize&#39; block
</span>        <span class='comment'># with #wait_until, read the comment in #acquire_read_lock first!
</span>
        <span class='comment'># We just came out of a wait
</span>        <span class='comment'># If we successfully turn the RUNNING_WRITER bit on with an atomic swap,
</span>        <span class='comment'>#   then we are OK to stop waiting and go ahead
</span>        <span class='comment'># Otherwise go back and wait again
</span>        <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>
        <span class='kw'>if</span> <span class='op'>!</span><span class='id identifier rubyid_running_writer?'><a href="#running_writer%3F-instance_method" title="Concurrent::ReentrantReadWriteLock#running_writer? (method)">running_writer?</a></span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>&amp;&amp;</span>
           <span class='id identifier rubyid_running_readers'><a href="#running_readers-instance_method" title="Concurrent::ReentrantReadWriteLock#running_readers (method)">running_readers</a></span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>==</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>&amp;&amp;</span>
           <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_compare_and_set'>compare_and_set</span>(<span class='id identifier rubyid_c'>c</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span><span class='op'>+</span><span class='const'><a href="#RUNNING_WRITER-constant" title="Concurrent::ReentrantReadWriteLock::RUNNING_WRITER (constant)">RUNNING_WRITER</a></span><span class='op'>-</span><span class='const'><a href="#WAITING_WRITER-constant" title="Concurrent::ReentrantReadWriteLock::WAITING_WRITER (constant)">WAITING_WRITER</a></span>)
          <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>+</span> <span class='const'><a href="#WRITE_LOCK_HELD-constant" title="Concurrent::ReentrantReadWriteLock::WRITE_LOCK_HELD (constant)">WRITE_LOCK_HELD</a></span>
          <span class='kw'>return</span> <span class='kw'>true</span>
        <span class='kw'>end</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="max_readers?-instance_method">
  <h3 class='signature priv'>
    #<strong>max_readers?</strong>(c = @Counter.value)  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L370-L372'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='370' data-end='372'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 370</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_max_readers?'>max_readers?</span>(<span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>)
  (<span class='id identifier rubyid_c'>c</span> <span class='op'>&amp;</span> <span class='const'><a href="#MAX_READERS-constant" title="Concurrent::ReentrantReadWriteLock::MAX_READERS (constant)">MAX_READERS</a></span>) <span class='op'>==</span> <span class='const'><a href="#MAX_READERS-constant" title="Concurrent::ReentrantReadWriteLock::MAX_READERS (constant)">MAX_READERS</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="max_writers?-instance_method">
  <h3 class='signature priv'>
    #<strong>max_writers?</strong>(c = @Counter.value)  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L375-L377'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='375' data-end='377'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 375</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_max_writers?'>max_writers?</span>(<span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>)
  (<span class='id identifier rubyid_c'>c</span> <span class='op'>&amp;</span> <span class='const'><a href="#MAX_WRITERS-constant" title="Concurrent::ReentrantReadWriteLock::MAX_WRITERS (constant)">MAX_WRITERS</a></span>) <span class='op'>==</span> <span class='const'><a href="#MAX_WRITERS-constant" title="Concurrent::ReentrantReadWriteLock::MAX_WRITERS (constant)">MAX_WRITERS</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="release_read_lock-instance_method">
  <h3 class='signature '>
    #<strong>release_read_lock</strong>  &#x21d2; <code>Boolean</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Release a previously acquired read lock.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Boolean</code>)</span>
&mdash;    <div class='inline'>
<p>true if the lock is successfully released</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L236-L249'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='236' data-end='249'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 236</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_release_read_lock'>release_read_lock</span>
  <span class='id identifier rubyid_held'>held</span> <span class='op'>=</span> <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>-</span> <span class='int'>1</span>
  <span class='id identifier rubyid_rlocks_held'>rlocks_held</span> <span class='op'>=</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>&amp;</span> <span class='const'><a href="#READ_LOCK_MASK-constant" title="Concurrent::ReentrantReadWriteLock::READ_LOCK_MASK (constant)">READ_LOCK_MASK</a></span>
  <span class='kw'>if</span> <span class='id identifier rubyid_rlocks_held'>rlocks_held</span> <span class='op'>==</span> <span class='int'>0</span>
    <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_update'>update</span> { <span class='op'>|</span><span class='id identifier rubyid_counter'>counter</span><span class='op'>|</span> <span class='id identifier rubyid_counter'>counter</span> <span class='op'>-</span> <span class='int'>1</span> }
    <span class='comment'># If one or more writers were waiting, and we were the last reader, wake a writer up
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_waiting_or_running_writer?'><a href="#waiting_or_running_writer%3F-instance_method" title="Concurrent::ReentrantReadWriteLock#waiting_or_running_writer? (method)">waiting_or_running_writer?</a></span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_running_readers'><a href="#running_readers-instance_method" title="Concurrent::ReentrantReadWriteLock#running_readers (method)">running_readers</a></span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>==</span> <span class='int'>0</span>
      <span class='ivar'>@WriteQueue</span>.<span class='id identifier rubyid_signal'>signal</span>
    <span class='kw'>end</span>
  <span class='kw'>elsif</span> <span class='id identifier rubyid_rlocks_held'>rlocks_held</span> <span class='op'>==</span> <span class='const'><a href="#READ_LOCK_MASK-constant" title="Concurrent::ReentrantReadWriteLock::READ_LOCK_MASK (constant)">READ_LOCK_MASK</a></span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../Concurrent.html#IllegalOperationError-constant" title="Concurrent::IllegalOperationError (constant)">IllegalOperationError</a></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Cannot release a read lock which is not held</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
  <span class='kw'>true</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="release_write_lock-instance_method">
  <h3 class='signature '>
    #<strong>release_write_lock</strong>  &#x21d2; <code>Boolean</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Release a previously acquired write lock.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Boolean</code>)</span>
&mdash;    <div class='inline'>
<p>true if the lock is successfully released</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L329-L340'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='329' data-end='340'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 329</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_release_write_lock'>release_write_lock</span>
  <span class='id identifier rubyid_held'>held</span> <span class='op'>=</span> <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>-</span> <span class='const'><a href="#WRITE_LOCK_HELD-constant" title="Concurrent::ReentrantReadWriteLock::WRITE_LOCK_HELD (constant)">WRITE_LOCK_HELD</a></span>
  <span class='id identifier rubyid_wlocks_held'>wlocks_held</span> <span class='op'>=</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>&amp;</span> <span class='const'><a href="#WRITE_LOCK_MASK-constant" title="Concurrent::ReentrantReadWriteLock::WRITE_LOCK_MASK (constant)">WRITE_LOCK_MASK</a></span>
  <span class='kw'>if</span> <span class='id identifier rubyid_wlocks_held'>wlocks_held</span> <span class='op'>==</span> <span class='int'>0</span>
    <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_update'>update</span> { <span class='op'>|</span><span class='id identifier rubyid_counter'>counter</span><span class='op'>|</span> <span class='id identifier rubyid_counter'>counter</span> <span class='op'>-</span> <span class='const'><a href="#RUNNING_WRITER-constant" title="Concurrent::ReentrantReadWriteLock::RUNNING_WRITER (constant)">RUNNING_WRITER</a></span> }
    <span class='ivar'>@ReadQueue</span>.<span class='id identifier rubyid_broadcast'>broadcast</span>
    <span class='ivar'>@WriteQueue</span>.<span class='id identifier rubyid_signal'>signal</span> <span class='kw'>if</span> <span class='id identifier rubyid_waiting_writers'><a href="#waiting_writers-instance_method" title="Concurrent::ReentrantReadWriteLock#waiting_writers (method)">waiting_writers</a></span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>&gt;</span> <span class='int'>0</span>
  <span class='kw'>elsif</span> <span class='id identifier rubyid_wlocks_held'>wlocks_held</span> <span class='op'>==</span> <span class='const'><a href="#WRITE_LOCK_MASK-constant" title="Concurrent::ReentrantReadWriteLock::WRITE_LOCK_MASK (constant)">WRITE_LOCK_MASK</a></span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../Concurrent.html#IllegalOperationError-constant" title="Concurrent::IllegalOperationError (constant)">IllegalOperationError</a></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Cannot release a write lock which is not held</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
  <span class='kw'>true</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="running_readers-instance_method">
  <h3 class='signature priv'>
    #<strong>running_readers</strong>(c = @Counter.value)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L345-L347'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='345' data-end='347'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 345</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_running_readers'>running_readers</span>(<span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>)
  <span class='id identifier rubyid_c'>c</span> <span class='op'>&amp;</span> <span class='const'><a href="#MAX_READERS-constant" title="Concurrent::ReentrantReadWriteLock::MAX_READERS (constant)">MAX_READERS</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="running_readers?-instance_method">
  <h3 class='signature priv'>
    #<strong>running_readers?</strong>(c = @Counter.value)  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L350-L352'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='350' data-end='352'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 350</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_running_readers?'>running_readers?</span>(<span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>)
  (<span class='id identifier rubyid_c'>c</span> <span class='op'>&amp;</span> <span class='const'><a href="#MAX_READERS-constant" title="Concurrent::ReentrantReadWriteLock::MAX_READERS (constant)">MAX_READERS</a></span>) <span class='op'>&gt;</span> <span class='int'>0</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="running_writer?-instance_method">
  <h3 class='signature priv'>
    #<strong>running_writer?</strong>(c = @Counter.value)  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L355-L357'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='355' data-end='357'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 355</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_running_writer?'>running_writer?</span>(<span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>)
  <span class='id identifier rubyid_c'>c</span> <span class='op'>&gt;=</span> <span class='const'><a href="#RUNNING_WRITER-constant" title="Concurrent::ReentrantReadWriteLock::RUNNING_WRITER (constant)">RUNNING_WRITER</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="try_read_lock-instance_method">
  <h3 class='signature '>
    #<strong>try_read_lock</strong>  &#x21d2; <code>Boolean</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Try to acquire a read lock and return true if we succeed. If it cannot be acquired immediately, return false.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Boolean</code>)</span>
&mdash;    <div class='inline'>
<p>true if the lock is successfully acquired</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L215-L231'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='215' data-end='231'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 215</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_try_read_lock'>try_read_lock</span>
  <span class='kw'>if</span> (<span class='id identifier rubyid_held'>held</span> <span class='op'>=</span> <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span>) <span class='op'>&gt;</span> <span class='int'>0</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>&amp;</span> <span class='const'><a href="#READ_LOCK_MASK-constant" title="Concurrent::ReentrantReadWriteLock::READ_LOCK_MASK (constant)">READ_LOCK_MASK</a></span> <span class='op'>==</span> <span class='int'>0</span>
      <span class='comment'># If we hold a write lock, but not a read lock...
</span>      <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_update'>update</span> { <span class='op'>|</span><span class='id identifier rubyid_c'>c</span><span class='op'>|</span> <span class='id identifier rubyid_c'>c</span> <span class='op'>+</span> <span class='int'>1</span> }
    <span class='kw'>end</span>
    <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>+</span> <span class='int'>1</span>
    <span class='kw'>return</span> <span class='kw'>true</span>
  <span class='kw'>else</span>
    <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>
    <span class='kw'>if</span> <span class='op'>!</span><span class='id identifier rubyid_waiting_or_running_writer?'><a href="#waiting_or_running_writer%3F-instance_method" title="Concurrent::ReentrantReadWriteLock#waiting_or_running_writer? (method)">waiting_or_running_writer?</a></span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>&amp;&amp;</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_compare_and_set'>compare_and_set</span>(<span class='id identifier rubyid_c'>c</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span><span class='op'>+</span><span class='int'>1</span>)
      <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>+</span> <span class='int'>1</span>
      <span class='kw'>return</span> <span class='kw'>true</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
  <span class='kw'>false</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="try_write_lock-instance_method">
  <h3 class='signature '>
    #<strong>try_write_lock</strong>  &#x21d2; <code>Boolean</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Try to acquire a write lock and return true if we succeed. If it cannot be acquired immediately, return false.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Boolean</code>)</span>
&mdash;    <div class='inline'>
<p>true if the lock is successfully acquired</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L310-L324'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='310' data-end='324'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 310</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_try_write_lock'>try_write_lock</span>
  <span class='kw'>if</span> (<span class='id identifier rubyid_held'>held</span> <span class='op'>=</span> <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span>) <span class='op'>&gt;=</span> <span class='const'><a href="#WRITE_LOCK_HELD-constant" title="Concurrent::ReentrantReadWriteLock::WRITE_LOCK_HELD (constant)">WRITE_LOCK_HELD</a></span>
    <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>+</span> <span class='const'><a href="#WRITE_LOCK_HELD-constant" title="Concurrent::ReentrantReadWriteLock::WRITE_LOCK_HELD (constant)">WRITE_LOCK_HELD</a></span>
    <span class='kw'>return</span> <span class='kw'>true</span>
  <span class='kw'>else</span>
    <span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>
    <span class='kw'>if</span> <span class='op'>!</span><span class='id identifier rubyid_waiting_or_running_writer?'><a href="#waiting_or_running_writer%3F-instance_method" title="Concurrent::ReentrantReadWriteLock#waiting_or_running_writer? (method)">waiting_or_running_writer?</a></span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>&amp;&amp;</span>
       <span class='id identifier rubyid_running_readers'><a href="#running_readers-instance_method" title="Concurrent::ReentrantReadWriteLock#running_readers (method)">running_readers</a></span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>==</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>&amp;&amp;</span>
       <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_compare_and_set'>compare_and_set</span>(<span class='id identifier rubyid_c'>c</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span><span class='op'>+</span><span class='const'><a href="#RUNNING_WRITER-constant" title="Concurrent::ReentrantReadWriteLock::RUNNING_WRITER (constant)">RUNNING_WRITER</a></span>)
       <span class='ivar'>@HeldCount</span>.<span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_held'>held</span> <span class='op'>+</span> <span class='const'><a href="#WRITE_LOCK_HELD-constant" title="Concurrent::ReentrantReadWriteLock::WRITE_LOCK_HELD (constant)">WRITE_LOCK_HELD</a></span>
      <span class='kw'>return</span> <span class='kw'>true</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
  <span class='kw'>false</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="waiting_or_running_writer?-instance_method">
  <h3 class='signature priv'>
    #<strong>waiting_or_running_writer?</strong>(c = @Counter.value)  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L365-L367'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='365' data-end='367'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 365</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_waiting_or_running_writer?'>waiting_or_running_writer?</span>(<span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>)
  <span class='id identifier rubyid_c'>c</span> <span class='op'>&gt;=</span> <span class='const'><a href="#WAITING_WRITER-constant" title="Concurrent::ReentrantReadWriteLock::WAITING_WRITER (constant)">WAITING_WRITER</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="waiting_writers-instance_method">
  <h3 class='signature priv'>
    #<strong>waiting_writers</strong>(c = @Counter.value)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L360-L362'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='360' data-end='362'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 360</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_waiting_writers'>waiting_writers</span>(<span class='id identifier rubyid_c'>c</span> <span class='op'>=</span> <span class='ivar'>@Counter</span>.<span class='id identifier rubyid_value'>value</span>)
  (<span class='id identifier rubyid_c'>c</span> <span class='op'>&amp;</span> <span class='const'><a href="#MAX_WRITERS-constant" title="Concurrent::ReentrantReadWriteLock::MAX_WRITERS (constant)">MAX_WRITERS</a></span>) <span class='op'>&gt;&gt;</span> <span class='const'><a href="#READER_BITS-constant" title="Concurrent::ReentrantReadWriteLock::READER_BITS (constant)">READER_BITS</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="with_read_lock-instance_method">
  <h3 class='signature '>
    #<strong>with_read_lock</strong> { ... } &#x21d2; <a href="../Object.html" title="Object (class)">Object</a> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Execute a block operation within a read lock.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Yields:</p>
<ul class='yield'>
  <li>
    <span class='type'></span>
    <div class='inline'>
<p>the task to be performed within the lock.</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="../Object.html" title="Object (class)">Object</a>)</span>
&mdash;    <div class='inline'>
<p>the result of the block operation.</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<code>ArgumentError</code>)</span>
&mdash;    <div class='inline'>
<p>when no block is given.</p>
</div>
  </li>
  <li>
    <span class='type'>(<a href="../Concurrent.html#ResourceLimitError-constant" title="Concurrent::ResourceLimitError (constant)">Concurrent::ResourceLimitError</a>)</span>
&mdash;    <div class='inline'>
<p>if the maximum number of readers is exceeded.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L126-L134'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='126' data-end='134'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 126</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_with_read_lock'>with_read_lock</span>
  <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::ReentrantReadWriteLock.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>no block given</span><span class='tstring_end'>&#39;</span></span>) <span class='kw'>unless</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='id identifier rubyid_acquire_read_lock'><a href="#acquire_read_lock-instance_method" title="Concurrent::ReentrantReadWriteLock#acquire_read_lock (method)">acquire_read_lock</a></span>
  <span class='kw'>begin</span>
    <span class='kw'>yield</span>
  <span class='kw'>ensure</span>
    <span class='id identifier rubyid_release_read_lock'><a href="#release_read_lock-instance_method" title="Concurrent::ReentrantReadWriteLock#release_read_lock (method)">release_read_lock</a></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="with_write_lock-instance_method">
  <h3 class='signature '>
    #<strong>with_write_lock</strong> { ... } &#x21d2; <a href="../Object.html" title="Object (class)">Object</a> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Execute a block operation within a write lock.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Yields:</p>
<ul class='yield'>
  <li>
    <span class='type'></span>
    <div class='inline'>
<p>the task to be performed within the lock.</p>
</div>
  </li>
</ul>
<p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="../Object.html" title="Object (class)">Object</a>)</span>
&mdash;    <div class='inline'>
<p>the result of the block operation.</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<code>ArgumentError</code>)</span>
&mdash;    <div class='inline'>
<p>when no block is given.</p>
</div>
  </li>
  <li>
    <span class='type'>(<a href="../Concurrent.html#ResourceLimitError-constant" title="Concurrent::ResourceLimitError (constant)">Concurrent::ResourceLimitError</a>)</span>
&mdash;    <div class='inline'>
<p>if the maximum number of readers is exceeded.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby-concurrency/concurrent-ruby/blob/master/lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#L145-L153'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='145' data-end='153'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb', line 145</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_with_write_lock'>with_write_lock</span>
  <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Concurrent::ReentrantReadWriteLock.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>no block given</span><span class='tstring_end'>&#39;</span></span>) <span class='kw'>unless</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
  <span class='id identifier rubyid_acquire_write_lock'><a href="#acquire_write_lock-instance_method" title="Concurrent::ReentrantReadWriteLock#acquire_write_lock (method)">acquire_write_lock</a></span>
  <span class='kw'>begin</span>
    <span class='kw'>yield</span>
  <span class='kw'>ensure</span>
    <span class='id identifier rubyid_release_write_lock'><a href="#release_write_lock-instance_method" title="Concurrent::ReentrantReadWriteLock#release_write_lock (method)">release_write_lock</a></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>