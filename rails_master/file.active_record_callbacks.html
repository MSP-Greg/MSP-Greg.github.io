<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Active Record Callbacks &mdash; Rails main</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "active_record_callbacks",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Rails main</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Active Record Callbacks&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<p><strong>DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON <a href="https://guides.rubyonrails.org">https://guides.rubyonrails.org</a>.</strong></p>

<h1>Active Record Callbacks</h1>

<p>This guide teaches you how to hook into the life cycle of your Active Record objects.</p>

<p>After reading this guide, you will know:</p>

<ul>
<li>When certain events occur during the life of an Active Record object</li>
<li>How to create callback methods that respond to events in the object life cycle.</li>
<li>How to create special classes that encapsulate common behavior for your callbacks.</li>
</ul>

<hr>

<h2>The Object Life Cycle</h2>

<p>During the normal operation of a <a href="Rails.html" title="Rails (module)"><code>Rails</code></a> application, objects may be created, updated, and destroyed. Active Record provides hooks into this <em>object life cycle</em> so that you can control your application and its data.</p>

<p>Callbacks allow you to trigger logic before or after an alteration of an object&#39;s state.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Baby</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_after_create'>after_create</span> <span class='tlambda'>-&gt;</span> <span class='tlambeg'>{</span> <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Congratulations!</span><span class='tstring_end'>&quot;</span></span> }
<span class='kw'>end</span></code></pre>

<pre class="code irb"><code class="irb">irb&gt; @baby = Baby.create
Congratulations!
</code></pre>

<p>As you will see, there are many life cycle events and you can choose to hook into any of these either before, after, or even around them.</p>

<h2>Callbacks Overview</h2>

<p>Callbacks are methods that get called at certain moments of an object&#39;s life cycle. With callbacks it is possible to write code that will run whenever an Active Record object is created, saved, updated, deleted, validated, or loaded from the database.</p>

<h3>Callback Registration</h3>

<p>In order to use the available callbacks, you need to register them. You can implement the callbacks as ordinary methods and use a macro-style class method to register them as callbacks:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>User</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_validates'>validates</span> <span class='symbeg'>:</span><span class='id identifier rubyid_login'>login</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_email'>email</span><span class='comma'>,</span> <span class='label'>presence:</span> <span class='kw'>true</span>

  <span class='id identifier rubyid_before_validation'>before_validation</span> <span class='symbeg'>:</span><span class='id identifier rubyid_ensure_login_has_a_value'>ensure_login_has_a_value</span>

  <span class='id identifier rubyid_private'>private</span>
    <span class='kw'>def</span> <span class='id identifier rubyid_ensure_login_has_a_value'>ensure_login_has_a_value</span>
      <span class='kw'>if</span> <span class='id identifier rubyid_login'>login</span>.<span class='id identifier rubyid_blank?'>blank?</span>
        <span class='kw'>self</span>.<span class='id identifier rubyid_login'>login</span> <span class='op'>=</span> <span class='id identifier rubyid_email'>email</span> <span class='kw'>unless</span> <span class='id identifier rubyid_email'>email</span>.<span class='id identifier rubyid_blank?'>blank?</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>The macro-style class methods can also receive a block. Consider using this style if the code inside your block is so short that it fits in a single line:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>User</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_validates'>validates</span> <span class='symbeg'>:</span><span class='id identifier rubyid_login'>login</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_email'>email</span><span class='comma'>,</span> <span class='label'>presence:</span> <span class='kw'>true</span>

  <span class='id identifier rubyid_before_create'>before_create</span> <span class='kw'>do</span>
    <span class='kw'>self</span>.<span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='id identifier rubyid_login'>login</span>.<span class='id identifier rubyid_capitalize'>capitalize</span> <span class='kw'>if</span> <span class='id identifier rubyid_name'>name</span>.<span class='id identifier rubyid_blank?'>blank?</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>Alternatively you can pass a proc to the callback to be triggered.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>User</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_before_create'>before_create</span> <span class='tlambda'>-&gt;</span>(<span class='id identifier rubyid_user'>user</span>) <span class='tlambeg'>{</span> <span class='id identifier rubyid_user'>user</span>.<span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='id identifier rubyid_user'>user</span>.<span class='id identifier rubyid_login'>login</span>.<span class='id identifier rubyid_capitalize'>capitalize</span> <span class='kw'>if</span> <span class='id identifier rubyid_user'>user</span>.<span class='id identifier rubyid_name'>name</span>.<span class='id identifier rubyid_blank?'>blank?</span> }
<span class='kw'>end</span></code></pre>

<p>Lastly, you can define your own custom callback object, which we will cover later in more detail <a href="#callback-classes">below</a>.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>User</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_before_create'>before_create</span> <span class='const'>MaybeAddName</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>MaybeAddName</span>
  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_before_create'>before_create</span>(<span class='id identifier rubyid_record'>record</span>)
    <span class='kw'>if</span> <span class='id identifier rubyid_record'>record</span>.<span class='id identifier rubyid_name'>name</span>.<span class='id identifier rubyid_blank?'>blank?</span>
      <span class='id identifier rubyid_record'>record</span>.<span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='id identifier rubyid_record'>record</span>.<span class='id identifier rubyid_login'>login</span>.<span class='id identifier rubyid_capitalize'>capitalize</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>Callbacks can also be registered to only fire on certain life cycle events, this allows complete control over when and in what context your callbacks are triggered.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>User</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_before_validation'>before_validation</span> <span class='symbeg'>:</span><span class='id identifier rubyid_normalize_name'>normalize_name</span><span class='comma'>,</span> <span class='label'>on:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_create'>create</span>

  <span class='comment'># :on takes an array as well
</span>  <span class='id identifier rubyid_after_validation'>after_validation</span> <span class='symbeg'>:</span><span class='id identifier rubyid_set_location'>set_location</span><span class='comma'>,</span> <span class='label'>on:</span> [ <span class='symbeg'>:</span><span class='id identifier rubyid_create'>create</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_update'>update</span> ]

  <span class='id identifier rubyid_private'>private</span>
    <span class='kw'>def</span> <span class='id identifier rubyid_normalize_name'>normalize_name</span>
      <span class='kw'>self</span>.<span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='id identifier rubyid_name'>name</span>.<span class='id identifier rubyid_downcase'>downcase</span>.<span class='id identifier rubyid_titleize'>titleize</span>
    <span class='kw'>end</span>

    <span class='kw'>def</span> <span class='id identifier rubyid_set_location'>set_location</span>
      <span class='kw'>self</span>.<span class='id identifier rubyid_location'>location</span> <span class='op'>=</span> <span class='const'>LocationService</span>.<span class='id identifier rubyid_query'>query</span>(<span class='kw'>self</span>)
    <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>It is considered good practice to declare callback methods as private. If left public, they can be called from outside of the model and violate the principle of object encapsulation.</p>

<p>WARNING. Avoid calls to <code>update</code>, <code>save</code> or other methods which create side-effects to the object inside your callback. For example, don&#39;t call <code>update(attribute: &quot;value&quot;)</code> within a callback. This can alter the state of the model and may result in unexpected side effects during commit. Instead, you can safely assign values directly (for example, <code>self.attribute = &quot;value&quot;</code>) in <code>before_create</code> / <code>before_update</code> or earlier callbacks.</p>

<h2>Available Callbacks</h2>

<p>Here is a list with all the available Active Record callbacks, listed in the same order in which they will get called during the respective operations:</p>

<h3>Creating an Object</h3>

<ul>
<li><a href="https://api.rubyonrails.org/classes/ActiveModel/Validations/Callbacks/ClassMethods.html#method-i-before_validation"><code>before_validation</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveModel/Validations/Callbacks/ClassMethods.html#method-i-after_validation"><code>after_validation</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_save"><code>before_save</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_save"><code>around_save</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_create"><code>before_create</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_create"><code>around_create</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_create"><code>after_create</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_save"><code>after_save</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_commit"><code>after_commit</code></a> / <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_rollback"><code>after_rollback</code></a></li>
</ul>

<h3>Updating an Object</h3>

<ul>
<li><a href="https://api.rubyonrails.org/classes/ActiveModel/Validations/Callbacks/ClassMethods.html#method-i-before_validation"><code>before_validation</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveModel/Validations/Callbacks/ClassMethods.html#method-i-after_validation"><code>after_validation</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_save"><code>before_save</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_save"><code>around_save</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_update"><code>before_update</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_update"><code>around_update</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_update"><code>after_update</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_save"><code>after_save</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_commit"><code>after_commit</code></a> / <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_rollback"><code>after_rollback</code></a></li>
</ul>

<p>WARNING. <code>after_save</code> runs both on create and update, but always <em>after</em> the more specific callbacks <code>after_create</code> and <code>after_update</code>, no matter the order in which the macro calls were executed.</p>

<h3>Destroying an Object</h3>

<ul>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-before_destroy"><code>before_destroy</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-around_destroy"><code>around_destroy</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_destroy"><code>after_destroy</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_commit"><code>after_commit</code></a> / <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_rollback"><code>after_rollback</code></a></li>
</ul>

<p>NOTE: <code>before_destroy</code> callbacks should be placed before <code>dependent: :destroy</code> associations (or use the <code>prepend: true</code> option), to ensure they execute before the records are deleted by <code>dependent: :destroy</code>.</p>

<p>WARNING. <code>after_commit</code> makes very different guarantees than <code>after_save</code>, <code>after_update</code>, and <code>after_destroy</code>. For example if an exception occurs in an <code>after_save</code> the transaction will be rolled back and the data will not be persisted. While anything that happens <code>after_commit</code> can guarantee the transaction has already completed and the data was persisted to the database. More on <a href="#transaction-callbacks">transactional callbacks</a> below.</p>

<h3><code>after_initialize</code> and <code>after_find</code></h3>

<p>Whenever an Active Record object is instantiated the <a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_initialize"><code>after_initialize</code></a> callback will be called, either by directly using <code>new</code> or when a record is loaded from the database. It can be useful to avoid the need to directly override your Active Record <code>initialize</code> method.</p>

<p>When loading a record from the database the <a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_find"><code>after_find</code></a> callback will be called. <code>after_find</code> is called before <code>after_initialize</code> if both are defined.</p>

<p>NOTE: The <code>after_initialize</code> and <code>after_find</code> callbacks have no <code>before_*</code> counterparts.</p>

<p>They can be registered just like the other Active Record callbacks.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>User</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_after_initialize'>after_initialize</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_user'>user</span><span class='op'>|</span>
    <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>You have initialized an object!</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_after_find'>after_find</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_user'>user</span><span class='op'>|</span>
    <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>You have found an object!</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<pre class="code irb"><code class="irb">irb&gt; User.new
You have initialized an object!
=&gt; #&lt;User id: nil&gt;

irb&gt; User.first
You have found an object!
You have initialized an object!
=&gt; #&lt;User id: 1&gt;
</code></pre>

<h3><code>after_touch</code></h3>

<p>The <a href="https://api.rubyonrails.org/classes/ActiveRecord/Callbacks/ClassMethods.html#method-i-after_touch"><code>after_touch</code></a> callback will be called whenever an Active Record object is touched.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>User</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_after_touch'>after_touch</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_user'>user</span><span class='op'>|</span>
    <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>You have touched an object</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<pre class="code irb"><code class="irb">irb&gt; u = User.create(name: &#39;Kuldeep&#39;)
=&gt; #&lt;User id: 1, name: &quot;Kuldeep&quot;, created_at: &quot;2013-11-25 12:17:49&quot;, updated_at: &quot;2013-11-25 12:17:49&quot;&gt;

irb&gt; u.touch
You have touched an object
=&gt; true
</code></pre>

<p>It can be used along with <code>belongs_to</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Book</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_belongs_to'>belongs_to</span> <span class='symbeg'>:</span><span class='id identifier rubyid_library'>library</span><span class='comma'>,</span> <span class='label'>touch:</span> <span class='kw'>true</span>
  <span class='id identifier rubyid_after_touch'>after_touch</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>A Book was touched</span><span class='tstring_end'>&#39;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>Library</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbeg'>:</span><span class='id identifier rubyid_books'>books</span>
  <span class='id identifier rubyid_after_touch'>after_touch</span> <span class='symbeg'>:</span><span class='id identifier rubyid_log_when_books_or_library_touched'>log_when_books_or_library_touched</span>

  <span class='id identifier rubyid_private'>private</span>
    <span class='kw'>def</span> <span class='id identifier rubyid_log_when_books_or_library_touched'>log_when_books_or_library_touched</span>
      <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Book/Library was touched</span><span class='tstring_end'>&#39;</span></span>
    <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<pre class="code irb"><code class="irb">irb&gt; @book = Book.last
=&gt; #&lt;Book id: 1, library_id: 1, created_at: &quot;2013-11-25 17:04:22&quot;, updated_at: &quot;2013-11-25 17:05:05&quot;&gt;

irb&gt; @book.touch # triggers @book.library.touch
A Book was touched
Book/Library was touched
=&gt; true
</code></pre>

<h2>Running Callbacks</h2>

<p>The following methods trigger callbacks:</p>

<ul>
<li><code>create</code></li>
<li><code>create!</code></li>
<li><code>destroy</code></li>
<li><code>destroy!</code></li>
<li><code>destroy_all</code></li>
<li><code>destroy_by</code></li>
<li><code>save</code></li>
<li><code>save!</code></li>
<li><code>save(validate: false)</code></li>
<li><code>save!(validate: false)</code></li>
<li><code>toggle!</code></li>
<li><code>touch</code></li>
<li><code>update_attribute</code></li>
<li><code>update</code></li>
<li><code>update!</code></li>
<li><code>valid?</code></li>
</ul>

<p>Additionally, the <code>after_find</code> callback is triggered by the following finder methods:</p>

<ul>
<li><code>all</code></li>
<li><code>first</code></li>
<li><code>find</code></li>
<li><code>find_by</code></li>
<li><code>find_by_*</code></li>
<li><code>find_by_*!</code></li>
<li><code>find_by_sql</code></li>
<li><code>last</code></li>
</ul>

<p>The <code>after_initialize</code> callback is triggered every time a new object of the class is initialized.</p>

<p>NOTE: The <code>find_by_*</code> and <code>find_by_*!</code> methods are dynamic finders generated automatically for every attribute. Learn more about them at the <a href="active_record_querying.html#dynamic-finders">Dynamic finders section</a></p>

<h2>Skipping Callbacks</h2>

<p>Just as with validations, it is also possible to skip callbacks by using the following methods:</p>

<ul>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-decrement-21"><code>decrement!</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/CounterCache/ClassMethods.html#method-i-decrement_counter"><code>decrement_counter</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-delete"><code>delete</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-delete_all"><code>delete_all</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-delete_by"><code>delete_by</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-increment-21"><code>increment!</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/CounterCache/ClassMethods.html#method-i-increment_counter"><code>increment_counter</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-insert"><code>insert</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-insert-21"><code>insert!</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-insert_all"><code>insert_all</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-insert_all-21"><code>insert_all!</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-touch_all"><code>touch_all</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-update_column"><code>update_column</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-update_columns"><code>update_columns</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-update_all"><code>update_all</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-update_counters"><code>update_counters</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-upsert"><code>upsert</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-upsert_all"><code>upsert_all</code></a></li>
</ul>

<p>These methods should be used with caution, however, because important business rules and application logic may be kept in callbacks. Bypassing them without understanding the potential implications may lead to invalid data. Refer to the method documentation to learn more.</p>

<h2>Halting Execution</h2>

<p>As you start registering new callbacks for your models, they will be queued for execution. This queue will include all your model&#39;s validations, the registered callbacks, and the database operation to be executed.</p>

<p>The whole callback chain is wrapped in a transaction. If any callback raises an exception, the execution chain gets halted and a ROLLBACK is issued. To intentionally stop a chain use:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_throw'>throw</span> <span class='symbeg'>:</span><span class='id identifier rubyid_abort'>abort</span></code></pre>

<p>WARNING. Any exception that is not <a href="ActiveRecord/Rollback.html" title="ActiveRecord::Rollback (class)"><code>::ActiveRecord::Rollback</code></a> or <a href="ActiveRecord/RecordInvalid.html" title="ActiveRecord::RecordInvalid (class)"><code>::ActiveRecord::RecordInvalid</code></a> will be re-raised by Rails after the callback chain is halted. Additionally, may break code that does not expect methods like <code>save</code> and <code>update</code> (which normally try to return <code>true</code> or <code>false</code>) to raise an exception.</p>

<p>NOTE: If an <a href="ActiveRecord/RecordNotDestroyed.html" title="ActiveRecord::RecordNotDestroyed (class)"><code>::ActiveRecord::RecordNotDestroyed</code></a> is raised within <code>after_destroy</code>, <code>before_destroy</code> or <code>around_destroy</code> callback, it will not be re-raised and the <code>destroy</code> method will return <code>false</code>.</p>

<h2>Relational Callbacks</h2>

<p>Callbacks work through model relationships, and can even be defined by them. Suppose an example where a user has many articles. A user&#39;s articles should be destroyed if the user is destroyed. Let&#39;s add an <code>after_destroy</code> callback to the <code>User</code> model by way of its relationship to the <code>Article</code> model:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>User</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbeg'>:</span><span class='id identifier rubyid_articles'>articles</span><span class='comma'>,</span> <span class='label'>dependent:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_destroy'>destroy</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>Article</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_after_destroy'>after_destroy</span> <span class='symbeg'>:</span><span class='id identifier rubyid_log_destroy_action'>log_destroy_action</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_log_destroy_action'>log_destroy_action</span>
    <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Article destroyed</span><span class='tstring_end'>&#39;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<pre class="code irb"><code class="irb">irb&gt; user = User.first
=&gt; #&lt;User id: 1&gt;
irb&gt; user.articles.create!
=&gt; #&lt;Article id: 1, user_id: 1&gt;
irb&gt; user.destroy
Article destroyed
=&gt; #&lt;User id: 1&gt;
</code></pre>

<h2>Association Callbacks</h2>

<p>Association callbacks are similar to normal callbacks, but they are triggered by events in the life cycle of a collection. There are four available association callbacks:</p>

<ul>
<li><code>before_add</code></li>
<li><code>after_add</code></li>
<li><code>before_remove</code></li>
<li><code>after_remove</code></li>
</ul>

<p>You define association callbacks by adding options to the association declaration. For example:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Author</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbeg'>:</span><span class='id identifier rubyid_books'>books</span><span class='comma'>,</span> <span class='label'>before_add:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_check_credit_limit'>check_credit_limit</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_check_credit_limit'>check_credit_limit</span>(<span class='id identifier rubyid_book'>book</span>)
    <span class='comment'># ...
</span>  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>Rails passes the object being added or removed to the callback.</p>

<p>You can stack callbacks on a single event by passing them as an array:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Author</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbeg'>:</span><span class='id identifier rubyid_books'>books</span><span class='comma'>,</span>
    <span class='label'>before_add:</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_check_credit_limit'>check_credit_limit</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_calculate_shipping_charges'>calculate_shipping_charges</span>]

  <span class='kw'>def</span> <span class='id identifier rubyid_check_credit_limit'>check_credit_limit</span>(<span class='id identifier rubyid_book'>book</span>)
    <span class='comment'># ...
</span>  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_calculate_shipping_charges'>calculate_shipping_charges</span>(<span class='id identifier rubyid_book'>book</span>)
    <span class='comment'># ...
</span>  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>If a <code>before_add</code> callback throws <code>:abort</code>, the object does not get added to
the collection. Similarly, if a <code>before_remove</code> callback throws <code>:abort</code>, the
object does not get removed from the collection:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># book won&#39;t be added if the limit has been reached
</span><span class='kw'>def</span> <span class='id identifier rubyid_check_credit_limit'>check_credit_limit</span>(<span class='id identifier rubyid_book'>book</span>)
  <span class='id identifier rubyid_throw'>throw</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_abort'>abort</span>) <span class='kw'>if</span> <span class='id identifier rubyid_limit_reached?'>limit_reached?</span>
<span class='kw'>end</span></code></pre>

<p>NOTE: These callbacks are called only when the associated objects are added or removed through the association collection:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Triggers `before_add` callback
</span><span class='id identifier rubyid_author'>author</span>.<span class='id identifier rubyid_books'>books</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_book'>book</span>
<span class='id identifier rubyid_author'>author</span>.<span class='id identifier rubyid_books'>books</span> <span class='op'>=</span> [<span class='id identifier rubyid_book'>book</span><span class='comma'>,</span> <span class='id identifier rubyid_book2'>book2</span>]

<span class='comment'># Does not trigger the `before_add` callback
</span><span class='id identifier rubyid_book'>book</span>.<span class='id identifier rubyid_update'>update</span>(<span class='label'>author_id:</span> <span class='int'>1</span>)</code></pre>

<h2>Conditional Callbacks</h2>

<p>As with validations, we can also make the calling of a callback method conditional on the satisfaction of a given predicate. We can do this using the <code>:if</code> and <code>:unless</code> options, which can take a symbol, a <code>Proc</code> or an <a href="Array.html" title="Array (class)"><code>Array</code></a>.</p>

<p>You may use the <code>:if</code> option when you want to specify under which conditions the callback <strong>should</strong> be called. If you want to specify the conditions under which the callback <strong>should not</strong> be called, then you may use the <code>:unless</code> option.</p>

<h3>Using <code>:if</code> and <code>:unless</code> with a <a href="Symbol.html" title="Symbol (class)"><code>Symbol</code></a></h3>

<p>You can associate the <code>:if</code> and <code>:unless</code> options with a symbol corresponding to the name of a predicate method that will get called right before the callback.</p>

<p>When using the <code>:if</code> option, the callback <strong>won&#39;t</strong> be executed if the predicate method returns <strong>false</strong>; when using the <code>:unless</code> option, the callback <strong>won&#39;t</strong> be executed if the predicate method returns <strong>true</strong>. This is the most common option.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Order</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_before_save'>before_save</span> <span class='symbeg'>:</span><span class='id identifier rubyid_normalize_card_number'>normalize_card_number</span><span class='comma'>,</span> <span class='label'>if:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_paid_with_card?'>paid_with_card?</span>
<span class='kw'>end</span></code></pre>

<p>Using this form of registration it is also possible to register several different predicates that should be called to check if the callback should be executed. We will cover this <a href="#multiple-callback-conditions">below</a>.</p>

<h3>Using <code>:if</code> and <code>:unless</code> with a <code>Proc</code></h3>

<p>It is possible to associate <code>:if</code> and <code>:unless</code> with a <code>Proc</code> object. This option is best suited when writing short validation methods, usually one-liners:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Order</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_before_save'>before_save</span> <span class='symbeg'>:</span><span class='id identifier rubyid_normalize_card_number'>normalize_card_number</span><span class='comma'>,</span>
    <span class='label'>if:</span> <span class='const'>Proc</span>.<span class='id identifier rubyid_new'>new</span> { <span class='op'>|</span><span class='id identifier rubyid_order'>order</span><span class='op'>|</span> <span class='id identifier rubyid_order'>order</span>.<span class='id identifier rubyid_paid_with_card?'>paid_with_card?</span> }
<span class='kw'>end</span></code></pre>

<p>As the proc is evaluated in the context of the object, it is also possible to write this as:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Order</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_before_save'>before_save</span> <span class='symbeg'>:</span><span class='id identifier rubyid_normalize_card_number'>normalize_card_number</span><span class='comma'>,</span> <span class='label'>if:</span> <span class='const'>Proc</span>.<span class='id identifier rubyid_new'>new</span> { <span class='id identifier rubyid_paid_with_card?'>paid_with_card?</span> }
<span class='kw'>end</span></code></pre>

<h3>Multiple Callback Conditions</h3>

<p>The <code>:if</code> and <code>:unless</code> options also accept an array of procs or method names as symbols:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Comment</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_before_save'>before_save</span> <span class='symbeg'>:</span><span class='id identifier rubyid_filter_content'>filter_content</span><span class='comma'>,</span>
    <span class='label'>if:</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_subject_to_parental_control?'>subject_to_parental_control?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_untrusted_author?'>untrusted_author?</span>]
<span class='kw'>end</span></code></pre>

<p>You can easily include a proc in the list of conditions:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Comment</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_before_save'>before_save</span> <span class='symbeg'>:</span><span class='id identifier rubyid_filter_content'>filter_content</span><span class='comma'>,</span>
    <span class='label'>if:</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_subject_to_parental_control?'>subject_to_parental_control?</span><span class='comma'>,</span> <span class='const'>Proc</span>.<span class='id identifier rubyid_new'>new</span> { <span class='id identifier rubyid_untrusted_author?'>untrusted_author?</span> }]
<span class='kw'>end</span></code></pre>

<h3>Using Both <code>:if</code> and <code>:unless</code></h3>

<p>Callbacks can mix both <code>:if</code> and <code>:unless</code> in the same declaration:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Comment</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_before_save'>before_save</span> <span class='symbeg'>:</span><span class='id identifier rubyid_filter_content'>filter_content</span><span class='comma'>,</span>
    <span class='label'>if:</span> <span class='const'>Proc</span>.<span class='id identifier rubyid_new'>new</span> { <span class='id identifier rubyid_forum'>forum</span>.<span class='id identifier rubyid_parental_control?'>parental_control?</span> }<span class='comma'>,</span>
    <span class='label'>unless:</span> <span class='const'>Proc</span>.<span class='id identifier rubyid_new'>new</span> { <span class='id identifier rubyid_author'>author</span>.<span class='id identifier rubyid_trusted?'>trusted?</span> }
<span class='kw'>end</span></code></pre>

<p>The callback only runs when all the <code>:if</code> conditions and none of the <code>:unless</code> conditions are evaluated to <code>true</code>.</p>

<h2>Callback Classes</h2>

<p>Sometimes the callback methods that you&#39;ll write will be useful enough to be reused by other models. Active Record makes it possible to create classes that encapsulate the callback methods, so they can be reused.</p>

<p>Here&#39;s an example where we create a class with an <code>after_destroy</code> callback to deal with the clean up of discarded files on the filesystem. This behavior may not be unique to our <code>PictureFile</code> model and we may want to share it, so it&#39;s a good idea to encapsulate this into a separate class. This will make testing that behavior and changing it much easier.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>FileDestroyerCallback</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_after_destroy'>after_destroy</span>(<span class='id identifier rubyid_file'>file</span>)
    <span class='kw'>if</span> <span class='const'><a href="File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_exist?'>exist?</span>(<span class='id identifier rubyid_file'>file</span>.<span class='id identifier rubyid_filepath'>filepath</span>)
      <span class='const'><a href="File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_delete'>delete</span>(<span class='id identifier rubyid_file'>file</span>.<span class='id identifier rubyid_filepath'>filepath</span>)
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>When declared inside a class, as above, the callback methods will receive the model object as a parameter. This will work on any model that uses the class like so:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>PictureFile</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_after_destroy'>after_destroy</span> <span class='const'>FileDestroyerCallback</span>.<span class='id identifier rubyid_new'>new</span>
<span class='kw'>end</span></code></pre>

<p>Note that we needed to instantiate a new <code>FileDestroyerCallback</code> object, since we declared our callback as an instance method. This is particularly useful if the callbacks make use of the state of the instantiated object. Often, however, it will make more sense to declare the callbacks as class methods:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>FileDestroyerCallback</span>
  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_after_destroy'>after_destroy</span>(<span class='id identifier rubyid_file'>file</span>)
    <span class='kw'>if</span> <span class='const'><a href="File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_exist?'>exist?</span>(<span class='id identifier rubyid_file'>file</span>.<span class='id identifier rubyid_filepath'>filepath</span>)
      <span class='const'><a href="File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_delete'>delete</span>(<span class='id identifier rubyid_file'>file</span>.<span class='id identifier rubyid_filepath'>filepath</span>)
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>When the callback method is declared this way, it won&#39;t be necessary to instantiate a new <code>FileDestroyerCallback</code> object in our model.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>PictureFile</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_after_destroy'>after_destroy</span> <span class='const'>FileDestroyerCallback</span>
<span class='kw'>end</span></code></pre>

<p>You can declare as many callbacks as you want inside your callback classes.</p>

<h2>Transaction Callbacks</h2>

<h3><code>after_commit</code> and <code>after_rollback</code></h3>

<p>There are two additional callbacks that are triggered by the completion of a database transaction: <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_commit"><code>after_commit</code></a> and <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_rollback"><code>after_rollback</code></a>. These callbacks are very similar to the <code>after_save</code> callback except that they don&#39;t execute until after database changes have either been committed or rolled back. They are most useful when your Active Record models need to interact with external systems which are not part of the database transaction.</p>

<p>Consider, for example, the previous example where the <code>PictureFile</code> model needs to delete a file after the corresponding record is destroyed. If anything raises an exception after the <code>after_destroy</code> callback is called and the transaction rolls back, the file will have been deleted and the model will be left in an inconsistent state. For example, suppose that <code>picture_file_2</code> in the code below is not valid and the <code>save!</code> method raises an error.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>PictureFile</span>.<span class='id identifier rubyid_transaction'>transaction</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_picture_file_1'>picture_file_1</span>.<span class='id identifier rubyid_destroy'>destroy</span>
  <span class='id identifier rubyid_picture_file_2'>picture_file_2</span>.<span class='id identifier rubyid_save!'>save!</span>
<span class='kw'>end</span></code></pre>

<p>By using the <code>after_commit</code> callback we can account for this case.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>PictureFile</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_after_commit'>after_commit</span> <span class='symbeg'>:</span><span class='id identifier rubyid_delete_picture_file_from_disk'>delete_picture_file_from_disk</span><span class='comma'>,</span> <span class='label'>on:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_destroy'>destroy</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_delete_picture_file_from_disk'>delete_picture_file_from_disk</span>
    <span class='kw'>if</span> <span class='const'><a href="File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_exist?'>exist?</span>(<span class='id identifier rubyid_filepath'>filepath</span>)
      <span class='const'><a href="File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_delete'>delete</span>(<span class='id identifier rubyid_filepath'>filepath</span>)
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>NOTE: The <code>:on</code> option specifies when a callback will be fired. If you don&#39;t supply the <code>:on</code> option the callback will fire for every action.</p>

<p>WARNING. When a transaction completes, the <code>after_commit</code> or <code>after_rollback</code> callbacks are called for all models created, updated, or destroyed within that transaction. However, if an exception is raised within one of these callbacks, the exception will bubble up and any remaining <code>after_commit</code> or <code>after_rollback</code> methods will <em>not</em> be executed. As such, if your callback code could raise an exception, you&#39;ll need to rescue it and handle it within the callback in order to allow other callbacks to run.</p>

<p>WARNING. The code executed within <code>after_commit</code> or <code>after_rollback</code> callbacks is itself not enclosed within a transaction.</p>

<p>WARNING. In the context of a single transaction, if you interact with multiple
loaded objects that represent the same record in the database, there&#39;s a crucial
behavior in the <code>after_commit</code> and <code>after_rollback</code> callbacks to note. These
callbacks are triggered only for the first object of the specific record that
undergoes a change within the transaction. Other loaded objects, despite
representing the same database record, will not have their respective
<code>after_commit</code> or <code>after_rollback</code> callbacks triggered. This nuanced behavior is
particularly impactful in scenarios where you expect independent callback
execution for each object associated with the same database record. It can
influence the flow and predictability of callback sequences, leading to potential
inconsistencies in application logic following the transaction.</p>

<h3>Aliases for <code>after_commit</code></h3>

<p>Since using the <code>after_commit</code> callback only on create, update, or delete is
common, there are aliases for those operations:</p>

<ul>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_create_commit"><code>after_create_commit</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_update_commit"><code>after_update_commit</code></a></li>
<li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_destroy_commit"><code>after_destroy_commit</code></a></li>
</ul>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>PictureFile</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_after_destroy_commit'>after_destroy_commit</span> <span class='symbeg'>:</span><span class='id identifier rubyid_delete_picture_file_from_disk'>delete_picture_file_from_disk</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_delete_picture_file_from_disk'>delete_picture_file_from_disk</span>
    <span class='kw'>if</span> <span class='const'><a href="File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_exist?'>exist?</span>(<span class='id identifier rubyid_filepath'>filepath</span>)
      <span class='const'><a href="File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_delete'>delete</span>(<span class='id identifier rubyid_filepath'>filepath</span>)
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>WARNING. Using both <code>after_create_commit</code> and <code>after_update_commit</code> with the same method name will only allow the last callback defined to take effect, as they both internally alias to <code>after_commit</code> which overrides previously defined callbacks with the same method name.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>User</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_after_create_commit'>after_create_commit</span> <span class='symbeg'>:</span><span class='id identifier rubyid_log_user_saved_to_db'>log_user_saved_to_db</span>
  <span class='id identifier rubyid_after_update_commit'>after_update_commit</span> <span class='symbeg'>:</span><span class='id identifier rubyid_log_user_saved_to_db'>log_user_saved_to_db</span>

  <span class='id identifier rubyid_private'>private</span>
    <span class='kw'>def</span> <span class='id identifier rubyid_log_user_saved_to_db'>log_user_saved_to_db</span>
      <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>User was saved to database</span><span class='tstring_end'>&#39;</span></span>
    <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<pre class="code irb"><code class="irb">irb&gt; @user = User.create # prints nothing

irb&gt; @user.save # updating @user
User was saved to database
</code></pre>

<h3><code>after_save_commit</code></h3>

<p>There is also <a href="https://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html#method-i-after_save_commit"><code>after_save_commit</code></a>, which is an alias for using the <code>after_commit</code> callback for both create and update together:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>User</span> <span class='op'>&lt;</span> <span class='const'>ApplicationRecord</span>
  <span class='id identifier rubyid_after_save_commit'>after_save_commit</span> <span class='symbeg'>:</span><span class='id identifier rubyid_log_user_saved_to_db'>log_user_saved_to_db</span>

  <span class='id identifier rubyid_private'>private</span>
    <span class='kw'>def</span> <span class='id identifier rubyid_log_user_saved_to_db'>log_user_saved_to_db</span>
      <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>User was saved to database</span><span class='tstring_end'>&#39;</span></span>
    <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<pre class="code irb"><code class="irb">irb&gt; @user = User.create # creating a User
User was saved to database

irb&gt; @user.save # updating @user
User was saved to database
</code></pre>

<h3>Transactional Callback Ordering</h3>

<p>By default, callbacks will run in the order they are defined. However, when
defining multiple transactional <code>after_</code> callbacks (<code>after_commit</code>,
<code>after_rollback</code>, etc), the order could be reversed from when they are defined.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>User</span> <span class='op'>&lt;</span> <span class='const'><a href="ActiveRecord.html" title="ActiveRecord (module)">ActiveRecord</a></span><span class='op'>::</span><span class='const'><a href="ActiveRecord/Base.html" title="ActiveRecord::Base (class)">Base</a></span>
  <span class='id identifier rubyid_after_commit'>after_commit</span> { <span class='id identifier rubyid_puts'>puts</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>this actually gets called second</span><span class='tstring_end'>&quot;</span></span>) }
  <span class='id identifier rubyid_after_commit'>after_commit</span> { <span class='id identifier rubyid_puts'>puts</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>this actually gets called first</span><span class='tstring_end'>&quot;</span></span>) }
<span class='kw'>end</span></code></pre>

<p>NOTE: This applies to all <code>after_*_commit</code> variations too, such as <code>after_destroy_commit</code>.</p>

<p>This order can be set via configuration:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_config'>config</span>.<span class='id identifier rubyid_active_record'>active_record</span>.<span class='id identifier rubyid_run_after_transaction_callbacks_in_order_defined'>run_after_transaction_callbacks_in_order_defined</span> <span class='op'>=</span> <span class='kw'>false</span></code></pre>

<p>When set to <code>true</code> (the default from Rails 7.1), callbacks are executed in the order they
are defined. When set to <code>false</code>, the order is reversed, just like in the example above.</p>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>