<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen' content='yes'>
<meta name='mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Structs &mdash; FFI master</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Structs",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>FFI master</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Structs&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<h3>An example</h3>
<p>This <a href="https://www.rubydoc.info/github/ffi/ffi/FFI/Struct"><code>FFI::Struct</code></a> (meant to mirror a C struct), has a single value, named &#8220;value&#8221;, of type &#8220;double&#8221;</p>
<pre class="code ruby"><code class='ruby'><span class='kw'>class</span> <span class='const'>SimpleStruct</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_double'>double</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> <span class='const'>SimpleStruct</span>.<span class='id identifier rubyid_new'>new</span> <span class='comment'># does a malloc on one of those structs
</span>
<span class='id identifier rubyid_a'>a</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span>] <span class='op'>=</span> <span class='int'>32</span> <span class='comment'># sets its internal value to 32</span></code></pre>
<h3>Passing structs as value or pointer parameters to functions</h3>
<p>Assuming you have a C library that looks like this, where the function takes a struct as an argument by value:</p>
<pre class="code c"><code class="c">typedef struct _WHAT {
  int d;
} WHAT;

int doit_by_value(WHAT w) {
  printf("%d\n", w.d);
  return w.d;
}

int doit_by_ptr(WHAT *w) {
  printf("%d\n", w-&gt;d);
  return w-&gt;d;
}
</code></pre>
<p>The resulting <span class="caps">FFI</span> wrapper code for the function should look like this:</p>
<pre class="code ruby"><code class='ruby'><span class='kw'>class</span> <span class='const'>WHAT</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_d'>d</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_int'>int</span>
<span class='kw'>end</span>
<span class='id identifier rubyid_attach_function'>attach_function</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>doit_by_value</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> [ <span class='const'>WHAT</span>.<span class='id identifier rubyid_by_value'>by_value</span> ]<span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_int'>int</span>
<span class='id identifier rubyid_attach_function'>attach_function</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>doit_by_ptr</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> [ <span class='const'>WHAT</span>.<span class='id identifier rubyid_by_ref'>by_ref</span> ]<span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_int'>int</span>

<span class='id identifier rubyid_w'>w</span> <span class='op'>=</span> <span class='const'>WHAT</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_w'>w</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_d'>d</span>] <span class='op'>=</span> <span class='int'>123</span>
<span class='const'>Foo</span>.<span class='id identifier rubyid_doit_by_value'>doit_by_value</span>(<span class='id identifier rubyid_w'>w</span>)
<span class='const'>Foo</span>.<span class='id identifier rubyid_doit_by_ptr'>doit_by_ptr</span>(<span class='id identifier rubyid_w'>w</span>)</code></pre>
<p><a href="http://stackoverflow.com/questions/8982393/how-to-wrap-function-in-ruby-ffi-method-that-takes-struct-as-argument/8990201#8990201">StackOverflow Question Relating to this</a></p>
<h3>When allocated</h3>
<p>When you call <code>FFI::Struct.new</code>, it allocates an &#8220;internal bytes&#8221; worth of memory right then.  When you then do a set, like <code>struct[:member] = 3</code>, the bits within that struct are set right then.  The inverse is also true; <code>x = struct[:member]</code> does a read from the raw memory (and translation into a ruby object), each time you access it.   Memory is &#8220;zeroed out&#8221; when it is first allocated, unless you pass in your own Pointer or specify it to not clear memory (<a href="http://groups.google.com/group/ruby-ffi/browse_thread/thread/509f727c52cb337">additional notes</a>).  If you pass it a Pointer it basically uses that as its base instead of allocating anything.</p>
<pre class="code ruby"><code class='ruby'><span class='comment'># Pass false as a 3rd argument to skip memory initialization
</span><span class='id identifier rubyid_pointer'>pointer</span> <span class='op'>=</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/MemoryPointer.html" title="FFI::MemoryPointer (class)">MemoryPointer</a></span>.<span class='id identifier rubyid_new'><a href="FFI/MemoryPointer.html#new-class_method" title="FFI::MemoryPointer.new (method)">new</a></span> <span class='symbeg'>:</span><span class='id identifier rubyid_char'>char</span><span class='comma'>,</span> <span class='const'>SimpleStruct</span>.<span class='id identifier rubyid_size'>size</span><span class='comma'>,</span> <span class='kw'>false</span>
<span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> <span class='const'>SimpleStruct</span>.<span class='id identifier rubyid_new'>new</span> <span class='id identifier rubyid_pointer'>pointer</span></code></pre>
<p>Note that you can get the actual address of the struct by using the <code>#pointer</code> method.</p>
<h3>Casting</h3>
<p>The same technique can be used to cast a &#8220;formless&#8221; blob of memory to a struct.</p>
<pre class="code ruby"><code class='ruby'><span class='kw'>class</span> <span class='const'>ComplexStruct</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_context'>context</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_pointer'>pointer</span><span class='comma'>,</span>
    <span class='symbeg'>:</span><span class='id identifier rubyid_value1'>value1</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_int32'>int32</span><span class='comma'>,</span>
    <span class='symbeg'>:</span><span class='id identifier rubyid_value2'>value2</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_uint64'>uint64</span><span class='comma'>,</span>
    <span class='symbeg'>:</span><span class='id identifier rubyid_value3'>value3</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_char'>char</span><span class='comma'>,</span>
    <span class='symbeg'>:</span><span class='kw'>next</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_pointer'>pointer</span>
<span class='kw'>end</span>

<span class='kw'>def</span> <span class='id identifier rubyid_cast_to_complex_struct'>cast_to_complex_struct</span> <span class='id identifier rubyid_pointer'>pointer</span>
  <span class='const'>ComplexStruct</span>.<span class='id identifier rubyid_new'>new</span> <span class='id identifier rubyid_pointer'>pointer</span>
<span class='kw'>end</span></code></pre>
<p>Calling <code>cast_to_complex_struct</code> and passing it a blob of memory will return a struct object mapped to that memory location. Code can then directly access the struct fields and operate on them.</p>
<pre class="code ruby"><code class='ruby'><span class='id identifier rubyid_my_struct'>my_struct</span> <span class='op'>=</span> <span class='id identifier rubyid_cast_to_complex_struct'>cast_to_complex_struct</span>(<span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/MemoryPointer.html" title="FFI::MemoryPointer (class)">MemoryPointer</a></span>.<span class='id identifier rubyid_new'><a href="FFI/MemoryPointer.html#new-class_method" title="FFI::MemoryPointer.new (method)">new</a></span> <span class='symbeg'>:</span><span class='id identifier rubyid_char'>char</span><span class='comma'>,</span> <span class='const'>ComplexStruct</span>.<span class='id identifier rubyid_size'>size</span>)
<span class='id identifier rubyid_my_struct'>my_struct</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_value1'>value1</span>] <span class='op'>=</span> <span class='id identifier rubyid_rand'>rand</span>(<span class='int'>1000</span>)
<span class='id identifier rubyid_my_struct'>my_struct</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_value2'>value2</span>] <span class='op'>=</span> <span class='id identifier rubyid_my_struct'>my_struct</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_value1'>value1</span>] <span class='op'>*</span> <span class='id identifier rubyid_my_struct'>my_struct</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_value3'>value3</span>]</code></pre>
<h3>Nested Structs</h3>
<p>It&#8217;s possible to nest structs within one another by direct reference.  Simply use the name of the struct type you wish to nest within another.  If instead you need a <strong>pointer</strong> to a struct of that type, use the next section, &#8220;Nested pointers&#8221; for more information.</p>
<pre class="code ruby"><code class='ruby'><span class='kw'>class</span> <span class='const'>InnerStruct</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_messageLength'>messageLength</span><span class='comma'>,</span>  <span class='symbeg'>:</span><span class='id identifier rubyid_uint32'>uint32</span><span class='comma'>,</span>
         <span class='symbeg'>:</span><span class='id identifier rubyid_pMessage'>pMessage</span><span class='comma'>,</span>       <span class='symbeg'>:</span><span class='id identifier rubyid_string'>string</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>OuterStruct</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span><span class='comma'>,</span>  <span class='symbeg'>:</span><span class='id identifier rubyid_uint32'>uint32</span><span class='comma'>,</span>
         <span class='symbeg'>:</span><span class='id identifier rubyid_inner'>inner</span><span class='comma'>,</span>  <span class='const'>InnerStruct</span>  <span class='comment'># this sets up our inner struct!
</span><span class='kw'>end</span></code></pre>
<h3>Nested pointers</h3>
<p>You can define nested pointers to structs within structs using <a href="https://www.rubydoc.info/github/ffi/ffi/FFI/Struct#ptr-class_method"><code>FFI::Struct.ptr</code></a> method. It&#8217;s important to keep in mind, that each object stored in a pointer reference needs to stored in a ruby variable, so that it isn&#8217;t garbage collected until the struct is no longer accessed. See <a href="https://github.com/ffi/ffi/wiki/Core-Concepts#memory-management">Core Concepts</a> for more description about memory management.</p>
<pre class="code ruby"><code class='ruby'><span class='kw'>class</span> <span class='const'>Struct2</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_age'>age</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_int'>int</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>Struct1</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_id'>id</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_int'>int</span><span class='comma'>,</span>
    <span class='symbeg'>:</span><span class='id identifier rubyid_data'>data</span><span class='comma'>,</span> <span class='const'>Struct2</span>.<span class='id identifier rubyid_ptr'>ptr</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_struct'>struct</span> <span class='op'>=</span> <span class='const'>Struct1</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_struct2'>struct2</span> <span class='op'>=</span> <span class='const'>Struct2</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_struct'>struct</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_data'>data</span>] <span class='op'>=</span> <span class='id identifier rubyid_struct2'>struct2</span>
<span class='id identifier rubyid_struct'>struct</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_data'>data</span>][<span class='symbeg'>:</span><span class='id identifier rubyid_age'>age</span>] <span class='op'>=</span> <span class='int'>27</span></code></pre>
<p>Don&#8217;t reference the inner Struct2 object by a pointer only! The ruby garbage collector doesn&#8217;t know about it and could free the memory behind Struct2 before the data has been processed. So this is dangerous:
```ruby
struct = Struct1.new
struct[:data] = Struct2.new  # Struct2.new object could be GC&#8217;ed immediately!
struct[:data][:age] = 27
</code></pre></p>
<h3>Pointers to Functions</h3>
<p>Some libraries have factory functions that return structures containing pointers to other functions in the library. Instead of modeling these pointers using the normal <code>:pointer</code> type, you can simply create an anonymous or named callback type using the <code>callback</code> method.</p>
<pre class="code ruby"><code class='ruby'><span class='kw'>class</span> <span class='const'>FunctionTable</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_function1'>function1</span><span class='comma'>,</span> <span class='id identifier rubyid_callback'>callback</span>([<span class='symbeg'>:</span><span class='id identifier rubyid_pointer'>pointer</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_int'>int</span>]<span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_void'>void</span>)  <span class='comment'># A pointer to an anonymous function that takes a pointer and an integer
</span>
  <span class='comment'># or more verbose with a named callback:
</span>  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_function1'>function1</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_completion_function'>completion_function</span>  <span class='comment'># A pointer to the named callback function
</span><span class='kw'>end</span>

<span class='id identifier rubyid_callback'>callback</span> <span class='symbeg'>:</span><span class='id identifier rubyid_completion_function'>completion_function</span><span class='comma'>,</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_pointer'>pointer</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_long'>long</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_uint8'>uint8</span>]<span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_void'>void</span>  <span class='comment'># define a named callback
</span><span class='id identifier rubyid_attach_function'>attach_function</span> <span class='symbeg'>:</span><span class='id identifier rubyid_factory'>factory</span><span class='comma'>,</span> []<span class='comma'>,</span> <span class='symbeg'>:</span><span class='const'>FunctionTable</span>.<span class='id identifier rubyid_by_ref'>by_ref</span></code></pre>
<p>Then, once the factory function has filled in the pointers, you can call them using the regular <code>call()</code> method.</p>
<pre class="code ruby"><code class='ruby'><span class='id identifier rubyid_vtable'>vtable</span> <span class='op'>=</span> <span class='id identifier rubyid_factory'>factory</span>()        <span class='comment'># Creates and returns a new structure
</span>
<span class='comment'># Call the function that the library provided
</span><span class='id identifier rubyid_vtable'>vtable</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_function1'>function1</span>].<span class='id identifier rubyid_call'>call</span>(<span class='id identifier rubyid_my_pointer'>my_pointer</span><span class='comma'>,</span> <span class='id identifier rubyid_my_integer'>my_integer</span>)</code></pre>
<h3>Char arrays</h3>
<p>from C</p>
<pre class="code c"><code class="c">struct { 
  uint8 Value; 
  uint8 String[SIZE_OF_ARRAY]; 
} MyArray_t; 
</code></pre>
<p>to Ruby</p>
<pre class="code ruby"><code class='ruby'><span class='kw'>class</span> <span class='const'>MyArray_t</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span> 
  <span class='id identifier rubyid_layout'>layout</span>  <span class='symbeg'>:</span><span class='const'>Value</span><span class='comma'>,</span>  <span class='symbeg'>:</span><span class='id identifier rubyid_uint8'>uint8</span><span class='comma'>,</span> 
         <span class='symbeg'>:</span><span class='const'>String</span><span class='comma'>,</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_uint8'>uint8</span><span class='comma'>,</span> <span class='const'>SIZE_OF_ARRAY</span>] 
<span class='kw'>end</span> 

<span class='comment'># use via:
</span><span class='id identifier rubyid_my_array_struct'>my_array_struct</span>[<span class='symbeg'>:</span><span class='const'>String</span>].<span class='id identifier rubyid_to_ptr'>to_ptr</span>.<span class='id identifier rubyid_read_string'>read_string</span></code></pre>
<p>Set them like</p>
<pre class="code ruby"><code class='ruby'><span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> <span class='const'>MyArray_t</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_a'>a</span>[<span class='symbeg'>:</span><span class='const'>String</span>][<span class='int'>0</span>] <span class='op'>=</span> <span class='int'>33</span> <span class='comment'># set a single byte within the struct</span></code></pre>
<p>or</p>
<pre class="code ruby"><code class='ruby'><span class='id identifier rubyid_a'>a</span>[<span class='symbeg'>:</span><span class='const'>String</span>].<span class='id identifier rubyid_to_ptr'>to_ptr</span>.<span class='id identifier rubyid_put_string'>put_string</span>(<span class='int'>0</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>)</code></pre>
<h3>custom packed structs</h3>
<p>By default, ffi will assume the structs you mentioned are to be packed &#8220;like normal for your system&#8221; &#8212; if this is not the case, as in if you use <code>#pragma pack</code> in msvc, or <code>__attribute__((__packed__))</code> on gcc, then you&#8217;ll need to specify the struct packing boundary.</p>
<pre class="code ruby"><code class='ruby'><span class='kw'>class</span> <span class='const'>CustomPacked</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='id identifier rubyid_pack'>pack</span> <span class='int'>1</span>  <span class='comment'># pack all members on a 1 byte boundary
</span>  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_a'>a</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_char'>char</span><span class='comma'>,</span>
         <span class='symbeg'>:</span><span class='id identifier rubyid_b'>b</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_int'>int</span><span class='comma'>,</span> <span class='comment'># starts at offset=1, not offset=4
</span><span class='kw'>end</span></code></pre>
<h3>Array of Structs</h3>
<p>You can access an array of structs by stepping through the array in increments of the struct size, and casting each blob of memory using <span class="caps">FFI</span>::Pointer#.</p>
<p>Here is an example of a parent struct that contains an array of structs, and each member of the array also contains a union.</p>
<p>From c:</p>
<pre class="code c"><code class="c"> // parent struct contains an array of child structs in *val
 typedef struct {
    uint len;
    F_TextItemT *val;
 } F_TextItemsT;

 typedef struct {
    int offset;
    int dataType; // indicates what part of the union is valid
    union {
	 char *sdata;  // string data
	 int idata;  // int data
	 } u;
    } F_TextItemT;
</code></pre>
<p>In Ruby the structs and union look like this:</p>
<pre class="code ruby"><code class='ruby'><span class='kw'>class</span> <span class='const'>FTextItemU</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Union.html" title="FFI::Union (class)">Union</a></span>
  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sdata'>sdata</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_string'>string</span><span class='comma'>,</span>
  <span class='symbeg'>:</span><span class='id identifier rubyid_idata'>idata</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_int'>int</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>FTextItemT</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='id identifier rubyid_layout'>layout</span>  <span class='symbeg'>:</span><span class='id identifier rubyid_offset'>offset</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_int'>int</span><span class='comma'>,</span>
    <span class='symbeg'>:</span><span class='id identifier rubyid_dataType'>dataType</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_int'>int</span><span class='comma'>,</span>
    <span class='symbeg'>:</span><span class='id identifier rubyid_u'>u</span><span class='comma'>,</span> <span class='const'>FTextItemU</span>
<span class='kw'>end</span> 

<span class='kw'>class</span> <span class='const'>FTextItemsT</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_len'>len</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_uint'>uint</span><span class='comma'>,</span>
    <span class='symbeg'>:</span><span class='id identifier rubyid_val'>val</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_pointer'>pointer</span>
<span class='kw'>end</span></code></pre>
<p>This code accesses members of the array using <span class="caps">FFI</span>::Pointer# by stepping through the array at increments of the struct size:</p>
<pre class="code ruby"><code class='ruby'><span class='id identifier rubyid_tis'>tis</span> <span class='op'>=</span> <span class='const'>FM</span>.<span class='const'>FApiGetText</span>(<span class='id identifier rubyid_docid'>docid</span><span class='comma'>,</span> <span class='id identifier rubyid_flowid'>flowid</span><span class='comma'>,</span> (<span class='const'>FM</span>.<span class='const'>FTIString</span> <span class='op'>|</span> <span class='const'>FM</span>.<span class='const'>FTILineEnd</span>))<span class='semicolon'>;</span>
<span class='comment'># Traverse text items and print strings and line ends.
</span> <span class='int'>0</span>.<span class='id identifier rubyid_upto'>upto</span>(<span class='id identifier rubyid_tis'>tis</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_len'>len</span>]<span class='op'>-</span><span class='int'>1</span>)  <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
   <span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='const'>FM</span><span class='op'>::</span><span class='const'>FTextItemT</span>.<span class='id identifier rubyid_new'>new</span>(<span class='id identifier rubyid_tis'>tis</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_val'>val</span>] <span class='op'>+</span> (<span class='id identifier rubyid_i'>i</span> <span class='op'>*</span> <span class='const'>FM</span><span class='op'>::</span><span class='const'>FTextItemT</span>.<span class='id identifier rubyid_size'>size</span>))
   <span class='kw'>if</span> <span class='id identifier rubyid_s'>s</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_dataType'>dataType</span>] <span class='op'>==</span> <span class='const'>FM</span>.<span class='const'>FTIString</span>
     <span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_s'>s</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_u'>u</span>][<span class='symbeg'>:</span><span class='id identifier rubyid_sdata'>sdata</span>]
   <span class='kw'>end</span>
 <span class='kw'>end</span></code></pre>
<p>Alternatively, you can use Pointer.new() to create a new pointer with a different type_size (the size used to step
along it using the [] method).</p>
<p>e.g.</p>
<pre class="code ruby"><code class='ruby'><span class='id identifier rubyid_val_array'>val_array</span> <span class='op'>=</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Pointer.html" title="FFI::Pointer (class)">Pointer</a></span>.<span class='id identifier rubyid_new'><a href="FFI/Pointer.html#new-class_method" title="FFI::Pointer.new (method)">new</a></span>(<span class='const'>FM</span><span class='op'>::</span><span class='const'>FTextItemT</span><span class='comma'>,</span> <span class='id identifier rubyid_tis'>tis</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_val'>val</span>])
<span class='int'>0</span>.<span class='id identifier rubyid_upto'>upto</span>(<span class='id identifier rubyid_tis'>tis</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_len'>len</span>]) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
   <span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='const'>FM</span><span class='op'>::</span><span class='const'>FTextItemT</span>.<span class='id identifier rubyid_new'>new</span>(<span class='id identifier rubyid_val_array'>val_array</span>[<span class='id identifier rubyid_i'>i</span>])
   <span class='comment'># do stuff with s struct here
</span><span class='kw'>end</span></code></pre>
<p>If you need to pass an array of structs to a function, you can use the same approach: first pre-allocate some memory for the array, and then step through it. If you wish, you can create an array of Ruby objects, each of which points to the correct place in the underlying storage. The following example uses struct iovec as used by sendmsg(2) and recvmsg(2)</p>
<pre class="code ruby"><code class='ruby'><span class='kw'>class</span> <span class='const'>IOVec</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='id identifier rubyid_layout'>layout</span> <span class='symbeg'>:</span><span class='id identifier rubyid_base'>base</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_pointer'>pointer</span><span class='comma'>,</span>
         <span class='symbeg'>:</span><span class='id identifier rubyid_len'>len</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_size_t'>size_t</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_iovlen'>iovlen</span> <span class='op'>=</span> <span class='int'>3</span>
<span class='id identifier rubyid_iov'>iov</span> <span class='op'>=</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/MemoryPointer.html" title="FFI::MemoryPointer (class)">MemoryPointer</a></span>.<span class='id identifier rubyid_new'><a href="FFI/MemoryPointer.html#new-class_method" title="FFI::MemoryPointer.new (method)">new</a></span>(<span class='const'>IOVec</span><span class='comma'>,</span> <span class='id identifier rubyid_iovlen'>iovlen</span>)
<span class='id identifier rubyid_iovs'>iovs</span> <span class='op'>=</span> <span class='id identifier rubyid_iovlen'>iovlen</span>.<span class='id identifier rubyid_times'>times</span>.<span class='id identifier rubyid_collect'>collect</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span>
  <span class='const'>IOVec</span>.<span class='id identifier rubyid_new'>new</span>(<span class='id identifier rubyid_iov'>iov</span> <span class='op'>+</span> <span class='id identifier rubyid_i'>i</span> <span class='op'>*</span> <span class='const'>IOVec</span>.<span class='id identifier rubyid_size'>size</span>)
<span class='kw'>end</span>

<span class='id identifier rubyid_iovs'>iovs</span>[<span class='int'>0</span>][<span class='symbeg'>:</span><span class='id identifier rubyid_base'>base</span>] <span class='op'>=</span> <span class='comment'>#...
</span><span class='id identifier rubyid_iovs'>iovs</span>[<span class='int'>0</span>][<span class='symbeg'>:</span><span class='id identifier rubyid_len'>len</span>]  <span class='op'>=</span> <span class='comment'>#...
</span><span class='id identifier rubyid_iovs'>iovs</span>[<span class='int'>1</span>][<span class='symbeg'>:</span><span class='id identifier rubyid_base'>base</span>] <span class='op'>=</span> <span class='comment'>#...
</span><span class='id identifier rubyid_iovs'>iovs</span>[<span class='int'>1</span>][<span class='symbeg'>:</span><span class='id identifier rubyid_len'>len</span>]  <span class='op'>=</span> <span class='comment'>#...
</span><span class='id identifier rubyid_iovs'>iovs</span>[<span class='int'>2</span>][<span class='symbeg'>:</span><span class='id identifier rubyid_base'>base</span>] <span class='op'>=</span> <span class='comment'>#...
</span><span class='id identifier rubyid_iovs'>iovs</span>[<span class='int'>2</span>][<span class='symbeg'>:</span><span class='id identifier rubyid_len'>len</span>]  <span class='op'>=</span> <span class='comment'>#...
</span>
<span class='id identifier rubyid_msghdr'>msghdr</span>.<span class='id identifier rubyid_msg_iov'>msg_iov</span> <span class='op'>=</span> <span class='id identifier rubyid_iov'>iov</span>
<span class='id identifier rubyid_msghdr'>msghdr</span>.<span class='id identifier rubyid_msg_iovlen'>msg_iovlen</span> <span class='op'>=</span> <span class='id identifier rubyid_iovlen'>iovlen</span></code></pre>
<h4>Simpler struct arrays</h4>
<p>An easier way to handle arrays of structs is to use a single memory pointer.</p>
<pre class="code ruby"><code class='ruby'><span class='kw'>class</span> <span class='const'>SomeStruct</span> <span class='op'>&lt;</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>
  <span class='comment'># . . .
</span><span class='kw'>end</span>

<span class='comment'># where length is the size of the array
</span><span class='id identifier rubyid_ary'>ary</span> <span class='op'>=</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/MemoryPointer.html" title="FFI::MemoryPointer (class)">MemoryPointer</a></span>.<span class='id identifier rubyid_new'><a href="FFI/MemoryPointer.html#new-class_method" title="FFI::MemoryPointer.new (method)">new</a></span>( <span class='symbeg'>:</span><span class='id identifier rubyid_uchar'>uchar</span><span class='comma'>,</span> <span class='const'>SomeStruct</span>.<span class='id identifier rubyid_size'>size</span>() <span class='op'>*</span> <span class='id identifier rubyid_length'>length</span> )</code></pre>
<p>This can be passed directly into a C-function and will have the requisite memory allocated to it to contain all instances of the struct you&#8217;re using.</p>
<p>To read out of it again, simply do the following:</p>
<pre class="code ruby"><code class='ruby'><span class='comment'># determine the length of the data
</span><span class='id identifier rubyid_bytes'>bytes</span> <span class='op'>=</span> <span class='const'>SomeStruct</span>.<span class='id identifier rubyid_size'>size</span>()

<span class='comment'># read a struct from a single index; this requires two steps:
</span><span class='comment'># 1. first we declare the container pointer.
</span><span class='comment'># 2. then we cast it.
</span><span class='id identifier rubyid_data'>data</span> <span class='op'>=</span> <span class='id identifier rubyid_ary'>ary</span>.<span class='id identifier rubyid_slice'>slice</span>( <span class='id identifier rubyid_bytes'>bytes</span> <span class='op'>*</span> <span class='id identifier rubyid_index'>index</span><span class='comma'>,</span> <span class='id identifier rubyid_bytes'>bytes</span> )
<span class='id identifier rubyid_instance_of_somestruct'>instance_of_somestruct</span> <span class='op'>=</span> <span class='const'>SomeStruct</span>.<span class='id identifier rubyid_new'>new</span>( <span class='id identifier rubyid_data'>data</span> )</code></pre>
<p>If you would rather read the entirety of the pointer as a ruby Array, you can instead do this:</p>
<pre class="code ruby"><code class='ruby'><span class='comment'># determine the length of the data
</span><span class='id identifier rubyid_bytes'>bytes</span> <span class='op'>=</span> <span class='const'>SomeStruct</span>.<span class='id identifier rubyid_size'>size</span>()

<span class='comment'># create an array
</span><span class='id identifier rubyid_instances_of_somestruct'>instances_of_somestruct</span> <span class='op'>=</span> <span class='const'>Array</span>.<span class='id identifier rubyid_new'>new</span>( <span class='id identifier rubyid_ary'>ary</span>.<span class='id identifier rubyid_size'>size</span> <span class='op'>/</span> <span class='id identifier rubyid_bytes'>bytes</span> ){<span class='op'>|</span><span class='id identifier rubyid_index'>index</span><span class='op'>|</span>
  <span class='comment'># set this index to the new SomeStruct instance
</span>  <span class='const'>SomeStruct</span>.<span class='id identifier rubyid_new'>new</span>( <span class='id identifier rubyid_ary'>ary</span>.<span class='id identifier rubyid_slice'>slice</span>( <span class='id identifier rubyid_index'>index</span> <span class='op'>*</span> <span class='id identifier rubyid_bytes'>bytes</span><span class='comma'>,</span> <span class='id identifier rubyid_bytes'>bytes</span> ) )
}</code></pre>
<h4>Getting Pointers to Struct Fields</h4>
<p>Some functions need the address of a field to be passed as an argument. There is no built-in method for returning a field&#8217;s address. Luckily we can mimic this behavior by using a {FFI::Pointer} and a field offset.</p>
<pre class="code c"><code class="c"> struct in_addr {
    uint32_t s_addr; // that's a 32-bit int (4 bytes)
 };

 struct sockaddr_in {
    short int          sin_family;  // Address family, AF_INET
    unsigned short int sin_port;    // Port number
    struct in_addr     sin_addr;    // Internet address
    unsigned char      sin_zero[8]; // Same size as struct sockaddr
 };

 char* result;
 char ip_string[INET_ADDRSTRLEN];
 struct sockaddr_in sa;      // pretend this is loaded with something

 result = inet_ntop(AF_INET, &amp;(sa.sin_addr), ip_string, INET_ADDRSTRLEN);

&lt;pre class="code"&gt;&lt;code class=""&gt;
Translating this to Ruby is fairly straightforward.

&lt;pre class="code ruby"&gt;&lt;code class="ruby"&gt; class SockAddrInStruct &lt; FFI::Struct
   layout :sin_len, :uint8,
     :sin_family, :sa_family_t,
     :sin_port, :ushort,
     :sin_addr, :uint32,
     :sin_zero, [:uint8, 8]
 end

 attach_function :inet_ntop, [:int, :pointer, :pointer, :int], :string, :blocking =&gt; true

 ip_string = FFI::MemoryPointer.new(:uint8, INET_ADDRSTRLEN)

 sa = SockAddrInStruct.new # pretend this is loaded with something
 field_ptr = FFI::Pointer.new(:uint8, sa.pointer.address + sa.offset_of(:sin_addr))

 result = inet_ntop(AF_INET, field_ptr, ip_string, INET_ADDRSTRLEN);
</code></pre>
<h3>Gotchas</h3>
<p>multidimentional arrays aren&#8217;t yet <a href="http://github.com/ffi/ffi/issues/#issue/18">fully supported</a></p>
<p>any type of class descendancy/hierarchy is not supported, at least it appears to not be.</p>
<h3>Helpers</h3>
<p>Currently structs only allow access &#8220;like a Hash&#8221; via <code>instance[:member]</code>.  If you desire methods for access, you can use ffi swig, or nice-ffi or <a href="https://github.com/ffi/ffi/issues/107">roll your own</a></p>
<h4>Helper example via &#8220;method_missing&#8221; builtin</h4>
<p>You can make a simple helper method to access struct members as if they were created with `attr_accessor` with the following code, which exploits the `method_missing()` builtin method for most Ruby objects:</p>
<pre class="code ruby"><code class='ruby'><span class='kw'>class</span> <span class='const'><a href="FFI.html" title="FFI (module)">FFI</a></span><span class='op'>::</span><span class='const'><a href="FFI/Struct.html" title="FFI::Struct (class)">Struct</a></span>

  <span class='comment'># Use the symbol passed from the method for accessing the analogous field.
</span>  <span class='comment'># This method can also take a &amp;block, but we would not use it.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_method_missing'>method_missing</span>( <span class='id identifier rubyid_sym'>sym</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span> )
    <span class='comment'># convert symbol to a string to allow regex checks
</span>    <span class='id identifier rubyid_str'>str</span> <span class='op'>=</span> <span class='id identifier rubyid_sym'>sym</span>.<span class='id identifier rubyid_to_s'>to_s</span>
    
    <span class='comment'># derive the member&#39;s symbolic name
</span>    <span class='id identifier rubyid_member'>member</span> <span class='op'>=</span> <span class='id identifier rubyid_str'>str</span>.<span class='id identifier rubyid_match'>match</span>( <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^([a-z0-9_]+)</span><span class='regexp_end'>/i</span></span> )[<span class='int'>1</span>].<span class='id identifier rubyid_to_sym'>to_sym</span>

    <span class='comment'># raise an exception via the default behavior if that symbol isn&#39;t a member!
</span>    <span class='kw'>super</span> <span class='kw'>unless</span> <span class='id identifier rubyid_members'>members</span>.<span class='id identifier rubyid_include?'>include?</span> <span class='id identifier rubyid_member'>member</span>

    <span class='comment'># this ternary checks for the presence of an equals sign (=) to indicate an
</span>    <span class='comment'># assignment operation and changes which method we invoke and whether or not
</span>    <span class='comment'># to send the splatted arguments as well.
</span>    (<span class='id identifier rubyid_str'>str</span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>=$</span><span class='regexp_end'>/</span></span>) <span class='op'>?</span> <span class='id identifier rubyid_send'>send</span>( <span class='symbeg'>:</span><span class='op'>[]=</span><span class='comma'>,</span> <span class='id identifier rubyid_member'>member</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span> ) <span class='op'>:</span> <span class='id identifier rubyid_send'>send</span>( <span class='symbeg'>:</span><span class='op'>[]</span><span class='comma'>,</span> <span class='id identifier rubyid_member'>member</span> )
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>
<h3>Platform dependent offsets of struct members</h3>
<p>Offsets of struct members are calculated based on the value types. There is a deprecated way to define offsets explicit by using [[Automatic Struct Layout]].</p>
<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>