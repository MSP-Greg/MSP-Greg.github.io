<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Queries &mdash; Mongoid master</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "queries",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Mongoid master</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Queries&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<h1>Queries</h1>

<div class="contents singlecol" markdown="1" local="" backlinks="none" depth="2"></div>

<p><a href="Mongoid.html" title="Mongoid (module)"><code>Mongoid</code></a> provides a rich query DSL inspired by ActiveRecord. A trivial query
looks as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Depeche Mode</span><span class='tstring_end'>&quot;</span></span>)</code></pre>

<p>A more complex query utilizing various Mongoid features could be as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.
  <span class='id identifier rubyid_where'>where</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_founded'>founded</span>.<span class='id identifier rubyid_gte'>gte</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>1980-01-01</span><span class='tstring_end'>&quot;</span></span>).
  <span class='id identifier rubyid_in'>in</span>(<span class='label'>name:</span> [ <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Tool</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Deftones</span><span class='tstring_end'>&quot;</span></span> ]).
  <span class='id identifier rubyid_union'>union</span>.
  <span class='id identifier rubyid_in'>in</span>(<span class='label'>name:</span> [ <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Melvins</span><span class='tstring_end'>&quot;</span></span> ])</code></pre>

<p>The query methods return <a href="Mongoid/Criteria.html" title="Mongoid::Criteria (class)"><code>::Mongoid::Criteria</code></a> objects, which are chainable
and lazily evaluated wrappers for MongoDB query language (MQL).
The queries are executed when their result sets are iterated. For example:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Construct a Criteria object:
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Deftones</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;name&quot;=&gt;&quot;Deftones&quot;}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;
</span>
<span class='comment'># Evaluate the query and get matching documents:
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Deftones</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_to_a'>to_a</span>
<span class='comment'># =&gt; [#&lt;Band _id: 5ebdeddfe1b83265a376a760, name: &quot;Deftones&quot;, description: nil&gt;]</span></code></pre>

<p>Methods like <code>first</code> and <code>last</code> return the individual documents immediately.
Otherwise, iterating a Criteria object with methods like <code>each</code> or <code>map</code>
retrieves the documents from the server. <code>to_a</code> can be used to force
execution of a query that returns an array of documents, literally converting
a Criteria object to an Array.</p>

<p>When a query method is called on a Criteria instance, the method returns a new
Criteria instance with the new conditions added to the existing conditions:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_scope'>scope</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_founded'>founded</span>.<span class='id identifier rubyid_gte'>gte</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>1980-01-01</span><span class='tstring_end'>&quot;</span></span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;founded&quot;=&gt;{&quot;$gte&quot;=&gt;&quot;1980-01-01&quot;}}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;
</span>
<span class='id identifier rubyid_scope'>scope</span>.<span class='id identifier rubyid_where'>where</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_founded'>founded</span>.<span class='id identifier rubyid_lte'>lte</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>2020-01-01</span><span class='tstring_end'>&quot;</span></span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;founded&quot;=&gt;{&quot;$gte&quot;=&gt;&quot;1980-01-01&quot;, &quot;$lte&quot;=&gt;&quot;2020-01-01&quot;}}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;
</span>
<span class='id identifier rubyid_scope'>scope</span>
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;founded&quot;=&gt;{&quot;$gte&quot;=&gt;&quot;1980-01-01&quot;}}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<h2>Condition Syntax</h2>

<p>Mongoid supports three ways of specifying individual conditions:</p>

<ol>
<li> Field syntax.</li>
<li> MQL syntax.</li>
<li> Symbol operator syntax.</li>
</ol>

<p>All syntaxes support querying embedded documents using the dot notation.
All syntaxes respect field types, if the field being queried is defined in the
model class, and field aliases.</p>

<p>The examples in this section use the following model definition:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_founded'>founded</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Integer.html" title="Integer (class)">Integer</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_m'>m</span><span class='comma'>,</span> <span class='label'>as:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_member_count'>member_count</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Integer.html" title="Integer (class)">Integer</a></span>

  <span class='id identifier rubyid_embeds_one'>embeds_one</span> <span class='symbeg'>:</span><span class='id identifier rubyid_manager'>manager</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>Manager</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_embedded_in'>embedded_in</span> <span class='symbeg'>:</span><span class='id identifier rubyid_band'>band</span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
<span class='kw'>end</span></code></pre>

<h3>Field Syntax</h3>

<p>The simplest querying syntax utilizes the basic Ruby hashes. Keys can be
symbols or strings, and correspond to field names in MongoDB documents:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Depeche Mode</span><span class='tstring_end'>&quot;</span></span>)
<span class='comment'>#   =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;name&quot;=&gt;&quot;Depeche Mode&quot;}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;
</span>
<span class='comment'># Equivalent to:
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Depeche Mode</span><span class='tstring_end'>&quot;</span></span>)</code></pre>

<h3>MQL Syntax</h3>

<p>An MQL operator may be specified on any field using the hash syntax:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>founded:</span> {<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>$gt</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='int'>1980</span>})
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;founded&quot;=&gt;{&quot;$gt&quot;=&gt;1980}}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;
</span>
<span class='comment'># Equivalent to:
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>founded</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> {<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>$gt</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='int'>1980</span>})</code></pre>

<h3>Symbol Operator Syntax</h3>

<p>MQL operators may be specified as methods on symbols for the respective field
name, as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_founded'>founded</span>.<span class='id identifier rubyid_gt'>gt</span> <span class='op'>=&gt;</span> <span class='int'>1980</span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;founded&quot;=&gt;{&quot;$gt&quot;=&gt;1980}}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<h2>Fields</h2>

<h3>Querying on Defined Fields</h3>

<p>In order to query on a field, it is not necessary to add the field to
<code>the model class definition &lt;fields&gt;</code>. However, if a field is defined in
the model class, Mongoid will coerce query values to match defined field types
when constructing the query:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='int'>2020</span><span class='comma'>,</span> <span class='label'>founded:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>2020</span><span class='tstring_end'>&quot;</span></span>)
<span class='comment'>#   =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;name&quot;=&gt;&quot;2020&quot;, &quot;founded&quot;=&gt;2020}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<h3>Querying for Raw Values</h3>

<p>If you&#39;d like to bypass Mongoid&#39;s query type coercion behavior and query
directly for the raw-typed value in the database, wrap the query value in
<a href="Mongoid/RawValue.html" title="Mongoid::RawValue (class)"><code>::Mongoid::RawValue</code></a> class. This can be useful when working with legacy data.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>founded:</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/RawValue.html" title="Mongoid::RawValue (class)">RawValue</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>2020</span><span class='tstring_end'>&quot;</span></span>))
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;founded&quot;=&gt;&quot;2020&quot;}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<h3>Field Aliases</h3>

<p>Queries take into account <code>storage field names &lt;storage-field-names&gt;</code>
and <code>field aliases &lt;field-aliases&gt;</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'>#   =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;n&quot;=&gt;&quot;Astral Projection&quot;}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<p>Since <code>id</code> and <code>_id</code> fields are aliases, either one can be used for queries:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>id:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>5ebdeddfe1b83265a376a760</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;_id&quot;=&gt;BSON::ObjectId(&#39;5ebdeddfe1b83265a376a760&#39;)}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<h2>Embedded Documents</h2>

<p>To match values of fields of embedded documents, use the dot notation:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>manager.name</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Smith</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;manager.name&quot;=&gt;&quot;Smith&quot;}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='symbeg'>:&#39;</span><span class='tstring_content'>manager.name</span><span class='tstring_end'>&#39;</span></span>.<span class='id identifier rubyid_ne'>ne</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Smith</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;manager.name&quot;=&gt;{&quot;$ne&quot;=&gt;&quot;Smith&quot;}}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<div class="note" markdown="1">

<div class="title" markdown="1">

Note

</div>

<p>Queries always return top-level model instances, even if all of the
conditions are referencing embedded documents.</p>

<p></div></p>

<h2>Logical Operations</h2>

<p>Mongoid supports <code>and</code>, <code>or</code>, <code>nor</code> and <code>not</code> logical operations on
<code>Criteria</code> objects. These methods take one or more hash of conditions
or another <code>Criteria</code> object as their arguments, with <code>not</code> additionally
having an argument-free version.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># and with conditions
</span><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>label:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Trust in Trance</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_and'>and</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>)

<span class='comment'># or with scope
</span><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>label:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Trust in Trance</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_or'>or</span>(<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>))

<span class='comment'># not with conditions
</span><span class='const'>Band</span>.<span class='id identifier rubyid_not'>not</span>(<span class='label'>label:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Trust in Trance</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>)

<span class='comment'># argument-less not
</span><span class='const'>Band</span>.<span class='id identifier rubyid_not'>not</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>label:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Trust in Trance</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>)</code></pre>

<p>For backwards compatibility with earlier Mongoid versions, all of the logical
operation methods also accept arrays of parameters, which will be flattened
to obtain the criteria. Passing arrays to logical operations is deprecated and
may be removed in a future version of Mongoid.</p>

<p>The following calls all produce the same query conditions:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Condition hashes passed to separate and invocations
</span><span class='const'>Band</span>.<span class='id identifier rubyid_and'>and</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>SUN Project</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_and'>and</span>(<span class='label'>member_count:</span> <span class='int'>2</span>)

<span class='comment'># Multiple condition hashes in the same and invocation
</span><span class='const'>Band</span>.<span class='id identifier rubyid_and'>and</span>({<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>SUN Project</span><span class='tstring_end'>&#39;</span></span>}<span class='comma'>,</span> {<span class='label'>member_count:</span> <span class='int'>2</span>})

<span class='comment'># Multiple condition hashes in an array - deprecated
</span><span class='const'>Band</span>.<span class='id identifier rubyid_and'>and</span>([{<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>SUN Project</span><span class='tstring_end'>&#39;</span></span>}<span class='comma'>,</span> {<span class='label'>member_count:</span> <span class='int'>2</span>}])

<span class='comment'># Condition hash in where and a scope
</span><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>SUN Project</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_and'>and</span>(<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>member_count:</span> <span class='int'>2</span>))

<span class='comment'># Condition hash in and and a scope
</span><span class='const'>Band</span>.<span class='id identifier rubyid_and'>and</span>({<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>SUN Project</span><span class='tstring_end'>&#39;</span></span>}<span class='comma'>,</span> <span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>member_count:</span> <span class='int'>2</span>))

<span class='comment'># Scope as an array element, nested arrays - deprecated
</span><span class='const'>Band</span>.<span class='id identifier rubyid_and'>and</span>([<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>SUN Project</span><span class='tstring_end'>&#39;</span></span>)<span class='comma'>,</span> [{<span class='label'>member_count:</span> <span class='int'>2</span>}]])

<span class='comment'># All produce:
</span><span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;name&quot;=&gt;&quot;SUN Project&quot;, &quot;member_count&quot;=&gt;2}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<h3>Operator Combinations</h3>

<p>As of Mongoid 7.1, logical operators (<code>and</code>, <code>or</code>, <code>nor</code> and <code>not</code>)
have been changed to have the the same semantics as <a href="https://guides.rubyonrails.org/active_record_querying.html">those of ActiveRecord</a>.
To obtain the semantics of <code>or</code> as it behaved in Mongoid 7.0 and earlier,
use <code>any_of</code> which is described below.</p>

<p>When conditions are specified on the same field multiple times, all
conditions are added to the criteria:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='int'>1</span>).<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='int'>2</span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;name&quot;=&gt;&quot;1&quot;, &quot;$and&quot;=&gt;[{&quot;name&quot;=&gt;&quot;2&quot;}]}
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='int'>1</span>).<span class='id identifier rubyid_or'>or</span>(<span class='label'>name:</span> <span class='int'>2</span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;$or&quot;=&gt;[{&quot;name&quot;=&gt;&quot;1&quot;}, {&quot;name&quot;=&gt;&quot;2&quot;}]}</span></code></pre>

<p><code>any_of</code>, <code>none_of</code>, <code>nor</code> and <code>not</code> behave similarly, with <code>not</code> producing
different query shapes as described below.</p>

<p>When <code>and</code>, <code>or</code> and <code>nor</code> logical operators are used, they
operate on the criteria built up to that point and its argument.
<code>where</code> has the same meaning as <code>and</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># or joins the two conditions
</span><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Sun</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_or'>or</span>(<span class='label'>label:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Trust</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;$or&quot;=&gt;[{&quot;name&quot;=&gt;&quot;Sun&quot;}, {&quot;label&quot;=&gt;&quot;Trust&quot;}]}
</span>
<span class='comment'># or applies only to the first condition, the second condition is added
</span><span class='comment'># to the top level as $and
</span><span class='const'>Band</span>.<span class='id identifier rubyid_or'>or</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Sun</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_where'>where</span>(<span class='label'>label:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Trust</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;$or&quot;=&gt;[{&quot;name&quot;=&gt;&quot;Sun&quot;}], &quot;label&quot;=&gt;&quot;Trust&quot;}
</span>
<span class='comment'># Same as previous example - where and and are aliases
</span><span class='const'>Band</span>.<span class='id identifier rubyid_or'>or</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Sun</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_and'>and</span>(<span class='label'>label:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Trust</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;$or&quot;=&gt;[{&quot;name&quot;=&gt;&quot;Sun&quot;}], &quot;label&quot;=&gt;&quot;Trust&quot;}
</span>
<span class='comment'># Same operator can be stacked any number of times
</span><span class='const'>Band</span>.<span class='id identifier rubyid_or'>or</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Sun</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_or'>or</span>(<span class='label'>label:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Trust</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;$or&quot;=&gt;[{&quot;name&quot;=&gt;&quot;Sun&quot;}, {&quot;label&quot;=&gt;&quot;Trust&quot;}]}
</span>
<span class='comment'># The label: Foo condition is added to the top level as $and
</span><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Sun</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_or'>or</span>(<span class='label'>label:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Trust</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_where'>where</span>(<span class='label'>label:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Foo</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;$or&quot;=&gt;[{&quot;name&quot;=&gt;&quot;Sun&quot;}, {&quot;label&quot;=&gt;&quot;Trust&quot;}], &quot;label&quot;=&gt;&quot;Foo&quot;}</span></code></pre>

<h3><code>and</code> Behavior</h3>

<p>The <code>and</code> method will add new simple conditions to the top level of the
criteria, unless the receiving criteria already has a condition on the
respective fields, in which case the conditions will be combined with <code>$and</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>label:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Trust in Trance</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_and'>and</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;label&quot;=&gt;&quot;Trust in Trance Records&quot;, &quot;name&quot;=&gt;&quot;Astral Projection&quot;}
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Best</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_and'>and</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;name&quot;=&gt;/Best/, &quot;$and&quot;=&gt;[{&quot;name&quot;=&gt;&quot;Astral Projection&quot;}]}</span></code></pre>

<p>As of Mongoid 7.1, specifying multiple criteria on the same field with <code>and</code>
combines all criteria so specified, whereas in previous versions of Mongoid
conditions on a field sometimes replaced previously specified conditions on
the same field, depending on which form of <code>and</code> was used.</p>

<p><code>or</code>/<code>nor</code> Behavior
_----------------------</p>

<p><code>or</code> and <code>nor</code> produce <code>$or</code> and <code>$nor</code> MongoDB operators, respectively,
using the receiver and all of the arguments as operands. For example:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Best</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_or'>or</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; {&quot;$or&quot;=&gt;[{&quot;name&quot;=&gt;/Best/}, {&quot;name&quot;=&gt;&quot;Astral Projection&quot;}]}
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Best</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_and'>and</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>).
  <span class='id identifier rubyid_or'>or</span>(<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>label:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Records</span><span class='regexp_end'>/</span></span>)).<span class='id identifier rubyid_and'>and</span>(<span class='label'>label:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Trust</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;$or&quot;=&gt;[{&quot;name&quot;=&gt;/Best/, &quot;$and&quot;=&gt;[{&quot;name&quot;=&gt;&quot;Astral Projection&quot;}]}, {&quot;label&quot;=&gt;/Records/}], &quot;label&quot;=&gt;&quot;Trust&quot;}</span></code></pre>

<p>If the only condition on the receiver is another <code>or</code>/<code>nor</code>, the new
conditions are added to the existing list:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Best</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_or'>or</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>).
  <span class='id identifier rubyid_or'>or</span>(<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>label:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Records</span><span class='regexp_end'>/</span></span>)).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;$or&quot;=&gt;[{&quot;name&quot;=&gt;/Best/}, {&quot;name&quot;=&gt;&quot;Astral Projection&quot;}, {&quot;label&quot;=&gt;/Records/}]}</span></code></pre>

<p>Use <code>any_of</code> to add a disjunction to a Criteria object while maintaining
all of the conditions built up so far as they are.</p>

<h3><code>any_of</code> Behavior [any-of]</h3>

<p><code>any_of</code> adds a disjunction built from its arguments to the existing
conditions in the criteria. For example:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>label:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Trust</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_any_of'>any_of</span>({<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>}<span class='comma'>,</span> {<span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Best</span><span class='regexp_end'>/</span></span>})
<span class='comment'># =&gt; {&quot;label&quot;=&gt;/Trust/, &quot;$or&quot;=&gt;[{&quot;name&quot;=&gt;&quot;Astral Projection&quot;}, {&quot;name&quot;=&gt;/Best/}]}</span></code></pre>

<p>The conditions are hoisted to the top level if possible:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>label:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Trust</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_any_of'>any_of</span>({<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>})
<span class='comment'># =&gt; {&quot;label&quot;=&gt;/Trust/, &quot;name&quot;=&gt;&quot;Astral Projection&quot;}</span></code></pre>

<h3><code>none_of</code> Behavior [none-of]</h3>

<p><code>none_of</code> adds a negated disjunction (&quot;nor&quot;) built from its arguments to
the existing conditions in the criteria. For example:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>label:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Trust</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_none_of'>none_of</span>({<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>}<span class='comma'>,</span> {<span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Best</span><span class='regexp_end'>/</span></span>})
<span class='comment'># =&gt; {&quot;label&quot;=&gt;/Trust/, &quot;$nor&quot;=&gt;[{&quot;name&quot;=&gt;&quot;Astral Projection&quot;}, {&quot;name&quot;=&gt;/Best/}]}</span></code></pre>

<h3><code>not</code> Behavior</h3>

<p><code>not</code> method can be called without arguments, in which case it will negate
the next condition that is specified. <code>not</code> can also be called with one
or more hash conditions or <code>Criteria</code> objects, which will all be negated and
added to the criteria.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># not negates subsequent where
</span><span class='const'>Band</span>.<span class='id identifier rubyid_not'>not</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Best</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;name&quot;=&gt;{&quot;$ne&quot;=&gt;&quot;Best&quot;}}
</span>
<span class='comment'># The second where is added as $and
</span><span class='const'>Band</span>.<span class='id identifier rubyid_not'>not</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Best</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_where'>where</span>(<span class='label'>label:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Records</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;name&quot;=&gt;{&quot;$ne&quot;=&gt;&quot;Best&quot;}, &quot;label&quot;=&gt;/Records/}
</span>
<span class='comment'># not negates its argument
</span><span class='const'>Band</span>.<span class='id identifier rubyid_not'>not</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Best</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;name&quot;=&gt;{&quot;$ne&quot;=&gt;&quot;Best&quot;}}</span></code></pre>

<div class="note" markdown="1">

<div class="title" markdown="1">

Note

</div>

<p><code>$not</code> in MongoDB server cannot be used with a string argument.
Mongoid uses <code>$ne</code> operator to achieve such a negation:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># String negation - uses $ne
</span><span class='const'>Band</span>.<span class='id identifier rubyid_not'>not</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Best</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;name&quot;=&gt;{&quot;$ne&quot;=&gt;&quot;Best&quot;}}
</span>
<span class='comment'># Regexp negation - uses $not
</span><span class='const'>Band</span>.<span class='id identifier rubyid_not'>not</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Best</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;name&quot;=&gt;{&quot;$not&quot;=&gt;/Best/}}</span></code></pre>

<p></div></p>

<p>Similarly to <code>and</code>, <code>not</code> will negate individual conditions for simple
field criteria. For complex conditions and when a field already has a condition
defined on it, since MongoDB server only supports the <code>$not</code> operator on
a per-field basis rather than globally, Mongoid emulates <code>$not</code> by using
an <code>{&#39;$and&#39; =&gt; [{&#39;$nor&#39; =&gt; ...}]}</code> construct:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Simple condition
</span><span class='const'>Band</span>.<span class='id identifier rubyid_not'>not</span>(<span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Best</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;name&quot;=&gt;{&quot;$not&quot;=&gt;/Best/}}
</span>
<span class='comment'># Complex conditions
</span><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Best</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_not'>not</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;name&quot;=&gt;/Best/, &quot;$and&quot;=&gt;[{&quot;$nor&quot;=&gt;[{&quot;name&quot;=&gt;&quot;Astral Projection&quot;}]}]}
</span>
<span class='comment'># Symbol operator syntax
</span><span class='const'>Band</span>.<span class='id identifier rubyid_not'>not</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span>.<span class='id identifier rubyid_ne'>ne</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;$and&quot;=&gt;[{&quot;$nor&quot;=&gt;[{&quot;name&quot;=&gt;{&quot;$ne&quot;=&gt;&quot;Astral Projection&quot;}}]}]}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<p>If using <code>not</code> with arrays or regular expressions, please note the
caveats/limitations of <code>$not</code> <a href="https://mongodb.com/docs/manual/reference/operator/query/not/">stated in the MongoDB server documentation</a>.</p>

<h2>Incremental Query Construction</h2>

<p>By default, when conditions are added to a query, Mongoid considers each
condition complete and independent from any other conditions potentially
present in the query. For example, calling <code>in</code> twice adds two separate
<code>$in</code> conditions:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_in'>in</span>(<span class='label'>name:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span>]).<span class='id identifier rubyid_in'>in</span>(<span class='label'>name:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>b</span><span class='tstring_end'>&#39;</span></span>])
<span class='op'>=&gt;</span> <span class='comment'>#&lt;Mongoid::Criteria
</span>  <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a</span><span class='tstring_end'>&quot;</span></span>]}<span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$and</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>b</span><span class='tstring_end'>&quot;</span></span>]}}]}
  <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {}
  <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
  <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span></code></pre>

<p>Some operator methods support building the condition incrementally. In this
case, when an condition on a field which uses one of the supported operators
is being added, if there already is a condition on the same field using the
same operator, the operator expressions are combined according to the
specified <em>merge strategy</em>.</p>

<h3>Merge Strategies</h3>

<p>Mongoid provides three merge strategies:</p>

<ul>
<li>  <strong>Override</strong>: the new operator instance replaces any existing conditions on
the same field using the same operator.</li>
<li>  <strong>Intersect</strong>: if there already is a condition using the same operator on the
same field, the values of the existing condition are intersected with the
values of the new condition and the result is stored as the operator value.</li>
<li>  <strong>Union</strong>: if there already is a condition using the same operator on the
same field, the values of the new condition are added to the values of the
existing condition and the result is stored as the operator value.</li>
</ul>

<p>The following snippet demonstrates all of the strategies, using <code>in</code> as the
example operator:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_in'>in</span>(<span class='label'>name:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span>]).<span class='id identifier rubyid_override'>override</span>.<span class='id identifier rubyid_in'>in</span>(<span class='label'>name:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>b</span><span class='tstring_end'>&#39;</span></span>])
<span class='op'>=&gt;</span> <span class='comment'>#&lt;Mongoid::Criteria
</span>  <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>b</span><span class='tstring_end'>&quot;</span></span>]}}
  <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {}
  <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
  <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_in'>in</span>(<span class='label'>name:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>b</span><span class='tstring_end'>&#39;</span></span>]).<span class='id identifier rubyid_intersect'>intersect</span>.<span class='id identifier rubyid_in'>in</span>(<span class='label'>name:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>b</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>c</span><span class='tstring_end'>&#39;</span></span>])
<span class='op'>=&gt;</span> <span class='comment'>#&lt;Mongoid::Criteria
</span>  <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>b</span><span class='tstring_end'>&quot;</span></span>]}}
  <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {}
  <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
  <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_in'>in</span>(<span class='label'>name:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span>]).<span class='id identifier rubyid_union'>union</span>.<span class='id identifier rubyid_in'>in</span>(<span class='label'>name:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>b</span><span class='tstring_end'>&#39;</span></span>])
<span class='op'>=&gt;</span> <span class='comment'>#&lt;Mongoid::Criteria
</span>  <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>b</span><span class='tstring_end'>&quot;</span></span>]}}
  <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {}
  <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
  <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span></code></pre>

<p>The strategy is requested by calling <code>override</code>, <code>intersect</code> or <code>union</code>
on a <code>Criteria</code> instance. The requested strategy applies to the next
condition method called on the query. If the next condition method called does
not support merge strategies, the strategy is reset, as shown in the following
example:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_in'>in</span>(<span class='label'>name:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span>]).<span class='id identifier rubyid_union'>union</span>.<span class='id identifier rubyid_ne'>ne</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>c</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_in'>in</span>(<span class='label'>name:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>b</span><span class='tstring_end'>&#39;</span></span>])
<span class='op'>=&gt;</span> <span class='comment'>#&lt;Mongoid::Criteria
</span>  <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a</span><span class='tstring_end'>&quot;</span></span>]<span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$ne</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>c</span><span class='tstring_end'>&quot;</span></span>}<span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$and</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>b</span><span class='tstring_end'>&quot;</span></span>]}}]}
  <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {}
  <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
  <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span></code></pre>

<p>Since <code>ne</code> does not support merge strategies, the <code>union</code> strategy was
ignored and reset and when <code>in</code> was invoked the second time there was no
strategy active.</p>

<div class="warning" markdown="1">

<div class="title" markdown="1">

Warning

</div>

<p>Merge strategies currently assume the previous condition(s) have been added
to the top level of the query, however this is not always the case
(conditions may be nested under an <code>$and</code> clause). Using merge strategies
with complex criteria may cause incorrect queries to be constructed.
This misbehavior is <a href="https://jira.mongodb.org/browse/MONGOID-5350">intended to be fixed in the future</a>.</p>

<p></div></p>

<h3>Supported Operator Methods</h3>

<p>The following operator methods support merge strategies:</p>

<ul>
<li>  <code>all</code></li>
<li>  <code>in</code></li>
<li>  <code>nin</code></li>
</ul>

<p>The set of methods may be expanded in future releases of Mongoid. For
future compatibility, only invoke a strategy method when the next method call
is an operator that supports merge strategies.</p>

<p>Note that the merge strategies are currently only applied when conditions are
added through the designated methods. In the following example merge strategy
is not applied because the second condition is added via <code>where</code>, not via
<code>in</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_in'>in</span>(<span class='label'>foo:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span>]).<span class='id identifier rubyid_union'>union</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>foo:</span> {<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>b</span><span class='tstring_end'>&#39;</span></span>})
<span class='op'>=&gt;</span> <span class='comment'>#&lt;Mongoid::Criteria
</span>  <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a</span><span class='tstring_end'>&quot;</span></span>]}<span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$and</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>b</span><span class='tstring_end'>&quot;</span></span>}}]}
  <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {}
  <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
  <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span></code></pre>

<p>This behavior may change in a future release of Mongoid and should not be
relied upon.</p>

<p>In contrast, it does not matter how the existing query was built when a
merge strategy-supporting operator method is invoked. In the following
example, the first condition was added through <code>where</code> but the strategy
mechanism still applies:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>foo:</span> {<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span>]}).<span class='id identifier rubyid_union'>union</span>.<span class='id identifier rubyid_in'>in</span>(<span class='label'>foo:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>b</span><span class='tstring_end'>&#39;</span></span>])
<span class='op'>=&gt;</span> <span class='comment'>#&lt;Mongoid::Criteria
</span>  <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>b</span><span class='tstring_end'>&quot;</span></span>]}}
  <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {}
  <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
  <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span></code></pre>

<h3>Operator Value Expansion</h3>

<p>Operator methods that support merge strategies all take <a href="Array.html" title="Array (class)"><code>Array</code></a> as their value
type. Mongoid expands <a href="Array.html" title="Array (class)"><code>Array</code></a>-compatible types, such as a <code>Range</code>,
when they are used with these operator methods:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_in'>in</span>(<span class='label'>year:</span> <span class='int'>1950</span><span class='op'>..</span><span class='int'>1960</span>)
<span class='op'>=&gt;</span> <span class='comment'>#&lt;Mongoid::Criteria
</span>  <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>year</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[<span class='int'>1950</span><span class='comma'>,</span> <span class='int'>1951</span><span class='comma'>,</span> <span class='int'>1952</span><span class='comma'>,</span> <span class='int'>1953</span><span class='comma'>,</span> <span class='int'>1954</span><span class='comma'>,</span> <span class='int'>1955</span><span class='comma'>,</span> <span class='int'>1956</span><span class='comma'>,</span> <span class='int'>1957</span><span class='comma'>,</span> <span class='int'>1958</span><span class='comma'>,</span> <span class='int'>1959</span><span class='comma'>,</span> <span class='int'>1960</span>]}}
  <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {}
  <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
  <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span></code></pre>

<p>Additionally, Mongoid has historically wrapped non-<a href="Array.html" title="Array (class)"><code>Array</code></a> values in arrays,
as the following example demonstrates:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_in'>in</span>(<span class='label'>year:</span> <span class='int'>1950</span>)
<span class='op'>=&gt;</span> <span class='comment'>#&lt;Mongoid::Criteria
</span>  <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>year</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$in</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span>[<span class='int'>1950</span>]}}
  <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {}
  <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
  <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span></code></pre>

<h2>Query Methods</h2>

<h3>elem_match</h3>

<p>This matcher finds documents with array fields where one of the array values
matches all of the conditions. For example:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_tours'>tours</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Array.html" title="Array (class)">Array</a></span>
<span class='kw'>end</span>

<span class='id identifier rubyid_aerosmith'>aerosmith</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Aerosmith</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>tours:</span> [
  {<span class='label'>city:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>London</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>year:</span> <span class='int'>1995</span>}<span class='comma'>,</span>
  {<span class='label'>city:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>New York</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>year:</span> <span class='int'>1999</span>}<span class='comma'>,</span>
])

<span class='const'>Band</span>.<span class='id identifier rubyid_elem_match'>elem_match</span>(<span class='label'>tours:</span> {<span class='label'>city:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>London</span><span class='tstring_end'>&#39;</span></span>}).<span class='id identifier rubyid_to_a'>to_a</span> <span class='comment'># =&gt; [aerosmith]</span></code></pre>

<p><code>elem_match</code> also works with embedded associations:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_embeds_many'>embeds_many</span> <span class='symbeg'>:</span><span class='id identifier rubyid_tours'>tours</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>Tour</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_city'>city</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_year'>year</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Integer.html" title="Integer (class)">Integer</a></span>
  <span class='id identifier rubyid_embedded_in'>embedded_in</span> <span class='symbeg'>:</span><span class='id identifier rubyid_band'>band</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_dm'>dm</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Depeche Mode</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_aerosmith'>aerosmith</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Aerosmith</span><span class='tstring_end'>&#39;</span></span>)
<span class='const'>Tour</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>band:</span> <span class='id identifier rubyid_aerosmith'>aerosmith</span><span class='comma'>,</span> <span class='label'>city:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>London</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>year:</span> <span class='int'>1995</span>)
<span class='const'>Tour</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>band:</span> <span class='id identifier rubyid_aerosmith'>aerosmith</span><span class='comma'>,</span> <span class='label'>city:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>New York</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>year:</span> <span class='int'>1999</span>)

<span class='const'>Band</span>.<span class='id identifier rubyid_elem_match'>elem_match</span>(<span class='label'>tours:</span> {<span class='label'>city:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>London</span><span class='tstring_end'>&#39;</span></span>}).<span class='id identifier rubyid_to_a'>to_a</span> <span class='comment'># =&gt; [aerosmith]</span></code></pre>

<p><code>elem_match</code> does not work with non-embedded associations because MongoDB
does not have joins - the conditions would be added to the collection
that is the source of a non-embedded association rather than the collection
of the association&#39;s target.</p>

<p><code>elem_match</code> can also be used with recursively embedded associations,
as the following example shows:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Tag</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_recursively_embeds_many'>recursively_embeds_many</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_root'>root</span> <span class='op'>=</span> <span class='const'>Tag</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>root</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_sub1'>sub1</span> <span class='op'>=</span> <span class='const'>Tag</span>.<span class='id identifier rubyid_new'>new</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>sub1</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>child_tags:</span> [<span class='const'>Tag</span>.<span class='id identifier rubyid_new'>new</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>subsub1</span><span class='tstring_end'>&#39;</span></span>)])
<span class='id identifier rubyid_root'>root</span>.<span class='id identifier rubyid_child_tags'>child_tags</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_sub1'>sub1</span>
<span class='id identifier rubyid_root'>root</span>.<span class='id identifier rubyid_child_tags'>child_tags</span> <span class='op'>&lt;&lt;</span> <span class='const'>Tag</span>.<span class='id identifier rubyid_new'>new</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>sub2</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_root'>root</span>.<span class='id identifier rubyid_save!'>save!</span>

<span class='const'>Tag</span>.<span class='id identifier rubyid_elem_match'>elem_match</span>(<span class='label'>child_tags:</span> {<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>sub1</span><span class='tstring_end'>&#39;</span></span>}).<span class='id identifier rubyid_to_a'>to_a</span> <span class='comment'># =&gt; [root]
</span>
<span class='id identifier rubyid_root'>root</span>.<span class='id identifier rubyid_child_tags'>child_tags</span>.<span class='id identifier rubyid_elem_match'>elem_match</span>(<span class='label'>child_tags:</span> {<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>subsub1</span><span class='tstring_end'>&#39;</span></span>}).<span class='id identifier rubyid_to_a'>to_a</span> <span class='comment'># =&gt; [sub1]</span></code></pre>

<h2>Projection</h2>

<p>Mongoid provides two projection operators: <code>only</code> and <code>without</code>.</p>

<h3><code>only</code></h3>

<p>The <code>only</code> method retrieves only the specified fields from the database. This
operation is sometimes called &quot;projection&quot;.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_label'>label</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>

  <span class='id identifier rubyid_embeds_many'>embeds_many</span> <span class='symbeg'>:</span><span class='id identifier rubyid_tours'>tours</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>Tour</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_city'>city</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_year'>year</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Integer.html" title="Integer (class)">Integer</a></span>

  <span class='id identifier rubyid_embedded_in'>embedded_in</span> <span class='symbeg'>:</span><span class='id identifier rubyid_band'>band</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_only'>only</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span>).<span class='id identifier rubyid_first'>first</span></code></pre>

<p>Attempting to reference attributes which have not been loaded results in
<a href="Mongoid/Errors/AttributeNotLoaded.html" title="Mongoid::Errors::AttributeNotLoaded (class)"><code>::Mongoid::Errors::AttributeNotLoaded</code></a>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_label'>label</span>
<span class='comment'>#=&gt; raises Mongoid::Errors::AttributeNotLoaded</span></code></pre>

<p>Even though Mongoid currently allows writing to attributes that have not
been loaded, such writes will not be persisted
(<a href="https://jira.mongodb.org/browse/MONGOID-4701">MONGOID-4701</a>) and
should therefore be avoided.</p>

<p><code>only</code> can also be used with embedded associations:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_only'>only</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>tours.year</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_last'>last</span>
<span class='comment'># =&gt; #&lt;Band _id: 5c59afb1026d7c034dba46ac, name: &quot;Aerosmith&quot;&gt;
</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_tours'>tours</span>.<span class='id identifier rubyid_first'>first</span>
<span class='comment'># =&gt; #&lt;Tour _id: 5c59afdf026d7c034dba46af, city: nil, year: 1995&gt;</span></code></pre>

<div class="note" markdown="1">

<div class="title" markdown="1">

Note

</div>

<p>Server versions 4.2 and lower allowed projecting both an association and
the association&#39;s fields in the same query, as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_only'>only</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_tours'>tours</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>tours.year</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_last'>last</span></code></pre>

<p>The most recent projection specification overrides the earlier one.
For example, the above query was equivalent to:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_only'>only</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>tours.year</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_last'>last</span></code></pre>

<p>Server versions 4.4 and higher prohibit specifying an association and its
fields in projection in the same query.</p>

<p></div></p>

<p><code>only</code> can be specified with referenced associations (has_one, has_many,
has_and_belongs_to_many) but is currently ignored for referenced associations -all fields of referenced associations will be loaded
(<a href="https://jira.mongodb.org/browse/MONGOID-4704">MONGOID-4704</a>).</p>

<p>Note that if a document has <code>has_one</code> or <code>has_and_belongs_to_many</code> associations,
the fields with foreign keys must be included in the list of attributes
loaded with <code>only</code> for those associations to be loaded. For example:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>

  <span class='id identifier rubyid_has_and_belongs_to_many'>has_and_belongs_to_many</span> <span class='symbeg'>:</span><span class='id identifier rubyid_managers'>managers</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>Manager</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_has_and_belongs_to_many'>has_and_belongs_to_many</span> <span class='symbeg'>:</span><span class='id identifier rubyid_bands'>bands</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_managers'>managers</span> <span class='op'>&lt;&lt;</span> <span class='const'>Manager</span>.<span class='id identifier rubyid_new'>new</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_only'>only</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span>).<span class='id identifier rubyid_first'>first</span>.<span class='id identifier rubyid_managers'>managers</span>
<span class='comment'># =&gt; []
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Astral Projection</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_only'>only</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_manager_ids'>manager_ids</span>).<span class='id identifier rubyid_first'>first</span>.<span class='id identifier rubyid_managers'>managers</span>
<span class='comment'># =&gt; [#&lt;Manager _id: 5c5dc2f0026d7c1730969843, band_ids: [BSON::ObjectId(&#39;5c5dc2f0026d7c1730969842&#39;)]&gt;]</span></code></pre>

<h3><code>without</code></h3>

<p>The opposite of <code>only</code>, <code>without</code> causes the specified fields to be omitted:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_without'>without</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {}
</span><span class='comment'>#   options:  {:fields=&gt;{&quot;name&quot;=&gt;0}}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<p>Because Mongoid requires the <code>_id</code> field for various operations, it (as well
as its <code>id</code> alias) cannot be omitted via <code>without</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_without'>without</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_id'>id</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {}
</span><span class='comment'>#   options:  {:fields=&gt;{&quot;name&quot;=&gt;0}}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_without'>without</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid__id'>_id</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {}
</span><span class='comment'>#   options:  {:fields=&gt;{&quot;name&quot;=&gt;0}}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<h2>Ordering</h2>

<p>Mongoid provides the <code>order</code> method on <code>Criteria</code> objects and its alias,
<code>order_by</code>, to specify the ordering of documents. These methods take a
hash indicating which fields to order the documents by, and whether to use
ascending or descending order for each field.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_order'>order</span>(<span class='label'>name:</span> <span class='int'>1</span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {}
</span><span class='comment'>#   options:  {:sort=&gt;{&quot;name&quot;=&gt;1}}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_order_by'>order_by</span>(<span class='label'>name:</span> <span class='op'>-</span><span class='int'>1</span><span class='comma'>,</span> <span class='label'>description:</span> <span class='int'>1</span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {}
</span><span class='comment'>#   options:  {:sort=&gt;{&quot;name&quot;=&gt;-1, &quot;description&quot;=&gt;1}}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_order_by'>order_by</span>(<span class='label'>name:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_desc'>desc</span><span class='comma'>,</span> <span class='label'>description:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>asc</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {}
</span><span class='comment'>#   options:  {:sort=&gt;{&quot;name&quot;=&gt;-1, &quot;description&quot;=&gt;1}}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<p>The direction may be specified as integers <code>1</code> and <code>-1</code> for ascending
and descending, respectively, or as symbols <code>:asc</code> and <code>:desc</code>, or as
strings <code>&quot;asc&quot;</code> and <code>&quot;desc&quot;</code>.</p>

<p>Alternatively, <code>order</code> accepts an array of two-element arrays specifying
the ordering. Field names and directions may be strings or symbols.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_order'>order</span>([[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>name</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>desc</span><span class='tstring_end'>&#39;</span></span>]<span class='comma'>,</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>description</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>asc</span><span class='tstring_end'>&#39;</span></span>]])

<span class='const'>Band</span>.<span class='id identifier rubyid_order'>order</span>([[<span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_desc'>desc</span>]<span class='comma'>,</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_description'>description</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_asc'>asc</span>]])</code></pre>

<p>Another way of providing the order is to use <code>#asc</code> and <code>#desc</code> methods
on symbols, as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_order'>order</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span>.<span class='id identifier rubyid_desc'>desc</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_description'>description</span>.<span class='id identifier rubyid_asc'>asc</span>)</code></pre>

<p>The arguments can be provided as a string using SQL syntax:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_order'>order</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>name desc, description asc</span><span class='tstring_end'>&#39;</span></span>)</code></pre>

<p>Finally, there are <code>asc</code> and <code>desc</code> methods that can be used instead of
<code>order</code>/<code>order_by</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_asc'>asc</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>name</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_desc'>desc</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>description</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span>  <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {}
  <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {<span class='symbeg'>:</span><span class='id identifier rubyid_sort'>sort</span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span><span class='int'>1</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>description</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span><span class='op'>-</span><span class='int'>1</span>}}
  <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
  <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span></code></pre>

<p><code>order</code> calls can be chained, in which case the oldest calls define the
most significant criteria and the newest calls define the least significant
ones (since in Ruby hashes maintain the order of their keys):</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_order'>order</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>name desc</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_order'>order</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>description asc</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span>  <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {}
  <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {<span class='symbeg'>:</span><span class='id identifier rubyid_sort'>sort</span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span><span class='op'>-</span><span class='int'>1</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>description</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span><span class='int'>1</span>}}
  <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
  <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span></code></pre>

<p>This can sometimes lead to surprising results if there are scopes, including
the default scope, that use <code>order</code>/<code>order_by</code>. For example, in the
following snippet bands are ordered by name first because the order in the
default scope takes precedence over the order given in the query, due to
the default scope being evaluated first:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_year'>year</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Integer.html" title="Integer (class)">Integer</a></span>

  <span class='id identifier rubyid_default_scope'>default_scope</span> <span class='tlambda'>-&gt;</span> <span class='tlambeg'>{</span> <span class='id identifier rubyid_order'>order</span>(<span class='label'>name:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_asc'>asc</span>) }
<span class='kw'>end</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_order'>order</span>(<span class='label'>year:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_desc'>desc</span>)
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span>  <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {}
  <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {<span class='symbeg'>:</span><span class='id identifier rubyid_sort'>sort</span><span class='op'>=&gt;</span>{<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span><span class='int'>1</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>year</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span><span class='op'>-</span><span class='int'>1</span>}}
  <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
  <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span></code></pre>

<h2>Pagination</h2>

<p>Mongoid provides the pagination operators <code>limit</code>, <code>skip</code>, and <code>batch_size</code> on <code>Criteria</code>.</p>

<h3><code>limit</code></h3>

<p><code>limit</code> sets the total number of documents to be returned by a query:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_limit'>limit</span>(<span class='int'>5</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {}
</span><span class='comment'>#   options:  {:limit=&gt;5}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<h3><code>skip</code></h3>

<p><code>skip</code> (alias: <code>offset</code>) sets the number of query results to skip
before returning documents. The <code>limit</code> value, if specified, will be applied
after documents are skipped. When performing pagination, <code>skip</code> is recommended
to be combined with <code>ordering &lt;ordering&gt;</code> to ensure consistent results.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_skip'>skip</span>(<span class='int'>10</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {}
</span><span class='comment'>#   options:  {:skip=&gt;10}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<h3><code>batch_size</code> [batch-size]</h3>

<p>When executing large queries, or when iterating over query results with an enumerator method such as
<code>Criteria#each</code>, Mongoid automatically uses the <a href="https://mongodb.com/docs/manual/reference/command/getMore/">MongoDB getMore command</a> to load results in batches.
The default <code>batch_size</code> is 1000, however you may set it explicitly:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_batch_size'>batch_size</span>(<span class='int'>500</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {}
</span><span class='comment'>#   options:  {:batch_size=&gt;500}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<h2>Finding By <code>_id</code></h2>

<p>Mongoid provides the <code>find</code> method on <code>Criteria</code> objects to find documents
by their <code>_id</code> values:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_find'>find</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>5f0e41d92c97a64a26aabd10</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; #&lt;Band _id: 5f0e41d92c97a64a26aabd10, name: &quot;Juno Reactor&quot;&gt;</span></code></pre>

<p>The <code>find</code> method performs type conversion, if necessary, of the argument
to the type declared in the model being queried for the <code>_id</code> field.
By default, the <code>_id</code> type is <a href="BSON/ObjectId.html" title="BSON::ObjectId (class)"><code>::BSON::ObjectId</code></a>, thus the query above
is equivalent to:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_find'>find</span>(<span class='const'><a href="BSON.html" title="BSON (module)">BSON</a></span><span class='op'>::</span><span class='const'><a href="BSON/ObjectId.html" title="BSON::ObjectId (class)">ObjectId</a></span>.<span class='id identifier rubyid_from_string'>from_string</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>5f0e41d92c97a64a26aabd10</span><span class='tstring_end'>&#39;</span></span>))
<span class='comment'># =&gt; #&lt;Band _id: 5f0e41d92c97a64a26aabd10, name: &quot;Juno Reactor&quot;&gt;</span></code></pre>

<div class="note" markdown="1">

<div class="title" markdown="1">

Note

</div>

<p>When querying collections directly using the driver, type conversion is not
automatically performed:</p>

<p></div></p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_collection'>collection</span>.<span class='id identifier rubyid_find'>find</span>(<span class='label'>_id:</span> <span class='const'><a href="BSON.html" title="BSON (module)">BSON</a></span><span class='op'>::</span><span class='const'><a href="BSON/ObjectId.html" title="BSON::ObjectId (class)">ObjectId</a></span>.<span class='id identifier rubyid_from_string'>from_string</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>5f0e41d92c97a64a26aabd10</span><span class='tstring_end'>&#39;</span></span>)).<span class='id identifier rubyid_first'>first</span>
<span class='comment'># =&gt; {&quot;_id&quot;=&gt;BSON::ObjectId(&#39;5f0e41d92c97a64a26aabd10&#39;), &quot;name&quot;=&gt;&quot;Juno Reactor&quot;}
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_collection'>collection</span>.<span class='id identifier rubyid_find'>find</span>(<span class='label'>_id:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>5f0e41d92c97a64a26aabd10</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_first'>first</span>
<span class='comment'># =&gt; nil</span></code></pre>

<p>The <code>find</code> method can accept multiple arguments, or an array of arguments.
In either case each of the arguments or array elements is taken to be an <code>_id</code>
value, and documents with all of the specified <code>_id</code> values are returned in
an array:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_find'>find</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>5f0e41d92c97a64a26aabd10</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>5f0e41b02c97a64a26aabd0e</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; [#&lt;Band _id: 5f0e41b02c97a64a26aabd0e, name: &quot;SUN Project&quot;, description: nil, likes: nil&gt;,
</span>  <span class='comment'>#&lt;Band _id: 5f0e41d92c97a64a26aabd10, name: &quot;Juno Reactor&quot;, description: nil, likes: nil&gt;]
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_find'>find</span>([<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>5f0e41d92c97a64a26aabd10</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>5f0e41b02c97a64a26aabd0e</span><span class='tstring_end'>&#39;</span></span>])
<span class='comment'># =&gt; [#&lt;Band _id: 5f0e41b02c97a64a26aabd0e, name: &quot;SUN Project&quot;, description: nil, likes: nil&gt;,
</span>  <span class='comment'>#&lt;Band _id: 5f0e41d92c97a64a26aabd10, name: &quot;Juno Reactor&quot;, description: nil, likes: nil&gt;]</span></code></pre>

<p>If the same <code>_id</code> value is given more than once, the corresponding document
is only returned once:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_find'>find</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>5f0e41b02c97a64a26aabd0e</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>5f0e41b02c97a64a26aabd0e</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; [#&lt;Band _id: 5f0e41b02c97a64a26aabd0e, name: &quot;SUN Project&quot;, description: nil, likes: nil&gt;]</span></code></pre>

<p>The documents returned are <em>not</em> ordered, and may be returned in a different
order from the order of provided <code>_id</code> values, as illustrated in the above
examples.</p>

<p>If any of the <code>_id</code> values are not found in the database, the behavior of
<code>find</code> depends on the value of the <code>raise_not_found_error</code> configuration
option. If the option is set to <code>true</code>, <code>find</code> raises
<a href="Mongoid/Errors/DocumentNotFound.html" title="Mongoid::Errors::DocumentNotFound (class)"><code>::Mongoid::Errors::DocumentNotFound</code></a> if any of the <code>_id</code>s are not found.
If the option is set to <code>false</code> and <code>find</code> is given a single <code>_id</code> to
find and there is no matching document, <code>find</code> returns <code>nil</code>. If the
option is set to <code>false</code> and <code>find</code> is given an array of ids to find
and some are not found, the return value is an array of documents that were
found (which could be empty if no documents were found at all).</p>

<h2>Additional Query Methods</h2>

<p>Mongoid also has some helpful methods on criteria.</p>

<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>Criteria#count</code></p>
<p><em>Get the total number of documents matching a filter, or the total
number of documents in a collection. Note this will always hit
the database for the count.</em></p>
<p><em>As of Mongoid 7.2, the</em> <code>count</code> <em>method uses the</em>
<code>count_documents</code> <em>driver helper to obtain the accurate count.
previously the</em> <code>count</code> <em>driver helper was used which used
collection metadata and was thus not necessarily accurate (but
may have returned the result faster). Use</em> <code>estimated_count</code>
<em>method to obtain an approximate number of documents in the collection
quickly.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.count
Band.where(name: "Photek").count</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#estimated_count</code></p>
<p><em>Get an approximate number of documents in the collection using the
collection metadata. The</em> <code>estimated_count</code> <em>method does not accept
query conditions; if any are given, it will raise</em>
<a href="Mongoid/Errors/InvalidEstimatedCountCriteria.html" title="Mongoid::Errors::InvalidEstimatedCountCriteria (class)"><code>::Mongoid::Errors::InvalidEstimatedCountCriteria</code></a>.
<em>If a model defines a default scope,</em> <code>estimated_count</code> <em>must be
called on the unscoped model</em>.</p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.count
Band.where(name: "Photek").count</p>
<dl>
<dt>class Contract</dt>
<dd><p>include Mongoid::Document</p>
<p>field :active, type: Boolean</p>
<p>default_scope -&gt; { where(active: true) }</p>
</dd>
</dl>
<p>end</p>
<p>Contract.estimated_count
# =&gt; raises Mongoid::Errors::InvalidEstimatedCountCriteria</p>
<p>Contract.unscoped.estimated_count
# =&gt; 0</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#distinct</code></p>
<p><em>Get a list of distinct values for a single field. Note this will always hit
the database for the distinct values.</em></p>
<p><em>This method accepts the dot notation, thus permitting referencing
fields in embedded associations.</em></p>
<p><em>This method respects :ref:`field aliases &lt;field-aliases&gt;`,
including those defined in embedded documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.distinct(:name)
Band.where(:fans.gt =&gt; 100000).
distinct(:name)</p>
<p>Band.distinct('cities.name')</p>
<p># Assuming an aliased field:
class Manager
include Mongoid::Document
embedded_in :band
field :name, as: :n
end</p>
<p># Expands out to "managers.name" in the query:
Band.distinct('managers.n')</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#each</code></p>
<p><em>Iterate over all matching documents in the criteria.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>Band.where(members: 1).each do</dt>
<dd><p>p band.name</p>
</dd>
</dl>
<p>end</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#exists?</code></p>
<p><em>Determine if any matching documents exist. Will return true if there
are 1 or more.</em></p>
<p><code>#exists?</code> <em>now takes a number of argument types:</em></p>
<ul>
<li><a href="Hash.html" title="Hash (class)"><code>Hash</code></a>: <em>A hash of conditions.</em></li>
<li><code>Object</code>: <em>An _id to search for.</em></li>
<li><code>false</code>/<code>nil</code>: <em>Always returns false.</em></li>
</ul></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.exists?
Band.where(name: "Photek").exists?
Band.exists?(name: "Photek")
Band.exists?(BSON::ObjectId('6320d96a3282a48cfce9e72c'))
Band.exists?('6320d96a3282a48cfce9e72c')
Band.exists?(false)
Band.exists?(nil)</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#fifth</code></p>
<p><em>Get the fifth document for the given criteria.</em></p>
<p><em>This method automatically adds a sort on _id if no sort is given.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.fifth</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#fifth!</code></p>
<p><em>Get the fifth document for the given criteria, or raise an error if
none exist.</em></p>
<p><em>This method automatically adds a sort on _id if no sort is given.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.fifth!</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#find_by</code></p>
<p><em>Find a document by the provided attributes. If not found,
raise an error or return nil depending on the value of the</em>
<code>raise_not_found_error</code> <em>configuration option.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.find_by(name: "Photek")</p>
<dl>
<dt>Band.find_by(name: "Tool") do</dt>
<dd><p>band.impressions += 1</p>
</dd>
</dl>
<p>end</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#find_or_create_by</code></p>
<p><em>Find a document by the provided attributes, and if not found
create and return a newly persisted one. Note that attributes provided in the arguments to
this method will override any set in <code>create_with</code></em>.</p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.find_or_create_by(name: "Photek")
Band.where(:likes.gt =&gt; 10).find_or_create_by(name: "Photek")</p>
<p><code>find_or_create_by</code> can be used on any scope, but in this case
the criteria given by the scope and by <code>find_or_create_by</code> are
combined. The following creates three bands:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ruby"><code class="sourceCode ruby"></code></pre></div>
<p>Band.find_or_create_by(name: "Photek")
Band.where(name: "Photek").find_or_create_by(name: "Aerosmith")
# creates Aerosmith again because there is no band whose name
# is Photek and Aerosmith at the same time
Band.where(name: "Photek").find_or_create_by(name: "Aerosmith")</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#find_or_initialize_by</code></p>
<p><em>Find a document by the provided attributes, and if not found
return a new one.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.find_or_initialize_by(name: "Photek")
Band.where(:likes.gt =&gt; 10).find_or_initialize_by(name: "Photek")</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#first|last</code></p>
<p><em>Finds a single document given the provided criteria. Get a list of
documents by passing in a limit argument. This method automatically adds
a sort on _id. This can cause performance issues, so if the sort is
undesirable, Criteria#take can be used instead.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.first
Band.where(:members.with_size =&gt; 3).first
Band.where(:members.with_size =&gt; 3).last
Band.first(2)</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#first!|last!</code></p>
<p><em>Finds a single document given the provided criteria, or raises an error
if none are found. This method automatically adds a sort on _id if no
sort is given. This can cause performance issues, so if the sort is
undesirable, Criteria#take! can be used instead.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.first!
Band.where(:members.with_size =&gt; 3).first!
Band.where(:members.with_size =&gt; 3).last!</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#first_or_create</code></p>
<p><em>Find the first document by the provided attributes, and if not found
create and return a newly persisted one.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Photek").first_or_create</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#first_or_create!</code></p>
<p><em>Find the first document by the provided attributes, and if not found
create and return a newly persisted one using</em> <code>create!</code>.</p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Photek").first_or_create!</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#first_or_initialize</code></p>
<p><em>Find the first document by the provided attributes, and if not found
return a new one.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Photek").first_or_initialize</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#for_js</code></p>
<p><em>Find documents for a provided JavaScript expression, optionally with
the specified variables added to the evaluation scope. The scope
argument is supported in MongoDB 4.2 and lower.</em>
<em>Prefer</em> <code class="interpreted-text" role="manual">$expr &lt;/reference/operator/query/expr/&gt;</code> <em>over</em> <code>for_js</code>.</p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p># All MongoDB versions
Band.for_js("this.name = 'Tool'")</p>
<p># MongoDB 4.2 and lower
Band.for_js("this.name = param", param: "Tool")</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#fourth</code></p>
<p><em>Get the fourth document for the given criteria.</em></p>
<p><em>This method automatically adds a sort on _id if no sort is given.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.fourth</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#fourth!</code></p>
<p><em>Get the fourth document for the given criteria, or raise an error if
none exist.</em></p>
<p><em>This method automatically adds a sort on _id if no sort is given.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.fourth!</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#length|size</code></p>
<p><em>Same as count but caches subsequent calls to the database</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.length
Band.where(name: "FKA Twigs").size</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#pick</code></p>
<p><em>Get the values from one document for the provided fields.
Returns nil for unset fields and for non-existent fields.</em></p>
<p><em>This method does not apply a sort to the documents, so it
will not necessarily return the values from the first document.</em></p>
<p><em>This method accepts the dot notation, thus permitting referencing
fields in embedded associations.</em></p>
<p><em>This method respects :ref:`field aliases &lt;field-aliases&gt;`,
including those defined in embedded documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.all.pick(:name)</p>
<p>Band.all.pick('cities.name')</p>
<p># Using the earlier definition of Manager,
# expands out to "managers.name" in the query:
Band.all.pick('managers.n')</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#pluck</code></p>
<p><em>Get all the values for the provided field.
Returns nil for unset fields and for non-existent fields.</em></p>
<p><em>This method accepts the dot notation, thus permitting referencing
fields in embedded associations.</em></p>
<p><em>This method respects :ref:`field aliases &lt;field-aliases&gt;`,
including those defined in embedded documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>Band.all.pluck(:name)</dt>
<dd><p>#=&gt; ["Daft Punk", "Aphex Twin", "Ween"]</p>
</dd>
<dt>Band.all.pluck('address.city')</dt>
<dd><p>#=&gt; ["Paris", "Limerick", "New Hope"]</p>
</dd>
</dl>
<p># Using the earlier definition of Manager,
# expands out to "managers.name" in the query:
Band.all.pluck('managers.n')
#=&gt; [ ["Berry Gordy", "Tommy Mottola"], [], ["Quincy Jones"] ]</p>
<p># Accepts multiple field arguments, in which case
# the result will be returned as an Array of Arrays.
Band.all.pluck(:name, :likes)
#=&gt; [ ["Daft Punk", 342], ["Aphex Twin", 98], ["Ween", 227] ]</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#read</code></p>
<p><em>Sets the read preference for the criteria.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.all.read(mode: :primary)</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#second</code></p>
<p><em>Get the second document for the given criteria.</em></p>
<p><em>This method automatically adds a sort on _id if no sort is given.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.second</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#second!</code></p>
<p><em>Get the second document for the given criteria, or raise an error if
none exist.</em></p>
<p><em>This method automatically adds a sort on _id if no sort is given.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.second!</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#second_to_last</code></p>
<p><em>Get the second to last document for the given criteria.</em></p>
<p><em>This method automatically adds a sort on _id if no sort is given.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.second_to_last</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#second_to_last!</code></p>
<p><em>Get the second to last document for the given criteria, or raise an
error if none exist.</em></p>
<p><em>This method automatically adds a sort on _id if no sort is given.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.second_to_last!</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#take</code></p>
<p><em>Get a list of n documents from the database or just one if no parameter
is provided.</em></p>
<p><em>This method does not apply a sort to the documents, so it can return
different document(s) than #first and #last.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.take
Band.take(5)</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#take!</code></p>
<p><em>Get a document from the database or raise an error if none exist.</em></p>
<p><em>This method does not apply a sort to the documents, so it can return
different document(s) than #first and #last.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.take!</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#tally</code></p>
<p><em>Get a mapping of values to counts for the provided field.</em></p>
<p><em>This method accepts the dot notation, thus permitting referencing
fields in embedded associations.</em></p>
<p><em>This method respects :ref:`field aliases &lt;field-aliases&gt;`,
including those defined in embedded documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.all.tally(:name)</p>
<p>Band.all.tally('cities.name')</p>
<p># Using the earlier definition of Manager,
# expands out to "managers.name" in the query:
Band.all.tally('managers.n')</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#third</code></p>
<p><em>Get the third document for the given criteria.</em></p>
<p><em>This method automatically adds a sort on _id if no sort is given.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.third</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#third!</code></p>
<p><em>Get the third document for the given criteria, or raise an error if
none exist.</em></p>
<p><em>This method automatically adds a sort on _id if no sort is given.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.third!</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#third_to_last</code></p>
<p><em>Get the third to last document for the given criteria.</em></p>
<p><em>This method automatically adds a sort on _id if no sort is given.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.third_to_last</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#third_to_last!</code></p>
<p><em>Get the third to last document for the given criteria, or raise an
error if none exist.</em></p>
<p><em>This method automatically adds a sort on _id if no sort is given.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.third_to_last!</p>
</blockquote></td>
</tr>
</tbody>
</table>

<h2>Eager Loading</h2>

<p>Mongoid provides a facility to eager load documents
from associations to prevent the n+1 issue when
iterating over documents with association access. Eager loading is supported on
all associations with the exception of polymorphic <code>belongs_to</code>
associations.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbeg'>:</span><span class='id identifier rubyid_albums'>albums</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>Album</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_belongs_to'>belongs_to</span> <span class='symbeg'>:</span><span class='id identifier rubyid_band'>band</span>
<span class='kw'>end</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_includes'>includes</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_albums'>albums</span>).<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_band'>band</span><span class='op'>|</span>
  <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_albums'>albums</span>.<span class='id identifier rubyid_first'>first</span>.<span class='id identifier rubyid_name'>name</span> <span class='comment'># Does not hit the database again.
</span><span class='kw'>end</span></code></pre>

<h2>Regular Expressions</h2>

<p>MongoDB, and Mongoid, allow querying documents by regular expressions.</p>

<p>Given the following model definitions:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_description'>description</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
<span class='kw'>end</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Sun Project</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>description:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Sun\nProject</span><span class='tstring_end'>&quot;</span></span>)</code></pre>

<p>... we can query using simple Ruby regular expressions in a natural way:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>project</span><span class='regexp_end'>/i</span></span>).<span class='id identifier rubyid_first'>first</span>
<span class='comment'># =&gt; #&lt;Band _id: 5dc9f7d5ce4ef34893354323, name: &quot;Sun Project&quot;, description: &quot;Sun\nProject&quot;&gt;</span></code></pre>

<p>It is also possible to query using PCRE syntax by constructing
<code>BSON::Regexp::Raw</code> objects explicitly:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>description:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\AProject</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_first'>first</span>
<span class='comment'># =&gt; #&lt;Band _id: 5dc9f7d5ce4ef34893354323, name: &quot;Sun Project&quot;, description: &quot;Sun\nProject&quot;&gt;
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>description:</span> <span class='const'><a href="BSON.html" title="BSON (module)">BSON</a></span><span class='op'>::</span><span class='const'><a href="Regexp.html" title="Regexp (class)">Regexp</a></span><span class='op'>::</span><span class='const'>Raw</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>^Project</span><span class='tstring_end'>&#39;</span></span>)).<span class='id identifier rubyid_first'>first</span>
<span class='comment'># =&gt; nil
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>description:</span> <span class='const'><a href="BSON.html" title="BSON (module)">BSON</a></span><span class='op'>::</span><span class='const'><a href="Regexp.html" title="Regexp (class)">Regexp</a></span><span class='op'>::</span><span class='const'>Raw</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>^Project</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>m</span><span class='tstring_end'>&#39;</span></span>)).<span class='id identifier rubyid_first'>first</span>
<span class='comment'># =&gt; #&lt;Band _id: 5dc9f7d5ce4ef34893354323, name: &quot;Sun Project&quot;, description: &quot;Sun\nProject&quot;&gt;</span></code></pre>

<h2>Conditions On Fields</h2>

<p>When a condition uses a field defined in the model, the value being specified
in the condition is converted according to the rules of the field, if any.
For example, consider the following model definition that contains a <a href="Time.html" title="Time (class)"><code>Time</code></a>
field, a <a href="Date.html" title="Date (class)"><code>Date</code></a> field and an implicit <code>Object</code> field, and also
intentionally does not define a field called <code>deregistered_at</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Voter</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_born_on'>born_on</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Date.html" title="Date (class)">Date</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_registered_at'>registered_at</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Time.html" title="Time (class)">Time</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_voted_at'>voted_at</span>
<span class='kw'>end</span></code></pre>

<p>Queries on <code>born_on</code> and <code>registered_at</code> fields using <a href="Date.html" title="Date (class)"><code>Date</code></a> and <a href="Time.html" title="Time (class)"><code>Time</code></a>
values, respectively, are straightforward:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Voter</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>born_on:</span> <span class='const'><a href="Date.html" title="Date (class)">Date</a></span>.<span class='id identifier rubyid_today'>today</span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;born_on&quot;=&gt;2020-12-18 00:00:00 UTC}
</span>
<span class='const'>Voter</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>registered_at:</span> <span class='const'><a href="Time.html" title="Time (class)">Time</a></span>.<span class='id identifier rubyid_now'>now</span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;registered_at&quot;=&gt;2020-12-19 04:33:36.939788067 UTC}</span></code></pre>

<p>But, note the differences in behavior when providing a <a href="Date.html" title="Date (class)"><code>Date</code></a> instance
in all possible scenarios:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Voter</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>born_on:</span> <span class='const'><a href="Date.html" title="Date (class)">Date</a></span>.<span class='id identifier rubyid_today'>today</span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;born_on&quot;=&gt;2020-12-18 00:00:00 UTC}
</span>
<span class='const'>Voter</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>registered_at:</span> <span class='const'><a href="Date.html" title="Date (class)">Date</a></span>.<span class='id identifier rubyid_today'>today</span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;registered_at&quot;=&gt;2020-12-18 00:00:00 -0500}
</span>
<span class='const'>Voter</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>voted_at:</span> <span class='const'><a href="Date.html" title="Date (class)">Date</a></span>.<span class='id identifier rubyid_today'>today</span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;voted_at&quot;=&gt;Fri, 18 Dec 2020}
</span>
<span class='const'>Voter</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>deregistered_at:</span> <span class='const'><a href="Date.html" title="Date (class)">Date</a></span>.<span class='id identifier rubyid_today'>today</span>).<span class='id identifier rubyid_selector'>selector</span>
<span class='comment'># =&gt; {&quot;deregistered_at&quot;=&gt;2020-12-18 00:00:00 UTC}</span></code></pre>

<p>When using the <code>registered_at</code> field which is of type <a href="Time.html" title="Time (class)"><code>Time</code></a>, the date
was interpreted to be in local time (as per the <code>configured time zone
&lt;time-zones&gt;</code>). When using the <code>born_on</code> field which is of type <a href="Date.html" title="Date (class)"><code>Date</code></a>,
the date was interpreted to be in UTC. When using the <code>voted_at</code> field
which was defined without a type (hence implicitly as an <code>Object</code>),
the date was used unmodified in the constructed query. When using a
nonexistent field <code>deregistered_at</code> the date was interpreted to be in UTC
and converted to a time, matching the behavior of querying a <a href="Date.html" title="Date (class)"><code>Date</code></a> field.</p>

<h2>Scoping</h2>

<p>Scopes provide a convenient way to reuse common criteria with more
business domain style syntax.</p>

<h3>Named Scopes</h3>

<p>Named scopes are simply criteria defined at class load that are referenced
by a provided name. Just like normal criteria, they are lazy and chainable.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_country'>country</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_genres'>genres</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Array.html" title="Array (class)">Array</a></span>

  <span class='id identifier rubyid_scope'>scope</span> <span class='symbeg'>:</span><span class='id identifier rubyid_english'>english</span><span class='comma'>,</span> <span class='tlambda'>-&gt;</span><span class='tlambeg'>{</span> <span class='id identifier rubyid_where'>where</span>(<span class='label'>country:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>England</span><span class='tstring_end'>&quot;</span></span>) }
  <span class='id identifier rubyid_scope'>scope</span> <span class='symbeg'>:</span><span class='id identifier rubyid_rock'>rock</span><span class='comma'>,</span> <span class='tlambda'>-&gt;</span><span class='tlambeg'>{</span> <span class='id identifier rubyid_where'>where</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_genres'>genres</span>.<span class='id identifier rubyid_in'>in</span> <span class='op'>=&gt;</span> [ <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rock</span><span class='tstring_end'>&quot;</span></span> ]) }
<span class='kw'>end</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_english'>english</span>.<span class='id identifier rubyid_rock'>rock</span> <span class='comment'># Get the English rock bands.</span></code></pre>

<p>Named scopes can take procs and blocks for accepting parameters or
extending functionality.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_country'>country</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_active'>active</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'>Boolean</span><span class='comma'>,</span> <span class='label'>default:</span> <span class='kw'>true</span>

  <span class='id identifier rubyid_scope'>scope</span> <span class='symbeg'>:</span><span class='id identifier rubyid_named'>named</span><span class='comma'>,</span> <span class='tlambda'>-&gt;</span>(<span class='id identifier rubyid_name'>name</span>)<span class='tlambeg'>{</span> <span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='id identifier rubyid_name'>name</span>) }
  <span class='id identifier rubyid_scope'>scope</span> <span class='symbeg'>:</span><span class='id identifier rubyid_active'>active</span><span class='comma'>,</span> <span class='tlambda'>-&gt;</span><span class='tlambeg'>{</span>
    <span class='id identifier rubyid_where'>where</span>(<span class='label'>active:</span> <span class='kw'>true</span>) <span class='kw'>do</span>
      <span class='kw'>def</span> <span class='id identifier rubyid_deutsch'>deutsch</span>
        <span class='id identifier rubyid_tap'>tap</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_scope'>scope</span><span class='op'>|</span>
          <span class='id identifier rubyid_scope'>scope</span>.<span class='id identifier rubyid_selector'>selector</span>.<span class='id identifier rubyid_store'>store</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>origin</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Deutschland</span><span class='tstring_end'>&quot;</span></span>)
        <span class='kw'>end</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  }
<span class='kw'>end</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_named'>named</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Depeche Mode</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'># Find Depeche Mode.
</span><span class='const'>Band</span>.<span class='id identifier rubyid_active'>active</span>.<span class='id identifier rubyid_deutsch'>deutsch</span> <span class='comment'># Find active German bands.</span></code></pre>

<p>By default, Mongoid allows defining a scope that would shadow an existing
class method, as the following example shows:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Product</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_fresh'>fresh</span>
    <span class='kw'>true</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_scope'>scope</span> <span class='symbeg'>:</span><span class='id identifier rubyid_fresh'>fresh</span><span class='comma'>,</span> <span class='tlambda'>-&gt;</span><span class='tlambeg'>{</span> <span class='id identifier rubyid_where'>where</span>(<span class='label'>fresh:</span> <span class='kw'>true</span>) }
<span class='kw'>end</span></code></pre>

<p>To have Mongoid raise an error when a scope would overwrite an existing class
method, set the <code>scope_overwrite_exception</code> <code>configuration option
&lt;configuration-options&gt;</code> to <code>true</code>.</p>

<h3>Default Scopes</h3>

<p>Default scopes can be useful when you find yourself applying the same
criteria to most queries, and wish to specify these criteria as the default.
Default scopes are procs that return criteria objects.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_active'>active</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'>Boolean</span>

  <span class='id identifier rubyid_default_scope'>default_scope</span> <span class='tlambda'>-&gt;</span><span class='tlambeg'>{</span> <span class='id identifier rubyid_where'>where</span>(<span class='label'>active:</span> <span class='kw'>true</span>) }
<span class='kw'>end</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_band'>band</span><span class='op'>|</span>
  <span class='comment'># All bands here are active.
</span><span class='kw'>end</span></code></pre>

<p>Specifying a default scope also initializes the fields of new models to
the values given in the default scope, if the values are simple literals:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_active'>active</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'>Boolean</span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_num_tours'>num_tours</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Integer.html" title="Integer (class)">Integer</a></span>

  <span class='id identifier rubyid_default_scope'>default_scope</span> <span class='tlambda'>-&gt;</span><span class='tlambeg'>{</span> <span class='id identifier rubyid_where'>where</span>(<span class='label'>active:</span> <span class='kw'>true</span><span class='comma'>,</span> <span class='label'>num_tours:</span> {<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>$gt</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='int'>1</span>}) }
<span class='kw'>end</span>

<span class='comment'># active is set, num_tours is not set
</span><span class='const'>Band</span>.<span class='id identifier rubyid_new'>new</span> <span class='comment'># =&gt; #&lt;Band _id: 5c3f7452ce4ef378295ca5f5, name: nil, active: true, num_tours: nil&gt;</span></code></pre>

<p>Note that if a default value is provided both in the field definition and
in the default scope, the value in the default scope takes precedence:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_active'>active</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'>Boolean</span><span class='comma'>,</span> <span class='label'>default:</span> <span class='kw'>true</span>

  <span class='id identifier rubyid_default_scope'>default_scope</span> <span class='tlambda'>-&gt;</span><span class='tlambeg'>{</span> <span class='id identifier rubyid_where'>where</span>(<span class='label'>active:</span> <span class='kw'>false</span>) }
<span class='kw'>end</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_new'>new</span> <span class='comment'># =&gt; #&lt;Band _id: 5c3f74ddce4ef3791abbb088, name: nil, active: false&gt;</span></code></pre>

<p>Because a default scope initializes fields in new models as just described,
defining a default scope with a dotted key and a simple literal value, while
possible, is not recommended:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_tags'>tags</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Hash.html" title="Hash (class)">Hash</a></span>

  <span class='id identifier rubyid_default_scope'>default_scope</span> <span class='tlambda'>-&gt;</span><span class='tlambeg'>{</span> <span class='id identifier rubyid_where'>where</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>tags.foo</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>bar</span><span class='tstring_end'>&#39;</span></span>) }
<span class='kw'>end</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>
<span class='comment'># =&gt; Created document: {&quot;_id&quot;=&gt;BSON::ObjectId(&#39;632de48f3282a404bee1877b&#39;), &quot;tags.foo&quot;=&gt;&quot;bar&quot;}
</span><span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>tags:</span> { <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>bar</span><span class='tstring_end'>&#39;</span></span> })
<span class='comment'># =&gt; Created document: {&quot;_id&quot;=&gt;BSON::ObjectId(&#39;632de4ad3282a404bee1877c&#39;), &quot;tags.foo&quot;=&gt;&quot;bar&quot;, &quot;tags&quot;=&gt;{&quot;foo&quot;=&gt;&quot;bar&quot;}}
</span><span class='const'>Band</span>.<span class='id identifier rubyid_all'>all</span>.<span class='id identifier rubyid_to_a'>to_a</span>
<span class='comment'># =&gt; [ #&lt;Band _id: 632de4ad3282a404bee1877c, tags: {&quot;foo&quot;=&gt;&quot;bar&quot;}&gt; ]</span></code></pre>

<p>Mongoid 8 allows dotted keys to be used in Mongoid, and when creating a document,
the scope is added as a dotted key in the attributes:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_new'>new</span>.<span class='id identifier rubyid_attribute'>attribute</span>
<span class='comment'># =&gt; {&quot;_id&quot;=&gt;BSON::ObjectId(&#39;632de97d3282a404bee1877d&#39;), &quot;tags.foo&quot;=&gt;&quot;bar&quot;}</span></code></pre>

<p>Whereas when querying, Mongoid looks for an embedded document:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>
<span class='comment'># =&gt; Created document: {&quot;_id&quot;=&gt;BSON::ObjectId(&#39;632de48f3282a404bee1877b&#39;), &quot;tags.foo&quot;=&gt;&quot;bar&quot;}
</span><span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>
<span class='comment'># =&gt; #&lt;Mongoid::Criteria
</span>       <span class='id identifier rubyid_selector'>selector</span><span class='op'>:</span> {<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>tags.foo</span><span class='tstring_end'>&quot;</span></span><span class='op'>=&gt;</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>bar</span><span class='tstring_end'>&quot;</span></span>}
       <span class='id identifier rubyid_options'>options</span><span class='op'>:</span>  {}
       <span class='kw'>class</span><span class='op'>:</span>    <span class='const'>Band</span>
       <span class='id identifier rubyid_embedded'>embedded</span><span class='op'>:</span> <span class='kw'>false</span><span class='op'>&gt;</span>
<span class='comment'># This looks for something like: { tags: { &quot;foo&quot; =&gt; &quot;bar&quot; } }
</span><span class='const'>Band</span>.<span class='id identifier rubyid_count'>count</span>
<span class='comment'># =&gt; 0</span></code></pre>

<p>A workaround is to define the default scope as a complex query:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_tags'>tags</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Hash.html" title="Hash (class)">Hash</a></span>

  <span class='id identifier rubyid_default_scope'>default_scope</span> <span class='tlambda'>-&gt;</span><span class='tlambeg'>{</span> <span class='id identifier rubyid_where'>where</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>tags.foo</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> {<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>$eq</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>bar</span><span class='tstring_end'>&#39;</span></span>}) }
<span class='kw'>end</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>tags:</span> { <span class='label'>hello:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>world</span><span class='tstring_end'>&#39;</span></span> })
<span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>tags:</span> { <span class='label'>foo:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>bar</span><span class='tstring_end'>&#39;</span></span> })
<span class='comment'># does not add a &quot;tags.foo&quot; dotted attribute
</span><span class='const'>Band</span>.<span class='id identifier rubyid_count'>count</span>
<span class='comment'># =&gt; 1</span></code></pre>

<p>You can tell Mongoid not to apply the default scope by using
<code>unscoped</code>, which can be inline or take a block.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_unscoped'>unscoped</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Depeche Mode</span><span class='tstring_end'>&quot;</span></span>)
<span class='const'>Band</span>.<span class='id identifier rubyid_unscoped'>unscoped</span> <span class='kw'>do</span>
  <span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Depeche Mode</span><span class='tstring_end'>&quot;</span></span>)
<span class='kw'>end</span></code></pre>

<p>You can also tell Mongoid to explicitly apply the default scope
again later to always ensure it&#39;s there.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_unscoped'>unscoped</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Depeche Mode</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_scoped'>scoped</span></code></pre>

<p>If you are using a default scope on a model that is part of an association,
you must reload the association to have scoping reapplied.
This is important to note if you change a value of a document in the association
that would affect its visibility within the scoped association.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Label</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_embeds_many'>embeds_many</span> <span class='symbeg'>:</span><span class='id identifier rubyid_bands'>bands</span>
<span class='kw'>end</span>

<span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_active'>active</span><span class='comma'>,</span> <span class='label'>default:</span> <span class='kw'>true</span>
  <span class='id identifier rubyid_embedded_in'>embedded_in</span> <span class='symbeg'>:</span><span class='id identifier rubyid_label'>label</span>
  <span class='id identifier rubyid_default_scope'>default_scope</span> <span class='tlambda'>-&gt;</span><span class='tlambeg'>{</span> <span class='id identifier rubyid_where'>where</span>(<span class='label'>active:</span> <span class='kw'>true</span>) }
<span class='kw'>end</span>

<span class='id identifier rubyid_label'>label</span>.<span class='id identifier rubyid_bands'>bands</span>.<span class='id identifier rubyid_push'>push</span>(<span class='id identifier rubyid_band'>band</span>)
<span class='id identifier rubyid_label'>label</span>.<span class='id identifier rubyid_bands'>bands</span> <span class='comment'># [ band ]
</span><span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_update_attribute'>update_attribute</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_active'>active</span><span class='comma'>,</span> <span class='kw'>false</span>)
<span class='id identifier rubyid_label'>label</span>.<span class='id identifier rubyid_bands'>bands</span> <span class='comment'># [ band ] Must reload.
</span><span class='id identifier rubyid_label'>label</span>.<span class='id identifier rubyid_reload'>reload</span>.<span class='id identifier rubyid_bands'>bands</span> <span class='comment'># []</span></code></pre>

<div class="note" markdown="1">

<div class="title" markdown="1">

Note

</div>

<p>After the default scope is applied, it is no longer distinguished from
other query conditions. This can lead to surprising behavior when using
<code>or</code> and <code>nor</code> operators in particular:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_active'>active</span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_touring'>touring</span>

  <span class='id identifier rubyid_default_scope'>default_scope</span> <span class='tlambda'>-&gt;</span><span class='tlambeg'>{</span> <span class='id identifier rubyid_where'>where</span>(<span class='label'>active:</span> <span class='kw'>true</span>) }
<span class='kw'>end</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Infected Mushroom</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;active&quot;=&gt;true, &quot;name&quot;=&gt;&quot;Infected Mushroom&quot;}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Infected Mushroom</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_or'>or</span>(<span class='label'>touring:</span> <span class='kw'>true</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;$or&quot;=&gt;[{&quot;active&quot;=&gt;true, &quot;name&quot;=&gt;&quot;Infected Mushroom&quot;}, {&quot;touring&quot;=&gt;true}]}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_or'>or</span>(<span class='label'>touring:</span> <span class='kw'>true</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;$or&quot;=&gt;[{&quot;active&quot;=&gt;true}, {&quot;touring&quot;=&gt;true}]}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<p>In the last example, you might expect the two conditions
(<code>active: true</code> and <code>touring: true</code>) to be combined with an <code>$and</code>,
but because the <code>Band</code> class already has the scope applied to it,
it becomes one of the disjunction branches of the <code>or</code>.</p>

<p></div></p>

<h3>Runtime Default Scope Override</h3>

<p>You can use the <code>with_scope</code> method to change the default scope in a block
at runtime:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_country'>country</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_genres'>genres</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Array.html" title="Array (class)">Array</a></span>

  <span class='id identifier rubyid_scope'>scope</span> <span class='symbeg'>:</span><span class='id identifier rubyid_english'>english</span><span class='comma'>,</span> <span class='tlambda'>-&gt;</span><span class='tlambeg'>{</span> <span class='id identifier rubyid_where'>where</span>(<span class='label'>country:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>England</span><span class='tstring_end'>&quot;</span></span>) }
<span class='kw'>end</span>

<span class='id identifier rubyid_criteria'>criteria</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_with_scope'>with_scope</span>(<span class='const'>Band</span>.<span class='id identifier rubyid_english'>english</span>) <span class='kw'>do</span>
  <span class='const'>Band</span>.<span class='id identifier rubyid_all'>all</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_criteria'>criteria</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;Mongoid::Criteria
</span><span class='comment'>#   selector: {&quot;country&quot;=&gt;&quot;England&quot;}
</span><span class='comment'>#   options:  {}
</span><span class='comment'>#   class:    Band
</span><span class='comment'>#   embedded: false&gt;</span></code></pre>

<div class="note" markdown="1">

<div class="title" markdown="1">

Note

</div>

<p>If with_scope calls are nested, when the nested with_scope block completes
Mongoid 7 sets the current scope to nil instead of the parent scope.
Mongoid 8 will set the current scope to the correct parent scope.
To get Mongoid 8 behavior in Mongoid 7.4 and higher, set the
<code>Mongoid.broken_scoping</code> global option to false.</p>

<p></div></p>

<h3>Class Methods</h3>

<p>Class methods on models that return criteria objects are also
treated like scopes, and can be chained as well.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_active'>active</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'>Boolean</span><span class='comma'>,</span> <span class='label'>default:</span> <span class='kw'>true</span>

  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_active'>active</span>
    <span class='id identifier rubyid_where'>where</span>(<span class='label'>active:</span> <span class='kw'>true</span>)
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='const'>Band</span>.<span class='id identifier rubyid_active'>active</span></code></pre>

<h2>Queries + Persistence</h2>

<p>Mongoid supports persistence operations off of criteria
in a light capacity for when you want to expressively perform multi
document inserts, updates, and deletion.</p>

<div class="warning" markdown="1">

<div class="title" markdown="1">

Warning

</div>

<p>Criteria ordering and pagination conditions, including <code>order</code>, <code>limit</code>,
<code>offset</code>, and <code>batch_size</code>, will be ignored on the following operations.</p>

<p></div></p>

<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>Criteria#create</code></p>
<p><em>Create a newly persisted document.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Photek").create</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#create!</code></p>
<p><em>Create a newly persisted document and raise an exception on validation failure.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Photek").create!</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#build|new</code></p>
<p><em>Create a new (unsaved) document.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Photek").build
Band.where(name: "Photek").new</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#update</code></p>
<p><em>Update attributes of the first matching document.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Photek").update(label: "Mute")</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#update_all</code></p>
<p><em>Update attributes of all matching documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(members: 2).update_all(label: "Mute")</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#add_to_set</code></p>
<p><em>Perform an $addToSet on all matching documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Photek").add_to_set(label: "Mute")</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#bit</code></p>
<p><em>Perform a $bit on all matching documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Photek").bit(likes: { and: 14, or: 4 })</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#inc</code></p>
<p><em>Perform an $inc on all matching documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Photek").inc(likes: 123)</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#pop</code></p>
<p><em>Perform a $pop on all matching documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Photek").pop(members: -1)
Band.where(name: "Photek").pop(members: 1)</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#pull</code></p>
<p><em>Perform a $pull on all matching documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Tool").pull(members: "Maynard")</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#pull_all</code></p>
<p><em>Perform a $pullAll on all matching documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>Band.where(name: "Tool").</dt>
<dd><p>pull_all(:members, [ "Maynard", "Danny" ])</p>
</dd>
</dl>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#push</code></p>
<p><em>Perform a $push on all matching documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Tool").push(members: "Maynard")</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#push_all</code></p>
<p><em>Perform a $push with $each on all matching documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>Band.where(name: "Tool").</dt>
<dd><p>push_all(members: [ "Maynard", "Danny" ])</p>
</dd>
</dl>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#rename</code></p>
<p><em>Perform a $rename on all matching documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Tool").rename(name: :title)</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#set</code></p>
<p><em>Perform a $set on all matching documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Tool").set(likes: 10000)</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#unset</code></p>
<p><em>Perform a $unset on all matching documents.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(name: "Tool").unset(:likes)</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Criteria#delete</code></p>
<p><em>Deletes all matching documents in the database.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(label: "Mute").delete</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Criteria#destroy</code></p>
<p><em>Deletes all matching documents in the database while running callbacks for all.
This loads all documents into memory and can be an expensive operation.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Band.where(label: "Mute").destroy</p>
</blockquote></td>
</tr>
</tbody>
</table>

<h2>Query Cache</h2>

<p>The Ruby MongoDB driver versions 2.14 and above provide query caching functionality. When enabled, the
query cache saves the results of previously executed find and aggregation
queries and reuses them in the future instead of performing the queries again,
thus increasing application performance and reducing database load.</p>

<p>Please review the <a href="https://mongodb.com/docs/ruby-driver/current/reference/query-cache/">driver query cache documentation</a>
for details about the driver&#39;s query cache behavior.</p>

<p>The rest of this section assumes that driver 2.14.0 or later is being used.</p>

<h3>Enabling Query Cache</h3>

<p>The query cache may be enabled by using the driver&#39;s namespace or Mongoid&#39;s
namespace.</p>

<h3>Enabling Query Cache Automatically</h3>

<p>The MongoDB Ruby Driver provides middleware to automatically enable the query cache for
Rack web requests and ActiveJob job runs. Please see the <code>Query Cache Rack Middleware
&lt;query-cache-middleware&gt;</code> section on the configuration page for instructions.</p>

<p>Note that the Query Cache Middleware does not apply to code executed outside web requests
and/or jobs.</p>

<h3>Enabling Query Cache Manually</h3>

<p>To enable the Query Cache manually for a code segment, use:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Mongo</span><span class='op'>::</span><span class='const'>QueryCache</span>.<span class='id identifier rubyid_cache'>cache</span> <span class='kw'>do</span>
  <span class='comment'># ...
</span><span class='kw'>end</span></code></pre>

<p>The Query Cache can also be explicitly enabled and disabled, although we
recommend to use the block form described above:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>begin</span>
  <span class='const'>Mongo</span><span class='op'>::</span><span class='const'>QueryCache</span>.<span class='id identifier rubyid_enabled'>enabled</span> <span class='op'>=</span> <span class='kw'>true</span>
  <span class='comment'># ...
</span><span class='kw'>ensure</span>
  <span class='const'>Mongo</span><span class='op'>::</span><span class='const'>QueryCache</span>.<span class='id identifier rubyid_enabled'>enabled</span> <span class='op'>=</span> <span class='kw'>false</span>
<span class='kw'>end</span></code></pre>

<h3>Caching the Result of <code>#first</code> [query-cache-first-method]</h3>

<p>Calling the <code>first</code> method on a model class imposes an ascending sort by
the <code>_id</code> field on the underlying query. This may produce unexpected behavior
with query caching.</p>

<p>For example, when calling <code>all</code> on a model class and then <code>first</code>,
one would expect the second query to use the cached results from the first.
However, because of the sort imposed on the second query, both methods
will query the database and separately cache their results.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Band</span>.<span class='id identifier rubyid_all'>all</span>.<span class='id identifier rubyid_to_a'>to_a</span>
<span class='comment'>#=&gt; Queries the database and caches the results
</span>
<span class='const'>Band</span>.<span class='id identifier rubyid_first'>first</span>
<span class='comment'>#=&gt; Queries the database again because of the sort</span></code></pre>

<p>To use the cached results, call <code>all.to_a.first</code> on the model class.</p>

<h2>Asynchronous Queries [load-async]</h2>

<p>Mongoid allows running database queries asynchronously in the background.
This can be beneficial when there is a need to get documents from different
collections.</p>

<p>In order to schedule an asynchronous query call the <code>load_async</code> method on a
<code>Criteria</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>PagesController</span> <span class='op'>&lt;</span> <span class='const'>ApplicationController</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_index'>index</span>
    <span class='ivar'>@active_bands</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>active:</span> <span class='kw'>true</span>).<span class='id identifier rubyid_load_async'>load_async</span>
    <span class='ivar'>@best_events</span> <span class='op'>=</span> <span class='const'>Event</span>.<span class='id identifier rubyid_best'>best</span>.<span class='id identifier rubyid_load_async'>load_async</span>
    <span class='ivar'>@public_articles</span> <span class='op'>=</span> <span class='const'>Article</span>.<span class='id identifier rubyid_where'>where</span>(<span class='label'>public:</span> <span class='kw'>true</span>).<span class='id identifier rubyid_load_async'>load_async</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>In the above example three queries will be scheduled for asynchronous execution.
Results of the queries can be later accessed as usual:</p>

<pre class="code xml"><code class="xml">&lt;ul&gt;
  &lt;%- @active_bands.each do -%&gt;
    &lt;li&gt;&lt;%= band.name %&gt;&lt;/li&gt;
  &lt;%- end -%&gt;
&lt;/ul&gt;
</code></pre>

<p>Even if a query is scheduled for asynchronous execution, it might be executed
synchronously on the caller&#39;s thread. There are three possible scenarios depending
on when the query results are being accessed:</p>

<ol>
<li> If the scheduled asynchronous task has been already executed, the results are returned.</li>
<li> If the task has been started, but not finished yet, the caller&#39;s thread blocks until the task is finished.</li>
<li> If the task has not been started yet, it is removed from the execution queue, and the query is executed synchronously on the caller&#39;s thread.</li>
</ol>

<div class="note" markdown="1">

<div class="title" markdown="1">

Note

</div>

<p>Even though <code>load_async</code> method returns a <code>Criteria</code> object, you should not
do any operations on this object except accessing query results. The query is
scheduled for execution immediately after calling <code>load_async</code>, therefore
later changes to the <code>Criteria</code> object may not be applied.</p>

<p></div></p>

<h3>Configuring asynchronous query execution</h3>

<p>Asynchronous queries are disabled by default. When asynchronous queries are
disabled, <code>load_async</code> will execute the query immediately on the current thread,
blocking as necessary. Therefore, calling <code>load_async</code> on criteria in this case
is roughly the equivalent of calling <code>to_a</code> to force query execution.</p>

<p>In order to enable asynchronous query execution, the following config options
must be set:</p>

<pre class="code yaml"><code class="yaml">development:
  ...
  options:
    # Execute asynchronous queries using a global thread pool.
    async_query_executor: :global_thread_pool
    # Number of threads in the pool. The default is 4.
    # global_executor_concurrency: 4
</code></pre>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>