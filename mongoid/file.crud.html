<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: CRUD Operations &mdash; Mongoid master</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "crud",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Mongoid master</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: CRUD Operations&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<h1>CRUD Operations</h1>

<div class="contents singlecol" markdown="1" local="" backlinks="none" depth="2"></div>

<h2>Saving Documents</h2>

<p><a href="Mongoid.html" title="Mongoid (module)"><code>Mongoid</code></a> supports all expected CRUD operations for those familiar with other
Ruby mappers like Active Record or Data Mapper. What distinguishes <a href="Mongoid.html" title="Mongoid (module)"><code>Mongoid</code></a>
from other mappers for MongoDB is that the general persistence operations
perform atomic updates on only the fields that have changed instead of
writing the entire document to the database each time.</p>

<p>The persistence sections will provide examples on what database operation is
performed when executing the documented command.</p>

<h3>Standard</h3>

<p>Mongoid&#39;s standard persistence methods come in the form of common methods you
would find in other mapping frameworks. The following table shows all standard
operations with examples.</p>

<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>Model#attributes</code></p>
<p><em>Returns the document's attributes as a <a href="Hash.html" title="Hash (class)"><code>Hash</code></a> with string keys, and
its values in Mongoized form (i.e. the way they are stored in the db).</em></p>
<p><em>The attributes hash also contains the attributes of all embedded
documents, as well as their embedded documents, etc. If an embedded
association is empty, its key will not show up in the returned hash.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person = Person.new(first_name: "Heinrich", last_name: "Heine")</p>
<p>person.attributes
# =&gt; { "_id" =&gt; BSON::ObjectId('633467d03282a43784c2d56e'), "first_name" =&gt; "Heinrich", "last_name" =&gt; "Heine" }</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model.create!</code></p>
<p><em>Insert a document or multiple documents into the database, raising an
error if a validation or server error occurs.</em></p>
<p><em>Pass a hash of attributes to create one document with the specified
attributes, or an array of hashes to create multiple documents.
If a single hash is passed, the corresponding document is returned.
If an array of hashes is passed, an array of documents corresponding
to the hashes is returned.</em></p>
<p><em>If a block is given to</em> <code>create!</code> <em>, it will be invoked with each
document as the argument in turn prior to attempting to save that
document.</em></p>
<p><em>If there is a problem saving any of the documents, such as
a validation error or a server error, an exception is raised
and, consequently, none of the documents are returned.
However, if an array of hashes was passed and previous documents were
successfully saved, those documents will remain in the database.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>Person.create!(</dt>
<dd><p>first_name: "Heinrich",
last_name: "Heine"</p>
</dd>
</dl>
<p>) # =&gt; Person instance</p>
<dl>
<dt>Person.create!([</dt>
<dd><p>{ first_name: "Heinrich", last_name: "Heine" },
{ first_name: "Willy", last_name: "Brandt" }</p>
</dd>
</dl>
<p>]) # =&gt; <a href="Array.html" title="Array (class)"><code>Array</code></a> of two Person instances</p>
<dl>
<dt>Person.create!(first_name: "Heinrich") do</dt>
<dd><p>doc.last_name = "Heine"</p>
</dd>
</dl>
<p>end # =&gt; Person instance</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Model.create</code></p>
<p><em>Instantiate a document or multiple documents and, if validations pass,
insert them into the database.</em></p>
<p><code>create</code> <em>is similar to</em> <code>create!</code> <em>but does not raise
exceptions on validation errors. It still raises errors on server
errors, such as trying to insert a document with an</em> <code>_id</code> <em>that
already exists in the collection.</em></p>
<p><em>If any validation errors are encountered, the respective document
is not inserted but is returned along with documents that were inserted.
Use</em> <code>persisted?</code> <em>,</em> <code>new_record?</code> <em>or</em> <code>errors</code> <em>methods
to check which of the returned documents were inserted into the
database.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>Person.create(</dt>
<dd><p>first_name: "Heinrich",
last_name: "Heine"</p>
</dd>
</dl>
<p>) # =&gt; Person instance</p>
<dl>
<dt>Person.create([</dt>
<dd><p>{ first_name: "Heinrich", last_name: "Heine" },
{ first_name: "Willy", last_name: "Brandt" }</p>
</dd>
</dl>
<p>]) # =&gt; <a href="Array.html" title="Array (class)"><code>Array</code></a> of two Person instances</p>
<dl>
<dt>Person.create(first_name: "Heinrich") do</dt>
<dd><p>doc.last_name = "Heine"</p>
</dd>
</dl>
<p>end # =&gt; Person instance</p>
<dl>
<dt>class Post</dt>
<dd><p>include Mongoid::Document</p>
<p>validates_uniqueness_of :title</p>
</dd>
</dl>
<p>end</p>
<p>posts = Post.create([<code>"test"</code>, <code>"test"</code>])
# =&gt; array of two Post instances
posts.map { post.persisted? } # =&gt; [true, false]</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model#save!</code></p>
<p><em>Save the changed attributes to the database atomically, or insert the document if
new. Raises an exception if validations fail or there is a server error.</em></p>
<p><em>Returns true if the changed attributes were saved, raises an exception otherwise.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>person = Person.new(</dt>
<dd><p>first_name: "Heinrich",
last_name: "Heine"</p>
</dd>
</dl>
<p>)
person.save!</p>
<p>person.first_name = "Christian Johan"
person.save!</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Model#save</code></p>
<p><em>Save the changed attributes to the database atomically, or insert the document
if new.</em></p>
<p><em>Returns true if the changed attributes were saved. Returns false
if there were any validation errors. Raises an exception if
the document passed validation but there was a server error during
the save.</em></p>
<p><em>Pass</em> <code>validate: false</code> <em>option to bypass validations.</em></p>
<p><em>Pass</em> <code>touch: false</code> <em>option to ignore the updates to the updated_at
field. If the document being save has not been previously persisted,
this option is ignored and the created_at and updated_at fields will be
updated with the current time.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>person = Person.new(</dt>
<dd><p>first_name: "Heinrich",
last_name: "Heine"</p>
</dd>
</dl>
<p>)
person.save
person.save(validate: false)
person.save(touch: false)</p>
<p>person.first_name = "Christian Johan"
person.save</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model#update_attributes</code></p>
<p><em>Update the document attributes in the database. Will return true if validation passed,
false if not.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>person.update_attributes(</dt>
<dd><p>first_name: "Jean",
last_name: "Zorg"</p>
</dd>
</dl>
<p>)</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Model#update_attributes!</code></p>
<p><em>Update the document attributes in the database and raise an error if validation failed.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>person.update_attributes!(</dt>
<dd><p>first_name: "Leo",
last_name: "Tolstoy"</p>
</dd>
</dl>
<p>)</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model#update_attribute</code></p>
<p><em>Update a single attribute, bypassing validations.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.update_attribute(:first_name, "Jean")</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Model#upsert</code></p>
<p><em>Performs a MongoDB replace with upsert on the document. If the document
exists in the database and the</em> <code>:replace</code> <em>option is set to true, it
will get overwritten with the current document in the application (any
attributes present in the database but not in the application's document
instance will be lost). If the</em> <code>:replace</code> <em>option is false (default),
the document will be updated, and any attributes not in the application's
document will be maintained.
If the document does not exist in the database, it will be inserted.
Note that this only runs the</em> <code>{before|after|around}_upsert</code> <em>callbacks.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>person = Person.new(</dt>
<dd><p>first_name: "Heinrich",
last_name: "Heine"</p>
</dd>
</dl>
<p>)
person.upsert
person.upsert(replace: true)</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model#touch</code></p>
<p><em>Update the document's updated_at timestamp, optionally with one extra
provided time field. This will cascade the touch to all</em>
<code>belongs_to</code> <em>associations of the document with the option set.
This operation skips validations and callbacks.</em></p>
<p><em>Attempting to touch a destroyed document will raise</em> <code>FrozenError</code>,
<em>same as if attempting to update an attribute on a destroyed
document.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.touch
person.touch(:audited_at)</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Model#delete</code></p>
<p><em>Deletes the document from the database without running callbacks.</em></p>
<p><em>If the document is not persisted, <a href="Mongoid.html" title="Mongoid (module)"><code>Mongoid</code></a> will attempt to delete from
the database any document with the same</em> <code>_id</code>.</p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.delete</p>
<p>person = Person.create!(...)
unsaved_person = Person.new(id: person.id)
unsaved_person.delete
person.reload
# raises Mongoid::Errors::DocumentNotFound because the person was deleted</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model#destroy</code></p>
<p><em>Deletes the document from the database while running destroy callbacks.</em></p>
<p><em>If the document is not persisted, <a href="Mongoid.html" title="Mongoid (module)"><code>Mongoid</code></a> will attempt to delete from
the database any document with the same</em> <code>_id</code>.</p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.destroy</p>
<p>person = Person.create!(...)
unsaved_person = Person.new(id: person.id)
unsaved_person.destroy
person.reload
# raises Mongoid::Errors::DocumentNotFound because the person was deleted</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Model.delete_all</code></p>
<p><em>Deletes all documents from the database without running any callbacks.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Person.delete_all</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model.destroy_all</code></p>
<p><em>Deletes all documents from the database while running callbacks. This is a
potentially expensive operation since all documents will be loaded into memory.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>Person.destroy_all</p>
</blockquote></td>
</tr>
</tbody>
</table>

<p><a href="Mongoid.html" title="Mongoid (module)"><code>Mongoid</code></a> provides the following persistence-related attributes:</p>

<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th>Attribute</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>Model#new_record?</code></p>
<p><em>Returns</em> <code>true</code> <em>if the model instance has not yet been saved
to the database. Opposite of</em> <code>persisted?</code></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>person = Person.new(</dt>
<dd><p>first_name: "Heinrich",
last_name: "Heine"</p>
</dd>
</dl>
<p>)
person.new_record? # =&gt; true
person.save!
person.new_record? # =&gt; false</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model#persisted?</code></p>
<p><em>Returns</em> <code>true</code> <em>if the model instance has been saved
to the database. Opposite of</em> <code>new_record?</code></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<dl>
<dt>person = Person.new(</dt>
<dd><p>first_name: "Heinrich",
last_name: "Heine"</p>
</dd>
</dl>
<p>)
person.persisted? # =&gt; false
person.save!
person.persisted? # =&gt; true</p>
</blockquote></td>
</tr>
</tbody>
</table>

<h3>Atomic</h3>

<p><a href="Mongoid.html" title="Mongoid (module)"><code>Mongoid</code></a> exposes <code>MongoDB update operators &lt;/reference/operator/update/&gt;</code>
as methods on <a href="Mongoid.html" title="Mongoid (module)"><code>Mongoid</code></a> documents. When these methods are used, callbacks are
not invoked and validations are not performed. The supported update operators
are:</p>

<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>Model#add_to_set</code></p>
<p><em>Performs an atomic $addToSet on the field.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.add_to_set(aliases: "Bond")</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model#bit</code></p>
<p><em>Performs an atomic $bit on the field.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.bit(age: { and: 10, or: 12 })</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Model#inc</code></p>
<p><em>Performs an atomic $inc on the field.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.inc(age: 1)</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model#pop</code></p>
<p><em>Performs an atomic $pop on the field.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.pop(aliases: 1)</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Model#pull</code></p>
<p><em>Performs an atomic $pull on the field.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.pull(aliases: "Bond")</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model#pull_all</code></p>
<p><em>Performs an atomic $pullAll on the field.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.pull_all(aliases: [ "Bond", "James" ])</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Model#push</code></p>
<p><em>Performs an atomic $push on the field.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.push(aliases: ["007","008"])</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model#rename</code></p>
<p><em>Performs an atomic $rename on the field.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.rename(bday: <code>:dob</code>)</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><p><code>Model#set</code></p>
<p><em>Updates an attribute on the model instance and, if the instance
is already persisted, performs an atomic $set on the field, bypassing
validations.</em></p>
<p><code>set</code> <em>can also deeply set values on <a href="Hash.html" title="Hash (class)"><code>Hash</code></a> fields.</em></p>
<p><code>set</code> <em>can also deeply set values on</em> <code>embeds_one</code> <em>associations.
If such an association's document is nil, one will be created prior
to the update.</em></p>
<p><code>set</code> <em>should not be used with</em> <code>has_one</code> <em>associations, as it
does not correctly work in such cases.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person = Person.create!(name: "Ricky Bobby")
person.set(name: "Tyler Durden") # updates name in the database</p>
<p>person = Person.new
person.set(name: "Tyler Durden") # does not write to database
person.name # =&gt; "Tyler Durden"
person.persisted? # =&gt; true</p>
<dl>
<dt>class Post</dt>
<dd><p>include Mongoid::Document</p>
<p>field <code>:metadata</code>, type: Hash</p>
</dd>
</dl>
<p>end</p>
<p>post = Post.create!
post.set('metadata.published_at' =&gt; <a href="Time.html" title="Time (class)"><code>Time</code></a>.now)
post.metadata['published_at'] # =&gt; <a href="Time.html" title="Time (class)"><code>Time</code></a> instance</p>
<p>post.set('metadata.approved.today' =&gt; true)
post.metadata['approved'] # =&gt; <code>=&gt; true</code></p>
<dl>
<dt>class Flight</dt>
<dd><p>include Mongoid::Document</p>
<p>embeds_one :plan</p>
</dd>
</dl>
<p>end</p>
<dl>
<dt>class Plan</dt>
<dd><p>include Mongoid::Document</p>
<p>embedded_in :flight</p>
<p>field <code>:route</code>, type: String</p>
</dd>
</dl>
<p>end</p>
<p>flight = Flight.create!
flight.plan # =&gt; nil
flight.set('plan.route', 'test route')
flight.plan # =&gt; Plan instance
flight.plan.route # =&gt; "test route"</p>
</blockquote></td>
</tr>
<tr class="even">
<td><p><code>Model#unset</code></p>
<p><em>Performs an atomic $unset on the field.</em></p></td>
<td><p>.. code-block:: ruby</p>
<blockquote>
<p>person.unset(:name)</p>
</blockquote></td>
</tr>
</tbody>
</table>

<p>Note that, because these methods skip validations, it is possible to both
save invalid documents into the database and end up with invalid documents
in the application (which would subsequently fail to save via a <code>save</code>
call due to the failing validations).</p>

<h4>Atomic Operation Grouping</h4>

<p>Atomic operations may be grouped together using the <code>#atomically</code> method
on a document. All operations inside the block given to <code>#atomically</code>
are sent to the cluster in a single atomic command. For example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_atomically'>atomically</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_inc'>inc</span>(<span class='label'>age:</span> <span class='int'>1</span>)
  <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_set'>set</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Jake</span><span class='tstring_end'>&#39;</span></span>)
<span class='kw'>end</span></code></pre>

<p><code>#atomically</code> blocks may be nested. The default behavior is to write
changes performed by each block as soon as the block ends:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_atomically'>atomically</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_atomically'>atomically</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_inc'>inc</span>(<span class='label'>age:</span> <span class='int'>1</span>)
    <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_set'>set</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Jake</span><span class='tstring_end'>&#39;</span></span>)
  <span class='kw'>end</span>
  <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>An exception</span><span class='tstring_end'>&#39;</span></span>
  <span class='comment'># name and age changes are still persisted
</span><span class='kw'>end</span></code></pre>

<p>This behavior can be changed by specifying the <code>join_context: true</code> option
to <code>#atomically</code>, or globally by setting the <code>join_contexts</code>
<code>configuration option &lt;configuration-options&gt;</code> to <code>true</code>. When
context joining is enabled, nested <code>#atomically</code> blocks are joined with
the outer blocks, and only the outermost block (or the first block where
<code>join_contexts</code> is false) actually writes changes to the cluster.
For example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_atomically'>atomically</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_atomically'>atomically</span>(<span class='label'>join_context:</span> <span class='kw'>true</span>) <span class='kw'>do</span>
    <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_inc'>inc</span>(<span class='label'>age:</span> <span class='int'>1</span>)
    <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_set'>set</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Jake</span><span class='tstring_end'>&#39;</span></span>)
  <span class='kw'>end</span>
  <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>An exception</span><span class='tstring_end'>&#39;</span></span>
  <span class='comment'># name and age changes are not persisted
</span><span class='kw'>end</span></code></pre>

<p>The context joining behavior can be enabled globally by default by setting
<code>join_context</code> option in Mongoid configuration. In this case specifying
<code>join_context: false</code> on an <code>#atomically</code> block can be used to
obtain the independent persistence context behavior.</p>

<p>If an exception is raised in an <code>#atomically</code> block which has not yet
persisted its changes to the cluster, any pending attribute changes on
Mongoid models are reverted. For example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_person'>person</span> <span class='op'>=</span> <span class='const'>Person</span>.<span class='id identifier rubyid_new'>new</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Tom</span><span class='tstring_end'>&#39;</span></span>)
<span class='kw'>begin</span>
  <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_atomically'>atomically</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_inc'>inc</span>(<span class='label'>age:</span> <span class='int'>1</span>)
    <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_set'>set</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Jake</span><span class='tstring_end'>&#39;</span></span>)
    <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_name'>name</span> <span class='comment'># =&gt; &#39;Jake&#39;
</span>    <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>An exception</span><span class='tstring_end'>&#39;</span></span>
  <span class='kw'>end</span>
<span class='kw'>rescue</span> <span class='const'>Exception</span>
  <span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_name'>name</span> <span class='comment'># =&gt; &#39;Tom&#39;
</span><span class='kw'>end</span></code></pre>

<p>Atomic operations described in this section apply to one document at a time,
therefore nesting <code>#atomically</code> blocks invoked on multiple documents does
not make changes to the different documents be persisted atomically together.
However, MongoDB offers <code>multi-document transactions &lt;transactions&gt;</code>
as of server version 4.0 which provide atomic persistence across multiple
documents.</p>

<h2>Reloading</h2>

<p>Use the <code>reload</code> method to fetch the most recent version of a document from
the database. Any unsaved modifications to the document&#39;s attributes are lost:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; #&lt;Band _id: 6206d06de1b8324561f179c9, name: &quot;foo&quot;, description: nil, likes: nil&gt;
</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>bar</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_band'>band</span>
<span class='comment'># =&gt; #&lt;Band _id: 6206d06de1b8324561f179c9, name: &quot;bar&quot;, description: nil, likes: nil&gt;
</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_reload'>reload</span>
<span class='comment'># =&gt; #&lt;Band _id: 6206d06de1b8324561f179c9, name: &quot;foo&quot;, description: nil, likes: nil&gt;</span></code></pre>

<p>When a document is reloaded, all of its embedded associations are also reloaded
in the same query (since embedded documents are stored in the parent document
on the server). If a document has referenced associations, the loaded
associations&#39; are not reloaded but their values are cleared, such that these
associations would be loaded from the database at the next access.</p>

<div class="note" markdown="1">

<div class="title" markdown="1">

Note

</div>

<p>Some operations on associations, for example assignment, persists the new
document. In these cases there may not be any unsaved modifications to
revert by reloading. In the following example, the assignment of the
empty array to the association is immediately persisted and reloading
does not make any changes to the document:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Assuming band has many tours, which could be referenced:
</span><span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>tours:</span> [<span class='const'>Tour</span>.<span class='id identifier rubyid_create!'>create!</span>])
<span class='comment'># ... or embedded:
</span><span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>tours:</span> [<span class='const'>Tour</span>.<span class='id identifier rubyid_new'>new</span>])

<span class='comment'># This writes the empty tour list into the database.
</span><span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_tours'>tours</span> <span class='op'>=</span> []

<span class='comment'># There are no unsaved modifications in band at this point to be reverted.
</span><span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_reload'>reload</span>

<span class='comment'># Returns the empty array since this is what is in the database.
</span><span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_tours'>tours</span>
<span class='comment'># =&gt; []</span></code></pre>

<p></div></p>

<p>If the model has a <code>shard key &lt;shard-keys&gt;</code> defined, the shard key value
is included in the reloading query.</p>

<p>If the database does not contain a matching document, Mongoid normally raises
<a href="Mongoid/Errors/DocumentNotFound.html" title="Mongoid::Errors::DocumentNotFound (class)"><code>::Mongoid::Errors::DocumentNotFound</code></a>. However, if the configuration option
<code>raise_not_found_error</code> is set to <code>false</code>, and the database does not
contain a matching document, Mongoid replaces the current document with a newly
created document whose attributes are set to default values. Importantly, this
generally causes the <code>_id</code> of the document to change, as the following
example demonstrates:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>
<span class='comment'># =&gt; #&lt;Band _id: 6206d00de1b8324561f179c7, name: &quot;foo&quot;, description: nil, likes: nil&gt;
</span>
<span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span>.<span class='id identifier rubyid_raise_not_found_error'>raise_not_found_error</span> <span class='op'>=</span> <span class='kw'>false</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_destroy'>destroy</span>

<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_reload'>reload</span>
<span class='comment'># =&gt; #&lt;Band _id: 6206d031e1b8324561f179c8, name: nil, description: nil, likes: nil&gt;</span></code></pre>

<p>For this reason, it is not recommended to use <code>reload</code> when
<code>raise_not_found_error</code> is set to <code>false</code>.</p>

<h3>Reloading Unsaved Documents</h3>

<p><code>reload</code> can be called when the document has not yet been persisted.
In this case <code>reload</code> performs a <code>find</code> query using the <code>id</code> value
specified in the document (and the shard key value, if a shard key is defined):</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_existing'>existing</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_create!'>create!</span>(<span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Photek</span><span class='tstring_end'>&#39;</span></span>)

<span class='comment'># Unsaved document
</span><span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_new'>new</span>(<span class='label'>id:</span> <span class='id identifier rubyid_existing'>existing</span>.<span class='id identifier rubyid_id'>id</span>)
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_reload'>reload</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_name'>name</span>
<span class='comment'># =&gt; &quot;Photek&quot;</span></code></pre>

<h2>Accessing Field Values</h2>

<p>Mongoid provides several ways of accessing field values.</p>

<div class="note" markdown="1">

<div class="title" markdown="1">

Note

</div>

<p>All of the access methods described below raise
<a href="Mongoid/Errors/AttributeNotLoaded.html" title="Mongoid::Errors::AttributeNotLoaded (class)"><code>::Mongoid::Errors::AttributeNotLoaded</code></a> when the field being accessed is
<code>projected out &lt;projection&gt;</code>, either by virtue of not being included in
<code>only &lt;only&gt;</code> or by virtue of being included in
<code>without &lt;without&gt;</code>. This applies to both reads and writes.</p>

<p></div></p>

<h3>Getters &amp; Setters</h3>

<p>The recommended way is to use the getter and setter methods generated for
each declared field:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Person</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_first_name'>first_name</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_person'>person</span> <span class='op'>=</span> <span class='const'>Person</span>.<span class='id identifier rubyid_new'>new</span>

<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_first_name'>first_name</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Artem</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_first_name'>first_name</span>
<span class='comment'># =&gt; &quot;Artem&quot;</span></code></pre>

<p>To use this mechanism, each field must be explicitly declared, or the
model class must enable <code>dynamic fields &lt;dynamic-fields&gt;</code>.</p>

<h3>Custom Getters &amp; Setters</h3>

<p>It is possible to explicitly define the getter and setter methods to provide
custom behavior when reading or writing fields, for example value
transformations or storing values under different field names. In this case
<code>read_attribute</code> and <code>write_attribute</code> methods can be used to read and
write the values directly into the attributes hash:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Person</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='kw'>def</span> <span class='id identifier rubyid_first_name'>first_name</span>
    <span class='id identifier rubyid_read_attribute'>read_attribute</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_fn'>fn</span>)
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_first_name='>first_name=</span>(<span class='id identifier rubyid_value'>value</span>)
    <span class='id identifier rubyid_write_attribute'>write_attribute</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_fn'>fn</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span>)
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_person'>person</span> <span class='op'>=</span> <span class='const'>Person</span>.<span class='id identifier rubyid_new'>new</span>

<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_first_name'>first_name</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Artem</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_first_name'>first_name</span>
<span class='comment'># =&gt; &quot;Artem&quot;
</span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_attributes'>attributes</span>
<span class='comment'># =&gt; {&quot;_id&quot;=&gt;BSON::ObjectId(&#39;606477dc2c97a628cf47075b&#39;), &quot;fn&quot;=&gt;&quot;Artem&quot;}</span></code></pre>

<div class="note" markdown="1">

<div class="title" markdown="1">

Note

</div>

<p>The custom setters are called during the assignment of
<code>nested attributes &lt;nested-attributes&gt;</code>, however they are called before
the associations are set up. Because of this, associations may not always
be available during these methods, and it is encouraged to include checks
for their presence whenever referring to them. <code>Callbacks &lt;callbacks&gt;</code>
can also be used to perform operations on certain events, and associations
will have already been setup and are available during their execution.</p>

<p></div></p>

<h3><code>read_attribute</code> &amp; <code>write_attribute</code> [read-write-attribute]</h3>

<p>The <code>read_attribute</code> and <code>write_attribute</code> methods can be used explicitly
as well. Note that if a field specifies its <code>storage field name
&lt;storage-field-names&gt;</code>, both <code>read_attribute</code> and <code>write_attribute</code>
accept either the declared field name or the storage field name for operations:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Person</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_first_name'>first_name</span><span class='comma'>,</span> <span class='label'>as:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_fn'>fn</span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_last_name'>last_name</span><span class='comma'>,</span> <span class='label'>as:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_ln'>ln</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_person'>person</span> <span class='op'>=</span> <span class='const'>Person</span>.<span class='id identifier rubyid_new'>new</span>(<span class='label'>first_name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Artem</span><span class='tstring_end'>&quot;</span></span>)
<span class='comment'># =&gt; #&lt;Person _id: 60647a522c97a6292c195b4b, first_name(fn): &quot;Artem&quot;, last_name(ln): nil&gt;
</span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_read_attribute'>read_attribute</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_first_name'>first_name</span>)
<span class='comment'># =&gt; &quot;Artem&quot;
</span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_read_attribute'>read_attribute</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_fn'>fn</span>)
<span class='comment'># =&gt; &quot;Artem&quot;
</span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_write_attribute'>write_attribute</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_last_name'>last_name</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Pushkin</span><span class='tstring_end'>&quot;</span></span>)
<span class='id identifier rubyid_person'>person</span>
<span class='comment'># =&gt; #&lt;Person _id: 60647a522c97a6292c195b4b, first_name(fn): &quot;Artem&quot;, last_name(ln): &quot;Pushkin&quot;&gt;
</span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_write_attribute'>write_attribute</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_ln'>ln</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Medvedev</span><span class='tstring_end'>&quot;</span></span>)
<span class='id identifier rubyid_person'>person</span>
<span class='comment'># =&gt; #&lt;Person _id: 60647a522c97a6292c195b4b, first_name(fn): &quot;Artem&quot;, last_name(ln): &quot;Medvedev&quot;&gt;</span></code></pre>

<p><code>read_attribute</code> and <code>write_attribute</code> do not require that a field with
the used name is defined, but writing field values with <code>write_attribute</code>
does not cause the respective field to be defined either:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_write_attribute'>write_attribute</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_undefined'>undefined</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello</span><span class='tstring_end'>&quot;</span></span>)
<span class='id identifier rubyid_person'>person</span>
<span class='comment'># =&gt; #&lt;Person _id: 60647b212c97a6292c195b4c, first_name(fn): &quot;Artem&quot;, last_name(ln): &quot;Medvedev&quot;&gt;
</span><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_attributes'>attributes</span>
<span class='comment'># =&gt; {&quot;_id&quot;=&gt;BSON::ObjectId(&#39;60647b212c97a6292c195b4c&#39;), &quot;first_name&quot;=&gt;&quot;Artem&quot;, &quot;last_name&quot;=&gt;&quot;Medvedev&quot;, &quot;undefined&quot;=&gt;&quot;Hello&quot;}
</span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_read_attribute'>read_attribute</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_undefined'>undefined</span>)
<span class='comment'># =&gt; &quot;Hello&quot;
</span><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_undefined'>undefined</span>
<span class='comment'># raises NoMethodError</span></code></pre>

<p>When <code>read_attribute</code> is used to access a missing field, it returns <code>nil</code>.</p>

<h3>Hash Access</h3>

<p>Mongoid model instances define the <code>[]</code> and <code>[]=</code> methods to provide
<a href="Hash.html" title="Hash (class)"><code>Hash</code></a> style access to the attributes. <code>[]</code> is an alias for
<code>read_attribute</code> and <code>[]=</code> is an alias for <code>write_attribute</code>; see
the section on <code>read_attribute and write_attribute &lt;read-write-attribute&gt;</code>
for the detailed description of their behavior.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Person</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_first_name'>first_name</span><span class='comma'>,</span> <span class='label'>as:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_fn'>fn</span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_last_name'>last_name</span><span class='comma'>,</span> <span class='label'>as:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_ln'>ln</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_person'>person</span> <span class='op'>=</span> <span class='const'>Person</span>.<span class='id identifier rubyid_new'>new</span>(<span class='label'>first_name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Artem</span><span class='tstring_end'>&quot;</span></span>)

<span class='id identifier rubyid_person'>person</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>fn</span><span class='tstring_end'>&quot;</span></span>]
<span class='comment'># =&gt; &quot;Artem&quot;
</span>
<span class='id identifier rubyid_person'>person</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_first_name'>first_name</span>]
<span class='comment'># =&gt; &quot;Artem&quot;
</span>
<span class='id identifier rubyid_person'>person</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_ln'>ln</span>] <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Medvedev</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_person'>person</span>
<span class='comment'># =&gt; #&lt;Person _id: 606483742c97a629bdde5cfc, first_name(fn): &quot;Artem&quot;, last_name(ln): &quot;Medvedev&quot;&gt;
</span>
<span class='id identifier rubyid_person'>person</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>last_name</span><span class='tstring_end'>&quot;</span></span>] <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Pushkin</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_person'>person</span>
<span class='comment'># =&gt; #&lt;Person _id: 606483742c97a629bdde5cfc, first_name(fn): &quot;Artem&quot;, last_name(ln): &quot;Pushkin&quot;&gt;</span></code></pre>

<h3>Bulk Attribute Writes</h3>

<p>In cases where you want to set multiple field values at once, there are a few
different ways of accomplishing this as well.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Get the field values as a hash.
</span><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_attributes'>attributes</span>

<span class='comment'># Set the field values in the document.
</span><span class='const'>Person</span>.<span class='id identifier rubyid_new'>new</span>(<span class='label'>first_name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Jean-Baptiste</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>middle_name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Emmanuel</span><span class='tstring_end'>&quot;</span></span>)
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_attributes'>attributes</span> <span class='op'>=</span> { <span class='label'>first_name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Jean-Baptiste</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>middle_name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Emmanuel</span><span class='tstring_end'>&quot;</span></span> }
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_write_attributes'>write_attributes</span>(
  <span class='label'>first_name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Jean-Baptiste</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>
  <span class='label'>middle_name:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Emmanuel</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>
)</code></pre>

<h2>Dirty Tracking</h2>

<p>Mongoid supports tracking of changed or &quot;dirty&quot; fields with an API that mirrors that of
Active Model. If a defined field has been modified in a model the model will be marked as
dirty and some additional behavior comes into play.</p>

<h3>Viewing Changes</h3>

<p>There are various ways to view what has been altered on a model. Changes are recorded
from the time a document is instantiated, either as a new document or via loading from
the database up to the time it is saved. Any persistence operation clears the changes.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Person</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
<span class='kw'>end</span>

<span class='id identifier rubyid_person'>person</span> <span class='op'>=</span> <span class='const'>Person</span>.<span class='id identifier rubyid_first'>first</span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Alan Garner</span><span class='tstring_end'>&quot;</span></span>

<span class='comment'># Check to see if the document has changed.
</span><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_changed?'>changed?</span> <span class='comment'># true
</span>
<span class='comment'># Get an array of the names of the changed fields.
</span><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_changed'>changed</span> <span class='comment'># [ :name ]
</span>
<span class='comment'># Get a hash of the old and changed values for each field.
</span><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_changes'>changes</span> <span class='comment'># { &quot;name&quot; =&gt; [ &quot;Alan Parsons&quot;, &quot;Alan Garner&quot; ] }
</span>
<span class='comment'># Check if a specific field has changed.
</span><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_name_changed?'>name_changed?</span> <span class='comment'># true
</span>
<span class='comment'># Get the changes for a specific field.
</span><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_name_change'>name_change</span> <span class='comment'># [ &quot;Alan Parsons&quot;, &quot;Alan Garner&quot; ]
</span>
<span class='comment'># Get the previous value for a field.
</span><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_name_was'>name_was</span> <span class='comment'># &quot;Alan Parsons&quot;</span></code></pre>

<div class="note" markdown="1">

<div class="title" markdown="1">

Note

</div>

<p>Setting the associations on a document does not cause the <code>changes</code> or
<code>changed_attributes</code> hashes to be modified. This is true for all associations
whether referenced or embedded. Note that changing the _id(s) field on
referenced associations does cause the changes to show up in the <code>changes</code>
and the <code>changed_attributes</code> hashes.</p>

<p></div></p>

<h3>Resetting Changes</h3>

<p>You can reset changes of a field to its previous value by calling the reset method.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_person'>person</span> <span class='op'>=</span> <span class='const'>Person</span>.<span class='id identifier rubyid_first'>first</span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Alan Garner</span><span class='tstring_end'>&quot;</span></span>

<span class='comment'># Reset the changed name back to the original
</span><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_reset_name!'>reset_name!</span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_name'>name</span> <span class='comment'># &quot;Alan Parsons&quot;</span></code></pre>

<h3>Persistence</h3>

<p>Mongoid uses dirty tracking as the core of its persistence operations. It looks at the
changes on a document and atomically updates only what has changed, unlike other frameworks
that write the entire document on each save. If no changes have been made, Mongoid will
not hit the database on a call to <code>Model#save</code>.</p>

<h3>Viewing Previous Changes</h3>

<p>After a document has been persisted, you can see what the changes were previously by
calling <code>Model#previous_changes</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_person'>person</span> <span class='op'>=</span> <span class='const'>Person</span>.<span class='id identifier rubyid_first'>first</span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Alan Garner</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_save'>save</span> <span class='comment'># Clears out current changes.
</span>
<span class='comment'># View the previous changes.
</span><span class='id identifier rubyid_person'>person</span>.<span class='id identifier rubyid_previous_changes'>previous_changes</span> <span class='comment'># { &quot;name&quot; =&gt; [ &quot;Alan Parsons&quot;, &quot;Alan Garner&quot; ] }</span></code></pre>

<h2>Updating Container Fields</h2>

<p>Be aware that, until
<a href="https://jira.mongodb.org/browse/MONGOID-2951">MONGOID-2951</a>
is resolved, all fields including container ones must be assigned to for
their values to be persisted to the database.</p>

<p>For example, adding to a set like this does not work:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_tours'>tours</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Set.html" title="Set (class)">Set</a></span>
<span class='kw'>end</span>

<span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_tours'>tours</span>
<span class='comment'># =&gt; #&lt;Set: {}&gt;
</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_tours'>tours</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>London</span><span class='tstring_end'>&#39;</span></span>
<span class='comment'># =&gt; #&lt;Set: {&quot;London&quot;}&gt;
</span><span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_tours'>tours</span>
<span class='comment'># =&gt; #&lt;Set: {}&gt;</span></code></pre>

<p>Instead, the field value must be modified outside of the model and assigned
back to the model as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>

  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_tours'>tours</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="Set.html" title="Set (class)">Set</a></span>
<span class='kw'>end</span>

<span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_new'>new</span>

<span class='id identifier rubyid_tours'>tours</span> <span class='op'>=</span> <span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_tours'>tours</span>
<span class='comment'># =&gt; #&lt;Set: {}&gt;
</span>
<span class='id identifier rubyid_tours'>tours</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>London</span><span class='tstring_end'>&#39;</span></span>
<span class='comment'># =&gt; #&lt;Set: {&quot;London&quot;}&gt;
</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_tours'>tours</span> <span class='op'>=</span> <span class='id identifier rubyid_tours'>tours</span>
<span class='comment'># =&gt; #&lt;Set: {&quot;London&quot;}&gt;
</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_tours'>tours</span>
<span class='comment'># =&gt; #&lt;Set: {&quot;London&quot;}&gt;</span></code></pre>

<h2>Readonly Documents</h2>

<p>Documents can be marked read-only in two ways, depending on the value of the
<code>Mongoid.legacy_readonly</code> feature flag:</p>

<p>If this flag is turned off, a document is marked read-only when the <code>#readonly!</code>
method is called on that documnet. A read-only document, with this flag turned off,
will raise a ReadonlyDocument error on attempting to perform any persistence
operation, including (but not limited to) saving, updating, deleting and
destroying. Note that reloading does not reset the read-only state.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_first'>first</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_readonly?'>readonly?</span> <span class='comment'># =&gt; false
</span><span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_readonly!'>readonly!</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_readonly?'>readonly?</span> <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>The Rolling Stones</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_save'>save</span> <span class='comment'># =&gt; raises ReadonlyDocument error
</span><span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_reload'>reload</span>.<span class='id identifier rubyid_readonly?'>readonly?</span> <span class='comment'># =&gt; true</span></code></pre>

<p>If this flag is turned on, a document is marked read-only when that document
has been projected (i.e. using <code>#only</code> or <code>#without</code>). A read-only document,
with this flag turned on, will not be deletable or destroyable (a
<code>ReadonlyDocument</code> error will be raised), but will be saveable and updatable.
The read-only status is reset on reloading the document.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_genre'>genre</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
<span class='kw'>end</span>

<span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_only'>only</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span>).<span class='id identifier rubyid_first'>first</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_readonly?'>readonly?</span> <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_destroy'>destroy</span> <span class='comment'># =&gt; raises ReadonlyDocument error
</span><span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_reload'>reload</span>.<span class='id identifier rubyid_readonly?'>readonly?</span> <span class='comment'># =&gt; false</span></code></pre>

<h3>Overriding <code>readonly?</code></h3>

<p>Another way to make a document read-only is by overriding the readonly? method:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Band</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><a href="Mongoid.html" title="Mongoid (module)">Mongoid</a></span><span class='op'>::</span><span class='const'><a href="Mongoid/Document.html" title="Mongoid::Document (module)">Document</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>
  <span class='id identifier rubyid_field'>field</span> <span class='symbeg'>:</span><span class='id identifier rubyid_genre'>genre</span><span class='comma'>,</span> <span class='label'>type:</span> <span class='const'><a href="String.html" title="String (class)">String</a></span>

  <span class='kw'>def</span> <span class='id identifier rubyid_readonly?'>readonly?</span>
    <span class='kw'>true</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_band'>band</span> <span class='op'>=</span> <span class='const'>Band</span>.<span class='id identifier rubyid_first'>first</span>
<span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_readonly?'>readonly?</span> <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_band'>band</span>.<span class='id identifier rubyid_destroy'>destroy</span> <span class='comment'># =&gt; raises ReadonlyDocument error</span></code></pre>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>