<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Namespace &mdash; Ruby-master</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "namespace",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Ruby-master</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Namespace&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="file_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<h1>Namespace - Ruby&#39;s in-process separation of Classes and Modules</h1>

<p>Namespace is designed to provide separated spaces in a Ruby process, to isolate applications and libraries.</p>

<h2>Known issues</h2>

<ul>
<li>Experimental warning is shown when ruby starts with <code>RUBY_NAMESPACE=1</code> (specify <code>-W:no-experimental</code> option to hide it)</li>
<li><code>bundle install</code> may fail</li>
<li><code>require &#39;active_support&#39;</code> may fail</li>
<li>A wrong current namespace detection happens sometimes in the root namespace</li>
</ul>

<h2>TODOs</h2>

<ul>
<li>Identify the CI failure cause and restore temporarily skipped tests (mmtk, test/ruby/test_allocation on i686)</li>
<li>Reconstruct current/loading namespace management based on control frames</li>
<li>Add the loaded namespace on iseq to check if another namespace tries running the iseq (add a field only when VM_CHECK_MODE?)</li>
<li>Delete per-namespace extension files (.so) lazily or process exit</li>
<li>Collect rb_classext_t entries for a namespace when the namespace is collected</li>
<li>Allocate an rb_namespace_t entry as the root namespace at first, then construct the contents and wrap it as rb_cNamespace instance later (to eliminate root/builtin two namespaces situation)</li>
<li>Assign its own TOPLEVEL_BINDING in namespaces</li>
<li>Fix <code>warn</code> in namespaces to refer <code>$VERBOSE</code> in the namespace</li>
<li>Make an internal data container <code>Namespace::Entry</code> invisible</li>
<li>More test cases about <code>$LOAD_PATH</code> and <code>$LOADED_FEATURES</code></li>
<li>Return classpath and nesting without the namespace prefix in the namespace itself <a href="https://bugs.ruby-lang.org/issues/21316">#21316</a>, <a href="https://bugs.ruby-lang.org/issues/21318">#21318</a></li>
</ul>

<h2>How to use</h2>

<h3>Enabling namespace</h3>

<p>First, an environment variable should be set at the ruby process bootup: <code>RUBY_NAMESPACE=1</code>.
The only valid value is <code>1</code> to enable namespace. Other values (or unset <code>RUBY_NAMESPACE</code>) means disabling namespace. And setting the value after Ruby program starts doesn&#39;t work.</p>

<h3>Using namespace</h3>

<p><code>Namespace</code> class is the entrypoint of namespaces.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ns'>ns</span> <span class='op'>=</span> <span class='const'>Namespace</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_ns'>ns</span>.<span class='id identifier rubyid_require'>require</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>something</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># or require_relative, load</span></code></pre>

<p>The required file (either .rb or .so/.dll/.bundle) is loaded in the namespace (<code>ns</code> here). The required/loaded files from <code>something</code> will be loaded in the namespace recursively.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># something.rb
</span>
<span class='const'>X</span> <span class='op'>=</span> <span class='int'>1</span>

<span class='kw'>class</span> <span class='const'>Something</span>
  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_x'>x</span> <span class='op'>=</span> <span class='const'>X</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_x'>x</span> <span class='op'>=</span> <span class='op'>::</span><span class='const'>X</span>
<span class='kw'>end</span></code></pre>

<p>Classes/modules, those methods and constants defined in the namespace can be accessed via <code>ns</code> object.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_ns'>ns</span><span class='op'>::</span><span class='const'>Something</span>.<span class='id identifier rubyid_x'>x</span>  <span class='comment'># 1
</span>
<span class='const'>X</span> <span class='op'>=</span> <span class='int'>2</span>
<span class='id identifier rubyid_p'>p</span> <span class='const'>X</span>                <span class='comment'># 2
</span><span class='id identifier rubyid_p'>p</span> <span class='op'>::</span><span class='const'>X</span>              <span class='comment'># 2
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_ns'>ns</span><span class='op'>::</span><span class='const'>Something</span>.<span class='id identifier rubyid_x'>x</span>  <span class='comment'># 1
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_ns'>ns</span><span class='op'>::</span><span class='const'>X</span>            <span class='comment'># 1</span></code></pre>

<p>Instance methods defined in the namespace also run with definitions in the namespace.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='id identifier rubyid_ns'>ns</span><span class='op'>::</span><span class='const'>Something</span>.<span class='id identifier rubyid_new'>new</span>

<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_s'>s</span>.<span class='id identifier rubyid_x'>x</span>  <span class='comment'># 1</span></code></pre>

<h2>Specifications</h2>

<h3>Namespace types</h3>

<p>There are two namespace types:</p>

<ul>
<li>Root namespace</li>
<li>User namespace</li>
</ul>

<p>There is the root namespace, just a single namespace in a Ruby process. Ruby bootstrap runs in the root namespace, and all builtin classes/modules are defined in the root namespace. (See &quot;Builtin classes and modules&quot;.)</p>

<p>User namespaces are to run user-written programs and libraries loaded from user programs. The user&#39;s main program (specified by the <code>ruby</code> command line argument) is executed in the &quot;main&quot; namespace, which is a user namespace automatically created at the end of Ruby&#39;s bootstrap, copied from the root namespace.</p>

<p>When <code>Namespace.new</code> is called, an &quot;optional&quot; namespace (a user, non-main namespace) is created, copied from the root namespace. All user namespaces are flat, copied from the root namespace.</p>

<h3>Namespace class and instances</h3>

<p><code>Namespace</code> is a top level class, as a subclass of <code>Module</code>, and <code>Namespace</code> instances are a kind of <code>Module</code>.</p>

<h3>Classes and modules defined in namespace</h3>

<p>The classes and modules, newly defined in a namespace <code>ns</code>, are defined under <code>ns</code>. For example, if a class <code>A</code> is defined in <code>ns</code>, it is actually defined as <code>ns::A</code>.</p>

<p>In the namespace <code>ns</code>, <code>ns::A</code> can be referred to as <code>A</code> (and <code>::A</code>). From outside of <code>ns</code>, it can be referred to as <code>ns::A</code>.</p>

<p>The main namespace is exceptional. Top level classes and modules defined in the main namespace are just top level classes and modules.</p>

<h3>Classes and modules reopened in namespace</h3>

<p>In namespaces, builtin classes/modules are visible and can be reopened. Those classes/modules can be reopened using <code>class</code> or <code>module</code> clauses, and class/module definitions can be changed.</p>

<p>The changed definitions are visible only in the namespace. In other namespaces, builtin classes/modules and those instances work without changed definitions.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># in foo.rb
</span><span class='kw'>class</span> <span class='const'>String</span>
  <span class='const'>BLANK_PATTERN</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A\s*\z</span><span class='regexp_end'>/</span></span>
  <span class='kw'>def</span> <span class='id identifier rubyid_blank?'>blank?</span>
    <span class='kw'>self</span> <span class='op'>=~</span> <span class='const'>BLANK_PATTERN</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='kw'>module</span> <span class='const'>Foo</span>
  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_foo'>foo</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>

  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_foo_is_blank?'>foo_is_blank?</span>
    <span class='id identifier rubyid_foo'>foo</span>.<span class='id identifier rubyid_blank?'>blank?</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='const'>Foo</span>.<span class='id identifier rubyid_foo'>foo</span>.<span class='id identifier rubyid_blank?'>blank?</span> <span class='comment'>#=&gt; false
</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_blank?'>blank?</span>   <span class='comment'>#=&gt; false
</span>
<span class='comment'># in main.rb
</span><span class='id identifier rubyid_ns'>ns</span> <span class='op'>=</span> <span class='const'>Namespace</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_ns'>ns</span>.<span class='id identifier rubyid_require'>require</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)

<span class='const'>Foo</span>.<span class='id identifier rubyid_foo_is_blank?'>foo_is_blank?</span> <span class='comment'>#=&gt; false   (#blank? called in ns)
</span>
<span class='const'>Foo</span>.<span class='id identifier rubyid_foo'>foo</span>.<span class='id identifier rubyid_blank?'>blank?</span>    <span class='comment'># NoMethodError
</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_blank?'>blank?</span>      <span class='comment'># NoMethodError
</span><span class='const'>String</span><span class='op'>::</span><span class='const'>BLANK_PATTERN</span> <span class='comment'># NameError</span></code></pre>

<p>The main namespace and <code>ns</code> are different namespaces, so monkey patches in main are also invisible in <code>ns</code>.</p>

<h3>Builtin classes and modules</h3>

<p>In the namespace context, &quot;builtin&quot; classes and modules are classes and modules:</p>

<ul>
<li>Accessible without any <code>require</code> calls in user scripts</li>
<li>Defined before any user program start running</li>
<li>Including classes/modules loaded by <code>prelude.rb</code> (including RubyGems <code>Gem</code>, for example)</li>
</ul>

<p>Hereafter, &quot;builtin classes and modules&quot; will be referred to as just &quot;builtin classes&quot;.</p>

<h3>Builtin classes referred via namespace objects</h3>

<p>Builtin classes in a namespace <code>ns</code> can be referred from other namespace. For example, <code>ns::String</code> is a valid reference, and <code>String</code> and <code>ns::String</code> are identical (<code>String == ns::String</code>, <code>String.object_id == ns::String.object_id</code>).</p>

<p><code>ns::String</code>-like reference returns just a <code>String</code> in the current namespace, so its definition is <code>String</code> in the namespace, not in <code>ns</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># foo.rb
</span><span class='kw'>class</span> <span class='const'>String</span>
  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_foo'>foo</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>

<span class='comment'># main.rb
</span><span class='id identifier rubyid_ns'>ns</span> <span class='op'>=</span> <span class='const'>Namespace</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_ns'>ns</span>.<span class='id identifier rubyid_require'>require</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)

<span class='id identifier rubyid_ns'>ns</span><span class='op'>::</span><span class='const'>String</span>.<span class='id identifier rubyid_foo'>foo</span>  <span class='comment'># NoMethodError</span></code></pre>

<h3>Class instance variables, class variables, constants</h3>

<p>Builtin classes can have different sets of class instance variables, class variables and constants between namespaces.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># foo.rb
</span><span class='kw'>class</span> <span class='const'>Array</span>
  <span class='ivar'>@v</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>
  <span class='cvar'>@@v</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_foo_</span><span class='tstring_end'>&quot;</span></span>
  <span class='const'>V</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>FOO</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>

<span class='const'>Array</span>.<span class='id identifier rubyid_instance_variable_get'>instance_variable_get</span>(<span class='symbeg'>:</span><span class='ivar'>@v</span>) <span class='comment'>#=&gt; &quot;foo&quot;
</span><span class='const'>Array</span>.<span class='id identifier rubyid_class_variable_get'>class_variable_get</span>(<span class='symbeg'>:</span><span class='cvar'>@@v</span>)   <span class='comment'>#=&gt; &quot;_foo_&quot;
</span><span class='const'>Array</span>.<span class='id identifier rubyid_const_get'>const_get</span>(<span class='symbeg'>:</span><span class='const'>V</span>)              <span class='comment'>#=&gt; &quot;FOO&quot;
</span>
<span class='comment'># main.rb
</span><span class='id identifier rubyid_ns'>ns</span> <span class='op'>=</span> <span class='const'>Namespace</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_ns'>ns</span>.<span class='id identifier rubyid_require'>require</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)

<span class='const'>Array</span>.<span class='id identifier rubyid_instance_variable_get'>instance_variable_get</span>(<span class='symbeg'>:</span><span class='ivar'>@v</span>) <span class='comment'>#=&gt; nil
</span><span class='const'>Array</span>.<span class='id identifier rubyid_class_variable_get'>class_variable_get</span>(<span class='symbeg'>:</span><span class='cvar'>@@v</span>)   <span class='comment'># NameError
</span><span class='const'>Array</span>.<span class='id identifier rubyid_const_get'>const_get</span>(<span class='symbeg'>:</span><span class='const'>V</span>)              <span class='comment'># NameError</span></code></pre>

<h3>Global variables</h3>

<p>In namespaces, changes on global variables are also isolated in the namespace. Changes on global variables in a namespace are visible/applied only in the namespace.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># foo.rb
</span><span class='gvar'>$foo</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>
<span class='gvar'>$VERBOSE</span> <span class='op'>=</span> <span class='kw'>nil</span>

<span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>This appears: &#39;</span><span class='embexpr_beg'>#{</span><span class='gvar'>$foo</span><span class='embexpr_end'>}</span><span class='tstring_content'>&#39;</span><span class='tstring_end'>&quot;</span></span>

<span class='comment'># main.rb
</span><span class='id identifier rubyid_p'>p</span> <span class='gvar'>$foo</span>      <span class='comment'>#=&gt; nil
</span><span class='id identifier rubyid_p'>p</span> <span class='gvar'>$VERBOSE</span>  <span class='comment'>#=&gt; false
</span>
<span class='id identifier rubyid_ns'>ns</span> <span class='op'>=</span> <span class='const'>Namespace</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_ns'>ns</span>.<span class='id identifier rubyid_require'>require</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)  <span class='comment'># &quot;This appears: &#39;foo&#39;&quot;
</span>
<span class='id identifier rubyid_p'>p</span> <span class='gvar'>$foo</span>      <span class='comment'>#=&gt; nil
</span><span class='id identifier rubyid_p'>p</span> <span class='gvar'>$VERBOSE</span>  <span class='comment'>#=&gt; false</span></code></pre>

<h3>Top level constants</h3>

<p>Usually, top level constants are defined as constants of <code>Object</code>. In namespaces, top level constants are constants of <code>Object</code> in the namespace. And the namespace object <code>ns</code>&#39;s constants are strictly equal to constants of <code>Object</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># foo.rb
</span><span class='const'>FOO</span> <span class='op'>=</span> <span class='int'>100</span>

<span class='const'>FOO</span>         <span class='comment'>#=&gt; 100
</span><span class='const'>Object</span><span class='op'>::</span><span class='const'>FOO</span> <span class='comment'>#=&gt; 100
</span>
<span class='comment'># main.rb
</span><span class='id identifier rubyid_ns'>ns</span> <span class='op'>=</span> <span class='const'>Namespace</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_ns'>ns</span>.<span class='id identifier rubyid_require'>require</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)

<span class='id identifier rubyid_ns'>ns</span><span class='op'>::</span><span class='const'>FOO</span>      <span class='comment'>#=&gt; 100
</span>
<span class='const'>FOO</span>          <span class='comment'># NameError
</span><span class='const'>Object</span><span class='op'>::</span><span class='const'>FOO</span>  <span class='comment'># NameError</span></code></pre>

<h3>Top level methods</h3>

<p>Top level methods are private instance methods of <code>Object</code>, in each namespace.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># foo.rb
</span><span class='kw'>def</span> <span class='id identifier rubyid_yay'>yay</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>

<span class='kw'>class</span> <span class='const'>Foo</span>
  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_say'>say</span> <span class='op'>=</span> <span class='id identifier rubyid_yay'>yay</span>
<span class='kw'>end</span>

<span class='const'>Foo</span>.<span class='id identifier rubyid_say'>say</span> <span class='comment'>#=&gt; &quot;foo&quot;
</span><span class='id identifier rubyid_yay'>yay</span>     <span class='comment'>#=&gt; &quot;foo&quot;
</span>
<span class='comment'># main.rb
</span><span class='id identifier rubyid_ns'>ns</span> <span class='op'>=</span> <span class='const'>Namespace</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_ns'>ns</span>.<span class='id identifier rubyid_require'>require</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)

<span class='id identifier rubyid_ns'>ns</span>.<span class='const'>Foo</span>.<span class='id identifier rubyid_say'>say</span>  <span class='comment'>#=&gt; &quot;foo&quot;
</span>
<span class='id identifier rubyid_yay'>yay</span>  <span class='comment'># NoMethodError</span></code></pre>

<p>There is no way to expose top level methods in namespaces to another namespace.
(See &quot;Expose top level methods as a method of the namespace object&quot; in &quot;Discussions&quot; section below)</p>

<h3>Namespace scopes</h3>

<p>Namespace works in file scope. One <code>.rb</code> file runs in a single namespace.</p>

<p>Once a file is loaded in a namespace <code>ns</code>, all methods/procs defined/created in the file run in <code>ns</code>.</p>

<h2>Implementation details</h2>

<h4>Object Shapes</h4>

<p>Once builtin classes are copied and modified in namespaces, its instance variable management fallbacks from Object Shapes to a traditional iv table (st_table) because RClass stores the shape in its <code>flags</code>, not in <code>rb_classext_t</code>.</p>

<h4>Size of RClass and rb_classext_t</h4>

<p>Namespace requires to move some fields from RClass to <code>rb_classext_t</code>, then the size of RClass and <code>rb_classext_t</code> is now larger than <code>4 * RVALUE_SIZE</code>. It&#39;s against the expectation of <a href="https://rubykaigi.org/2021-takeout/presentations/peterzhu2118.html">Variable Width Allocation</a>.</p>

<p>Now the <code>STATIC_ASSERT</code> to check the size is commented-out. (See &quot;Minimize the size of RClass and rb_classext_t&quot; in &quot;Discussion&quot; section below)</p>

<h4>ISeq inline method/constant cache</h4>

<p>As described above in &quot;Namespace scopes&quot;, an &quot;.rb&quot; file runs in a namespace. So method/constant resolution will be done in a namespace consistently.</p>

<p>That means ISeq inline caches work well even with namespaces. Otherwise, it&#39;s a bug.</p>

<h4>Method call global cache (gccct)</h4>

<p><code>rb_funcall()</code> C function refers to the global cc cache table (gccct), and the cache key is calculated with the current namespace.</p>

<p>So, <code>rb_funcall()</code> calls have a performance penalty when namespace is enabled.</p>

<h4>Current namespace and loading namespace</h4>

<p>The current namespace is the namespace that the executing code is in. <code>Namespace.current</code> returns the current namespace object.</p>

<p>The loading namespace is an internally managed namespace to determine the namespace to load newly required/loaded files. For example, <code>ns</code> is the loading namespace when <code>ns.require(&quot;foo&quot;)</code> is called.</p>

<h2>Discussions</h2>

<h4>Namespace#inspect</h4>

<p>Currently, <code>Namespace#inspect</code> returns values like <code>&quot;#&lt;Namespace:0x00000001083a5660&gt;&quot;</code>. This results in the very redundant and poorly visible classpath outside the namespace.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># foo.rb
</span><span class='kw'>class</span> <span class='const'>C</span><span class='semicolon'>;</span> <span class='kw'>end</span>

<span class='comment'># main.rb
</span><span class='id identifier rubyid_ns'>ns</span> <span class='op'>=</span> <span class='const'>Namespace</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_ns'>ns</span>.<span class='id identifier rubyid_require'>require</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)

<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_ns'>ns</span><span class='op'>::</span><span class='const'>C</span> <span class='comment'># &quot;#&lt;Namespace:0x00000001083a5660&gt;::C&quot;</span></code></pre>

<p>And currently, if a namespace is assigned to a constant <code>NS1</code>, the classpath output will be <code>NS1::C</code>. But the namespace object can be brought to another namespace and the constant <code>NS1</code> in the namespace is something different. So the constant-based classpath for namespace is not safe basically.</p>

<p>So we should find a better format to show namespaces. Options are:</p>

<ul>
<li><code>NS1::C</code> (only when this namespace is created and assigned to NS1 in the current namespace)</li>
<li><code>#&lt;Namespace:user:1083a5660&gt;::C</code> (with namespace type and without preceding 0)</li>
<li>or something else</li>
</ul>

<h4>Namespace#eval</h4>

<p>Testing namespace features needs to create files to be loaded in namespaces. It&#39;s not easy nor casual.</p>

<p>If <code>Namespace</code> class has an instance method <code>#eval</code> to evaluate code in the namespace, it can be helpful.</p>

<h4>More builtin methods written in Ruby</h4>

<p>If namespace is enabled by default, builtin methods can be written in Ruby because it can&#39;t be overridden by users&#39; monkey patches. Builtin Ruby methods can be JIT-ed, and it could bring performance reward.</p>

<h4>Monkey patching methods called by builtin methods</h4>

<p>Builtin methods sometimes call other builtin methods. For example, <code>Hash#map</code> calls <code>Hash#each</code> to retrieve entries to be mapped. Without namespace, Ruby users can overwrite <code>Hash#each</code> and expect the behavior change of <code>Hash#map</code> as a result.</p>

<p>But with namespaces, <code>Hash#map</code> runs in the root namespace. Ruby users can define <code>Hash#each</code> only in user namespaces, so users cannot change <code>Hash#map</code>&#39;s behavior in this case. To achieve it, users should override both<code>Hash#map</code> and <code>Hash#each</code> (or only <code>Hash#map</code>).</p>

<p>It is a breaking change.</p>

<p>It&#39;s an option to change the behavior of methods in the root namespace to refer to definitions in user namespaces. But if we do so, that means we can&#39;t proceed with &quot;More builtin methods written in Ruby&quot;.</p>

<h4>Context of \$LOAD_PATH and \$LOADED_FEATURES</h4>

<p>Global variables <code>$LOAD_PATH</code> and <code>$LOADED_FEATURES</code> control <code>require</code> method behaviors. So those namespaces are determined by the loading namespace instead of the current namespace.</p>

<p>This could potentially conflict with the user&#39;s expectations. We should find the solution.</p>

<h4>Expose top level methods as a method of the namespace object</h4>

<p>Currently, top level methods in namespaces are not accessible from outside of the namespace. But there might be a use case to call other namespace&#39;s top level methods.</p>

<h4>Split root and builtin namespace</h4>

<p>NOTE: &quot;builtin&quot; namespace is a different one from the &quot;builtin&quot; namespace in the current implementation</p>

<p>Currently, the single &quot;root&quot; namespace is the source of classext CoW. And also, the &quot;root&quot; namespace can load additional files after starting main script evaluation by calling methods which contain lines like <code>require &quot;openssl&quot;</code>.</p>

<p>That means, user namespaces can have different sets of definitions according to when it is created.</p>

<pre class="code ruby"><code class="ruby">[<span class='id identifier rubyid_root'>root</span>]
 <span class='op'>|</span>
 <span class='op'>|</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span>[<span class='id identifier rubyid_main'>main</span>]
 <span class='op'>|</span>
 <span class='op'>|</span>(<span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>openssl</span><span class='tstring_end'>&quot;</span></span> <span class='id identifier rubyid_called'>called</span> <span class='kw'>in</span> <span class='id identifier rubyid_root'>root</span>)
 <span class='op'>|</span>
 <span class='op'>|</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span>[<span class='id identifier rubyid_ns1'>ns1</span>] <span class='id identifier rubyid_having'>having</span> <span class='const'>OpenSSL</span>
 <span class='op'>|</span>
 <span class='op'>|</span>(<span class='id identifier rubyid_remove_const'>remove_const</span> <span class='id identifier rubyid_called'>called</span> <span class='kw'>for</span> <span class='const'>OpenSSL</span> <span class='kw'>in</span> <span class='id identifier rubyid_root'>root</span>)
 <span class='op'>|</span>
 <span class='op'>|</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span>[<span class='id identifier rubyid_ns2'>ns2</span>] <span class='id identifier rubyid_without'>without</span> <span class='const'>OpenSSL</span></code></pre>

<p>This could cause unexpected behavior differences between user namespaces. It should NOT be a problem because user scripts which refer to <code>OpenSSL</code> should call <code>require &quot;openssl&quot;</code> by themselves.
But in the worst case, a script (without <code>require &quot;openssl&quot;</code>) runs well in <code>ns1</code>, but doesn&#39;t run in <code>ns2</code>. This situation looks like a &quot;random failure&quot; to users.</p>

<p>An option possible to prevent this situation is to have &quot;root&quot; and &quot;builtin&quot; namespaces.</p>

<ul>
<li>root

<ul>
<li>The namespace for the Ruby process bootstrap, then the source of CoW</li>
<li>After starting the main namespace, no code runs in this namespace</li>
</ul></li>
<li>builtin

<ul>
<li>The namespace copied from the root namespace at the same time with &quot;main&quot;</li>
<li>Methods and procs defined in the &quot;root&quot; namespace run in this namespace</li>
<li>Classes and modules required will be loaded in this namespace</li>
</ul></li>
</ul>

<p>This design realizes a consistent source of namespace CoW.</p>

<h4>Separate cc_tbl and callable_m_tbl, cvc_tbl for less classext CoW</h4>

<p>The fields of <code>rb_classext_t</code> contains several cache(-like) data, <code>cc_tbl</code>(callcache table), <code>callable_m_tbl</code>(table of resolved complemented methods) and <code>cvc_tbl</code>(class variable cache table).</p>

<p>The classext CoW is triggered when the contents of <code>rb_classext_t</code> are changed, including <code>cc_tbl</code>, <code>callable_m_tbl</code>, and <code>cvc_tbl</code>. But those three tables are changed by just calling methods or referring class variables. So, currently, classext CoW is triggered much more times than the original expectation.</p>

<p>If we can move those three tables outside of <code>rb_classext_t</code>, the number of copied <code>rb_classext_t</code> will be much less than the current implementation.</p>

<h4>Object Shapes per namespace</h4>

<p>Now the classext CoW requires RClass and <code>rb_classext_t</code> to fallback its instance variable management from Object Shapes to the traditional <code>st_table</code>. It may have a performance penalty.</p>

<p>If we can apply Object Shapes on <code>rb_classext_t</code> instead of <code>RClass</code>, per-namespace classext can have its own shapes, and it may be able to avoid the performance penalty.</p>

<h4>Minimize the size of RClass and rb_classext_t</h4>

<p>As described in &quot;Size of RClass and rb_classext_t&quot; section above, the size of RClass and <code>rb_classext_t</code> is currently larger than <code>4 * RVALUE_SIZE</code> (<code>20 * VALUE_SIZE</code>). Now the size is <code>23 * VALUE_SIZE + 7 bits</code>.</p>

<p>The fields possibly removed from <code>rb_classext_t</code> are:</p>

<ul>
<li><code>cc_tbl</code>, <code>callable_m_tbl</code>, <code>cvc_tbl</code> (See the section &quot;Separate cc_tbl and callable_m_tbl, cvc_tbl for less classext CoW&quot; above)</li>
<li><code>ns_super_subclasses</code>, <code>module_super_subclasses</code>

<ul>
<li><code>RCLASSEXT_SUBCLASSES(RCLASS_EXT_PRIME(RCLASSEXT_SUPER(klass)))->ns_subclasses</code> can replace it</li>
<li>These fields are used only in GC, how&#39;s the actual performance benefit?</li>
</ul></li>
</ul>

<p>If we can move or remove those fields, the size satisfies the assertion (<code>&lt;= 4 * RVALUE_SIZE</code>).</p>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>