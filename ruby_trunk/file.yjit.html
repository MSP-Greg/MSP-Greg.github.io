<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Yjit &mdash; Ruby-master</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "yjit",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Ruby-master</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Yjit&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="file_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<p align="center">
  <a href="https://yjit.org/" target="_blank" rel="noopener noreferrer">
    <img src="https://user-images.githubusercontent.com/224488/131155756-aa8fb528-a813-4dfd-99ac-8785c3d5eed7.png" width="400">
  </a>
</p>

<h1>YJIT - Yet Another Ruby JIT</h1>

<p>YJIT is a lightweight, minimalistic Ruby JIT built inside CRuby.
It lazily compiles code using a Basic Block Versioning (BBV) architecture.
YJIT is currently supported for macOS, Linux and BSD on x86-64 and arm64/aarch64 CPUs.
This project is open source and falls under the same license as CRuby.</p>

<p align="center"><b>
    If you're using YJIT in production, please
    <a href="mailto:maxime.chevalierboisvert@shopify.com">share your success stories with us!</a>
</b></p>

<p>If you wish to learn more about the approach taken, here are some conference talks and publications:</p>

<ul>
<li>MPLR 2023 talk: <a href="https://www.youtube.com/watch?v=pVRmPZcNUhc">Evaluating YJIT’s Performance in a Production Context: A Pragmatic Approach</a></li>
<li>RubyKaigi 2023 keynote: <a href="https://www.youtube.com/watch?v=X0JRhh8w_4I">Optimizing YJIT’s Performance, from Inception to Production</a></li>
<li>RubyKaigi 2023 keynote: <a href="https://www.youtube.com/watch?v=GI7vvAgP_Qs">Fitting Rust YJIT into CRuby</a></li>
<li>RubyKaigi 2022 keynote: <a href="https://www.youtube.com/watch?v=EMchdR9C8XM">Stories from developing YJIT</a></li>
<li>RubyKaigi 2022 talk: <a href="https://www.youtube.com/watch?v=BbLGqTxTRp0">Building a Lightweight IR and Backend for YJIT</a></li>
<li>RubyKaigi 2021 talk: <a href="https://www.youtube.com/watch?v=PBVLf3yfMs8">YJIT: Building a New JIT Compiler Inside CRuby</a></li>
<li>Blog post: <a href="https://pointersgonewild.com/2021/06/02/yjit-building-a-new-jit-compiler-inside-cruby/">YJIT: Building a New JIT Compiler Inside CRuby</a></li>
<li>MPLR 2023 paper: <a href="https://dl.acm.org/doi/10.1145/3617651.3622982">Evaluating YJIT’s Performance in a Production Context: A Pragmatic Approach</a></li>
<li>VMIL 2021 paper: <a href="https://dl.acm.org/doi/10.1145/3486606.3486781">YJIT: A Basic Block Versioning JIT Compiler for CRuby</a></li>
<li>MoreVMs 2021 talk: <a href="https://www.youtube.com/watch?v=vucLAqv7qpc">YJIT: Building a New JIT Compiler Inside CRuby</a></li>
<li>ECOOP 2016 talk: <a href="https://www.youtube.com/watch?v=sRNBY7Ss97A">Interprocedural Type Specialization of JavaScript Programs Without Type Analysis</a></li>
<li>ECOOP 2016 paper: <a href="https://drops.dagstuhl.de/opus/volltexte/2016/6101/pdf/LIPIcs-ECOOP-2016-7.pdf">Interprocedural Type Specialization of JavaScript Programs Without Type Analysis</a></li>
<li>ECOOP 2015 talk: <a href="https://www.youtube.com/watch?v=S-aHBuoiYE0">Simple and Effective Type Check Removal through Lazy Basic Block Versioning</a></li>
<li>ECOOP 2015 paper: <a href="https://arxiv.org/pdf/1411.0352.pdf">Simple and Effective Type Check Removal through Lazy Basic Block Versioning</a></li>
</ul>

<p>To cite YJIT in your publications, please cite the MPLR 2023 paper:</p>

<pre class="code BibTeX"><code class="BibTeX">@inproceedings{yjit_mplr_2023,
author = {Chevalier-Boisvert, Maxime and Kokubun, Takashi and Gibbs, Noah and Wu, Si Xing (Alan) and Patterson, Aaron and Issroff, Jemma},
title = {Evaluating YJIT’s Performance in a Production Context: A Pragmatic Approach},
year = {2023},
isbn = {9798400703805},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3617651.3622982},
doi = {10.1145/3617651.3622982},
booktitle = {Proceedings of the 20th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes},
pages = {20–33},
numpages = {14},
keywords = {dynamically typed, optimization, just-in-time, virtual machine, ruby, compiler, bytecode},
location = {Cascais, Portugal},
series = {MPLR 2023}
}
</code></pre>

<h2>Current Limitations</h2>

<p>YJIT may not be suitable for certain applications. It currently only supports macOS, Linux and BSD on x86-64 and arm64/aarch64 CPUs. YJIT will use more memory than the Ruby interpreter because the JIT compiler needs to generate machine code in memory and maintain additional state information.
You can change how much executable memory is allocated using <a href="#command-line-options">YJIT&#39;s command-line options</a>.</p>

<h2>Installation</h2>

<h3>Requirements</h3>

<p>You will need to install:</p>

<ul>
<li>All the usual build tools for Ruby. See <a href="file.building_ruby.html">Building Ruby</a></li>
<li>The Rust compiler <code>rustc</code>

<ul>
<li>The Rust version must be <a href="../../yjit/Cargo.toml">&gt;= 1.58.0</a>.</li>
</ul></li>
<li>Optionally, only if you wish to build in dev/debug mode, Rust&#39;s <code>cargo</code></li>
</ul>

<p>If you don&#39;t intend on making code changes to YJIT itself, we recommend
obtaining <code>rustc</code> through your OS&#39;s package manager since that
likely reuses the same vendor which provides the C toolchain.</p>

<p>If you will be changing YJIT&#39;s Rust code, we suggest using the
<a href="https://www.rust-lang.org/tools/install">first-party installation method</a> for Rust. Rust also provides
first class <a href="https://www.rust-lang.org/tools">support</a> for many source code editors.</p>

<h3>Building YJIT</h3>

<p>Start by cloning the <code>ruby/ruby</code> repository:</p>

<pre class="code sh"><code class="sh">git clone https://github.com/ruby/ruby yjit
cd yjit
</code></pre>

<p>The YJIT <code>ruby</code> binary can be built with either GCC or Clang. It can be built either in dev (debug) mode or in release mode. For maximum performance, compile YJIT in release mode with GCC. More detailed build instructions are provided in the <a href="https://github.com/ruby/ruby#how-to-build">Ruby README</a>.</p>

<pre class="code sh"><code class="sh"># Configure in release mode for maximum performance, build and install
./autogen.sh
./configure --enable-yjit --prefix=$HOME/.rubies/ruby-yjit --disable-install-doc
make -j &amp;&amp; make install
</code></pre>

<p>or</p>

<pre class="code sh"><code class="sh"># Configure in lower-performance dev (debug) mode for development, build and install
./autogen.sh
./configure --enable-yjit=dev --prefix=$HOME/.rubies/ruby-yjit --disable-install-doc
make -j &amp;&amp; make install
</code></pre>

<p>Dev mode includes extended YJIT statistics, but can be slow. For only statistics you can configure in stats mode:</p>

<pre class="code sh"><code class="sh"># Configure in extended-stats mode without slow runtime checks, build and install
./autogen.sh
./configure --enable-yjit=stats --prefix=$HOME/.rubies/ruby-yjit --disable-install-doc
make -j &amp;&amp; make install
</code></pre>

<p>On macOS, you may need to specify where to find some libraries:</p>

<pre class="code sh"><code class="sh"># Install dependencies
brew install openssl libyaml

# Configure in dev (debug) mode for development, build and install
./autogen.sh
./configure --enable-yjit=dev --prefix=$HOME/.rubies/ruby-yjit --disable-install-doc --with-opt-dir=&quot;$(brew --prefix openssl):$(brew --prefix readline):$(brew --prefix libyaml)&quot;
make -j &amp;&amp; make install
</code></pre>

<p>Typically configure will choose the default C compiler. To specify the C compiler, use</p>

<pre class="code sh"><code class="sh"># Choosing a specific c compiler
export CC=/path/to/my/chosen/c/compiler
</code></pre>

<p>before running <code>./configure</code>.</p>

<p>You can test that YJIT works correctly by running:</p>

<pre class="code sh"><code class="sh"># Quick tests found in /bootstraptest
make btest

# Complete set of tests
make -j test-all
</code></pre>

<h2>Usage</h2>

<h3>Examples</h3>

<p>Once YJIT is built, you can either use <code>./miniruby</code> from within your build directory, or switch to the YJIT version of <code>ruby</code>
by using the <code>chruby</code> tool:</p>

<pre class="code sh"><code class="sh">chruby ruby-yjit
ruby myscript.rb
</code></pre>

<p>You can dump statistics about compilation and execution by running YJIT with the <code>--yjit-stats</code> command-line option:</p>

<pre class="code sh"><code class="sh">./miniruby --yjit-stats myscript.rb
</code></pre>

<p>You can see what YJIT has compiled by running YJIT with the <code>--yjit-log</code> command-line option:</p>

<pre class="code sh"><code class="sh">./miniruby --yjit-log myscript.rb
</code></pre>

<p>The machine code generated for a given method can be printed by adding <code>puts RubyVM::YJIT.disasm(method(:method_name))</code> to a Ruby script. Note that no code will be generated if the method is not compiled.</p>

<h3 id="command-line-options">Command-Line Options</h3>

<p>YJIT supports all command-line options supported by upstream CRuby, but also adds a few YJIT-specific options:</p>

<ul>
<li><code>--yjit</code>: enable YJIT (disabled by default)</li>
<li><code>--yjit-mem-size=N</code>: soft limit on YJIT memory usage in MiB (default: 128). Tries to limit <code>code_region_size + yjit_alloc_size</code></li>
<li><code>--yjit-exec-mem-size=N</code>: hard limit on executable memory block in MiB. Limits <code>code_region_size</code></li>
<li><code>--yjit-call-threshold=N</code>: number of calls after which YJIT begins to compile a function.
It defaults to 30, and it&#39;s then increased to 120 when the number of ISEQs in the process reaches 40,000.</li>
<li><code>--yjit-cold-threshold=N</code>: number of global calls after which an ISEQ is considered cold and not
compiled, lower values mean less code is compiled (default 200K)</li>
<li><code>--yjit-stats</code>: print statistics after the execution of a program (incurs a run-time cost)</li>
<li><code>--yjit-stats=quiet</code>: gather statistics while running a program but don&#39;t print them. Stats are accessible through <code>RubyVM::YJIT.runtime_stats</code>. (incurs a run-time cost)</li>
<li><code>--yjit-log[=file|dir]</code>: log all compilation events to the specified file or directory. If no name is supplied, the last 1024 log entries will be printed to stderr when the application exits.</li>
<li><code>--yjit-log=quiet</code>: gather a circular buffer of recent YJIT compilations. The compilation log entries are accessible through <code>RubyVM::YJIT.log</code> and old entries will be discarded if the buffer is not drained quickly. (incurs a run-time cost)</li>
<li><code>--yjit-disable</code>: disable YJIT despite other <code>--yjit*</code> flags for lazily enabling it with <code>RubyVM::YJIT.enable</code></li>
<li><code>--yjit-code-gc</code>: enable code GC (disabled by default as of Ruby 3.3).
It will cause all machine code to be discarded when the executable memory size limit is hit, meaning JIT compilation will then start over.
This can allow you to use a lower executable memory size limit, but may cause a slight drop in performance when the limit is hit.</li>
<li><code>--yjit-perf</code>: enable frame pointers and profiling with the <code>perf</code> tool</li>
<li><code>--yjit-trace-exits</code>: produce a Marshal dump of backtraces from all exits. Automatically enables <code>--yjit-stats</code></li>
<li><code>--yjit-trace-exits=COUNTER</code>: produce a Marshal dump of backtraces from a counted exit or a fallback. Automatically enables <code>--yjit-stats</code></li>
<li><code>--yjit-trace-exits-sample-rate=N</code>: trace exit locations only every Nth occurrence. Automatically enables <code>--yjit-trace-exits</code></li>
</ul>

<p>Note that there is also an environment variable <code>RUBY_YJIT_ENABLE</code> which can be used to enable YJIT.
This can be useful for some deployment scripts where specifying an extra command-line option to Ruby is not practical.</p>

<p>You can also enable YJIT at run-time using <code>RubyVM::YJIT.enable</code>. This can allow you to enable YJIT after your application is done
booting, which makes it possible to avoid compiling any initialization code.</p>

<p>You can verify that YJIT is enabled using <code>RubyVM::YJIT.enabled?</code> or by checking that <code>ruby --yjit -v</code> includes the string <code>+YJIT</code>:</p>

<pre class="code sh"><code class="sh">ruby --yjit -v
ruby 3.3.0dev (2023-01-31T15:11:10Z master 2a0bf269c9) +YJIT dev [x86_64-darwin22]

ruby --yjit -e &quot;p RubyVM::YJIT.enabled?&quot;
true

ruby -e &quot;RubyVM::YJIT.enable; p RubyVM::YJIT.enabled?&quot;
true
</code></pre>

<h3>Benchmarking</h3>

<p>We have collected a set of benchmarks and implemented a simple benchmarking harness in the <a href="https://github.com/Shopify/yjit-bench">yjit-bench</a> repository. This benchmarking harness is designed to disable CPU frequency scaling, set process affinity and disable address space randomization so that the variance between benchmarking runs will be as small as possible.</p>

<h2>Performance Tips for Production Deployments</h2>

<p>While YJIT options default to what we think would work well for most workloads,
they might not necessarily be the best configuration for your application.
This section covers tips on improving YJIT performance in case YJIT does not
speed up your application in production.</p>

<h3>Increasing --yjit-mem-size</h3>

<p>The <code>--yjit-mem-size</code> value can be used to set the maximum amount of memory that YJIT
is allowed to use. This corresponds to the total of <code>RubyVM::YJIT.runtime_stats[:code_region_size]</code>
and <code>RubyVM::YJIT.runtime_stats[:yjit_alloc_size]</code>
Increasing the <code>--yjit-mem-size</code> value means more code
can be optimized by YJIT, at the cost of more memory usage.</p>

<p>If you start Ruby with <code>--yjit-stats</code>, e.g. using an environment variable <code>RUBYOPT=--yjit-stats</code>,
<code>RubyVM::YJIT.runtime_stats[:ratio_in_yjit]</code> shows the percentage of total YARV instructions
executed by YJIT as opposed to the CRuby interpreter.
Ideally, <code>ratio_in_yjit</code> should be as large as 99%, and increasing <code>--yjit-mem-size</code> often
helps improving <code>ratio_in_yjit</code>.</p>

<h3>Running workers as long as possible</h3>

<p>It&#39;s helpful to call the same code as many times as possible before a process restarts.
If a process is killed too frequently, the time taken for compiling methods may outweigh
the speedup obtained by compiling them.</p>

<p>You should monitor the number of requests each process has served.
If you&#39;re periodically killing worker processes, e.g. with <code>unicorn-worker-killer</code> or <code>puma_worker_killer</code>,
you may want to reduce the killing frequency or increase the limit.</p>

<h2>Reducing YJIT Memory Usage</h2>

<p>YJIT allocates memory for JIT code and metadata. Enabling YJIT generally results in more memory usage.
This section goes over tips on minimizing YJIT memory usage in case it uses more than your capacity.</p>

<h3>Decreasing --yjit-mem-size</h3>

<p>YJIT uses memory for compiled code and metadata. You can change the maximum amount of memory
that YJIT can use by specifying a different <code>--yjit-mem-size</code> command-line option. The default value
is currently <code>128</code>.
When changing this value, you may want to monitor <code>RubyVM::YJIT.runtime_stats[:ratio_in_yjit]</code>
as explained above.</p>

<h3>Enabling YJIT lazily</h3>

<p>If you enable YJIT by <code>--yjit</code> options or <code>RUBY_YJIT_ENABLE=1</code>, YJIT may compile code that is
used only during the application boot. <code>RubyVM::YJIT.enable</code> allows you to enable YJIT from Ruby code,
and you can call this after your application is initialized, e.g. on Unicorn&#39;s <code>after_fork</code> hook.
If you use any YJIT options (<code>--yjit-*</code>), YJIT will start at boot by default, but <code>--yjit-disable</code>
allows you to start Ruby with the YJIT-disabled mode while passing YJIT tuning options.</p>

<h2>Code Optimization Tips</h2>

<p>This section contains tips on writing Ruby code that will run as fast as possible on YJIT. Some of this advice is based on current limitations of YJIT, while other advice is broadly applicable. It probably won&#39;t be practical to apply these tips everywhere in your codebase. You should ideally start by profiling your application using a tool such as <a href="https://github.com/tmm1/stackprof">stackprof</a> so that you can determine which methods make up most of the execution time. You can then refactor the specific methods that make up the largest fractions of the execution time. We do not recommend modifying your entire codebase based on the current limitations of YJIT.</p>

<ul>
<li>Avoid using <code>OpenStruct</code></li>
<li>Avoid redefining basic integer operations (i.e. +, -, &lt;, &gt;, etc.)</li>
<li>Avoid redefining the meaning of <code>nil</code>, equality, etc.</li>
<li>Avoid allocating objects in the hot parts of your code</li>
<li>Minimize layers of indirection

<ul>
<li>Avoid writing wrapper classes if you can (e.g. a class that only wraps a Ruby hash)</li>
<li>Avoid methods that just call another method</li>
</ul></li>
<li>Ruby method calls are costly. Avoid things such as methods that only return a value from a hash</li>
<li>Try to write code so that the same variables and method arguments always have the same type</li>
<li>Avoid using <code>TracePoint</code> as it can cause YJIT to deoptimize code</li>
<li>Avoid using <code>binding</code> as it can cause YJIT to deoptimize code</li>
</ul>

<p>You can also use the <code>--yjit-stats</code> command-line option to see which bytecodes cause YJIT to exit, and refactor your code to avoid using these instructions in the hottest methods of your code.</p>

<h3>Other Statistics</h3>

<p>If you run <code>ruby</code> with <code>--yjit-stats</code>, YJIT will track and return performance statistics in <code>RubyVM::YJIT.runtime_stats</code>.</p>

<pre class="code rb"><code class="rb">$ RUBYOPT=&quot;--yjit-stats&quot; irb
irb(main):001:0&gt; RubyVM::YJIT.runtime_stats
=&gt;
{:inline_code_size=&gt;340745,
 :outlined_code_size=&gt;297664,
 :all_stats=&gt;true,
 :yjit_insns_count=&gt;1547816,
 :send_callsite_not_simple=&gt;7267,
 :send_kw_splat=&gt;7,
 :send_ivar_set_method=&gt;72,
...
</code></pre>

<p>Some of the counters include:</p>

<ul>
<li><code>:yjit_insns_count</code> - how many Ruby bytecode instructions have been executed</li>
<li><code>:binding_allocations</code> - number of bindings allocated</li>
<li><code>:binding_set</code> - number of variables set via a binding</li>
<li><code>:code_gc_count</code> - number of garbage collections of compiled code since process start</li>
<li><code>:vm_insns_count</code> - number of instructions executed by the Ruby interpreter</li>
<li><code>:compiled_iseq_count</code> - number of bytecode sequences compiled</li>
<li><code>:inline_code_size</code> - size in bytes of compiled YJIT blocks</li>
<li><code>:outline_code_size</code> - size in bytes of YJIT error-handling compiled code</li>
<li><code>:side_exit_count</code> - number of side exits taken at runtime</li>
<li><code>:total_exit_count</code> - number of exits, including side exits, taken at runtime</li>
<li><code>:avg_len_in_yjit</code> - avg. number of instructions in compiled blocks before exiting to interpreter</li>
</ul>

<p>Counters starting with &quot;exit_&quot; show reasons for YJIT code taking a side exit (return to the interpreter.)</p>

<p>Performance counter names are not guaranteed to remain the same between Ruby versions. If you&#39;re curious what each counter means,
it&#39;s usually best to search the source code for it &mdash; but it may change in a later Ruby version.</p>

<p>The printed text after a <code>--yjit-stats</code> run includes other information that may be named differently than the information in {RubyVM::YJIT.runtime_stats}.</p>

<h2>Contributing</h2>

<p>We welcome open source contributions. You should feel free to open new issues to report bugs or just to ask questions.
Suggestions on how to make this readme file more helpful for new contributors are most welcome.</p>

<p>Bug fixes and bug reports are very valuable to us. If you find a bug in YJIT, it&#39;s very possible be that nobody has reported it before,
or that we don&#39;t have a good reproduction for it, so please open an issue and provide as much information as you can about your configuration and a description of how you encountered the problem. List the commands you used to run YJIT so that we can easily reproduce the issue on our end and investigate it. If you are able to produce a small program reproducing the error to help us track it down, that is very much appreciated as well.</p>

<p>If you would like to contribute a large patch to YJIT, we suggest opening an issue or a discussion on the <a href="https://github.com/Shopify/ruby/issues">Shopify/ruby repository</a> so that
we can have an active discussion. A common problem is that sometimes people submit large pull requests to open source projects
without prior communication, and we have to reject them because the work they implemented does not fit within the design of the
project. We want to save you time and frustration, so please reach out so we can have a productive discussion as to how
you can contribute patches we will want to merge into YJIT.</p>

<h3>Source Code Organization</h3>

<p>The YJIT source code is divided between:</p>

<ul>
<li><code>yjit.c</code>: code YJIT uses to interface with the rest of CRuby</li>
<li><code>yjit.h</code>: C definitions YJIT exposes to the rest of the CRuby</li>
<li><code>yjit.rb</code>: {YJIT} Ruby module that is exposed to Ruby</li>
<li><code>yjit/src/asm/*</code>: in-memory assembler we use to generate machine code</li>
<li><code>yjit/src/codegen.rs</code>: logic for translating Ruby bytecode to machine code</li>
<li><code>yjit/src/core.rb</code>: basic block versioning logic, core structure of YJIT</li>
<li><code>yjit/src/stats.rs</code>: gathering of run-time statistics</li>
<li><code>yjit/src/options.rs</code>: handling of command-line options</li>
<li><code>yjit/src/cruby.rs</code>: C bindings manually exposed to the Rust codebase</li>
<li><code>yjit/bindgen/src/main.rs</code>: C bindings exposed to the Rust codebase through bindgen</li>
</ul>

<p>The core of CRuby&#39;s interpreter logic is found in:</p>

<ul>
<li><code>insns.def</code>: defines Ruby&#39;s bytecode instructions (gets compiled into <code>vm.inc</code>)</li>
<li><code>vm_insnshelper.c</code>: logic used by Ruby&#39;s bytecode instructions</li>
<li><code>vm_exec.c</code>: Ruby interpreter loop</li>
</ul>

<h3>Generating C bindings with bindgen</h3>

<p>In order to expose C functions to the Rust codebase, you will need to generate C bindings:</p>

<pre class="code sh"><code class="sh">CC=clang ./configure --enable-yjit=dev
make -j yjit-bindgen
</code></pre>

<p>This uses the bindgen tools to generate/update <code>yjit/src/cruby_bindings.inc.rs</code> based on the
bindings listed in <code>yjit/bindgen/src/main.rs</code>. Avoid manually editing this file
as it could be automatically regenerated at a later time. If you need to manually add C bindings,
add them to <code>yjit/cruby.rs</code> instead.</p>

<h3>Coding &amp; Debugging Protips</h3>

<p>There are multiple test suites:</p>

<ul>
<li><code>make btest</code> (see <code>/bootstraptest</code>)</li>
<li><code>make test-all</code></li>
<li><code>make test-spec</code></li>
<li><code>make check</code> runs all of the above</li>
<li><code>make yjit-check</code> runs quick checks to see that YJIT is working correctly</li>
</ul>

<p>The tests can be run in parallel like this:</p>

<pre class="code sh"><code class="sh">make -j test-all RUN_OPTS=&quot;--yjit-call-threshold=1&quot;
</code></pre>

<p>Or single-threaded like this, to more easily identify which specific test is failing:</p>

<pre class="code sh"><code class="sh">make test-all TESTOPTS=--verbose RUN_OPTS=&quot;--yjit-call-threshold=1&quot;
</code></pre>

<p>To run a single test file with <code>test-all</code>:</p>

<pre class="code sh"><code class="sh">make test-all TESTS=&#39;test/-ext-/marshal/test_usrmarshal.rb&#39; RUNRUBYOPT=--debugger=lldb RUN_OPTS=&quot;--yjit-call-threshold=1&quot;
</code></pre>

<p>It&#39;s also possible to filter tests by name to run a single test:</p>

<pre class="code sh"><code class="sh">make test-all TESTS=&#39;-n /test_float_plus/&#39; RUN_OPTS=&quot;--yjit-call-threshold=1&quot;
</code></pre>

<p>You can also run one specific test in <code>btest</code>:</p>

<pre class="code sh"><code class="sh">make btest BTESTS=bootstraptest/test_ractor.rb RUN_OPTS=&quot;--yjit-call-threshold=1&quot;
</code></pre>

<p>There are shortcuts to run/debug your own test/repro in <code>test.rb</code>:</p>

<pre class="code sh"><code class="sh">make run  # runs ./miniruby test.rb
make lldb # launches ./miniruby test.rb in lldb
</code></pre>

<p>You can use the Intel syntax for disassembly in LLDB, keeping it consistent with YJIT&#39;s disassembly:</p>

<pre class="code sh"><code class="sh">echo &quot;settings set target.x86-disassembly-flavor intel&quot; &gt;&gt; ~/.lldbinit
</code></pre>

<h2>Running x86 YJIT on Apple&#39;s Rosetta</h2>

<p>For development purposes, it is possible to run x86 YJIT on an Apple M1 via Rosetta.  You can find basic
instructions below, but there are a few caveats listed further down.</p>

<p>First, install Rosetta:</p>

<pre class="code console"><code class="console">$ softwareupdate --install-rosetta
</code></pre>

<p>Now any command can be run with Rosetta via the <code>arch</code> command line tool.</p>

<p>Then you can start your shell in an x86 environment:</p>

<pre class="code console"><code class="console">$ arch -x86_64 zsh
</code></pre>

<p>You can double check your current architecture via the <code>arch</code> command:</p>

<pre class="code console"><code class="console">$ arch -x86_64 zsh
$ arch
i386
</code></pre>

<p>You may need to set the default target for <code>rustc</code> to x86-64, e.g.</p>

<pre class="code console"><code class="console">$ rustup default stable-x86_64-apple-darwin
</code></pre>

<p>While in your i386 shell, install Cargo and Homebrew, then hack away!</p>

<h3>Rosetta Caveats</h3>

<ol>
<li>You must install a version of Homebrew for each architecture</li>
<li>Cargo will install in $HOME/.cargo by default, and I don&#39;t know a good way to change architectures after install</li>
</ol>

<p>If you use Fish shell you can <a href="https://tenderlovemaking.com/2022/01/07/homebrew-rosetta-and-ruby.html">read this link</a> for information on making the dev environment easier.</p>

<h2>Profiling with Linux perf</h2>

<p><code>--yjit-perf</code> allows you to profile JIT-ed methods along with other native functions using Linux perf.
When you run Ruby with <code>perf record</code>, perf looks up <code>/tmp/perf-{pid}.map</code> to resolve symbols in JIT code,
and this option lets YJIT write method symbols into that file as well as enabling frame pointers.</p>

<h3>Call graph</h3>

<p>Here&#39;s an example way to use this option with <a href="https://profiler.firefox.com">Firefox Profiler</a>
(See also: <a href="https://profiler.firefox.com/docs/#/./guide-perf-profiling">Profiling with Linux perf</a>):</p>

<pre class="code bash"><code class="bash"># Compile the interpreter with frame pointers enabled
./configure --enable-yjit --prefix=$HOME/.rubies/ruby-yjit --disable-install-doc cflags=-fno-omit-frame-pointer
make -j &amp;&amp; make install

# [Optional] Allow running perf without sudo
echo 0 | sudo tee /proc/sys/kernel/kptr_restrict
echo -1 | sudo tee /proc/sys/kernel/perf_event_paranoid

# Profile Ruby with --yjit-perf
cd ../yjit-bench
PERF=&quot;record --call-graph fp&quot; ruby --yjit-perf -Iharness-perf benchmarks/liquid-render/benchmark.rb

# View results on Firefox Profiler https://profiler.firefox.com.
# Create /tmp/test.perf as below and upload it using &quot;Load a profile from file&quot;.
perf script --fields +pid &gt; /tmp/test.perf
</code></pre>

<h3>YJIT codegen</h3>

<p>You can also profile the number of cycles consumed by code generated by each YJIT function.</p>

<pre class="code bash"><code class="bash"># Install perf
apt-get install linux-tools-common linux-tools-generic linux-tools-`uname -r`

# [Optional] Allow running perf without sudo
echo 0 | sudo tee /proc/sys/kernel/kptr_restrict
echo -1 | sudo tee /proc/sys/kernel/perf_event_paranoid

# Profile Ruby with --yjit-perf=codegen
cd ../yjit-bench
PERF=record ruby --yjit-perf=codegen -Iharness-perf benchmarks/lobsters/benchmark.rb

# Aggregate results
perf script &gt; /tmp/perf.txt
../ruby/misc/yjit_perf.py /tmp/perf.txt
</code></pre>

<h4>Building perf with Python support</h4>

<p>The above instructions work fine for most people, but you could also use
a handy <code>perf script -s</code> interface if you build perf from source.</p>

<pre class="code bash"><code class="bash"># Build perf from source for Python support
sudo apt-get install libpython3-dev python3-pip flex libtraceevent-dev \
  libelf-dev libunwind-dev libaudit-dev libslang2-dev libdw-dev
git clone --depth=1 https://github.com/torvalds/linux
cd linux/tools/perf
make
make install

# Aggregate results
perf script -s ../ruby/misc/yjit_perf.py
</code></pre>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>