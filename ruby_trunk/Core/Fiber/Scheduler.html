<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen' content='yes'>
<meta name='mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: Fiber::Scheduler &mdash; Core  Ruby-master dev</title>

<link rel='stylesheet'  type='text/css' href='../../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Fiber::Scheduler",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../../'>Ruby-master</a> &raquo; 
      <a href='../'>Core</a> &raquo; 
      <a href='../_index.html#alpha_S'>Index (S)</a> &raquo; 
        <a href="../Fiber.html" title="Fiber (class)">Fiber</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>Scheduler&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: Fiber::Scheduler</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr>
      <td id='t2_inherits' class='box_2'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'><a href="../Object.html" title="Object (class)">Object</a></span>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2 o'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L347'>scheduler.c</a><span class='defines'>,<br /><a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L307'>scheduler.c</a></span>
      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p>This is not an existing class, but documentation of the interface that <code>Scheduler</code> object should comply to in order to be used as argument to <a href="../Fiber.html#scheduler-class_method" title="Fiber.scheduler (method)">scheduler</a> and handle non-blocking fibers. See also the “Non-blocking fibers” section in <a href="../Fiber.html" title="Fiber (class)"><code>::Fiber</code></a> class docs for explanations of some concepts.</p>

<p>Scheduler’s behavior and usage are expected to be as follows:</p>
<ul><li>
<p>When the execution in the non-blocking <a href="../Fiber.html" title="Fiber (class)"><code>::Fiber</code></a> reaches some blocking operation (like sleep, wait for a process, or a non-ready I/O), it calls some of the scheduler’s hook methods, listed below.</p>
</li><li>
<p><code>Scheduler</code> somehow registers what the current fiber is waiting on, and yields control to other fibers with Fiber.yield (so the fiber would be suspended while expecting its wait to end, and other fibers in the same thread can perform)</p>
</li><li>
<p>At the end of the current thread execution, the scheduler’s method <code>#scheduler_close</code> is called</p>
</li><li>
<p>The scheduler runs into a wait loop, checking all the blocked fibers (which it has registered on hook calls) and resuming them when the awaited resource is ready (e.g. I/O ready or sleep time elapsed).</p>
</li></ul>

<p>This way concurrent execution will be achieved transparently for every individual Fiber’s code.</p>

<p><code>Scheduler</code> implementations are provided by gems, like <a href="https://github.com/socketry/async" target="_parent" title="Async">Async</a>.</p>

<p>Hook methods are:</p>
<ul><li>
<p><a href="#io_wait-instance_method" title="Fiber::Scheduler#io_wait (method)">#io_wait</a>, <a href="#io_read-instance_method" title="Fiber::Scheduler#io_read (method)">#io_read</a>, <a href="#io_write-instance_method" title="Fiber::Scheduler#io_write (method)">#io_write</a>, <a href="#io_pread-instance_method" title="Fiber::Scheduler#io_pread (method)">#io_pread</a>, <a href="#io_pwrite-instance_method" title="Fiber::Scheduler#io_pwrite (method)">#io_pwrite</a> <a href="#io_select-instance_method" title="Fiber::Scheduler#io_select (method)">#io_select</a>, and <a href="#io_close-instance_method" title="Fiber::Scheduler#io_close (method)">#io_close</a></p>
</li><li>
<p><a href="#process_wait-instance_method" title="Fiber::Scheduler#process_wait (method)">#process_wait</a></p>
</li><li>
<p><a href="#kernel_sleep-instance_method" title="Fiber::Scheduler#kernel_sleep (method)">#kernel_sleep</a></p>
</li><li>
<p><a href="#timeout_after-instance_method" title="Fiber::Scheduler#timeout_after (method)">#timeout_after</a></p>
</li><li>
<p><a href="#address_resolve-instance_method" title="Fiber::Scheduler#address_resolve (method)">#address_resolve</a></p>
</li><li>
<p><a href="#block-instance_method" title="Fiber::Scheduler#block (method)">#block</a> and <a href="#unblock-instance_method" title="Fiber::Scheduler#unblock (method)">#unblock</a></p>
</li><li>
<p><a href="#blocking_operation_wait-instance_method" title="Fiber::Scheduler#blocking_operation_wait (method)">#blocking_operation_wait</a></p>
</li><li>
<p><a href="#fiber_interrupt-instance_method" title="Fiber::Scheduler#fiber_interrupt (method)">#fiber_interrupt</a></p>
</li><li>
<p><a href="#yield-instance_method" title="Fiber::Scheduler#yield (method)">#yield</a></p>
</li><li>
<p>(the list is expanded as <a href="../Ruby.html" title="Ruby (module)"><code>::Ruby</code></a> developers make more methods having non-blocking calls)</p>
</li></ul>

<p>When not specified otherwise, the hook implementations are mandatory: if they are not implemented, the methods trying to call hook will fail. To provide backward compatibility, in the future hooks will be optional (if they are not implemented, due to the scheduler being created for the older <a href="../Ruby.html" title="Ruby (module)"><code>::Ruby</code></a> version, the code which needs this hook will not fail, and will just behave in a blocking fashion).</p>

<p>It is also strongly recommended that the scheduler implements the <a href="#fiber-instance_method" title="Fiber::Scheduler#fiber (method)">#fiber</a> method, which is delegated to by <a href="../Fiber.html#schedule-class_method" title="Fiber.schedule (method)">schedule</a>.</p>

<p>Sample <em>toy</em> implementation of the scheduler can be found in Ruby’s code, in <code>test/fiber/scheduler.rb</code></p>

  </div>
</div>
</div>
<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#address_resolve-instance_method" title="#address_resolve (instance method)">#<strong>address_resolve</strong>(hostname)  &#x21d2; array_of_strings<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by any method that performs a non-reverse DNS lookup.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#block-instance_method" title="#block (instance method)">#<strong>block</strong>(blocker, timeout = nil)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by methods like <code>Thread.join</code>, and by <a href="../Thread/Mutex.html" title="Thread::Mutex (class)"><code>::Thread::Mutex</code></a>, to signify that current <a href="../Fiber.html" title="Fiber (class)"><code>::Fiber</code></a> is blocked until further notice (e.g. <a href="#unblock-instance_method" title="Fiber::Scheduler#unblock (method)">#unblock</a>) or until <code>timeout</code> has elapsed.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#blocking_operation_wait-instance_method" title="#blocking_operation_wait (instance method)">#<strong>blocking_operation_wait</strong>(blocking_operation)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by Ruby’s core methods to run a blocking operation in a non-blocking way.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#close-instance_method" title="#close (instance method)">#<strong>close</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Called when the current thread exits.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#fiber-instance_method" title="#fiber (instance method)">#<strong>fiber</strong>(&amp;block)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Implementation of the <a href="../Fiber.html#schedule-class_method" title="Fiber.schedule (method)">schedule</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#fiber_interrupt-instance_method" title="#fiber_interrupt (instance method)">#<strong>fiber_interrupt</strong>(fiber, exception)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by Ruby’s core methods to notify the scheduler that the blocked fiber should be interrupted with an exception.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#io_close-instance_method" title="#io_close (instance method)">#<strong>io_close</strong>(fd)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by Ruby’s core methods to notify scheduler that the <a href="../IO.html" title="IO (class)"><code>::IO</code></a> object is closed.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#io_pread-instance_method" title="#io_pread (instance method)">#<strong>io_pread</strong>(io, buffer, from, length, offset)  &#x21d2; read length, -errno </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by <a href="../IO.html#pread-instance_method" title="IO#pread (method)">IO#pread</a> or <code>IO::Buffer#pread</code> to read <code>length</code> bytes from <code>io</code> at offset <code>from</code> into a specified <code>buffer</code> (see <a href="../IO/Buffer.html" title="IO::Buffer (class)"><code>::IO::Buffer</code></a>) at the given <code>offset</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#io_pwrite-instance_method" title="#io_pwrite (instance method)">#<strong>io_pwrite</strong>(io, buffer, from, length, offset)  &#x21d2; written length, -errno </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by <a href="../IO.html#pwrite-instance_method" title="IO#pwrite (method)">IO#pwrite</a> or <code>IO::Buffer#pwrite</code> to write <code>length</code> bytes to <code>io</code> at offset <code>from</code> into a specified <code>buffer</code> (see <a href="../IO/Buffer.html" title="IO::Buffer (class)"><code>::IO::Buffer</code></a>) at the given <code>offset</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#io_read-instance_method" title="#io_read (instance method)">#<strong>io_read</strong>(io, buffer, length, offset)  &#x21d2; read length, -errno </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by <a href="../IO.html#read-instance_method" title="IO#read (method)">IO#read</a> or <code>IO#Buffer</code>.read to read <code>length</code> bytes from <code>io</code> into a specified <code>buffer</code> (see <a href="../IO/Buffer.html" title="IO::Buffer (class)"><code>::IO::Buffer</code></a>) at the given <code>offset</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#io_select-instance_method" title="#io_select (instance method)">#<strong>io_select</strong>(readables, writables, exceptables, timeout)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by <a href="../IO.html#select-class_method" title="IO.select (method)">IO.select</a> to ask whether the specified descriptors are ready for specified events within the specified <code>timeout</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#io_wait-instance_method" title="#io_wait (instance method)">#<strong>io_wait</strong>(io, events, timeout)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by <a href="../IO.html#wait-instance_method" title="IO#wait (method)">IO#wait</a>, <a href="../IO.html#wait_readable-instance_method" title="IO#wait_readable (method)">IO#wait_readable</a>, <a href="../IO.html#wait_writable-instance_method" title="IO#wait_writable (method)">IO#wait_writable</a> to ask whether the specified descriptor is ready for specified events within the specified <code>timeout</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#io_write-instance_method" title="#io_write (instance method)">#<strong>io_write</strong>(io, buffer, length, offset)  &#x21d2; written length, -errno </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by <a href="../IO.html#write-instance_method" title="IO#write (method)">IO#write</a> or <a href="../IO/Buffer.html#write-instance_method" title="IO::Buffer#write (method)">IO::Buffer#write</a> to write <code>length</code> bytes to <code>io</code> from from a specified <code>buffer</code> (see <a href="../IO/Buffer.html" title="IO::Buffer (class)"><code>::IO::Buffer</code></a>) at the given <code>offset</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#kernel_sleep-instance_method" title="#kernel_sleep (instance method)">#<strong>kernel_sleep</strong>(duration = nil)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by <a href="../Kernel.html#sleep-class_method" title="Kernel.sleep (method)">Kernel.sleep</a> and <a href="../Thread/Mutex.html#sleep-instance_method" title="Thread::Mutex#sleep (method)">Thread::Mutex#sleep</a> and is expected to provide an implementation of sleeping in a non-blocking way.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#process_wait-instance_method" title="#process_wait (instance method)">#<strong>process_wait</strong>(pid, flags)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by <code>Process::Status.wait</code> in order to wait for a specified process.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#timeout_after-instance_method" title="#timeout_after (instance method)">#<strong>timeout_after</strong>(duration, exception_class, *exception_arguments, &amp;block)  &#x21d2; result of block </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked by <code>Timeout.timeout</code> to execute the given <a href="#block-instance_method" title="Fiber::Scheduler#block (method)">#block</a> within the given <code>duration</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#unblock-instance_method" title="#unblock (instance method)">#<strong>unblock</strong>(blocker, fiber)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Invoked to wake up <a href="../Fiber.html" title="Fiber (class)"><code>::Fiber</code></a> previously blocked with <a href="#block-instance_method" title="Fiber::Scheduler#block (method)">#block</a> (for example, <a href="../Thread/Mutex.html#lock-instance_method" title="Thread::Mutex#lock (method)">Thread::Mutex#lock</a> calls <a href="#block-instance_method" title="Fiber::Scheduler#block (method)">#block</a> and <a href="../Thread/Mutex.html#unlock-instance_method" title="Thread::Mutex#unlock (method)">Thread::Mutex#unlock</a> calls <a href="#unblock-instance_method" title="Fiber::Scheduler#unblock (method)">#unblock</a>).</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#yield-instance_method" title="#yield (instance method)">#<strong>yield</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Yield to the scheduler, to be resumed on the next scheduling cycle.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- instance_method_summary -->
<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="address_resolve-instance_method">
  <h3 class='signature  first'>
    #<strong>address_resolve</strong>(hostname)  &#x21d2; <code>array_of_strings</code><sup>?</sup>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by any method that performs a non-reverse DNS lookup. The most notable method is <code>Addrinfo.getaddrinfo</code>, but there are many other.</p>

<p>The method is expected to return an array of strings corresponding to ip addresses the <code>hostname</code> is resolved to, or <code>nil</code> if it can not be resolved.</p>

<p>Fairly exhaustive list of all possible call-sites:</p>
<ul><li>
<p><code>Addrinfo.getaddrinfo</code></p>
</li><li>
<p><code>Addrinfo.tcp</code></p>
</li><li>
<p><code>Addrinfo.udp</code></p>
</li><li>
<p><code>Addrinfo.ip</code></p>
</li><li>
<p><code>Addrinfo.new</code></p>
</li><li>
<p><code>Addrinfo.marshal_load</code></p>
</li><li>
<p><code>SOCKSSocket.new</code></p>
</li><li>
<p><code>TCPServer.new</code></p>
</li><li>
<p><code>TCPSocket.new</code></p>
</li><li>
<p><code>IPSocket.getaddress</code></p>
</li><li>
<p><code>TCPSocket.gethostbyname</code></p>
</li><li>
<p><code>UDPSocket#connect</code></p>
</li><li>
<p><code>UDPSocket#bind</code></p>
</li><li>
<p><code>UDPSocket#send</code></p>
</li><li>
<p><code>Socket.getaddrinfo</code></p>
</li><li>
<p><code>Socket.gethostbyname</code></p>
</li><li>
<p><code>Socket.pack_sockaddr_in</code></p>
</li><li>
<p><code>Socket.sockaddr_in</code></p>
</li><li>
<p><code>Socket.unpack_sockaddr_in</code></p>
</li></ul>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L1064-L1072'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1064' data-end='1072'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 1064</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_address_resolve(VALUE scheduler, VALUE hostname)
{
    VALUE arguments[] = {
        hostname
    };

    return rb_check_funcall(scheduler, id_address_resolve, 1, arguments);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="block-instance_method">
  <h3 class='signature '>
    #<strong>block</strong>(blocker, timeout = nil)    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by methods like <code>Thread.join</code>, and by <a href="../Thread/Mutex.html" title="Thread::Mutex (class)"><code>::Thread::Mutex</code></a>, to signify that current <a href="../Fiber.html" title="Fiber (class)"><code>::Fiber</code></a> is blocked until further notice (e.g. <a href="#unblock-instance_method" title="Fiber::Scheduler#unblock (method)">#unblock</a>) or until <code>timeout</code> has elapsed.</p>

<p><code>blocker</code> is what we are waiting on, informational only (for debugging and logging). There are no guarantee about its value.</p>

<p>Expected to return boolean, specifying whether the blocking operation was successful or not.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L646-L650'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='646' data-end='650'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 646</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_block(VALUE scheduler, VALUE blocker, VALUE timeout)
{
    return rb_funcall(scheduler, id_block, 2, blocker, timeout);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="blocking_operation_wait-instance_method">
  <h3 class='signature '>
    #<strong>blocking_operation_wait</strong>(blocking_operation)    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by Ruby’s core methods to run a blocking operation in a non-blocking way. The blocking_operation is an opaque object that encapsulates the blocking operation and responds to a <code>#call</code> method without any arguments.</p>

<p>If the scheduler doesn’t implement this method, or if the scheduler doesn’t execute the blocking operation, <a href="../Ruby.html" title="Ruby (module)"><code>::Ruby</code></a> will fall back to the non-scheduler implementation.</p>

<p>Minimal suggested implementation is:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_blocking_operation_wait'>blocking_operation_wait</span>(<span class='id identifier rubyid_blocking_operation'>blocking_operation</span>)
  <span class='const'><a href="../Thread.html" title="Thread (class)">Thread</a></span>.<span class='id identifier rubyid_new'><a href="../Thread.html#new-class_method" title="Thread.new (method)">new</a></span> { <span class='id identifier rubyid_blocking_operation'>blocking_operation</span>.<span class='id identifier rubyid_call'>call</span> }.<span class='id identifier rubyid_join'>join</span>
<span class='kw'>end</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L1091-L1120'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1091' data-end='1120'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 1091</span></pre>
<pre class='code cpp'>

VALUE rb_fiber_scheduler_blocking_operation_wait(VALUE scheduler, void* (*function)(void *), void *data, rb_unblock_function_t *unblock_function, void *data2, int flags, struct rb_fiber_scheduler_blocking_operation_state *state)
{
    // Check if scheduler supports blocking_operation_wait before creating the object
    if (!rb_respond_to(scheduler, id_blocking_operation_wait)) {
        return Qundef;
    }

    // Create a new BlockingOperation with the blocking operation
    VALUE blocking_operation = rb_fiber_scheduler_blocking_operation_new(function, data, unblock_function, data2, flags, state);

    VALUE result = rb_funcall(scheduler, id_blocking_operation_wait, 1, blocking_operation);

    // Get the operation data to check if it was executed
    rb_fiber_scheduler_blocking_operation_t *operation = get_blocking_operation(blocking_operation);
    rb_atomic_t current_status = RUBY_ATOMIC_LOAD(operation-&gt;status);

    // Invalidate the operation now that we&#39;re done with it
    operation-&gt;function = NULL;
    operation-&gt;state = NULL;
    operation-&gt;data = NULL;
    operation-&gt;data2 = NULL;
    operation-&gt;unblock_function = NULL;

    // If the blocking operation was never executed, return Qundef to signal the caller to use rb_nogvl instead
    if (current_status == RB_FIBER_SCHEDULER_BLOCKING_OPERATION_STATUS_QUEUED) {
        return Qundef;
    }

    return result;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="close-instance_method">
  <h3 class='signature '>
    #<strong>close</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Called when the current thread exits. The scheduler is expected to implement this method in order to allow all waiting fibers to finalize their execution.</p>

<p>The suggested pattern is to implement the main event loop in the <code>#close</code> method.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L486-L506'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='486' data-end='506'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 486</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_close(VALUE scheduler)
{
    RUBY_ASSERT(ruby_thread_has_gvl_p());

    VALUE result;

    // The reason for calling `scheduler_close` before calling `close` is for
    // legacy schedulers which implement `close` and expect the user to call
    // it. Subsequently, that method would call `Fiber.set_scheduler(nil)`
    // which should call `scheduler_close`. If it were to call `close`, it
    // would create an infinite loop.

    result = rb_check_funcall(scheduler, id_scheduler_close, 0, NULL);
    if (!UNDEF_P(result)) return result;

    result = rb_check_funcall(scheduler, id_close, 0, NULL);
    if (!UNDEF_P(result)) return result;

    return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="fiber-instance_method">
  <h3 class='signature '>
    #<strong>fiber</strong>(&amp;block)    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Implementation of the <a href="../Fiber.html#schedule-class_method" title="Fiber.schedule (method)">Fiber.schedule</a>. The method is <em>expected</em> to immediately run the given block of code in a separate non-blocking fiber, and to return that <a href="../Fiber.html" title="Fiber (class)"><code>::Fiber</code></a>.</p>

<p>Minimal suggested implementation is:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_fiber'>fiber</span>(<span class='op'>&amp;</span><span class='id identifier rubyid_block'><a href="#block-instance_method" title="Fiber::Scheduler#block (method)">block</a></span>)
  <span class='id identifier rubyid_fiber'>fiber</span> <span class='op'>=</span> <span class='const'><a href="../Fiber.html" title="Fiber (class)">Fiber</a></span>.<span class='id identifier rubyid_new'><a href="../Fiber.html#new-class_method" title="Fiber.new (method)">new</a></span>(<span class='label'>blocking:</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'><a href="#block-instance_method" title="Fiber::Scheduler#block (method)">block</a></span>)
  <span class='id identifier rubyid_fiber'>fiber</span>.<span class='id identifier rubyid_resume'><a href="../Fiber.html#resume-instance_method" title="Fiber#resume (method)">resume</a></span>
  <span class='id identifier rubyid_fiber'>fiber</span>
<span class='kw'>end</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L1177-L1181'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1177' data-end='1181'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 1177</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_fiber(VALUE scheduler, int argc, VALUE *argv, int kw_splat)
{
    return rb_funcall_passing_block_kw(scheduler, id_fiber_schedule, argc, argv, kw_splat);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="fiber_interrupt-instance_method">
  <h3 class='signature '>
    #<strong>fiber_interrupt</strong>(fiber, exception)    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by Ruby’s core methods to notify the scheduler that the blocked fiber should be interrupted with an exception. For example, <a href="../IO.html#close-instance_method" title="IO#close (method)">IO#close</a> uses this method to interrupt fibers that are performing blocking <a href="../IO.html" title="IO (class)"><code>::IO</code></a> operations.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L1131-L1160'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1131' data-end='1160'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 1131</span></pre>
<pre class='code cpp'>

VALUE rb_fiber_scheduler_fiber_interrupt(VALUE scheduler, VALUE fiber, VALUE exception)
{
    VALUE arguments[] = {
        fiber, exception
    };

    VALUE result;
    enum ruby_tag_type state;

    // We must prevent interrupts while invoking the fiber_interrupt method, because otherwise fibers can be left permanently blocked if an interrupt occurs during the execution of user code. See also `rb_fiber_scheduler_unblock`.
    rb_execution_context_t *ec = GET_EC();
    int saved_interrupt_mask = ec-&gt;interrupt_mask;
    ec-&gt;interrupt_mask |= PENDING_INTERRUPT_MASK;

    EC_PUSH_TAG(ec);
    if ((state = EC_EXEC_TAG()) == TAG_NONE) {
        result = rb_check_funcall(scheduler, id_fiber_interrupt, 2, arguments);
    }
    EC_POP_TAG();

    ec-&gt;interrupt_mask = saved_interrupt_mask;

    if (state) {
        EC_JUMP_TAG(ec, state);
    }

    RUBY_VM_CHECK_INTS(ec);

    return result;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="io_close-instance_method">
  <h3 class='signature '>
    #<strong>io_close</strong>(fd)    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by Ruby’s core methods to notify scheduler that the <a href="../IO.html" title="IO (class)"><code>::IO</code></a> object is closed. Note that the method will receive an integer file descriptor of the closed object, not an object itself.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L1024-L1030'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1024' data-end='1030'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 1024</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_io_close(VALUE scheduler, VALUE io)
{
    VALUE arguments[] = {io};

    return rb_check_funcall(scheduler, id_io_close, 1, arguments);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="io_pread-instance_method">
  <h3 class='signature '>
    #<strong>io_pread</strong>(io, buffer, from, length, offset)  &#x21d2; <code>read</code> <code>length</code>, -<code>errno</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by <a href="../IO.html#pread-instance_method" title="IO#pread (method)">IO#pread</a> or <code>IO::Buffer#pread</code> to read <code>length</code> bytes from <code>io</code> at offset <code>from</code> into a specified <code>buffer</code> (see <a href="../IO/Buffer.html" title="IO::Buffer (class)"><code>::IO::Buffer</code></a>) at the given <code>offset</code>.</p>

<p>This method is semantically the same as <a href="#io_read-instance_method" title="Fiber::Scheduler#io_read (method)">#io_read</a>, but it allows to specify the offset to read from and is often better for asynchronous <a href="../IO.html" title="IO (class)"><code>::IO</code></a> on the same file.</p>

<p>The method should be considered <em>experimental</em>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L855-L871'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='855' data-end='871'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 855</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_io_pread(VALUE scheduler, VALUE io, rb_off_t from, VALUE buffer, size_t length, size_t offset)
{
    if (!rb_respond_to(scheduler, id_io_pread)) {
        return RUBY_Qundef;
    }

    VALUE arguments[] = {
        scheduler, io, buffer, OFFT2NUM(from), SIZET2NUM(length), SIZET2NUM(offset)
    };

    if (rb_respond_to(scheduler, id_fiber_interrupt)) {
        return rb_thread_io_blocking_operation(io, fiber_scheduler_io_pread, (VALUE)&amp;arguments);
    } else {
        return fiber_scheduler_io_pread((VALUE)&amp;arguments);
    }
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="io_pwrite-instance_method">
  <h3 class='signature '>
    #<strong>io_pwrite</strong>(io, buffer, from, length, offset)  &#x21d2; <code>written</code> <code>length</code>, -<code>errno</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by <a href="../IO.html#pwrite-instance_method" title="IO#pwrite (method)">IO#pwrite</a> or <code>IO::Buffer#pwrite</code> to write <code>length</code> bytes to <code>io</code> at offset <code>from</code> into a specified <code>buffer</code> (see <a href="../IO/Buffer.html" title="IO::Buffer (class)"><code>::IO::Buffer</code></a>) at the given <code>offset</code>.</p>

<p>This method is semantically the same as <a href="#io_write-instance_method" title="Fiber::Scheduler#io_write (method)">#io_write</a>, but it allows to specify the offset to write to and is often better for asynchronous <a href="../IO.html" title="IO (class)"><code>::IO</code></a> on the same file.</p>

<p>The method should be considered <em>experimental</em>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L948-L966'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='948' data-end='966'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 948</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_io_pwrite(VALUE scheduler, VALUE io, rb_off_t from, VALUE buffer, size_t length, size_t offset)
{


    if (!rb_respond_to(scheduler, id_io_pwrite)) {
        return RUBY_Qundef;
    }

    VALUE arguments[] = {
        scheduler, io, buffer, OFFT2NUM(from), SIZET2NUM(length), SIZET2NUM(offset)
    };

    if (rb_respond_to(scheduler, id_fiber_interrupt)) {
        return rb_thread_io_blocking_operation(io, fiber_scheduler_io_pwrite, (VALUE)&amp;arguments);
    } else {
        return fiber_scheduler_io_pwrite((VALUE)&amp;arguments);
    }
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="io_read-instance_method">
  <h3 class='signature '>
    #<strong>io_read</strong>(io, buffer, length, offset)  &#x21d2; <code>read</code> <code>length</code>, -<code>errno</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by <a href="../IO.html#read-instance_method" title="IO#read (method)">IO#read</a> or <code>IO#Buffer</code>.read to read <code>length</code> bytes from <code>io</code> into a specified <code>buffer</code> (see <a href="../IO/Buffer.html" title="IO::Buffer (class)"><code>::IO::Buffer</code></a>) at the given <code>offset</code>.</p>

<p>The <code>length</code> argument is the “minimum length to be read”. If the <a href="../IO.html" title="IO (class)"><code>::IO</code></a> buffer size is 8KiB, but the <code>length</code> is <code>1024</code> (1KiB), up to 8KiB might be read, but at least 1KiB will be. Generally, the only case where less data than <code>length</code> will be read is if there is an error reading the data.</p>

<p>Specifying a <code>length</code> of 0 is valid and means try reading at least once and return any available data.</p>

<p>Suggested implementation should try to read from <code>io</code> in a non-blocking manner and call <a href="#io_wait-instance_method" title="Fiber::Scheduler#io_wait (method)">#io_wait</a> if the <code>io</code> is not ready (which will yield control to other fibers).</p>

<p>See <a href="../IO/Buffer.html" title="IO::Buffer (class)"><code>::IO::Buffer</code></a> for an interface available to return data.</p>

<p>Expected to return number of bytes read, or, in case of an error, <code>-errno</code> (negated number corresponding to system’s error code).</p>

<p>The method should be considered <em>experimental</em>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L816-L832'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='816' data-end='832'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 816</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_io_read(VALUE scheduler, VALUE io, VALUE buffer, size_t length, size_t offset)
{
    if (!rb_respond_to(scheduler, id_io_read)) {
        return RUBY_Qundef;
    }

    VALUE arguments[] = {
        scheduler, io, buffer, SIZET2NUM(length), SIZET2NUM(offset)
    };

    if (rb_respond_to(scheduler, id_fiber_interrupt)) {
        return rb_thread_io_blocking_operation(io, fiber_scheduler_io_read, (VALUE)&amp;arguments);
    } else {
        return fiber_scheduler_io_read((VALUE)&amp;arguments);
    }
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="io_select-instance_method">
  <h3 class='signature '>
    #<strong>io_select</strong>(readables, writables, exceptables, timeout)    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by <a href="../IO.html#select-class_method" title="IO.select (method)">IO.select</a> to ask whether the specified descriptors are ready for specified events within the specified <code>timeout</code>.</p>

<p>Expected to return the 3-tuple of <a href="../Array.html" title="Array (class)"><code>::Array</code></a> of IOs that are ready.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L764-L771'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='764' data-end='771'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 764</span></pre>
<pre class='code cpp'>

VALUE rb_fiber_scheduler_io_select(VALUE scheduler, VALUE readables, VALUE writables, VALUE exceptables, VALUE timeout)
{
    VALUE arguments[] = {
        readables, writables, exceptables, timeout
    };

    return rb_fiber_scheduler_io_selectv(scheduler, 4, arguments);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="io_wait-instance_method">
  <h3 class='signature '>
    #<strong>io_wait</strong>(io, events, timeout)    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by <a href="../IO.html#wait-instance_method" title="IO#wait (method)">IO#wait</a>, <a href="../IO.html#wait_readable-instance_method" title="IO#wait_readable (method)">IO#wait_readable</a>, <a href="../IO.html#wait_writable-instance_method" title="IO#wait_writable (method)">IO#wait_writable</a> to ask whether the specified descriptor is ready for specified events within the specified <code>timeout</code>.</p>

<p><code>events</code> is a bit mask of <a href="../IO.html#READABLE-constant" title="IO::READABLE (constant)">IO::READABLE</a>, <a href="../IO.html#WRITABLE-constant" title="IO::WRITABLE (constant)">IO::WRITABLE</a>, and <a href="../IO.html#PRIORITY-constant" title="IO::PRIORITY (constant)">IO::PRIORITY</a>.</p>

<p>Suggested implementation should register which <a href="../Fiber.html" title="Fiber (class)"><code>::Fiber</code></a> is waiting for which resources and immediately calling <a href="../Fiber.html#yield-class_method" title="Fiber.yield (method)">Fiber.yield</a> to pass control to other fibers. Then, in the <a href="#close-instance_method" title="Fiber::Scheduler#close (method)">#close</a> method, the scheduler might dispatch all the I/O resources to fibers waiting for it.</p>

<p>Expected to return the subset of events that are ready immediately.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L728-L740'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='728' data-end='740'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 728</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_io_wait(VALUE scheduler, VALUE io, VALUE events, VALUE timeout)
{
    VALUE arguments[] = {
        scheduler, io, events, timeout
    };

    if (rb_respond_to(scheduler, id_fiber_interrupt)) {
        return rb_thread_io_blocking_operation(io, fiber_scheduler_io_wait, (VALUE)&amp;arguments);
    } else {
        return fiber_scheduler_io_wait((VALUE)&amp;arguments);
    }
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="io_write-instance_method">
  <h3 class='signature '>
    #<strong>io_write</strong>(io, buffer, length, offset)  &#x21d2; <code>written</code> <code>length</code>, -<code>errno</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by <a href="../IO.html#write-instance_method" title="IO#write (method)">IO#write</a> or <a href="../IO/Buffer.html#write-instance_method" title="IO::Buffer#write (method)">IO::Buffer#write</a> to write <code>length</code> bytes to <code>io</code> from from a specified <code>buffer</code> (see <a href="../IO/Buffer.html" title="IO::Buffer (class)"><code>::IO::Buffer</code></a>) at the given <code>offset</code>.</p>

<p>The <code>length</code> argument is the “minimum length to be written”. If the <a href="../IO.html" title="IO (class)"><code>::IO</code></a> buffer size is 8KiB, but the <code>length</code> specified is 1024 (1KiB), at most 8KiB will be written, but at least 1KiB will be. Generally, the only case where less data than <code>length</code> will be written is if there is an error writing the data.</p>

<p>Specifying a <code>length</code> of 0 is valid and means try writing at least once, as much data as possible.</p>

<p>Suggested implementation should try to write to <code>io</code> in a non-blocking manner and call <a href="#io_wait-instance_method" title="Fiber::Scheduler#io_wait (method)">#io_wait</a> if the <code>io</code> is not ready (which will yield control to other fibers).</p>

<p>See <a href="../IO/Buffer.html" title="IO::Buffer (class)"><code>::IO::Buffer</code></a> for an interface available to get data from buffer efficiently.</p>

<p>Expected to return number of bytes written, or, in case of an error, <code>-errno</code> (negated number corresponding to system’s error code).</p>

<p>The method should be considered <em>experimental</em>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L908-L924'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='908' data-end='924'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 908</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_io_write(VALUE scheduler, VALUE io, VALUE buffer, size_t length, size_t offset)
{
    if (!rb_respond_to(scheduler, id_io_write)) {
        return RUBY_Qundef;
    }

    VALUE arguments[] = {
        scheduler, io, buffer, SIZET2NUM(length), SIZET2NUM(offset)
    };

    if (rb_respond_to(scheduler, id_fiber_interrupt)) {
        return rb_thread_io_blocking_operation(io, fiber_scheduler_io_write, (VALUE)&amp;arguments);
    } else {
        return fiber_scheduler_io_write((VALUE)&amp;arguments);
    }
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="kernel_sleep-instance_method">
  <h3 class='signature '>
    #<strong>kernel_sleep</strong>(duration = nil)    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by <a href="../Kernel.html#sleep-class_method" title="Kernel.sleep (method)">Kernel.sleep</a> and <a href="../Thread/Mutex.html#sleep-instance_method" title="Thread::Mutex#sleep (method)">Thread::Mutex#sleep</a> and is expected to provide an implementation of sleeping in a non-blocking way. Implementation might register the current fiber in some list of “which fiber wait until what moment”, call <a href="../Fiber.html#yield-class_method" title="Fiber.yield (method)">Fiber.yield</a> to pass control, and then in <a href="#close-instance_method" title="Fiber::Scheduler#close (method)">#close</a> resume the fibers whose wait period has elapsed.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L529-L533'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='529' data-end='533'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 529</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_kernel_sleep(VALUE scheduler, VALUE timeout)
{
    return rb_funcall(scheduler, id_kernel_sleep, 1, timeout);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="process_wait-instance_method">
  <h3 class='signature '>
    #<strong>process_wait</strong>(pid, flags)    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by <code>Process::Status.wait</code> in order to wait for a specified process. See that method description for arguments description.</p>

<p>Suggested minimal implementation:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../Thread.html" title="Thread (class)">Thread</a></span>.<span class='id identifier rubyid_new'><a href="../Thread.html#new-class_method" title="Thread.new (method)">new</a></span> <span class='kw'>do</span>
  <span class='const'><a href="../Process.html" title="Process (module)">Process</a></span><span class='op'>::</span><span class='const'><a href="../Process/Status.html" title="Process::Status (class)">Status</a></span>.<span class='id identifier rubyid_wait'><a href="../Process.html#wait-class_method" title="Process.wait (method)">wait</a></span>(<span class='id identifier rubyid_pid'>pid</span><span class='comma'>,</span> <span class='id identifier rubyid_flags'>flags</span>)
<span class='kw'>end</span>.<span class='id identifier rubyid_value'>value</span></code></pre>

<p>This hook is optional: if it is not present in the current scheduler, <code>Process::Status.wait</code> will behave as a blocking method.</p>

<p>Expected to return a <a href="../Process/Status.html" title="Process::Status (class)"><code>::Process::Status</code></a> instance.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L622-L630'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='622' data-end='630'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 622</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_process_wait(VALUE scheduler, rb_pid_t pid, int flags)
{
    VALUE arguments[] = {
        PIDT2NUM(pid), RB_INT2NUM(flags)
    };

    return rb_check_funcall(scheduler, id_process_wait, 2, arguments);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="timeout_after-instance_method">
  <h3 class='signature '>
    #<strong>timeout_after</strong>(duration, exception_class, *exception_arguments, &amp;block)  &#x21d2; <code>result</code> <code>of</code> <a href="#block-instance_method" title="Fiber::Scheduler#block (method)">block</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked by <code>Timeout.timeout</code> to execute the given <a href="#block-instance_method" title="Fiber::Scheduler#block (method)">#block</a> within the given <code>duration</code>. It can also be invoked directly by the scheduler or user code.</p>

<p>Attempt to limit the execution time of a given <a href="#block-instance_method" title="Fiber::Scheduler#block (method)">#block</a> to the given <code>duration</code> if possible. When a non-blocking operation causes the <a href="#block-instance_method" title="Fiber::Scheduler#block (method)">#block</a>‘s execution time to exceed the specified <code>duration</code>, that non-blocking operation should be interrupted by raising the specified <code>exception_class</code> constructed with the given <code>exception_arguments</code>.</p>

<p>General execution timeouts are often considered risky. This implementation will only interrupt non-blocking operations. This is by design because it’s expected that non-blocking operations can fail for a variety of unpredictable reasons, so applications should already be robust in handling these conditions and by implication timeouts.</p>

<p>However, as a result of this design, if the <a href="#block-instance_method" title="Fiber::Scheduler#block (method)">#block</a> does not invoke any non-blocking operations, it will be impossible to interrupt it. If you desire to provide predictable points for timeouts, consider adding <code>sleep(0)</code>.</p>

<p>If the block is executed successfully, its result will be returned.</p>

<p>The exception will typically be raised using <a href="../Fiber.html#raise-instance_method" title="Fiber#raise (method)">Fiber#raise</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L587-L595'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='587' data-end='595'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 587</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_timeout_after(VALUE scheduler, VALUE timeout, VALUE exception, VALUE message)
{
    VALUE arguments[] = {
        timeout, exception, message
    };

    return rb_check_funcall(scheduler, id_timeout_after, 3, arguments);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="unblock-instance_method">
  <h3 class='signature '>
    #<strong>unblock</strong>(blocker, fiber)    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Invoked to wake up <a href="../Fiber.html" title="Fiber (class)"><code>::Fiber</code></a> previously blocked with <a href="#block-instance_method" title="Fiber::Scheduler#block (method)">#block</a> (for example, <a href="../Thread/Mutex.html#lock-instance_method" title="Thread::Mutex#lock (method)">Thread::Mutex#lock</a> calls <a href="#block-instance_method" title="Fiber::Scheduler#block (method)">#block</a> and <a href="../Thread/Mutex.html#unlock-instance_method" title="Thread::Mutex#unlock (method)">Thread::Mutex#unlock</a> calls <code>#unblock</code>). The scheduler should use the <a href="#fiber-instance_method" title="Fiber::Scheduler#fiber (method)">#fiber</a> parameter to understand which fiber is unblocked.</p>

<p><code>blocker</code> is what was awaited for, but it is informational only (for debugging and logging), and it is not guaranteed to be the same value as the <code>blocker</code> for <a href="#block-instance_method" title="Fiber::Scheduler#block (method)">#block</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L665-L700'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='665' data-end='700'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 665</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_unblock(VALUE scheduler, VALUE blocker, VALUE fiber)
{
    RUBY_ASSERT(rb_obj_is_fiber(fiber));

    VALUE result;
    enum ruby_tag_type state;

    // `rb_fiber_scheduler_unblock` can be called from points where `errno` is expected to be preserved. Therefore, we should save and restore it. For example `io_binwrite` calls `rb_fiber_scheduler_unblock` and if `errno` is reset to 0 by user code, it will break the error handling in `io_write`.
    //
    // If we explicitly preserve `errno` in `io_binwrite` and other similar functions (e.g. by returning it), this code is no longer needed. I hope in the future we will be able to remove it.
    int saved_errno = errno;

    // We must prevent interrupts while invoking the unblock method, because otherwise fibers can be left permanently blocked if an interrupt occurs during the execution of user code. See also `rb_fiber_scheduler_fiber_interrupt`.
    rb_execution_context_t *ec = GET_EC();
    int saved_interrupt_mask = ec-&gt;interrupt_mask;
    ec-&gt;interrupt_mask |= PENDING_INTERRUPT_MASK;

    EC_PUSH_TAG(ec);
    if ((state = EC_EXEC_TAG()) == TAG_NONE) {
        result = rb_funcall(scheduler, id_unblock, 2, blocker, fiber);
    }
    EC_POP_TAG();

    ec-&gt;interrupt_mask = saved_interrupt_mask;

    if (state) {
        EC_JUMP_TAG(ec, state);
    }

    RUBY_VM_CHECK_INTS(ec);

    errno = saved_errno;

    return result;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="yield-instance_method">
  <h3 class='signature '>
    #<strong>yield</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Yield to the scheduler, to be resumed on the next scheduling cycle.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/scheduler.c#L547-L556'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='547' data-end='556'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'scheduler.c', line 547</span></pre>
<pre class='code cpp'>

VALUE
rb_fiber_scheduler_yield(VALUE scheduler)
{
    // First try to call the scheduler&#39;s yield method, if it exists:
    VALUE result = rb_check_funcall(scheduler, id_yield, 0, NULL);
    if (!UNDEF_P(result)) return result;

    // Otherwise, we can emulate yield by sleeping for 0 seconds:
    return rb_fiber_scheduler_kernel_sleep(scheduler, RB_INT2NUM(0));
}
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>