<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen' content='yes'>
<meta name='mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Box &mdash; Ruby-master</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "box",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Ruby-master</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Box&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="file_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<h1>Ruby Box - Ruby&#39;s in-process separation of Classes and Modules</h1>

<p>Ruby Box is designed to provide separated spaces in a Ruby process, to isolate application code, libraries and monkey patches.</p>

<h2>Known issues</h2>

<ul>
<li>Experimental warning is shown when ruby starts with <code>RUBY_BOX=1</code> (specify <code>-W:no-experimental</code> option to hide it)</li>
<li>Installing native extensions may fail under <code>RUBY_BOX=1</code> because of stack level too deep in extconf.rb</li>
<li><code>require &#39;active_support/core_ext&#39;</code> may fail under <code>RUBY_BOX=1</code></li>
<li>Defined methods in a box may not be referred by built-in methods written in Ruby</li>
</ul>

<h2>TODOs</h2>

<ul>
<li>Add the loaded box on iseq to check if another box tries running the iseq (add a field only when VM_CHECK_MODE?)</li>
<li>Assign its own TOPLEVEL_BINDING in boxes</li>
<li>Fix calling <code>warn</code> in boxes to refer <code>$VERBOSE</code> and <code>Warning.warn</code> in the box</li>
<li>Make an internal data container class <code>Ruby::Box::Entry</code> invisible</li>
<li>More test cases about <code>$LOAD_PATH</code> and <code>$LOADED_FEATURES</code></li>
</ul>

<h2>How to use</h2>

<h3>Enabling Ruby Box</h3>

<p>First, an environment variable should be set at the ruby process bootup: <code>RUBY_BOX=1</code>.
The only valid value is <code>1</code> to enable Ruby Box. Other values (or unset <code>RUBY_BOX</code>) means disabling Ruby Box. And setting the value after Ruby program starts doesn&#39;t work.</p>

<h3>Using Ruby Box</h3>

<p><code>Ruby::Box</code> class is the entrypoint of Ruby Box.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_box'>box</span> <span class='op'>=</span> <span class='const'>Ruby</span><span class='op'>::</span><span class='const'>Box</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_box'>box</span>.<span class='id identifier rubyid_require'>require</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>something</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># or require_relative, load</span></code></pre>

<p>The required file (either .rb or .so/.dll/.bundle) is loaded in the box (<code>box</code> here). The required/loaded files from <code>something</code> will be loaded in the box recursively.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># something.rb
</span>
<span class='const'>X</span> <span class='op'>=</span> <span class='int'>1</span>

<span class='kw'>class</span> <span class='const'>Something</span>
  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_x'>x</span> <span class='op'>=</span> <span class='const'>X</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_x'>x</span> <span class='op'>=</span> <span class='op'>::</span><span class='const'>X</span>
<span class='kw'>end</span></code></pre>

<p>Classes/modules, those methods and constants defined in the box can be accessed via <code>box</code> object.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>X</span> <span class='op'>=</span> <span class='int'>2</span>
<span class='id identifier rubyid_p'>p</span> <span class='const'>X</span>                 <span class='comment'># 2
</span><span class='id identifier rubyid_p'>p</span> <span class='op'>::</span><span class='const'>X</span>               <span class='comment'># 2
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_box'>box</span><span class='op'>::</span><span class='const'>Something</span>.<span class='id identifier rubyid_x'>x</span>  <span class='comment'># 1
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_box'>box</span><span class='op'>::</span><span class='const'>X</span>            <span class='comment'># 1</span></code></pre>

<p>Instance methods defined in the box also run with definitions in the box.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='id identifier rubyid_box'>box</span><span class='op'>::</span><span class='const'>Something</span>.<span class='id identifier rubyid_new'>new</span>

<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_s'>s</span>.<span class='id identifier rubyid_x'>x</span>  <span class='comment'># 1</span></code></pre>

<h2>Specifications</h2>

<h3>Ruby Box types</h3>

<p>There are two box types:</p>

<ul>
<li>Root box</li>
<li>User boxes</li>
</ul>

<p>There is the root box, just a single box in a Ruby process. Ruby bootstrap runs in the root box, and all builtin classes/modules are defined in the root box. (See &quot;Builtin classes and modules&quot;.)</p>

<p>User boxes are to run user-written programs and libraries loaded from user programs. The user&#39;s main program (specified by the <code>ruby</code> command line argument) is executed in the &quot;main&quot; box, which is a user box automatically created at the end of Ruby&#39;s bootstrap, copied from the root box.</p>

<p>When <code>Ruby::Box.new</code> is called, an &quot;optional&quot; box (a user, non-main box) is created, copied from the root box. All user boxes are flat, copied from the root box.</p>

<h3>Ruby Box class and instances</h3>

<p><code>Ruby::Box</code> is a class, as a subclass of <code>Module</code>. <code>Ruby::Box</code> instances are a kind of <code>Module</code>.</p>

<h3>Classes and modules defined in boxes</h3>

<p>The classes and modules, newly defined in a box <code>box</code>, are accessible via <code>box</code>. For example, if a class <code>A</code> is defined in <code>box</code>, it is accessible as <code>box::A</code> from outside of the box.</p>

<p>In the box <code>box</code>, <code>A</code> can be referred to as <code>A</code> (and <code>::A</code>).</p>

<h3>Built-in classes and modules reopened in boxes</h3>

<p>In boxes, builtin classes/modules are visible and can be reopened. Those classes/modules can be reopened using <code>class</code> or <code>module</code> clauses, and class/module definitions can be changed.</p>

<p>The changed definitions are visible only in the box. In other boxes, builtin classes/modules and those instances work without changed definitions.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># in foo.rb
</span><span class='kw'>class</span> <span class='const'>String</span>
  <span class='const'>BLANK_PATTERN</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A\s*\z</span><span class='regexp_end'>/</span></span>
  <span class='kw'>def</span> <span class='id identifier rubyid_blank?'>blank?</span>
    <span class='kw'>self</span>.<span class='id identifier rubyid_match?'>match?</span>(<span class='const'>BLANK_PATTERN</span>)
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='kw'>module</span> <span class='const'>Foo</span>
  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_foo'>foo</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>

  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_foo_is_blank?'>foo_is_blank?</span>
    <span class='id identifier rubyid_foo'>foo</span>.<span class='id identifier rubyid_blank?'>blank?</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='const'>Foo</span>.<span class='id identifier rubyid_foo'>foo</span>.<span class='id identifier rubyid_blank?'>blank?</span> <span class='comment'>#=&gt; false
</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_blank?'>blank?</span>   <span class='comment'>#=&gt; false
</span>
<span class='comment'># in main.rb
</span><span class='id identifier rubyid_box'>box</span> <span class='op'>=</span> <span class='const'>Ruby</span><span class='op'>::</span><span class='const'>Box</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_box'>box</span>.<span class='id identifier rubyid_require_relative'>require_relative</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)

<span class='id identifier rubyid_box'>box</span><span class='op'>::</span><span class='const'>Foo</span>.<span class='id identifier rubyid_foo_is_blank?'>foo_is_blank?</span> <span class='comment'>#=&gt; false   (#blank? called in box)
</span>
<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_blank?'>blank?</span>          <span class='comment'># NoMethodError
</span><span class='const'>String</span><span class='op'>::</span><span class='const'>BLANK_PATTERN</span> <span class='comment'># NameError</span></code></pre>

<p>The main box and <code>box</code> are different boxes, so monkey patches in main are also invisible in <code>box</code>.</p>

<h3>Builtin classes and modules</h3>

<p>In the box context, &quot;builtin&quot; classes and modules are classes and modules:</p>

<ul>
<li>Accessible without any <code>require</code> calls in user scripts</li>
<li>Defined before any user program start running</li>
<li>Including classes/modules loaded by <code>prelude.rb</code> (including RubyGems <code>Gem</code>, for example)</li>
</ul>

<p>Hereafter, &quot;builtin classes and modules&quot; will be referred to as just &quot;builtin classes&quot;.</p>

<h3>Builtin classes referred via box objects</h3>

<p>Builtin classes in a box <code>box</code> can be referred from other boxes. For example, <code>box::String</code> is a valid reference, and <code>String</code> and <code>box::String</code> are identical (<code>String == box::String</code>, <code>String.object_id == box::String.object_id</code>).</p>

<p><code>box::String</code>-like reference returns just a <code>String</code> in the current box, so its definition is <code>String</code> in the box, not in <code>box</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># foo.rb
</span><span class='kw'>class</span> <span class='const'>String</span>
  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_foo'>foo</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>

<span class='comment'># main.rb
</span><span class='id identifier rubyid_box'>box</span> <span class='op'>=</span> <span class='const'>Ruby</span><span class='op'>::</span><span class='const'>Box</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_box'>box</span>.<span class='id identifier rubyid_require_relative'>require_relative</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)

<span class='id identifier rubyid_box'>box</span><span class='op'>::</span><span class='const'>String</span>.<span class='id identifier rubyid_foo'>foo</span>  <span class='comment'># NoMethodError</span></code></pre>

<h3>Class instance variables, class variables, constants</h3>

<p>Builtin classes can have different sets of class instance variables, class variables and constants between boxes.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># foo.rb
</span><span class='kw'>class</span> <span class='const'>Array</span>
  <span class='ivar'>@v</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>
  <span class='cvar'>@@v</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>_foo_</span><span class='tstring_end'>&quot;</span></span>
  <span class='const'>V</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>FOO</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>

<span class='const'>Array</span>.<span class='id identifier rubyid_instance_variable_get'>instance_variable_get</span>(<span class='symbeg'>:</span><span class='ivar'>@v</span>) <span class='comment'>#=&gt; &quot;foo&quot;
</span><span class='const'>Array</span>.<span class='id identifier rubyid_class_variable_get'>class_variable_get</span>(<span class='symbeg'>:</span><span class='cvar'>@@v</span>)   <span class='comment'>#=&gt; &quot;_foo_&quot;
</span><span class='const'>Array</span>.<span class='id identifier rubyid_const_get'>const_get</span>(<span class='symbeg'>:</span><span class='const'>V</span>)              <span class='comment'>#=&gt; &quot;FOO&quot;
</span>
<span class='comment'># main.rb
</span><span class='id identifier rubyid_box'>box</span> <span class='op'>=</span> <span class='const'>Ruby</span><span class='op'>::</span><span class='const'>Box</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_box'>box</span>.<span class='id identifier rubyid_require_relative'>require_relative</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)

<span class='const'>Array</span>.<span class='id identifier rubyid_instance_variable_get'>instance_variable_get</span>(<span class='symbeg'>:</span><span class='ivar'>@v</span>) <span class='comment'>#=&gt; nil
</span><span class='const'>Array</span>.<span class='id identifier rubyid_class_variable_get'>class_variable_get</span>(<span class='symbeg'>:</span><span class='cvar'>@@v</span>)   <span class='comment'># NameError
</span><span class='const'>Array</span>.<span class='id identifier rubyid_const_get'>const_get</span>(<span class='symbeg'>:</span><span class='const'>V</span>)              <span class='comment'># NameError</span></code></pre>

<h3>Global variables</h3>

<p>In boxes, changes on global variables are also isolated in the boxes. Changes on global variables in a box are visible/applied only in the box.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># foo.rb
</span><span class='gvar'>$foo</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>
<span class='gvar'>$VERBOSE</span> <span class='op'>=</span> <span class='kw'>nil</span>

<span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>This appears: &#39;</span><span class='embexpr_beg'>#{</span><span class='gvar'>$foo</span><span class='embexpr_end'>}</span><span class='tstring_content'>&#39;</span><span class='tstring_end'>&quot;</span></span>

<span class='comment'># main.rb
</span><span class='id identifier rubyid_p'>p</span> <span class='gvar'>$foo</span>      <span class='comment'>#=&gt; nil
</span><span class='id identifier rubyid_p'>p</span> <span class='gvar'>$VERBOSE</span>  <span class='comment'>#=&gt; false
</span>
<span class='id identifier rubyid_box'>box</span> <span class='op'>=</span> <span class='const'>Ruby</span><span class='op'>::</span><span class='const'>Box</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_box'>box</span>.<span class='id identifier rubyid_require_relative'>require_relative</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)  <span class='comment'># &quot;This appears: &#39;foo&#39;&quot;
</span>
<span class='id identifier rubyid_p'>p</span> <span class='gvar'>$foo</span>      <span class='comment'>#=&gt; nil
</span><span class='id identifier rubyid_p'>p</span> <span class='gvar'>$VERBOSE</span>  <span class='comment'>#=&gt; false</span></code></pre>

<h3>Top level constants</h3>

<p>Usually, top level constants are defined as constants of <code>Object</code>. In boxes, top level constants are constants of <code>Object</code> in the box. And the box object <code>box</code>&#39;s constants are strictly equal to constants of <code>Object</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># foo.rb
</span><span class='const'>FOO</span> <span class='op'>=</span> <span class='int'>100</span>

<span class='const'>FOO</span>         <span class='comment'>#=&gt; 100
</span><span class='const'>Object</span><span class='op'>::</span><span class='const'>FOO</span> <span class='comment'>#=&gt; 100
</span>
<span class='comment'># main.rb
</span><span class='id identifier rubyid_box'>box</span> <span class='op'>=</span> <span class='const'>Ruby</span><span class='op'>::</span><span class='const'>Box</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_box'>box</span>.<span class='id identifier rubyid_require_relative'>require_relative</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)

<span class='id identifier rubyid_box'>box</span><span class='op'>::</span><span class='const'>FOO</span>      <span class='comment'>#=&gt; 100
</span>
<span class='const'>FOO</span>          <span class='comment'># NameError
</span><span class='const'>Object</span><span class='op'>::</span><span class='const'>FOO</span>  <span class='comment'># NameError</span></code></pre>

<h3>Top level methods</h3>

<p>Top level methods are private instance methods of <code>Object</code>, in each box.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># foo.rb
</span><span class='kw'>def</span> <span class='id identifier rubyid_yay'>yay</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&quot;</span></span>

<span class='kw'>class</span> <span class='const'>Foo</span>
  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_say'>say</span> <span class='op'>=</span> <span class='id identifier rubyid_yay'>yay</span>
<span class='kw'>end</span>

<span class='const'>Foo</span>.<span class='id identifier rubyid_say'>say</span> <span class='comment'>#=&gt; &quot;foo&quot;
</span><span class='id identifier rubyid_yay'>yay</span>     <span class='comment'>#=&gt; &quot;foo&quot;
</span>
<span class='comment'># main.rb
</span><span class='id identifier rubyid_box'>box</span> <span class='op'>=</span> <span class='const'>Ruby</span><span class='op'>::</span><span class='const'>Box</span>.<span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_box'>box</span>.<span class='id identifier rubyid_require_relative'>require_relative</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)

<span class='id identifier rubyid_box'>box</span><span class='op'>::</span><span class='const'>Foo</span>.<span class='id identifier rubyid_say'>say</span>  <span class='comment'>#=&gt; &quot;foo&quot;
</span>
<span class='id identifier rubyid_yay'>yay</span>  <span class='comment'># NoMethodError</span></code></pre>

<p>There is no way to expose top level methods in boxes to others.
(See &quot;Expose top level methods as a method of the box object&quot; in &quot;Discussions&quot; section below)</p>

<h3>Ruby Box scopes</h3>

<p>Ruby Box works in file scope. One <code>.rb</code> file runs in a single box.</p>

<p>Once a file is loaded in a box <code>box</code>, all methods/procs defined/created in the file run in <code>box</code>.</p>

<h3>Utility methods</h3>

<p>Several methods are available for trying/testing Ruby Box.</p>

<ul>
<li><code>Ruby::Box.current</code> returns the current box</li>
<li><code>Ruby::Box.enabled?</code> returns true/false to represent <code>RUBY_BOX=1</code> is specified or not</li>
<li><code>Ruby::Box.root</code> returns the root box</li>
<li><code>Ruby::Box.main</code> returns the main box</li>
<li><code>Ruby::Box#eval</code> evaluates a Ruby code (String) in the receiver box, just like calling <code>#load</code> with a file</li>
</ul>

<h2>Implementation details</h2>

<h4>ISeq inline method/constant cache</h4>

<p>As described above in &quot;Ruby Box scopes&quot;, an &quot;.rb&quot; file runs in a box. So method/constant resolution will be done in a box consistently.</p>

<p>That means ISeq inline caches work well even with boxes. Otherwise, it&#39;s a bug.</p>

<h4>Method call global cache (gccct)</h4>

<p><code>rb_funcall()</code> C function refers to the global cc cache table (gccct), and the cache key is calculated with the current box.</p>

<p>So, <code>rb_funcall()</code> calls have a performance penalty when Ruby Box is enabled.</p>

<h4>Current box and loading box</h4>

<p>The current box is the box that the executing code is in. <code>Ruby::Box.current</code> returns the current box object.</p>

<p>The loading box is an internally managed box to determine the box to load newly required/loaded files. For example, <code>box</code> is the loading box when <code>box.require(&quot;foo&quot;)</code> is called.</p>

<h2>Discussions</h2>

<h4>More builtin methods written in Ruby</h4>

<p>If Ruby Box is enabled by default, builtin methods can be written in Ruby because it can&#39;t be overridden by users&#39; monkey patches. Builtin Ruby methods can be JIT-ed, and it could bring performance reward.</p>

<h4>Monkey patching methods called by builtin methods</h4>

<p>Builtin methods sometimes call other builtin methods. For example, <code>Hash#map</code> calls <code>Hash#each</code> to retrieve entries to be mapped. Without Ruby Box, Ruby users can overwrite <code>Hash#each</code> and expect the behavior change of <code>Hash#map</code> as a result.</p>

<p>But with boxes, <code>Hash#map</code> runs in the root box. Ruby users can define <code>Hash#each</code> only in user boxes, so users cannot change <code>Hash#map</code>&#39;s behavior in this case. To achieve it, users should override both<code>Hash#map</code> and <code>Hash#each</code> (or only <code>Hash#map</code>).</p>

<p>It is a breaking change.</p>

<p>Users can define methods using <code>Ruby::Box.root.eval(...)</code>, but it&#39;s clearly not ideal API.</p>

<h4>Assigning values to global variables used by builtin methods</h4>

<p>Similar to monkey patching methods, global variables assigned in a box is separated from the root box. Methods defined in the root box referring a global variable can&#39;t find the re-assigned one.</p>

<h4>Context of <code>$LOAD_PATH</code> and <code>$LOADED_FEATURES</code></h4>

<p>Global variables <code>$LOAD_PATH</code> and <code>$LOADED_FEATURES</code> control <code>require</code> method behaviors. So those variables are determined by the loading box instead of the current box.</p>

<p>This could potentially conflict with the user&#39;s expectations. We should find the solution.</p>

<h4>Expose top level methods as a method of the box object</h4>

<p>Currently, top level methods in boxes are not accessible from outside of the box. But there might be a use case to call other box&#39;s top level methods.</p>

<h4>Split root and builtin box</h4>

<p>Currently, the single &quot;root&quot; box is the source of classext CoW. And also, the &quot;root&quot; box can load additional files after starting main script evaluation by calling methods which contain lines like <code>require &quot;openssl&quot;</code>.</p>

<p>That means, user boxes can have different sets of definitions according to when it is created.</p>

<pre class="code ruby"><code class="ruby">[<span class='id identifier rubyid_root'>root</span>]
 <span class='op'>|</span>
 <span class='op'>|</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span>[<span class='id identifier rubyid_main'>main</span>]
 <span class='op'>|</span>
 <span class='op'>|</span>(<span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>openssl</span><span class='tstring_end'>&quot;</span></span> <span class='id identifier rubyid_called'>called</span> <span class='kw'>in</span> <span class='id identifier rubyid_root'>root</span>)
 <span class='op'>|</span>
 <span class='op'>|</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span>[<span class='id identifier rubyid_box1'>box1</span>] <span class='id identifier rubyid_having'>having</span> <span class='const'>OpenSSL</span>
 <span class='op'>|</span>
 <span class='op'>|</span>(<span class='id identifier rubyid_remove_const'>remove_const</span> <span class='id identifier rubyid_called'>called</span> <span class='kw'>for</span> <span class='const'>OpenSSL</span> <span class='kw'>in</span> <span class='id identifier rubyid_root'>root</span>)
 <span class='op'>|</span>
 <span class='op'>|</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span><span class='op'>-</span>[<span class='id identifier rubyid_box2'>box2</span>] <span class='id identifier rubyid_without'>without</span> <span class='const'>OpenSSL</span></code></pre>

<p>This could cause unexpected behavior differences between user boxes. It should NOT be a problem because user scripts which refer to <code>OpenSSL</code> should call <code>require &quot;openssl&quot;</code> by themselves.
But in the worst case, a script (without <code>require &quot;openssl&quot;</code>) runs well in <code>box1</code>, but doesn&#39;t run in <code>box2</code>. This situation looks like a &quot;random failure&quot; to users.</p>

<p>An option possible to prevent this situation is to have &quot;root&quot; and &quot;builtin&quot; boxes.</p>

<ul>
<li>root

<ul>
<li>The box for the Ruby process bootstrap, then the source of CoW</li>
<li>After starting the main box, no code runs in this box</li>
</ul></li>
<li>builtin

<ul>
<li>The box copied from the root box at the same time with &quot;main&quot;</li>
<li>Methods and procs defined in the &quot;root&quot; box run in this box</li>
<li>Classes and modules required will be loaded in this box</li>
</ul></li>
</ul>

<p>This design realizes a consistent source of box CoW.</p>

<h4>Separate <code>cc_tbl</code> and <code>callable_m_tbl</code>, <code>cvc_tbl</code> for less classext CoW</h4>

<p>The fields of <code>rb_classext_t</code> contains several cache(-like) data, <code>cc_tbl</code>(callcache table), <code>callable_m_tbl</code>(table of resolved complemented methods) and <code>cvc_tbl</code>(class variable cache table).</p>

<p>The classext CoW is triggered when the contents of <code>rb_classext_t</code> are changed, including <code>cc_tbl</code>, <code>callable_m_tbl</code>, and <code>cvc_tbl</code>. But those three tables are changed by just calling methods or referring class variables. So, currently, classext CoW is triggered much more times than the original expectation.</p>

<p>If we can move those three tables outside of <code>rb_classext_t</code>, the number of copied <code>rb_classext_t</code> will be much less than the current implementation.</p>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>