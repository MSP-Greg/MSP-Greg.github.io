<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Doc &mdash; typeprof  Ruby-master dev</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "doc",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../.'>Ruby-master</a> &raquo; 
      <a href='.'>typeprof</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Doc&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<h1>TypeProf: A type analysis tool for Ruby code based on abstract interpretation</h1>

<h2>How to use TypeProf as a CLI tool</h2>

<p>Analyze app.rb:</p>

<pre class="code ruby"><code class="ruby"><span class='gvar'>$ </span><span class='id identifier rubyid_typeprof'>typeprof</span> <span class='id identifier rubyid_app'>app</span>.<span class='id identifier rubyid_rb'>rb</span></code></pre>

<p>Analyze app.rb with sig/app.rbs that specifies some method types:</p>

<pre class="code ruby"><code class="ruby"><span class='gvar'>$ </span><span class='id identifier rubyid_typeprof'>typeprof</span> <span class='id identifier rubyid_sig'>sig</span><span class='op'>/</span><span class='id identifier rubyid_app'>app</span>.<span class='id identifier rubyid_rbs'>rbs</span> <span class='id identifier rubyid_app'>app</span>.<span class='id identifier rubyid_rb'>rb</span></code></pre>

<p>Here is a typical use case:</p>

<pre class="code ruby"><code class="ruby"><span class='gvar'>$ </span><span class='id identifier rubyid_typeprof'>typeprof</span> <span class='id identifier rubyid_sig'>sig</span><span class='op'>/</span><span class='id identifier rubyid_app'>app</span>.<span class='id identifier rubyid_rbs'>rbs</span> <span class='id identifier rubyid_app'>app</span>.<span class='id identifier rubyid_rb'>rb</span> <span class='op'>-</span><span class='id identifier rubyid_o'>o</span> <span class='id identifier rubyid_sig'>sig</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>app.gen.rbs</span></code></pre>

<h2>How to use TypeProf as a Language Server</h2>

<p>See <a href="https://speakerdeck.com/mame/good-first-issues-of-typeprof">the slide deck of my talk in RubyKaigi 2024</a> for now.</p>

<h2>What is a TypeProf?</h2>

<p>TypeProf is a Ruby interpreter that <em>abstractly</em> executes Ruby programs at the type level.
It executes a given program and observes what types are passed to and returned from methods and what types are assigned to instance variables.
All values are, in principle, abstracted to the class to which the object belongs, not the object itself (detailed in the next section).</p>

<p>Here is an example of a method call.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_foo'>foo</span>(<span class='id identifier rubyid_n'>n</span>)
  <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_n'>n</span>      <span class='comment'>#=&gt; Integer
</span>  <span class='id identifier rubyid_n'>n</span>.<span class='id identifier rubyid_to_s'>to_s</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_foo'>foo</span>(<span class='int'>42</span>)  <span class='comment'>#=&gt; String</span></code></pre>

<p>The analysis results of TypeProf are as follows.</p>

<pre class="code ruby"><code class="ruby"><span class='gvar'>$ </span><span class='id identifier rubyid_ruby'>ruby</span> <span class='id identifier rubyid_exe'>exe</span><span class='op'>/</span><span class='id identifier rubyid_typeprof'>typeprof</span> <span class='id identifier rubyid_test'>test</span>.<span class='id identifier rubyid_rb'>rb</span>
<span class='comment'># Revealed types
</span><span class='comment'>#  test.rb:2 #=&gt; Integer
</span><span class='comment'>#  test.rb:6 #=&gt; String
</span>
<span class='comment'># Classes
</span><span class='kw'>class</span> <span class='const'>Object</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_foo'>foo</span> <span class='op'>:</span> (<span class='const'>Integer</span>) <span class='tlambda'>-&gt;</span> <span class='const'>String</span>
<span class='kw'>end</span></code></pre>

<p>When the method call <code>foo(42)</code> is executed, the type (abstract value) &quot;<code>Integer</code>&quot; is passed instead of the <code>Integer</code> object 42.
The method <code>foo</code> executes <code>n.to_s</code>.
Then, the built-in method <code>Integer#to_s</code> is called and you get the type &quot;<code>String</code>&quot;, which the method <code>foo</code> returns.
Collecting observations of these execution results, TypeProf outputs, &quot;the method <code>foo</code> receives <code>Integer</code> and returns <code>String</code>&quot; in the RBS format.
Also, the argument of <code>p</code> is output in the <code>Revealed types</code> section.</p>

<p>Instance variables are stored in each object in Ruby, but are aggregated in class units in TypeProf.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Foo</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span>
    <span class='ivar'>@a</span> <span class='op'>=</span> <span class='int'>42</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_attr_accessor'>attr_accessor</span> <span class='symbeg'>:</span><span class='id identifier rubyid_a'>a</span>
<span class='kw'>end</span>

<span class='const'>Foo</span>.<span class='id identifier rubyid_new'>new</span>.<span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>str</span><span class='tstring_end'>&quot;</span></span>

<span class='id identifier rubyid_p'>p</span> <span class='const'>Foo</span>.<span class='id identifier rubyid_new'>new</span>.<span class='id identifier rubyid_a'>a</span> <span class='comment'>#=&gt; Integer | String</span></code></pre>

<pre class="code ruby"><code class="ruby"><span class='gvar'>$ </span><span class='id identifier rubyid_ruby'>ruby</span> <span class='id identifier rubyid_exe'>exe</span><span class='op'>/</span><span class='id identifier rubyid_typeprof'>typeprof</span> <span class='id identifier rubyid_test'>test</span>.<span class='id identifier rubyid_rb'>rb</span>
<span class='comment'># Revealed types
</span><span class='comment'>#  test.rb:11 #=&gt; Integer | String
</span>
<span class='comment'># Classes
</span><span class='kw'>class</span> <span class='const'>Foo</span>
  <span class='id identifier rubyid_attr_accessor'>attr_accessor</span> <span class='id identifier rubyid_a'>a</span> <span class='op'>:</span> <span class='const'>Integer</span> <span class='op'>|</span> <span class='const'>String</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span> <span class='op'>:</span> <span class='tlambda'>-&gt;</span> <span class='const'>Integer</span>
<span class='kw'>end</span></code></pre>

<h2>Abstract values</h2>

<p>As mentioned above, TypeProf abstracts almost all Ruby values to the type level, with some exceptions like class objects.
To avoid confusion with normal Ruby values, we use the word &quot;abstract value&quot; to refer the values that TypeProf handles.</p>

<p>TypeProf handles the following abstract values.</p>

<ul>
<li>Instance of a class</li>
<li>Class object</li>
<li>Symbol</li>
<li><code>untyped</code></li>
<li>Union of abstract values</li>
<li>Instance of a container class</li>
<li>Proc object</li>
</ul>

<p>Instances of classes are the most common values.
A Ruby code <code>Foo.new</code> returns an instance of the class <code>Foo</code>.
This abstract value is represented as <code>Foo</code> in the RBS format, though it is a bit confusing.
The integer literal <code>42</code> generates an instance of <code>Integer</code> and the string literal <code>&quot;str&quot;</code> generates an instance of <code>String</code>.</p>

<p>A class object is a value that represents the class itself.
For example, the constants <code>Integer</code> and <code>String</code> has class objects.
In Ruby semantics, a class object is an instance of the class <code>Class</code>, but it is not abstracted into <code>Class</code> in TypeProf.
This is because, if it is abstracted, TypeProf cannot handle constant references and class methods correctly.</p>

<p>A symbol is an abstract value returned by Symbol literals like <code>:foo</code>.
A symbol object is not abstracted to an instance of the class <code>Symbol</code> because its concrete value is often required in many cases, such as keyword arguments, JSON data keys, the argument of <code>Module#attr_reader</code>, etc.
Note that some Symbol objects are handled as instances of the class <code>Symbol</code>, for example, the return value of <code>String#to_sym</code> and Symbol literals that contains interpolation like <code>:&quot;foo_#{ x }&quot;</code>.</p>

<p><code>untyped</code> is an abstract value generated when TypeProf fails to trace values due to analysis limits or restrictions.
Any operations and method calls on <code>untyped</code> are ignored, and the evaluation result is also <code>untyped</code>.</p>

<p>A union of abstract values is a value that represents multiple possibilities.,
For (a bit artificial) example, the result of <code>rand &lt; 0.5 ? 42 : &quot;str&quot;</code> is a union, <code>Integer | String</code>.</p>

<p>An instance of a container class, such as Array and Hash, is an object that contains other abstract values as elements.
At present, only Array, Enumerator and Hash are supported.
Details will be described later.</p>

<p>A Proc object is a closure produced by lambda expressions (<code>-&gt; {... }</code>) and block parameters (<code>&amp;blk</code>).
During the interpretation, these objects are not abstracted but treated as concrete values associated with a piece of code.
In the RBS result, they are represented by using anonymous proc type, whose types they accepted and returned.</p>

<p>TODO: write more</p>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>