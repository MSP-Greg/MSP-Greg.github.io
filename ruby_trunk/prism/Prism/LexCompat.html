<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: Prism::LexCompat &mdash; prism  Ruby-master dev</title>

<link rel='stylesheet'  type='text/css' href='../../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Prism::LexCompat",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../../'>Ruby-master</a> &raquo; 
      <a href='../'>prism</a> &raquo; 
      <a href='../_index.html#alpha_L'>Index (L)</a> &raquo; 
        <a href="../Prism.html" title="Prism (module)">Prism</a> &raquo; 
      <span class='title'><a class='nodoc' id='t2_doc_top' href='#'>LexCompat&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: Prism::LexCompat</h1>
  <div class='note nodoc inline-block'>
    <strong>Do not use.  This class is for internal use only.</strong>
  </div>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Namespace Children</td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Modules:</div>
      <div class='box_11'>
          <a class='nodoc' href="LexCompat/Heredoc.html" title="Prism::LexCompat::Heredoc (module)"><code>Heredoc</code></a>      </div>
    </td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Classes:</div>
      <div class='box_11'>
          <a href="LexCompat/EndContentToken.html" title="Prism::LexCompat::EndContentToken (class)"><code>EndContentToken</code></a>,
        <a href="LexCompat/IdentToken.html" title="Prism::LexCompat::IdentToken (class)"><code>IdentToken</code></a>,
        <a href="LexCompat/IgnoreStateToken.html" title="Prism::LexCompat::IgnoreStateToken (class)"><code>IgnoreStateToken</code></a>,
        <a href="LexCompat/IgnoredNewlineToken.html" title="Prism::LexCompat::IgnoredNewlineToken (class)"><code>IgnoredNewlineToken</code></a>,
        <a href="LexCompat/ParamToken.html" title="Prism::LexCompat::ParamToken (class)"><code>ParamToken</code></a>,
        <a href="LexCompat/Token.html" title="Prism::LexCompat::Token (class)"><code>Token</code></a>      </div>
    </td></tr>
    <tr>
      <td id='t2_inherits' class='box_2'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'>Object</span>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby/ruby/blob/master/lib/prism/lex_compat.rb#L12'>lib/prism/lex_compat.rb</a>      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p>This class is responsible for lexing the source using prism and then converting those tokens to be compatible with <a href="../top-level-namespace.html#Ripper-constant" title="Ripper (constant)">Ripper</a>. In the vast majority of cases, this is a one-to-one mapping of the token type. Everything else generally lines up. However, there are a few cases that require special handling.</p>

  </div>
</div>
</div>
<h2 id='t2_cnst' class='h2_sum'>Constant Summary</h2>
<div>
<ul class='constants summary full nodoc'>
  <li>
    <span id='RIPPER-constant' class='summary_signature nodoc'>RIPPER =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>This is a mapping of prism token types to <a href="../top-level-namespace.html#Ripper-constant" title="Ripper (constant)">Ripper</a> token types. This is a many-to-one mapping because we split up our token types, whereas <a href="../top-level-namespace.html#Ripper-constant" title="Ripper (constant)">Ripper</a> tends to group them.</p>

  </div>
</div>
    <a class='repo' href='https://github.com/ruby/ruby/blob/master/lib/prism/lex_compat.rb#L16-L182'># File 'lib/prism/lex_compat.rb', line 16</a>    <pre class='code ruby'>{
  <span class='label'>AMPERSAND:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>AMPERSAND_AMPERSAND:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>AMPERSAND_AMPERSAND_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>AMPERSAND_DOT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>AMPERSAND_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>BACK_REFERENCE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_backref'>on_backref</span><span class='comma'>,</span>
  <span class='label'>BACKTICK:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_backtick'>on_backtick</span><span class='comma'>,</span>
  <span class='label'>BANG:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>BANG_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>BANG_TILDE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>BRACE_LEFT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_lbrace'>on_lbrace</span><span class='comma'>,</span>
  <span class='label'>BRACE_RIGHT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_rbrace'>on_rbrace</span><span class='comma'>,</span>
  <span class='label'>BRACKET_LEFT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_lbracket'>on_lbracket</span><span class='comma'>,</span>
  <span class='label'>BRACKET_LEFT_ARRAY:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_lbracket'>on_lbracket</span><span class='comma'>,</span>
  <span class='label'>BRACKET_LEFT_RIGHT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>BRACKET_LEFT_RIGHT_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>BRACKET_RIGHT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_rbracket'>on_rbracket</span><span class='comma'>,</span>
  <span class='label'>CARET:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>CARET_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>CHARACTER_LITERAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_CHAR'>on_CHAR</span><span class='comma'>,</span>
  <span class='label'>CLASS_VARIABLE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_cvar'>on_cvar</span><span class='comma'>,</span>
  <span class='label'>COLON:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>COLON_COLON:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>COMMA:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_comma'>on_comma</span><span class='comma'>,</span>
  <span class='label'>COMMENT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_comment'>on_comment</span><span class='comma'>,</span>
  <span class='label'>CONSTANT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_const'>on_const</span><span class='comma'>,</span>
  <span class='label'>DOT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_period'>on_period</span><span class='comma'>,</span>
  <span class='label'>DOT_DOT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>DOT_DOT_DOT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>EMBDOC_BEGIN:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_embdoc_beg'>on_embdoc_beg</span><span class='comma'>,</span>
  <span class='label'>EMBDOC_END:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_embdoc_end'>on_embdoc_end</span><span class='comma'>,</span>
  <span class='label'>EMBDOC_LINE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_embdoc'>on_embdoc</span><span class='comma'>,</span>
  <span class='label'>EMBEXPR_BEGIN:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_embexpr_beg'>on_embexpr_beg</span><span class='comma'>,</span>
  <span class='label'>EMBEXPR_END:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_embexpr_end'>on_embexpr_end</span><span class='comma'>,</span>
  <span class='label'>EMBVAR:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_embvar'>on_embvar</span><span class='comma'>,</span>
  <span class='label'>EOF:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_eof'>on_eof</span><span class='comma'>,</span>
  <span class='label'>EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>EQUAL_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>EQUAL_EQUAL_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>EQUAL_GREATER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>EQUAL_TILDE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>FLOAT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_float'>on_float</span><span class='comma'>,</span>
  <span class='label'>FLOAT_IMAGINARY:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_imaginary'>on_imaginary</span><span class='comma'>,</span>
  <span class='label'>FLOAT_RATIONAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_rational'>on_rational</span><span class='comma'>,</span>
  <span class='label'>FLOAT_RATIONAL_IMAGINARY:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_imaginary'>on_imaginary</span><span class='comma'>,</span>
  <span class='label'>GREATER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>GREATER_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>GREATER_GREATER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>GREATER_GREATER_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>GLOBAL_VARIABLE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_gvar'>on_gvar</span><span class='comma'>,</span>
  <span class='label'>HEREDOC_END:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_heredoc_end'>on_heredoc_end</span><span class='comma'>,</span>
  <span class='label'>HEREDOC_START:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_heredoc_beg'>on_heredoc_beg</span><span class='comma'>,</span>
  <span class='label'>IDENTIFIER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_ident'>on_ident</span><span class='comma'>,</span>
  <span class='label'>IGNORED_NEWLINE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_ignored_nl'>on_ignored_nl</span><span class='comma'>,</span>
  <span class='label'>INTEGER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_int'>on_int</span><span class='comma'>,</span>
  <span class='label'>INTEGER_IMAGINARY:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_imaginary'>on_imaginary</span><span class='comma'>,</span>
  <span class='label'>INTEGER_RATIONAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_rational'>on_rational</span><span class='comma'>,</span>
  <span class='label'>INTEGER_RATIONAL_IMAGINARY:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_imaginary'>on_imaginary</span><span class='comma'>,</span>
  <span class='label'>INSTANCE_VARIABLE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_ivar'>on_ivar</span><span class='comma'>,</span>
  <span class='label'>INVALID:</span> <span class='symbeg'>:</span><span class='const'>INVALID</span><span class='comma'>,</span>
  <span class='label'>KEYWORD___ENCODING__:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD___LINE__:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD___FILE__:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_ALIAS:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_AND:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_BEGIN:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_BEGIN_UPCASE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_BREAK:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_CASE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_CLASS:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_DEF:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_DEFINED:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_DO:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_DO_LOOP:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_ELSE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_ELSIF:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_END:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_END_UPCASE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_ENSURE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_FALSE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_FOR:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_IF:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_IF_MODIFIER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_IN:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_MODULE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_NEXT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_NIL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_NOT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_OR:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_REDO:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_RESCUE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_RESCUE_MODIFIER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_RETRY:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_RETURN:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_SELF:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_SUPER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_THEN:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_TRUE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_UNDEF:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_UNLESS:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_UNLESS_MODIFIER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_UNTIL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_UNTIL_MODIFIER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_WHEN:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_WHILE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_WHILE_MODIFIER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>KEYWORD_YIELD:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_kw'>on_kw</span><span class='comma'>,</span>
  <span class='label'>LABEL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_label'>on_label</span><span class='comma'>,</span>
  <span class='label'>LABEL_END:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_label_end'>on_label_end</span><span class='comma'>,</span>
  <span class='label'>LAMBDA_BEGIN:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_tlambeg'>on_tlambeg</span><span class='comma'>,</span>
  <span class='label'>LESS:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>LESS_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>LESS_EQUAL_GREATER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>LESS_LESS:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>LESS_LESS_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>METHOD_NAME:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_ident'>on_ident</span><span class='comma'>,</span>
  <span class='label'>MINUS:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>MINUS_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>MINUS_GREATER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_tlambda'>on_tlambda</span><span class='comma'>,</span>
  <span class='label'>NEWLINE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_nl'>on_nl</span><span class='comma'>,</span>
  <span class='label'>NUMBERED_REFERENCE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_backref'>on_backref</span><span class='comma'>,</span>
  <span class='label'>PARENTHESIS_LEFT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_lparen'>on_lparen</span><span class='comma'>,</span>
  <span class='label'>PARENTHESIS_LEFT_PARENTHESES:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_lparen'>on_lparen</span><span class='comma'>,</span>
  <span class='label'>PARENTHESIS_RIGHT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_rparen'>on_rparen</span><span class='comma'>,</span>
  <span class='label'>PERCENT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>PERCENT_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>PERCENT_LOWER_I:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_qsymbols_beg'>on_qsymbols_beg</span><span class='comma'>,</span>
  <span class='label'>PERCENT_LOWER_W:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_qwords_beg'>on_qwords_beg</span><span class='comma'>,</span>
  <span class='label'>PERCENT_LOWER_X:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_backtick'>on_backtick</span><span class='comma'>,</span>
  <span class='label'>PERCENT_UPPER_I:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_symbols_beg'>on_symbols_beg</span><span class='comma'>,</span>
  <span class='label'>PERCENT_UPPER_W:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_words_beg'>on_words_beg</span><span class='comma'>,</span>
  <span class='label'>PIPE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>PIPE_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>PIPE_PIPE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>PIPE_PIPE_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>PLUS:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>PLUS_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>QUESTION_MARK:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>RATIONAL_FLOAT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_rational'>on_rational</span><span class='comma'>,</span>
  <span class='label'>RATIONAL_INTEGER:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_rational'>on_rational</span><span class='comma'>,</span>
  <span class='label'>REGEXP_BEGIN:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_regexp_beg'>on_regexp_beg</span><span class='comma'>,</span>
  <span class='label'>REGEXP_END:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_regexp_end'>on_regexp_end</span><span class='comma'>,</span>
  <span class='label'>SEMICOLON:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_semicolon'>on_semicolon</span><span class='comma'>,</span>
  <span class='label'>SLASH:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>SLASH_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>STAR:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>STAR_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>STAR_STAR:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>STAR_STAR_EQUAL:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>STRING_BEGIN:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_tstring_beg'>on_tstring_beg</span><span class='comma'>,</span>
  <span class='label'>STRING_CONTENT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_tstring_content'>on_tstring_content</span><span class='comma'>,</span>
  <span class='label'>STRING_END:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_tstring_end'>on_tstring_end</span><span class='comma'>,</span>
  <span class='label'>SYMBOL_BEGIN:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_symbeg'>on_symbeg</span><span class='comma'>,</span>
  <span class='label'>TILDE:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>UAMPERSAND:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>UCOLON_COLON:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>UDOT_DOT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>UDOT_DOT_DOT:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>UMINUS:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>UMINUS_NUM:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>UPLUS:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>USTAR:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>USTAR_STAR:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_op'>on_op</span><span class='comma'>,</span>
  <span class='label'>WORDS_SEP:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_words_sep'>on_words_sep</span><span class='comma'>,</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>__END__</span><span class='label_end'>&quot;:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on___end__'>on___end__</span>
}.<span class='id identifier rubyid_freeze'>freeze</span></pre>
  </li>
</ul>
</div>

<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full nodoc'>
  <li>
    <span class='summary_signature nodoc'>
      <a href="#new-class_method" title=".new (class method)">.<strong>new</strong>(source, **options)  &#x21d2; LexCompat </a>
    </span>
    <span class='note title constructor'>constructor</span>
  </li>
</ul>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_attribute_summary'>Instance Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full nodoc'>
  <li>
    <span class='summary_signature ro nodoc'>
      <a href="#options-instance_method" title="#options (instance method)">#<strong>options</strong>  </a>
    </span>
    <span class='note title readonly'>readonly</span>
  </li>
  <li>
    <span class='summary_signature ro nodoc'>
      <a href="#source-instance_method" title="#source (instance method)">#<strong>source</strong>  </a>
    </span>
    <span class='note title readonly'>readonly</span>
  </li>
</ul>
</div>  <!-- instance_attribute_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full nodoc'>
  <li>
    <span class='summary_signature nodoc'>
      <a href="#result-instance_method" title="#result (instance method)">#<strong>result</strong>  </a>
    </span>
  </li>
</ul>
</div>  <!-- instance_method_summary -->
<h2 id='Constructor_Details' class='y_details'>Constructor Details</h2>

  <section class='method_details first' id="new-class_method">
  <h3 class='signature nodoc first'>
    .<strong>new</strong>(source, **options)  &#x21d2; <code>LexCompat</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/lib/prism/lex_compat.rb#L602-L605'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='602' data-end='605'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/prism/lex_compat.rb', line 602</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span>(<span class='id identifier rubyid_source'><a href="#source-instance_method" title="Prism::LexCompat#source (method)">source</a></span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_options'><a href="#options-instance_method" title="Prism::LexCompat#options (method)">options</a></span>)
  <span class='ivar'>@source</span> <span class='op'>=</span> <span class='id identifier rubyid_source'><a href="#source-instance_method" title="Prism::LexCompat#source (method)">source</a></span>
  <span class='ivar'>@options</span> <span class='op'>=</span> <span class='id identifier rubyid_options'><a href="#options-instance_method" title="Prism::LexCompat#options (method)">options</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Attribute Details</h2>
<section class='method_details first' id="options-instance_method">
  <h3 class='signature ro  nodoc first'>
    #<strong>options</strong>   <span class="extras">(<span class='readonly'>readonly</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/lib/prism/lex_compat.rb#L600-L600'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='600' data-end='600'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/prism/lex_compat.rb', line 600</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_attr_reader'>attr_reader</span> <span class='symbeg'>:</span><span class='id identifier rubyid_source'><a href="#source-instance_method" title="Prism::LexCompat#source (method)">source</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_options'>options</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="source-instance_method">
  <h3 class='signature ro  nodoc'>
    #<strong>source</strong>   <span class="extras">(<span class='readonly'>readonly</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/lib/prism/lex_compat.rb#L600-L600'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='600' data-end='600'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/prism/lex_compat.rb', line 600</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_attr_reader'>attr_reader</span> <span class='symbeg'>:</span><span class='id identifier rubyid_source'>source</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_options'><a href="#options-instance_method" title="Prism::LexCompat#options (method)">options</a></span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="result-instance_method">
  <h3 class='signature nodoc first'>
    #<strong>result</strong>  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/master/lib/prism/lex_compat.rb#L607-L848'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='607' data-end='848'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/prism/lex_compat.rb', line 607</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_result'>result</span>
  <span class='id identifier rubyid_tokens'>tokens</span> <span class='op'>=</span> [] <span class='comment'>#: Array[LexCompat::Token]
</span>
  <span class='id identifier rubyid_state'>state</span> <span class='op'>=</span> <span class='symbeg'>:</span><span class='id identifier rubyid_default'>default</span>
  <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span> <span class='op'>=</span> [[]] <span class='comment'>#: Array[Array[Heredoc::PlainHeredoc | Heredoc::DashHeredoc | Heredoc::DedentingHeredoc]]
</span>
  <span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='const'><a href="../Prism.html" title="Prism (module)">Prism</a></span>.<span class='id identifier rubyid_lex'><a href="../Prism.html#lex-class_method" title="Prism.lex (method)">lex</a></span>(<span class='id identifier rubyid_source'><a href="#source-instance_method" title="Prism::LexCompat#source (method)">source</a></span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_options'><a href="#options-instance_method" title="Prism::LexCompat#options (method)">options</a></span>)
  <span class='id identifier rubyid_result_value'>result_value</span> <span class='op'>=</span> <span class='id identifier rubyid_result'>result</span>.<span class='id identifier rubyid_value'>value</span>
  <span class='id identifier rubyid_previous_state'>previous_state</span> <span class='op'>=</span> <span class='kw'>nil</span> <span class='comment'>#: Ripper::Lexer::State?
</span>  <span class='id identifier rubyid_last_heredoc_end'>last_heredoc_end</span> <span class='op'>=</span> <span class='kw'>nil</span> <span class='comment'>#: Integer?
</span>
  <span class='comment'># In previous versions of Ruby, Ripper wouldn&#39;t flush the bom before the
</span>  <span class='comment'># first token, so we had to have a hack in place to account for that. This
</span>  <span class='comment'># checks for that behavior.
</span>  <span class='id identifier rubyid_bom_flushed'>bom_flushed</span> <span class='op'>=</span> <span class='const'><a href="../top-level-namespace.html#Ripper-constant" title="Ripper (constant)">Ripper</a></span>.<span class='id identifier rubyid_lex'><a href="../Prism.html#lex-class_method" title="Prism.lex (method)">lex</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xEF\xBB\xBF# test</span><span class='tstring_end'>&quot;</span></span>)[<span class='int'>0</span>][<span class='int'>0</span>][<span class='int'>1</span>] <span class='op'>==</span> <span class='int'>0</span>
  <span class='id identifier rubyid_bom'>bom</span> <span class='op'>=</span> <span class='id identifier rubyid_source'><a href="#source-instance_method" title="Prism::LexCompat#source (method)">source</a></span>.<span class='id identifier rubyid_byteslice'>byteslice</span>(<span class='int'>0</span><span class='op'>..</span><span class='int'>2</span>) <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xEF\xBB\xBF</span><span class='tstring_end'>&quot;</span></span>

  <span class='id identifier rubyid_result_value'>result_value</span>.<span class='id identifier rubyid_each_with_index'>each_with_index</span> <span class='kw'>do</span> <span class='op'>|</span>(<span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>)<span class='comma'>,</span> <span class='id identifier rubyid_index'>index</span><span class='op'>|</span>
    <span class='id identifier rubyid_lineno'>lineno</span> <span class='op'>=</span> <span class='id identifier rubyid_token'>token</span>.<span class='id identifier rubyid_location'>location</span>.<span class='id identifier rubyid_start_line'>start_line</span>
    <span class='id identifier rubyid_column'>column</span> <span class='op'>=</span> <span class='id identifier rubyid_token'>token</span>.<span class='id identifier rubyid_location'>location</span>.<span class='id identifier rubyid_start_column'>start_column</span>

    <span class='comment'># If there&#39;s a UTF-8 byte-order mark as the start of the file, then for
</span>    <span class='comment'># certain tokens ripper sets the first token back by 3 bytes. It also
</span>    <span class='comment'># keeps the byte order mark in the first token&#39;s value. This is weird,
</span>    <span class='comment'># and I don&#39;t want to mirror that in our parser. So instead, we&#39;ll match
</span>    <span class='comment'># up the columns and values here.
</span>    <span class='kw'>if</span> <span class='id identifier rubyid_bom'>bom</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_lineno'>lineno</span> <span class='op'>==</span> <span class='int'>1</span>
      <span class='id identifier rubyid_column'>column</span> <span class='op'>-=</span> <span class='int'>3</span>

      <span class='kw'>if</span> <span class='id identifier rubyid_index'>index</span> <span class='op'>==</span> <span class='int'>0</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_column'>column</span> <span class='op'>==</span> <span class='int'>0</span> <span class='op'>&amp;&amp;</span> <span class='op'>!</span><span class='id identifier rubyid_bom_flushed'>bom_flushed</span>
        <span class='id identifier rubyid_flushed'>flushed</span> <span class='op'>=</span>
          <span class='kw'>case</span> <span class='id identifier rubyid_token'>token</span>.<span class='id identifier rubyid_type'>type</span>
          <span class='kw'>when</span> <span class='symbeg'>:</span><span class='const'>BACK_REFERENCE</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='const'>INSTANCE_VARIABLE</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='const'>CLASS_VARIABLE</span><span class='comma'>,</span>
              <span class='symbeg'>:</span><span class='const'>GLOBAL_VARIABLE</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='const'>NUMBERED_REFERENCE</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='const'>PERCENT_LOWER_I</span><span class='comma'>,</span>
              <span class='symbeg'>:</span><span class='const'>PERCENT_LOWER_X</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='const'>PERCENT_LOWER_W</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='const'>PERCENT_UPPER_I</span><span class='comma'>,</span>
              <span class='symbeg'>:</span><span class='const'>PERCENT_UPPER_W</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='const'>STRING_BEGIN</span>
            <span class='kw'>true</span>
          <span class='kw'>when</span> <span class='symbeg'>:</span><span class='const'>REGEXP_BEGIN</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='const'>SYMBOL_BEGIN</span>
            <span class='id identifier rubyid_token'>token</span>.<span class='id identifier rubyid_value'>value</span>.<span class='id identifier rubyid_start_with?'>start_with?</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>%</span><span class='tstring_end'>&quot;</span></span>)
          <span class='kw'>else</span>
            <span class='kw'>false</span>
          <span class='kw'>end</span>

        <span class='kw'>unless</span> <span class='id identifier rubyid_flushed'>flushed</span>
          <span class='id identifier rubyid_column'>column</span> <span class='op'>-=</span> <span class='int'>3</span>
          <span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_token'>token</span>.<span class='id identifier rubyid_value'>value</span>
          <span class='id identifier rubyid_value'>value</span>.<span class='id identifier rubyid_prepend'>prepend</span>(<span class='const'>String</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xEF\xBB\xBF</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>encoding:</span> <span class='id identifier rubyid_value'>value</span>.<span class='id identifier rubyid_encoding'>encoding</span>))
        <span class='kw'>end</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_event'>event</span> <span class='op'>=</span> <span class='const'><a href="#RIPPER-constant" title="Prism::LexCompat::RIPPER (constant)">RIPPER</a></span>.<span class='id identifier rubyid_fetch'>fetch</span>(<span class='id identifier rubyid_token'>token</span>.<span class='id identifier rubyid_type'>type</span>)
    <span class='id identifier rubyid_value'>value</span> <span class='op'>=</span> <span class='id identifier rubyid_token'>token</span>.<span class='id identifier rubyid_value'>value</span>
    <span class='id identifier rubyid_lex_state'>lex_state</span> <span class='op'>=</span> <span class='const'><a href="../top-level-namespace.html#Ripper-constant" title="Ripper (constant)">Ripper</a></span><span class='op'>::</span><span class='const'>Lexer</span><span class='op'>::</span><span class='const'>State</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>(<span class='id identifier rubyid_lex_state'>lex_state</span>)

    <span class='id identifier rubyid_token'>token</span> <span class='op'>=</span>
      <span class='kw'>case</span> <span class='id identifier rubyid_event'>event</span>
      <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on___end__'>on___end__</span>
        <span class='const'><a href="LexCompat/EndContentToken.html" title="Prism::LexCompat::EndContentToken (class)">EndContentToken</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>([[<span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_column'>column</span>]<span class='comma'>,</span> <span class='id identifier rubyid_event'>event</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>])
      <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_comment'>on_comment</span>
        <span class='const'><a href="LexCompat/IgnoreStateToken.html" title="Prism::LexCompat::IgnoreStateToken (class)">IgnoreStateToken</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>([[<span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_column'>column</span>]<span class='comma'>,</span> <span class='id identifier rubyid_event'>event</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>])
      <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_heredoc_end'>on_heredoc_end</span>
        <span class='comment'># Heredoc end tokens can be emitted in an odd order, so we don&#39;t
</span>        <span class='comment'># want to bother comparing the state on them.
</span>        <span class='id identifier rubyid_last_heredoc_end'>last_heredoc_end</span> <span class='op'>=</span> <span class='id identifier rubyid_token'>token</span>.<span class='id identifier rubyid_location'>location</span>.<span class='id identifier rubyid_end_offset'>end_offset</span>
        <span class='const'><a href="LexCompat/IgnoreStateToken.html" title="Prism::LexCompat::IgnoreStateToken (class)">IgnoreStateToken</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>([[<span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_column'>column</span>]<span class='comma'>,</span> <span class='id identifier rubyid_event'>event</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>])
      <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_ident'>on_ident</span>
        <span class='kw'>if</span> <span class='id identifier rubyid_lex_state'>lex_state</span> <span class='op'>==</span> <span class='const'><a href="../top-level-namespace.html#Ripper-constant" title="Ripper (constant)">Ripper</a></span><span class='op'>::</span><span class='const'>EXPR_END</span>
          <span class='comment'># If we have an identifier that follows a method name like:
</span>          <span class='comment'>#
</span>          <span class='comment'>#     def foo bar
</span>          <span class='comment'>#
</span>          <span class='comment'># then Ripper will mark bar as END|LABEL if there is a local in a
</span>          <span class='comment'># parent scope named bar because it hasn&#39;t pushed the local table
</span>          <span class='comment'># yet. We do this more accurately, so we need to allow comparing
</span>          <span class='comment'># against both END and END|LABEL.
</span>          <span class='const'><a href="LexCompat/ParamToken.html" title="Prism::LexCompat::ParamToken (class)">ParamToken</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>([[<span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_column'>column</span>]<span class='comma'>,</span> <span class='id identifier rubyid_event'>event</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>])
        <span class='kw'>elsif</span> <span class='id identifier rubyid_lex_state'>lex_state</span> <span class='op'>==</span> <span class='const'><a href="../top-level-namespace.html#Ripper-constant" title="Ripper (constant)">Ripper</a></span><span class='op'>::</span><span class='const'>EXPR_END</span> <span class='op'>|</span> <span class='const'><a href="../top-level-namespace.html#Ripper-constant" title="Ripper (constant)">Ripper</a></span><span class='op'>::</span><span class='const'>EXPR_LABEL</span>
          <span class='comment'># In the event that we&#39;re comparing identifiers, we&#39;re going to
</span>          <span class='comment'># allow a little divergence. Ripper doesn&#39;t account for local
</span>          <span class='comment'># variables introduced through named captures in regexes, and we
</span>          <span class='comment'># do, which accounts for this difference.
</span>          <span class='const'><a href="LexCompat/IdentToken.html" title="Prism::LexCompat::IdentToken (class)">IdentToken</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>([[<span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_column'>column</span>]<span class='comma'>,</span> <span class='id identifier rubyid_event'>event</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>])
        <span class='kw'>else</span>
          <span class='const'><a href="LexCompat/Token.html" title="Prism::LexCompat::Token (class)">Token</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>([[<span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_column'>column</span>]<span class='comma'>,</span> <span class='id identifier rubyid_event'>event</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>])
        <span class='kw'>end</span>
      <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_embexpr_end'>on_embexpr_end</span>
        <span class='const'><a href="LexCompat/IgnoreStateToken.html" title="Prism::LexCompat::IgnoreStateToken (class)">IgnoreStateToken</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>([[<span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_column'>column</span>]<span class='comma'>,</span> <span class='id identifier rubyid_event'>event</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>])
      <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_ignored_nl'>on_ignored_nl</span>
        <span class='comment'># Ignored newlines can occasionally have a LABEL state attached to
</span>        <span class='comment'># them which doesn&#39;t actually impact anything. We don&#39;t mirror that
</span>        <span class='comment'># state so we ignored it.
</span>        <span class='const'><a href="LexCompat/IgnoredNewlineToken.html" title="Prism::LexCompat::IgnoredNewlineToken (class)">IgnoredNewlineToken</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>([[<span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_column'>column</span>]<span class='comma'>,</span> <span class='id identifier rubyid_event'>event</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>])
      <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_regexp_end'>on_regexp_end</span>
        <span class='comment'># On regex end, Ripper scans and then sets end state, so the ripper
</span>        <span class='comment'># lexed output is begin, when it should be end. prism sets lex state
</span>        <span class='comment'># correctly to end state, but we want to be able to compare against
</span>        <span class='comment'># Ripper&#39;s lexed state. So here, if it&#39;s a regexp end token, we
</span>        <span class='comment'># output the state as the previous state, solely for the sake of
</span>        <span class='comment'># comparison.
</span>        <span class='id identifier rubyid_previous_token'>previous_token</span> <span class='op'>=</span> <span class='id identifier rubyid_result_value'>result_value</span>[<span class='id identifier rubyid_index'>index</span> <span class='op'>-</span> <span class='int'>1</span>][<span class='int'>0</span>]
        <span class='id identifier rubyid_lex_state'>lex_state</span> <span class='op'>=</span>
          <span class='kw'>if</span> <span class='const'><a href="#RIPPER-constant" title="Prism::LexCompat::RIPPER (constant)">RIPPER</a></span>.<span class='id identifier rubyid_fetch'>fetch</span>(<span class='id identifier rubyid_previous_token'>previous_token</span>.<span class='id identifier rubyid_type'>type</span>) <span class='op'>==</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_embexpr_end'>on_embexpr_end</span>
            <span class='comment'># If the previous token is embexpr_end, then we have to do even
</span>            <span class='comment'># more processing. The end of an embedded expression sets the
</span>            <span class='comment'># state to the state that it had at the beginning of the
</span>            <span class='comment'># embedded expression. So we have to go and find that state and
</span>            <span class='comment'># set it here.
</span>            <span class='id identifier rubyid_counter'>counter</span> <span class='op'>=</span> <span class='int'>1</span>
            <span class='id identifier rubyid_current_index'>current_index</span> <span class='op'>=</span> <span class='id identifier rubyid_index'>index</span> <span class='op'>-</span> <span class='int'>1</span>

            <span class='kw'>until</span> <span class='id identifier rubyid_counter'>counter</span> <span class='op'>==</span> <span class='int'>0</span>
              <span class='id identifier rubyid_current_index'>current_index</span> <span class='op'>-=</span> <span class='int'>1</span>
              <span class='id identifier rubyid_current_event'>current_event</span> <span class='op'>=</span> <span class='const'><a href="#RIPPER-constant" title="Prism::LexCompat::RIPPER (constant)">RIPPER</a></span>.<span class='id identifier rubyid_fetch'>fetch</span>(<span class='id identifier rubyid_result_value'>result_value</span>[<span class='id identifier rubyid_current_index'>current_index</span>][<span class='int'>0</span>].<span class='id identifier rubyid_type'>type</span>)
              <span class='id identifier rubyid_counter'>counter</span> <span class='op'>+=</span> { <span class='label'>on_embexpr_beg:</span> <span class='op'>-</span><span class='int'>1</span><span class='comma'>,</span> <span class='label'>on_embexpr_end:</span> <span class='int'>1</span> }[<span class='id identifier rubyid_current_event'>current_event</span>] <span class='op'>||</span> <span class='int'>0</span>
            <span class='kw'>end</span>

            <span class='const'><a href="../top-level-namespace.html#Ripper-constant" title="Ripper (constant)">Ripper</a></span><span class='op'>::</span><span class='const'>Lexer</span><span class='op'>::</span><span class='const'>State</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>(<span class='id identifier rubyid_result_value'>result_value</span>[<span class='id identifier rubyid_current_index'>current_index</span>][<span class='int'>1</span>])
          <span class='kw'>else</span>
            <span class='id identifier rubyid_previous_state'>previous_state</span>
          <span class='kw'>end</span>

        <span class='const'><a href="LexCompat/Token.html" title="Prism::LexCompat::Token (class)">Token</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>([[<span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_column'>column</span>]<span class='comma'>,</span> <span class='id identifier rubyid_event'>event</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>])
      <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_eof'>on_eof</span>
        <span class='id identifier rubyid_previous_token'>previous_token</span> <span class='op'>=</span> <span class='id identifier rubyid_result_value'>result_value</span>[<span class='id identifier rubyid_index'>index</span> <span class='op'>-</span> <span class='int'>1</span>][<span class='int'>0</span>]

        <span class='comment'># If we&#39;re at the end of the file and the previous token was a
</span>        <span class='comment'># comment and there is still whitespace after the comment, then
</span>        <span class='comment'># Ripper will append a on_nl token (even though there isn&#39;t
</span>        <span class='comment'># necessarily a newline). We mirror that here.
</span>        <span class='kw'>if</span> <span class='id identifier rubyid_previous_token'>previous_token</span>.<span class='id identifier rubyid_type'>type</span> <span class='op'>==</span> <span class='symbeg'>:</span><span class='const'>COMMENT</span>
          <span class='comment'># If the comment is at the start of a heredoc: &lt;&lt;HEREDOC # comment
</span>          <span class='comment'># then the comment&#39;s end_offset is up near the heredoc_beg.
</span>          <span class='comment'># This is not the correct offset to use for figuring out if
</span>          <span class='comment'># there is trailing whitespace after the last token.
</span>          <span class='comment'># Use the greater offset of the two to determine the start of
</span>          <span class='comment'># the trailing whitespace.
</span>          <span class='id identifier rubyid_start_offset'>start_offset</span> <span class='op'>=</span> [<span class='id identifier rubyid_previous_token'>previous_token</span>.<span class='id identifier rubyid_location'>location</span>.<span class='id identifier rubyid_end_offset'>end_offset</span><span class='comma'>,</span> <span class='id identifier rubyid_last_heredoc_end'>last_heredoc_end</span>].<span class='id identifier rubyid_compact'>compact</span>.<span class='id identifier rubyid_max'>max</span>
          <span class='id identifier rubyid_end_offset'>end_offset</span> <span class='op'>=</span> <span class='id identifier rubyid_token'>token</span>.<span class='id identifier rubyid_location'>location</span>.<span class='id identifier rubyid_start_offset'>start_offset</span>

          <span class='kw'>if</span> <span class='id identifier rubyid_start_offset'>start_offset</span> <span class='op'>&lt;</span> <span class='id identifier rubyid_end_offset'>end_offset</span>
            <span class='kw'>if</span> <span class='id identifier rubyid_bom'>bom</span>
              <span class='id identifier rubyid_start_offset'>start_offset</span> <span class='op'>+=</span> <span class='int'>3</span>
              <span class='id identifier rubyid_end_offset'>end_offset</span> <span class='op'>+=</span> <span class='int'>3</span>
            <span class='kw'>end</span>

            <span class='id identifier rubyid_tokens'>tokens</span> <span class='op'>&lt;&lt;</span> <span class='const'><a href="LexCompat/Token.html" title="Prism::LexCompat::Token (class)">Token</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>([[<span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='int'>0</span>]<span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_nl'>on_nl</span><span class='comma'>,</span> <span class='id identifier rubyid_source'><a href="#source-instance_method" title="Prism::LexCompat#source (method)">source</a></span>.<span class='id identifier rubyid_byteslice'>byteslice</span>(<span class='id identifier rubyid_start_offset'>start_offset</span><span class='op'>...</span><span class='id identifier rubyid_end_offset'>end_offset</span>)<span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>])
          <span class='kw'>end</span>
        <span class='kw'>end</span>

        <span class='const'><a href="LexCompat/Token.html" title="Prism::LexCompat::Token (class)">Token</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>([[<span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_column'>column</span>]<span class='comma'>,</span> <span class='id identifier rubyid_event'>event</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>])
      <span class='kw'>else</span>
        <span class='const'><a href="LexCompat/Token.html" title="Prism::LexCompat::Token (class)">Token</a></span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Prism::LexCompat.new (method)">new</a></span>([[<span class='id identifier rubyid_lineno'>lineno</span><span class='comma'>,</span> <span class='id identifier rubyid_column'>column</span>]<span class='comma'>,</span> <span class='id identifier rubyid_event'>event</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_lex_state'>lex_state</span>])
      <span class='kw'>end</span>

    <span class='id identifier rubyid_previous_state'>previous_state</span> <span class='op'>=</span> <span class='id identifier rubyid_lex_state'>lex_state</span>

    <span class='comment'># The order in which tokens appear in our lexer is different from the
</span>    <span class='comment'># order that they appear in Ripper. When we hit the declaration of a
</span>    <span class='comment'># heredoc in prism, we skip forward and lex the rest of the content of
</span>    <span class='comment'># the heredoc before going back and lexing at the end of the heredoc
</span>    <span class='comment'># identifier.
</span>    <span class='comment'>#
</span>    <span class='comment'># To match up to ripper, we keep a small state variable around here to
</span>    <span class='comment'># track whether we&#39;re in the middle of a heredoc or not. In this way we
</span>    <span class='comment'># can shuffle around the token to match Ripper&#39;s output.
</span>    <span class='kw'>case</span> <span class='id identifier rubyid_state'>state</span>
    <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_default'>default</span>
      <span class='comment'># The default state is when there are no heredocs at all. In this
</span>      <span class='comment'># state we can append the token to the list of tokens and move on.
</span>      <span class='id identifier rubyid_tokens'>tokens</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_token'>token</span>

      <span class='comment'># If we get the declaration of a heredoc, then we open a new heredoc
</span>      <span class='comment'># and move into the heredoc_opened state.
</span>      <span class='kw'>if</span> <span class='id identifier rubyid_event'>event</span> <span class='op'>==</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_heredoc_beg'>on_heredoc_beg</span>
        <span class='id identifier rubyid_state'>state</span> <span class='op'>=</span> <span class='symbeg'>:</span><span class='id identifier rubyid_heredoc_opened'>heredoc_opened</span>
        <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span>.<span class='id identifier rubyid_last'>last</span> <span class='op'>&lt;&lt;</span> <span class='const'><a href="LexCompat/Heredoc.html" title="Prism::LexCompat::Heredoc (module)">Heredoc</a></span>.<span class='id identifier rubyid_build'><a href="LexCompat/Heredoc.html#build-class_method" title="Prism::LexCompat::Heredoc.build (method)">build</a></span>(<span class='id identifier rubyid_token'>token</span>)
      <span class='kw'>end</span>
    <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_heredoc_opened'>heredoc_opened</span>
      <span class='comment'># The heredoc_opened state is when we&#39;ve seen the declaration of a
</span>      <span class='comment'># heredoc and are now lexing the body of the heredoc. In this state we
</span>      <span class='comment'># push tokens onto the most recently created heredoc.
</span>      <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span>.<span class='id identifier rubyid_last'>last</span>.<span class='id identifier rubyid_last'>last</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_token'>token</span>

      <span class='kw'>case</span> <span class='id identifier rubyid_event'>event</span>
      <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_heredoc_beg'>on_heredoc_beg</span>
        <span class='comment'># If we receive a heredoc declaration while lexing the body of a
</span>        <span class='comment'># heredoc, this means we have nested heredocs. In this case we&#39;ll
</span>        <span class='comment'># push a new heredoc onto the stack and stay in the heredoc_opened
</span>        <span class='comment'># state since we&#39;re now lexing the body of the new heredoc.
</span>        <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span> <span class='op'>&lt;&lt;</span> [<span class='const'><a href="LexCompat/Heredoc.html" title="Prism::LexCompat::Heredoc (module)">Heredoc</a></span>.<span class='id identifier rubyid_build'><a href="LexCompat/Heredoc.html#build-class_method" title="Prism::LexCompat::Heredoc.build (method)">build</a></span>(<span class='id identifier rubyid_token'>token</span>)]
      <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_heredoc_end'>on_heredoc_end</span>
        <span class='comment'># If we receive the end of a heredoc, then we&#39;re done lexing the
</span>        <span class='comment'># body of the heredoc. In this case we now have a completed heredoc
</span>        <span class='comment'># but need to wait for the next newline to push it into the token
</span>        <span class='comment'># stream.
</span>        <span class='id identifier rubyid_state'>state</span> <span class='op'>=</span> <span class='symbeg'>:</span><span class='id identifier rubyid_heredoc_closed'>heredoc_closed</span>
      <span class='kw'>end</span>
    <span class='kw'>when</span> <span class='symbeg'>:</span><span class='id identifier rubyid_heredoc_closed'>heredoc_closed</span>
      <span class='kw'>if</span> <span class='qsymbols'><span class='qsymbols_beg'>%i[</span><span class='tstring_content'>on_nl</span><span class='words_sep'> </span><span class='tstring_content'>on_ignored_nl</span><span class='words_sep'> </span><span class='tstring_content'>on_comment</span><span class='tstring_end'>]</span></span>.<span class='id identifier rubyid_include?'>include?</span>(<span class='id identifier rubyid_event'>event</span>) <span class='op'>||</span> (<span class='id identifier rubyid_event'>event</span> <span class='op'>==</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_tstring_content'>on_tstring_content</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_value'>value</span>.<span class='id identifier rubyid_end_with?'>end_with?</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>))
        <span class='kw'>if</span> <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span>.<span class='id identifier rubyid_size'>size</span> <span class='op'>&gt;</span> <span class='int'>1</span>
          <span class='id identifier rubyid_flushing'>flushing</span> <span class='op'>=</span> <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span>.<span class='id identifier rubyid_pop'>pop</span>
          <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span>.<span class='id identifier rubyid_last'>last</span>.<span class='id identifier rubyid_last'>last</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_token'>token</span>

          <span class='id identifier rubyid_flushing'>flushing</span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_heredoc'>heredoc</span><span class='op'>|</span>
            <span class='id identifier rubyid_heredoc'>heredoc</span>.<span class='id identifier rubyid_to_a'>to_a</span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_flushed_token'>flushed_token</span><span class='op'>|</span>
              <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span>.<span class='id identifier rubyid_last'>last</span>.<span class='id identifier rubyid_last'>last</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_flushed_token'>flushed_token</span>
            <span class='kw'>end</span>
          <span class='kw'>end</span>

          <span class='id identifier rubyid_state'>state</span> <span class='op'>=</span> <span class='symbeg'>:</span><span class='id identifier rubyid_heredoc_opened'>heredoc_opened</span>
          <span class='kw'>next</span>
        <span class='kw'>end</span>
      <span class='kw'>elsif</span> <span class='id identifier rubyid_event'>event</span> <span class='op'>==</span> <span class='symbeg'>:</span><span class='id identifier rubyid_on_heredoc_beg'>on_heredoc_beg</span>
        <span class='id identifier rubyid_tokens'>tokens</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_token'>token</span>
        <span class='id identifier rubyid_state'>state</span> <span class='op'>=</span> <span class='symbeg'>:</span><span class='id identifier rubyid_heredoc_opened'>heredoc_opened</span>
        <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span>.<span class='id identifier rubyid_last'>last</span> <span class='op'>&lt;&lt;</span> <span class='const'><a href="LexCompat/Heredoc.html" title="Prism::LexCompat::Heredoc (module)">Heredoc</a></span>.<span class='id identifier rubyid_build'><a href="LexCompat/Heredoc.html#build-class_method" title="Prism::LexCompat::Heredoc.build (method)">build</a></span>(<span class='id identifier rubyid_token'>token</span>)
        <span class='kw'>next</span>
      <span class='kw'>elsif</span> <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span>.<span class='id identifier rubyid_size'>size</span> <span class='op'>&gt;</span> <span class='int'>1</span>
        <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span>[<span class='op'>-</span><span class='int'>2</span>].<span class='id identifier rubyid_last'>last</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_token'>token</span>
        <span class='kw'>next</span>
      <span class='kw'>end</span>

      <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span>.<span class='id identifier rubyid_last'>last</span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_heredoc'>heredoc</span><span class='op'>|</span>
        <span class='id identifier rubyid_tokens'>tokens</span>.<span class='id identifier rubyid_concat'>concat</span>(<span class='id identifier rubyid_heredoc'>heredoc</span>.<span class='id identifier rubyid_to_a'>to_a</span>)
      <span class='kw'>end</span>

      <span class='id identifier rubyid_heredoc_stack'>heredoc_stack</span>.<span class='id identifier rubyid_last'>last</span>.<span class='id identifier rubyid_clear'>clear</span>
      <span class='id identifier rubyid_state'>state</span> <span class='op'>=</span> <span class='symbeg'>:</span><span class='id identifier rubyid_default'>default</span>

      <span class='id identifier rubyid_tokens'>tokens</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_token'>token</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='comment'># Drop the EOF token from the list
</span>  <span class='id identifier rubyid_tokens'>tokens</span> <span class='op'>=</span> <span class='id identifier rubyid_tokens'>tokens</span>[<span class='int'>0</span><span class='op'>...</span><span class='op'>-</span><span class='int'>1</span>]

  <span class='comment'># We sort by location to compare against Ripper&#39;s output
</span>  <span class='id identifier rubyid_tokens'>tokens</span>.<span class='id identifier rubyid_sort_by!'>sort_by!</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_location'>location</span>)

  <span class='const'><a href="ParseResult.html" title="Prism::ParseResult (class)">ParseResult</a></span>.<span class='id identifier rubyid_new'><a href="ParseResult.html#new-class_method" title="Prism::ParseResult.new (method)">new</a></span>(<span class='id identifier rubyid_tokens'>tokens</span><span class='comma'>,</span> <span class='id identifier rubyid_result'>result</span>.<span class='id identifier rubyid_comments'>comments</span><span class='comma'>,</span> <span class='id identifier rubyid_result'>result</span>.<span class='id identifier rubyid_magic_comments'>magic_comments</span><span class='comma'>,</span> <span class='id identifier rubyid_result'>result</span>.<span class='id identifier rubyid_data_loc'>data_loc</span><span class='comma'>,</span> <span class='id identifier rubyid_result'>result</span>.<span class='id identifier rubyid_errors'>errors</span><span class='comma'>,</span> <span class='id identifier rubyid_result'>result</span>.<span class='id identifier rubyid_warnings'>warnings</span><span class='comma'>,</span> <span class='const'><a href="Source.html" title="Prism::Source (class)">Source</a></span>.<span class='id identifier rubyid_new'><a href="Source.html#new-class_method" title="Prism::Source.new (method)">new</a></span>(<span class='id identifier rubyid_source'><a href="#source-instance_method" title="Prism::LexCompat#source (method)">source</a></span>))
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>