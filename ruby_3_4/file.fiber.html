<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Fiber &mdash; Ruby-3.4.6</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "fiber",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Ruby-3.4.6</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Fiber&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="file_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<h1>Fiber</h1>

<p>Fibers provide a mechanism for cooperative concurrency.</p>

<h2>Context Switching</h2>

<p>Fibers execute a user-provided block. During the execution, the block may call <code>Fiber.yield</code> or <code>Fiber.transfer</code> to switch to another fiber. <code>Fiber#resume</code> is used to continue execution from the point where <code>Fiber.yield</code> was called.</p>

<pre class="code rb"><code class="rb">#!/usr/bin/env ruby

puts &quot;1: Start program.&quot;

f = Fiber.new do
  puts &quot;3: Entered fiber.&quot;
  Fiber.yield
  puts &quot;5: Resumed fiber.&quot;
end

puts &quot;2: Resume fiber first time.&quot;
f.resume

puts &quot;4: Resume fiber second time.&quot;
f.resume

puts &quot;6: Finished.&quot;
</code></pre>

<p>This program demonstrates the flow control of fibers.</p>

<h2>Scheduler</h2>

<p>The scheduler interface is used to intercept blocking operations. A typical
implementation would be a wrapper for a gem like <code>EventMachine</code> or <code>Async</code>. This
design provides separation of concerns between the event loop implementation
and application code. It also allows for layered schedulers which can perform
instrumentation.</p>

<p>To set the scheduler for the current thread:</p>

<pre class="code rb"><code class="rb">Fiber.set_scheduler(MyScheduler.new)
</code></pre>

<p>When the thread exits, there is an implicit call to <code>set_scheduler</code>:</p>

<pre class="code rb"><code class="rb">Fiber.set_scheduler(nil)
</code></pre>

<h3>Design</h3>

<p>The scheduler interface is designed to be a un-opinionated light-weight layer
between user code and blocking operations. The scheduler hooks should avoid
translating or converting arguments or return values. Ideally, the exact same
arguments from the user code are provided directly to the scheduler hook with
no changes.</p>

<h3>Interface</h3>

<p>This is the interface you need to implement.</p>

<pre class="code rb"><code class="rb">class Scheduler
  # Wait for the specified process ID to exit.
  # This hook is optional.
  # @parameter pid [Integer] The process ID to wait for.
  # @parameter flags [Integer] A bit-mask of flags suitable for {Process::Status.wait}.
  # @returns [Process::Status] A process status instance.
  def process_wait(pid, flags)
    Thread.new do
      Process::Status.wait(pid, flags)
    end.value
  end

  # Wait for the given io readiness to match the specified events within
  # the specified timeout.
  # @parameter event [Integer] A bit mask of {IO::READABLE},
  #   {IO::WRITABLE} and {IO::PRIORITY}.
  # @parameter timeout [Numeric] The amount of time to wait for the event in seconds.
  # @returns [Integer] The subset of events that are ready.
  def io_wait(io, events, timeout)
  end

  # Read from the given io into the specified buffer.
  # WARNING: Experimental hook! Do not use in production code!
  # @parameter io [IO] The io to read from.
  # @parameter buffer [IO::Buffer] The buffer to read into.
  # @parameter length [Integer] The minimum amount to read.
  def io_read(io, buffer, length)
  end

  # Write from the given buffer into the specified IO.
  # WARNING: Experimental hook! Do not use in production code!
  # @parameter io [IO] The io to write to.
  # @parameter buffer [IO::Buffer] The buffer to write from.
  # @parameter length [Integer] The minimum amount to write.
  def io_write(io, buffer, length)
  end

  # Sleep the current task for the specified duration, or forever if not
  # specified.
  # @parameter duration [Numeric] The amount of time to sleep in seconds.
  def kernel_sleep(duration = nil)
  end

  # Execute the given block. If the block execution exceeds the given timeout,
  # the specified exception `klass` will be raised. Typically, only non-blocking
  # methods which enter the scheduler will raise such exceptions.
  # @parameter duration [Integer] The amount of time to wait, after which an exception will be raised.
  # @parameter klass [Class] The exception class to raise.
  # @parameter *arguments [Array] The arguments to send to the constructor of the exception.
  # @yields {...} The user code to execute.
  def timeout_after(duration, klass, *arguments, &amp;block)
  end

  # Resolve hostname to an array of IP addresses.
  # This hook is optional.
  # @parameter hostname [String] Example: &quot;www.ruby-lang.org&quot;.
  # @returns [Array] An array of IPv4 and/or IPv6 address strings that the hostname resolves to.
  def address_resolve(hostname)
  end

  # Block the calling fiber.
  # @parameter blocker [Object] What we are waiting on, informational only.
  # @parameter timeout [Numeric | Nil] The amount of time to wait for in seconds.
  # @returns [Boolean] Whether the blocking operation was successful or not.
  def block(blocker, timeout = nil)
  end

  # Unblock the specified fiber.
  # @parameter blocker [Object] What we are waiting on, informational only.
  # @parameter fiber [Fiber] The fiber to unblock.
  # @reentrant Thread safe.
  def unblock(blocker, fiber)
  end

  # Intercept the creation of a non-blocking fiber.
  # @returns [Fiber]
  def fiber(&amp;block)
    Fiber.new(blocking: false, &amp;block)
  end

  # Invoked when the thread exits.
  def close
    self.run
  end

  def run
    # Implement event loop here.
  end
end
</code></pre>

<p>Additional hooks may be introduced in the future, we will use feature detection
in order to enable these hooks.</p>

<h3>Non-blocking Execution</h3>

<p>The scheduler hooks will only be used in special non-blocking execution
contexts. Non-blocking execution contexts introduce non-determinism because the
execution of scheduler hooks may introduce context switching points into your
program.</p>

<h4>Fibers</h4>

<p>Fibers can be used to create non-blocking execution contexts.</p>

<pre class="code rb"><code class="rb">Fiber.new do
  puts Fiber.current.blocking? # false

  # May invoke {Fiber.scheduler&amp;.io_wait}.
  io.read(...)

  # May invoke {Fiber.scheduler&amp;.io_wait}.
  io.write(...)

  # Will invoke {Fiber.scheduler&amp;.kernel_sleep}.
  sleep(n)
end.resume
</code></pre>

<p>We also introduce a new method which simplifies the creation of these
non-blocking fibers:</p>

<pre class="code rb"><code class="rb">Fiber.schedule do
  puts Fiber.current.blocking? # false
end
</code></pre>

<p>The purpose of this method is to allow the scheduler to internally decide the
policy for when to start the fiber, and whether to use symmetric or asymmetric
fibers.</p>

<p>You can also create blocking execution contexts:</p>

<pre class="code rb"><code class="rb">Fiber.new(blocking: true) do
  # Won&#39;t use the scheduler:
  sleep(n)
end
</code></pre>

<p>However you should generally avoid this unless you are implementing a scheduler.</p>

<h4>IO</h4>

<p>By default, I/O is non-blocking. Not all operating systems support non-blocking
I/O. Windows is a notable example where socket I/O can be non-blocking but pipe
I/O is blocking. Provided that there <em>is</em> a scheduler and the current thread <em>is
non-blocking</em>, the operation will invoke the scheduler.</p>

<h4>Mutex</h4>

<p>The <code>Mutex</code> class can be used in a non-blocking context and is fiber specific.</p>

<h4>ConditionVariable</h4>

<p>The <code>ConditionVariable</code> class can be used in a non-blocking context and is
fiber-specific.</p>

<h4>Queue / SizedQueue</h4>

<p>The <code>Queue</code> and <code>SizedQueue</code> classes can be used in a non-blocking context and
are fiber-specific.</p>

<h4>Thread</h4>

<p>The <code>Thread#join</code> operation can be used in a non-blocking context and is
fiber-specific.</p>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>