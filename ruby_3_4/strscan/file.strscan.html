<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Strscan &mdash; strscan  Ruby-3.4.6 p54</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "strscan",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../.'>Ruby-3.4.6</a> &raquo; 
      <a href='.'>strscan</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Strscan&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<p>\Class <a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> supports processing a stored string as a stream;
this code creates a new <a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> object with string <code>&#39;foobarbaz&#39;</code>:</p>

<pre class="code rb"><code class="rb">require &#39;strscan&#39;
scanner = StringScanner.new(&#39;foobarbaz&#39;)
</code></pre>

<h2>About the Examples</h2>

<p>All examples here assume that <a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> has been required:</p>

<pre class="code rb"><code class="rb">require &#39;strscan&#39;
</code></pre>

<p>Some examples here assume that these constants are defined:</p>

<pre class="code rb"><code class="rb">MULTILINE_TEXT = &lt;&lt;~EOT
Go placidly amid the noise and haste,
and remember what peace there may be in silence.
EOT

HIRAGANA_TEXT = &#39;こんにちは&#39;

ENGLISH_TEXT = &#39;Hello&#39;
</code></pre>

<p>Some examples here assume that certain helper methods are defined:</p>

<ul>
<li><code>put_situation(scanner)</code>:
Displays the values of the scanner&#39;s
methods #pos, #charpos, #rest, and #rest_size.</li>
<li><code>put_match_values(scanner)</code>:
Displays the scanner&#39;s [match values][9].</li>
<li><code>match_values_cleared?(scanner)</code>:
Returns whether the scanner&#39;s [match values][9] are cleared.</li>
</ul>

<p>See examples [here][ext/strscan/helper_methods_md.html].</p>

<h2>The <a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> \Object</h2>

<p>This code creates a <a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> object
(we&#39;ll call it simply a <em>scanner</em>),
and shows some of its basic properties:</p>

<pre class="code rb"><code class="rb">scanner = StringScanner.new(&#39;foobarbaz&#39;)
scanner.string # =&gt; &quot;foobarbaz&quot;
put_situation(scanner)
# Situation:
#   pos:       0
#   charpos:   0
#   rest:      &quot;foobarbaz&quot;
#   rest_size: 9
</code></pre>

<p>The scanner has:</p>

<ul>
<li><p>A <i>stored string</i>, which is:</p>

<ul>
<li>Initially set by StringScanner.new(string) to the given <code>string</code>
(<code>&#39;foobarbaz&#39;</code> in the example above).</li>
<li>Modifiable by methods #string=(new_string) and #concat(more_string).</li>
<li>Returned by method #string.</li>
</ul>

<p>More at [Stored String][1] below.</p></li>
<li><p>A <em>position</em>;
a zero-based index into the bytes of the stored string (<em>not</em> into its characters):</p>

<ul>
<li>Initially set by StringScanner.new to <code>0</code>.</li>
<li>Returned by method #pos.</li>
<li>Modifiable explicitly by methods #reset, #terminate, and #pos=(new_pos).</li>
<li>Modifiable implicitly (various traversing methods, among others).</li>
</ul>

<p>More at [Byte Position][2] below.</p></li>
<li><p>A <i>target substring</i>,
which is a trailing substring of the stored string;
it extends from the current position to the end of the stored string:</p>

<ul>
<li>Initially set by StringScanner.new(string) to the given <code>string</code>
(<code>&#39;foobarbaz&#39;</code> in the example above).</li>
<li>Returned by method #rest.</li>
<li>Modified by any modification to either the stored string or the position.</li>
</ul>

<p><b>Most importantly</b>:
the searching and traversing methods operate on the target substring,
which may be (and often is) less than the entire stored string.</p>

<p>More at [Target Substring][3] below.</p></li>
</ul>

<h2>Stored \String</h2>

<p>The <i>stored string</i> is the string stored in the <a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> object.</p>

<p>Each of these methods sets, modifies, or returns the stored string:</p>

<table><thead>
<tr>
<th>Method</th>
<th>Effect</th>
</tr>
</thead><tbody>
<tr>
<td>::new(string)</td>
<td>Creates a new scanner for the given string.</td>
</tr>
<tr>
<td>#string=(new_string)</td>
<td>Replaces the existing stored string.</td>
</tr>
<tr>
<td>#concat(more_string)</td>
<td>Appends a string to the existing stored string.</td>
</tr>
<tr>
<td>#string</td>
<td>Returns the stored string.</td>
</tr>
</tbody></table>

<h2>Positions</h2>

<p>A <a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> object maintains a zero-based <i>byte position</i>
and a zero-based <i>character position</i>.</p>

<p>Each of these methods explicitly sets positions:</p>

<table><thead>
<tr>
<th>Method</th>
<th>Effect</th>
</tr>
</thead><tbody>
<tr>
<td>#reset</td>
<td>Sets both positions to zero (begining of stored string).</td>
</tr>
<tr>
<td>#terminate</td>
<td>Sets both positions to the end of the stored string.</td>
</tr>
<tr>
<td>#pos=(new_byte_position)</td>
<td>Sets byte position; adjusts character position.</td>
</tr>
</tbody></table>

<h3>Byte Position (Position)</h3>

<p>The byte position (or simply <em>position</em>)
is a zero-based index into the bytes in the scanner&#39;s stored string;
for a new <a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> object, the byte position is zero.</p>

<p>When the byte position is:</p>

<ul>
<li>Zero (at the beginning), the target substring is the entire stored string.</li>
<li>Equal to the size of the stored string (at the end),
the target substring is the empty string <code>&#39;&#39;</code>.</li>
</ul>

<p>To get or set the byte position:</p>

<ul>
<li>#pos: returns the byte position.</li>
<li>#pos=(new_pos): sets the byte position.</li>
</ul>

<p>Many methods use the byte position as the basis for finding matches;
many others set, increment, or decrement the byte position:</p>

<pre class="code rb"><code class="rb">scanner = StringScanner.new(&#39;foobar&#39;)
scanner.pos # =&gt; 0
scanner.scan(/foo/) # =&gt; &quot;foo&quot; # Match found.
scanner.pos         # =&gt; 3     # Byte position incremented.
scanner.scan(/foo/) # =&gt; nil   # Match not found.
scanner.pos # =&gt; 3             # Byte position not changed.
</code></pre>

<p>Some methods implicitly modify the byte position;
see:</p>

<ul>
<li>[Setting the Target Substring][4].</li>
<li>[Traversing the Target Substring][5].</li>
</ul>

<p>The values of these methods are derived directly from the values of #pos and #string:</p>

<ul>
<li>#charpos: the [character position][7].</li>
<li>#rest: the [target substring][3].</li>
<li>#rest_size: <code>rest.size</code>.</li>
</ul>

<h3>Character Position</h3>

<p>The character position is a zero-based index into the <em>characters</em>
in the stored string;
for a new <a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> object, the character position is zero.</p>

<p>\Method #charpos returns the character position;
its value may not be reset explicitly.</p>

<p>Some methods change (increment or reset) the character position;
see:</p>

<ul>
<li>[Setting the Target Substring][4].</li>
<li>[Traversing the Target Substring][5].</li>
</ul>

<p>Example (string includes multi-byte characters):</p>

<pre class="code rb"><code class="rb">scanner = StringScanner.new(ENGLISH_TEXT) # Five 1-byte characters.
scanner.concat(HIRAGANA_TEXT)             # Five 3-byte characters
scanner.string # =&gt; &quot;Helloこんにちは&quot;       # Twenty bytes in all.
put_situation(scanner)
# Situation:
#   pos:       0
#   charpos:   0
#   rest:      &quot;Helloこんにちは&quot;
#   rest_size: 20
scanner.scan(/Hello/) # =&gt; &quot;Hello&quot; # Five 1-byte characters.
put_situation(scanner)
# Situation:
#   pos:       5
#   charpos:   5
#   rest:      &quot;こんにちは&quot;
#   rest_size: 15
scanner.getch         # =&gt; &quot;こ&quot;    # One 3-byte character.
put_situation(scanner)
# Situation:
#   pos:       8
#   charpos:   6
#   rest:      &quot;んにちは&quot;
#   rest_size: 12
</code></pre>

<h2>Target Substring</h2>

<p>The target substring is the the part of the [stored string][1]
that extends from the current [byte position][2] to the end of the stored string;
it is always either:</p>

<ul>
<li>The entire stored string (byte position is zero).</li>
<li>A trailing substring of the stored string (byte position positive).</li>
</ul>

<p>The target substring is returned by method #rest,
and its size is returned by method #rest_size.</p>

<p>Examples:</p>

<pre class="code rb"><code class="rb">scanner = StringScanner.new(&#39;foobarbaz&#39;)
put_situation(scanner)
# Situation:
#   pos:       0
#   charpos:   0
#   rest:      &quot;foobarbaz&quot;
#   rest_size: 9
scanner.pos = 3
put_situation(scanner)
# Situation:
#   pos:       3
#   charpos:   3
#   rest:      &quot;barbaz&quot;
#   rest_size: 6
scanner.pos = 9
put_situation(scanner)
# Situation:
#   pos:       9
#   charpos:   9
#   rest:      &quot;&quot;
#   rest_size: 0
</code></pre>

<h3>Setting the Target Substring</h3>

<p>The target substring is set whenever:</p>

<ul>
<li>The [stored string][1] is set (position reset to zero; target substring set to stored string).</li>
<li>The [byte position][2] is set (target substring adjusted accordingly).</li>
</ul>

<h3>Querying the Target Substring</h3>

<p>This table summarizes (details and examples at the links):</p>

<table><thead>
<tr>
<th>Method</th>
<th>Returns</th>
</tr>
</thead><tbody>
<tr>
<td>#rest</td>
<td>Target substring.</td>
</tr>
<tr>
<td>#rest_size</td>
<td>Size (bytes) of target substring.</td>
</tr>
</tbody></table>

<h3>Searching the Target Substring</h3>

<p>A <em>search</em> method examines the target substring,
but does not advance the [positions][11]
or (by implication) shorten the target substring.</p>

<p>This table summarizes (details and examples at the links):</p>

<table><thead>
<tr>
<th>Method</th>
<th>Returns</th>
<th>Sets Match Values?</th>
</tr>
</thead><tbody>
<tr>
<td>#check(pattern)</td>
<td>Matched leading substring or <code>nil</code>.</td>
<td>Yes.</td>
</tr>
<tr>
<td>#check_until(pattern)</td>
<td>Matched substring (anywhere) or <code>nil</code>.</td>
<td>Yes.</td>
</tr>
<tr>
<td>#exist?(pattern)</td>
<td>Matched substring (anywhere) end index.</td>
<td>Yes.</td>
</tr>
<tr>
<td>#match?(pattern)</td>
<td>Size of matched leading substring or <code>nil</code>.</td>
<td>Yes.</td>
</tr>
<tr>
<td>#peek(size)</td>
<td>Leading substring of given length (bytes).</td>
<td>No.</td>
</tr>
<tr>
<td>#peek_byte</td>
<td>Integer leading byte or <code>nil</code>.</td>
<td>No.</td>
</tr>
<tr>
<td>#rest</td>
<td>Target substring (from byte position to end).</td>
<td>No.</td>
</tr>
</tbody></table>

<h3>Traversing the Target Substring</h3>

<p>A <em>traversal</em> method examines the target substring,
and, if successful:</p>

<ul>
<li>Advances the [positions][11].</li>
<li>Shortens the target substring.</li>
</ul>

<p>This table summarizes (details and examples at links):</p>

<table><thead>
<tr>
<th>Method</th>
<th>Returns</th>
<th>Sets Match Values?</th>
</tr>
</thead><tbody>
<tr>
<td>#get_byte</td>
<td>Leading byte or <code>nil</code>.</td>
<td>No.</td>
</tr>
<tr>
<td>#getch</td>
<td>Leading character or <code>nil</code>.</td>
<td>No.</td>
</tr>
<tr>
<td>#scan(pattern)</td>
<td>Matched leading substring or <code>nil</code>.</td>
<td>Yes.</td>
</tr>
<tr>
<td>#scan_byte</td>
<td>Integer leading byte or <code>nil</code>.</td>
<td>No.</td>
</tr>
<tr>
<td>#scan_until(pattern)</td>
<td>Matched substring (anywhere) or <code>nil</code>.</td>
<td>Yes.</td>
</tr>
<tr>
<td>#skip(pattern)</td>
<td>Matched leading substring size or <code>nil</code>.</td>
<td>Yes.</td>
</tr>
<tr>
<td>#skip_until(pattern)</td>
<td>Position delta to end-of-matched-substring or <code>nil</code>.</td>
<td>Yes.</td>
</tr>
<tr>
<td>#unscan</td>
<td><code>self</code>.</td>
<td>No.</td>
</tr>
</tbody></table>

<h2>Querying the Scanner</h2>

<p>Each of these methods queries the scanner object
without modifying it (details and examples at links)</p>

<table><thead>
<tr>
<th>Method</th>
<th>Returns</th>
</tr>
</thead><tbody>
<tr>
<td>#beginning_of_line?</td>
<td><code>true</code> or <code>false</code>.</td>
</tr>
<tr>
<td>#charpos</td>
<td>Character position.</td>
</tr>
<tr>
<td>#eos?</td>
<td><code>true</code> or <code>false</code>.</td>
</tr>
<tr>
<td>#fixed_anchor?</td>
<td><code>true</code> or <code>false</code>.</td>
</tr>
<tr>
<td>#inspect</td>
<td>String representation of <code>self</code>.</td>
</tr>
<tr>
<td>#pos</td>
<td>Byte position.</td>
</tr>
<tr>
<td>#rest</td>
<td>Target substring.</td>
</tr>
<tr>
<td>#rest_size</td>
<td>Size of target substring.</td>
</tr>
<tr>
<td>#string</td>
<td>Stored string.</td>
</tr>
</tbody></table>

<h2>Matching</h2>

<p><a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> implements pattern matching via Ruby class [Regexp][6],
and its matching behaviors are the same as Ruby&#39;s
except for the [fixed-anchor property][10].</p>

<h3>Matcher Methods</h3>

<p>Each <i>matcher method</i> takes a single argument <code>pattern</code>,
and attempts to find a matching substring in the [target substring][3].</p>

<table><thead>
<tr>
<th>Method</th>
<th>Pattern Type</th>
<th>Matches Target Substring</th>
<th>Success Return</th>
<th>May Update Positions?</th>
</tr>
</thead><tbody>
<tr>
<td>#check</td>
<td>Regexp or String.</td>
<td>At beginning.</td>
<td>Matched substring.</td>
<td>No.</td>
</tr>
<tr>
<td>#check_until</td>
<td>Regexp or String.</td>
<td>Anywhere.</td>
<td>Substring.</td>
<td>No.</td>
</tr>
<tr>
<td>#match?</td>
<td>Regexp or String.</td>
<td>At beginning.</td>
<td>Match size.</td>
<td>No.</td>
</tr>
<tr>
<td>#exist?</td>
<td>Regexp or String.</td>
<td>Anywhere.</td>
<td>Substring size.</td>
<td>No.</td>
</tr>
<tr>
<td>#scan</td>
<td>Regexp or String.</td>
<td>At beginning.</td>
<td>Matched substring.</td>
<td>Yes.</td>
</tr>
<tr>
<td>#scan_until</td>
<td>Regexp or String.</td>
<td>Anywhere.</td>
<td>Substring.</td>
<td>Yes.</td>
</tr>
<tr>
<td>#skip</td>
<td>Regexp or String.</td>
<td>At beginning.</td>
<td>Match size.</td>
<td>Yes.</td>
</tr>
<tr>
<td>#skip_until</td>
<td>Regexp or String.</td>
<td>Anywhere.</td>
<td>Substring size.</td>
<td>Yes.</td>
</tr>
</tbody></table>

<p><br></p>

<p>Which matcher you choose will depend on:</p>

<ul>
<li><p>Where you want to find a match:</p>

<ul>
<li>Only at the beginning of the target substring:
#check, #match?, #scan, #skip.</li>
<li>Anywhere in the target substring:
#check_until, #exist?, #scan_until, #skip_until.</li>
</ul></li>
<li><p>Whether you want to:</p>

<ul>
<li>Traverse, by advancing the positions:
#scan, #scan_until, #skip, #skip_until.</li>
<li>Keep the positions unchanged:
#check, #check_until, #match?, #exist?.</li>
</ul></li>
<li><p>What you want for the return value:</p>

<ul>
<li>The matched substring: #check, #scan.</li>
<li>The substring: #check_until, #scan_until.</li>
<li>The match size: #match?, #skip.</li>
<li>The substring size: #exist?, #skip_until.</li>
</ul></li>
</ul>

<h3>Match Values</h3>

<p>The <i>match values</i> in a <a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> object
generally contain the results of the most recent attempted match.</p>

<p>Each match value may be thought of as:</p>

<ul>
<li><em>Clear</em>: Initially, or after an unsuccessful match attempt:
usually, <code>false</code>, <code>nil</code>, or <code>{}</code>.</li>
<li><em>Set</em>: After a successful match attempt:
<code>true</code>, string, array, or hash.</li>
</ul>

<p>Each of these methods clears match values:</p>

<ul>
<li>::new(string).</li>
<li>#reset.</li>
<li>#terminate.</li>
</ul>

<p>Each of these methods attempts a match based on a pattern,
and either sets match values (if successful) or clears them (if not);</p>

<ul>
<li>#check(pattern)</li>
<li>#check_until(pattern)</li>
<li>#exist?(pattern)</li>
<li>#match?(pattern)</li>
<li>#scan(pattern)</li>
<li>#scan_until(pattern)</li>
<li>#skip(pattern)</li>
<li>#skip_until(pattern)</li>
</ul>

<h4>Basic Match Values</h4>

<p>Basic match values are those not related to captures.</p>

<p>Each of these methods returns a basic match value:</p>

<table><thead>
<tr>
<th>Method</th>
<th>Return After Match</th>
<th>Return After No Match</th>
</tr>
</thead><tbody>
<tr>
<td>#matched?</td>
<td><code>true</code>.</td>
<td><code>false</code>.</td>
</tr>
<tr>
<td>#matched_size</td>
<td>Size of matched substring.</td>
<td><code>nil</code>.</td>
</tr>
<tr>
<td>#matched</td>
<td>Matched substring.</td>
<td><code>nil</code>.</td>
</tr>
<tr>
<td>#pre_match</td>
<td>Substring preceding matched substring.</td>
<td><code>nil</code>.</td>
</tr>
<tr>
<td>#post_match</td>
<td>Substring following matched substring.</td>
<td><code>nil</code>.</td>
</tr>
</tbody></table>

<p><br></p>

<p>See examples below.</p>

<h4>Captured Match Values</h4>

<p>Captured match values are those related to [captures][16].</p>

<p>Each of these methods returns a captured match value:</p>

<table><thead>
<tr>
<th>Method</th>
<th>Return After Match</th>
<th>Return After No Match</th>
</tr>
</thead><tbody>
<tr>
<td>#size</td>
<td>Count of captured substrings.</td>
<td><code>nil</code>.</td>
</tr>
<tr>
<td>#<a href="n"></a></td>
<td><tt>n</tt>th captured substring.</td>
<td><code>nil</code>.</td>
</tr>
<tr>
<td>#captures</td>
<td>Array of all captured substrings.</td>
<td><code>nil</code>.</td>
</tr>
<tr>
<td>#values_at(*n)</td>
<td>Array of specified captured substrings.</td>
<td><code>nil</code>.</td>
</tr>
<tr>
<td>#named_captures</td>
<td>Hash of named captures.</td>
<td><tt>{}</tt>.</td>
</tr>
</tbody></table>

<p><br></p>

<p>See examples below.</p>

<h4>Match Values Examples</h4>

<p>Successful basic match attempt (no captures):</p>

<pre class="code rb"><code class="rb">scanner = StringScanner.new(&#39;foobarbaz&#39;)
scanner.exist?(/bar/)
put_match_values(scanner)
# Basic match values:
#   matched?:       true
#   matched_size:   3
#   pre_match:      &quot;foo&quot;
#   matched  :      &quot;bar&quot;
#   post_match:     &quot;baz&quot;
# Captured match values:
#   size:           1
#   captures:       []
#   named_captures: {}
#   values_at:      [&quot;bar&quot;, nil]
#   []:
#     [0]:          &quot;bar&quot;
#     [1]:          nil
</code></pre>

<p>Failed basic match attempt (no captures);</p>

<pre class="code rb"><code class="rb">scanner = StringScanner.new(&#39;foobarbaz&#39;)
scanner.exist?(/nope/)
match_values_cleared?(scanner) # =&gt; true
</code></pre>

<p>Successful unnamed capture match attempt:</p>

<pre class="code rb"><code class="rb">scanner = StringScanner.new(&#39;foobarbazbatbam&#39;)
scanner.exist?(/(foo)bar(baz)bat(bam)/)
put_match_values(scanner)
# Basic match values:
#   matched?:       true
#   matched_size:   15
#   pre_match:      &quot;&quot;
#   matched  :      &quot;foobarbazbatbam&quot;
#   post_match:     &quot;&quot;
# Captured match values:
#   size:           4
#   captures:       [&quot;foo&quot;, &quot;baz&quot;, &quot;bam&quot;]
#   named_captures: {}
#   values_at:      [&quot;foobarbazbatbam&quot;, &quot;foo&quot;, &quot;baz&quot;, &quot;bam&quot;, nil]
#   []:
#     [0]:          &quot;foobarbazbatbam&quot;
#     [1]:          &quot;foo&quot;
#     [2]:          &quot;baz&quot;
#     [3]:          &quot;bam&quot;
#     [4]:          nil
</code></pre>

<p>Successful named capture match attempt;
same as unnamed above, except for #named_captures:</p>

<pre class="code rb"><code class="rb">scanner = StringScanner.new(&#39;foobarbazbatbam&#39;)
scanner.exist?(/(?&lt;x&gt;foo)bar(?&lt;y&gt;baz)bat(?&lt;z&gt;bam)/)
scanner.named_captures # =&gt; {&quot;x&quot;=&gt;&quot;foo&quot;, &quot;y&quot;=&gt;&quot;baz&quot;, &quot;z&quot;=&gt;&quot;bam&quot;}
</code></pre>

<p>Failed unnamed capture match attempt:</p>

<pre class="code rb"><code class="rb">scanner = StringScanner.new(&#39;somestring&#39;)
scanner.exist?(/(foo)bar(baz)bat(bam)/)
match_values_cleared?(scanner) # =&gt; true
</code></pre>

<p>Failed named capture match attempt;
same as unnamed above, except for #named_captures:</p>

<pre class="code rb"><code class="rb">scanner = StringScanner.new(&#39;somestring&#39;)
scanner.exist?(/(?&lt;x&gt;foo)bar(?&lt;y&gt;baz)bat(?&lt;z&gt;bam)/)
match_values_cleared?(scanner) # =&gt; false
scanner.named_captures # =&gt; {&quot;x&quot;=&gt;nil, &quot;y&quot;=&gt;nil, &quot;z&quot;=&gt;nil}
</code></pre>

<h2>Fixed-Anchor Property</h2>

<p>Pattern matching in <a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> is the same as in Ruby&#39;s,
except for its fixed-anchor property,
which determines the meaning of <code>&#39;\A&#39;</code>:</p>

<ul>
<li><p><code>false</code> (the default): matches the current byte position.</p>

<pre class="code rb"><code class="rb">scanner = StringScanner.new(&#39;foobar&#39;)
scanner.scan(/\A./) # =&gt; &quot;f&quot;
scanner.scan(/\A./) # =&gt; &quot;o&quot;
scanner.scan(/\A./) # =&gt; &quot;o&quot;
scanner.scan(/\A./) # =&gt; &quot;b&quot;
</code></pre></li>
<li><p><code>true</code>: matches the beginning of the target substring;
never matches unless the byte position is zero:</p>

<pre class="code rb"><code class="rb">scanner = StringScanner.new(&#39;foobar&#39;, fixed_anchor: true)
scanner.scan(/\A./) # =&gt; &quot;f&quot;
scanner.scan(/\A./) # =&gt; nil
scanner.reset
scanner.scan(/\A./) # =&gt; &quot;f&quot;
</code></pre></li>
</ul>

<p>The fixed-anchor property is set when the <a href="StringScanner.html" title="StringScanner (class)"><code>StringScanner</code></a> object is created,
and may not be modified
(see StringScanner.new);
method #fixed_anchor? returns the setting.</p>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>