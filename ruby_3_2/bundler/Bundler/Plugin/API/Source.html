<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Module: Bundler::Plugin::API::Source &mdash; bundler  Ruby-3.2.9 p265</title>

<link rel='stylesheet'  type='text/css' href='../../../../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../../../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../../../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../../../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../../../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Bundler::Plugin::API::Source",
    relpath = '../../../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../../../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../../../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../../../../'>Ruby-3.2.9</a> &raquo; 
      <a href='../../../'>bundler</a> &raquo; 
      <a href='../../../_index.html#alpha_S'>Index (S)</a> &raquo; 
        <a href="../../../Bundler.html" title="Bundler (module)">Bundler</a> &raquo; 
        <a href="../../Plugin.html" title="Bundler::Plugin (module)">Plugin</a> &raquo; 
        <a href="../API.html" title="Bundler::Plugin::API (class)">API</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>Source&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../../../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='module'>
<h1>Module: Bundler::Plugin::API::Source</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L41'>lib/bundler/plugin/api/source.rb</a>      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p>This class provides the base to build source plugins All the method here are required to build a source plugin (except <a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">#uri_hash</a>, <a href="#gem_install_dir-instance_method" title="Bundler::Plugin::API::Source#gem_install_dir (method)">#gem_install_dir</a>; they are helpers).</p>

<p>Defaults for methods, where ever possible are provided which is expected to work. But, all source plugins have to override <a href="#fetch_gemspec_files-instance_method" title="Bundler::Plugin::API::Source#fetch_gemspec_files (method)">#fetch_gemspec_files</a> and <a href="#install-instance_method" title="Bundler::Plugin::API::Source#install (method)">#install</a>. Defaults are also not provided for <a href="#remote!-instance_method" title="Bundler::Plugin::API::Source#remote! (method)">#remote!</a>, <code>cache!</code> and <a href="#unlock!-instance_method" title="Bundler::Plugin::API::Source#unlock! (method)">#unlock!</a>.</p>

<p>The defaults shall work for most situations but nevertheless they can be (preferably should be) overridden as per the plugins’ needs safely (as long as they behave as expected). On overriding <a href="#initialize-instance_method" title="Bundler::Plugin::API::Source#initialize (method)">#initialize</a> you should call super first.</p>

<p>If required plugin should override <a href="#hash-instance_method" title="Bundler::Plugin::API::Source#hash (method)">#hash</a>, <a href="#==-instance_method" title="Bundler::Plugin::API::Source#== (method)">#==</a> and <a href="#eql%3F-instance_method" title="Bundler::Plugin::API::Source#eql? (method)">#eql?</a> methods to be able to match objects representing same sources, but may be created in different situation (like form gemfile and lockfile). The default ones checks only for class and uri, but elaborate source plugins may need more comparisons (e.g. git checking on branch or tag).</p>

  </div>
</div>
</div>
<h2 class='h2_sum' id='instance_attribute_summary'>Instance Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature rw'>
      <a href="#dependency_names-instance_method" title="#dependency_names (instance method)">#<strong>dependency_names</strong>  &#x21d2; Array&lt;String&gt; </a>
    </span>
    <span class='note title rw'>rw</span>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#installed%3F-instance_method" title="#installed? (instance method)">#<strong>installed?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>A helper method, not necessary if not used internally.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#name-instance_method" title="#name (instance method)">#<strong>name</strong>  &#x21d2; String </a>
    </span>
    <span class='note title readonly'>readonly</span>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#options-instance_method" title="#options (instance method)">#<strong>options</strong>  &#x21d2; String </a>
    </span>
    <span class='note title readonly'>readonly</span>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#uri-instance_method" title="#uri (instance method)">#<strong>uri</strong>  &#x21d2; String </a>
    </span>
    <span class='note title readonly'>readonly</span>
  </li>
</ul>
</div>  <!-- instance_attribute_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#==-instance_method" title="#== (instance method)">#<strong>==</strong>(other)  </a>
      (also: #eql?)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This shall check if two source object represent the same source.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#add_dependency_names-instance_method" title="#add_dependency_names (instance method)">#<strong>add_dependency_names</strong>(names)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Used by definition.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#app_cache_dirname-instance_method" title="#app_cache_dirname (instance method)">#<strong>app_cache_dirname</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Name of directory where plugin the is expected to cache the gems when <a href="#cache-instance_method" title="Bundler::Plugin::API::Source#cache (method)">#cache</a> is called.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#app_cache_path-instance_method" title="#app_cache_path (instance method)">#<strong>app_cache_path</strong>(custom_path = nil)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>The full path where the plugin should cache the gem so that it can be installed latter.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#cache-instance_method" title="#cache (instance method)">#<strong>cache</strong>(spec, custom_path = nil)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This method is called while caching to save copy of the gems that the source can resolve to path provided by <code>app_cache_app</code>so that they can be reinstalled from the cache without querying the remote (i.e. an alternative to remote).</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#cached!-instance_method" title="#cached! (instance method)">#<strong>cached!</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Set internal representation to fetch the gems/specs from app cache.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#can_lock%3F-instance_method" title="#can_lock? (instance method)">#<strong>can_lock?</strong>(spec)  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>NOTE: Do not override if you don’t know what you are doing.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#eql%3F-instance_method" title="#eql? (instance method)">#<strong>eql?</strong>(other)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#==-instance_method" title="Bundler::Plugin::API::Source#== (method)">#==</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#fetch_gemspec_files-instance_method" title="#fetch_gemspec_files (instance method)">#<strong>fetch_gemspec_files</strong>  &#x21d2; Array&lt;String&gt; </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This is used by the default <code>spec</code> method to constructs the Specification objects for the gems and versions that can be installed by this source plugin.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#gem_install_dir-instance_method" title="#gem_install_dir (instance method)">#<strong>gem_install_dir</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>NOTE: Do not override if you don’t know what you are doing.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#hash-instance_method" title="#hash (instance method)">#<strong>hash</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>When overriding <a href="#hash-instance_method" title="Bundler::Plugin::API::Source#hash (method)">#hash</a> please preserve the behaviour as mentioned in docstring for <a href="#==-instance_method" title="Bundler::Plugin::API::Source#== (method)">#==</a> method, i.e.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#identifier-instance_method" title="#identifier (instance method)">#<strong>identifier</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#to_s-instance_method" title="Bundler::Plugin::API::Source#to_s (method)">#to_s</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#include%3F-instance_method" title="#include? (instance method)">#<strong>include?</strong>(other)  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>NOTE: Do not override if you don’t know what you are doing.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#initialize-instance_method" title="#initialize (instance method)">#<strong>initialize</strong>(opts)  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#install-instance_method" title="#install (instance method)">#<strong>install</strong>(spec, opts)  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Install the gem specified by the spec at appropriate path.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#install_path-instance_method" title="#install_path (instance method)">#<strong>install_path</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>A default installation path to install a single gem.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#local!-instance_method" title="#local! (instance method)">#<strong>local!</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Set internal representation to fetch the gems/specs locally.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#options_to_lock-instance_method" title="#options_to_lock (instance method)">#<strong>options_to_lock</strong>  &#x21d2; Hash </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Options to be saved in the lockfile so that the source plugin is able to check out same version of gem later.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#post_install-instance_method" title="#post_install (instance method)">#<strong>post_install</strong>(spec, disable_exts = false)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>It builds extensions, generates bins and installs them for the spec provided.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#remote!-instance_method" title="#remote! (instance method)">#<strong>remote!</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Set internal representation to fetch the gems/specs from remote.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#root-instance_method" title="#root (instance method)">#<strong>root</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>It is used to obtain the full_gem_path.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#spec_names-instance_method" title="#spec_names (instance method)">#<strong>spec_names</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Used by definition.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#specs-instance_method" title="#specs (instance method)">#<strong>specs</strong>  &#x21d2; Bundler::Index </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Parses the gemspec files to find the specs for the gems that can be satisfied by the source.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#to_lock-instance_method" title="#to_lock (instance method)">#<strong>to_lock</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Generates the content to be entered into the lockfile.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#to_s-instance_method" title="#to_s (instance method)">#<strong>to_s</strong>  </a>
      (also: #identifier)
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#unlock!-instance_method" title="#unlock! (instance method)">#<strong>unlock!</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This is called to update the spec and installation.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#unmet_deps-instance_method" title="#unmet_deps (instance method)">#<strong>unmet_deps</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Used by definition.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#uri_hash-instance_method" title="#uri_hash (instance method)">#<strong>uri_hash</strong>  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature nodoc'>
      <a href="#double_check_for-instance_method" title="#double_check_for (instance method)">#<strong>double_check_for</strong>  </a>
    </span>
    <span class='nodoc note title'>Internal use only</span>
    <span class='nodoc note title'>Internal use only</span>
    <div class='summary_desc'>
      <div class='inline'><p>This API on source might not be stable, and for now we expect plugins to download all specs in <a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">#specs</a>, so we implement the method for compatibility purposes and leave it undocumented (and don’t support) overriding it).</p></div>
    </div>
  </li>
</ul>
</div>  <!-- instance_method_summary -->
<h2 class='y_details'>Instance Attribute Details</h2>
<section class='method_details first' id="dependency_names-instance_method">
  <h3 class='signature rw first'>
    #<strong>dependency_names</strong>  &#x21d2; <code>Array</code>&lt;<code>String</code>&gt;  <span class="extras">(<span class='rw'>rw</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Array</code>&lt;<code>String</code>&gt;)</span>
&mdash;    <div class='inline'>
<p>Names of dependencies that the source should try to resolve. It is not necessary to use this list internally. This is present to be compatible with <a href="../../Definition.html" title="Bundler::Definition (class)"><code>::Bundler::Definition</code></a> and is used by rubygems source.</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L41-L317'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='41' data-end='317'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 41</span></pre>
<pre class='code ruby'>

<span class='kw'>module</span> <span class='const'>Source</span>
  <span class='id identifier rubyid_attr_reader'>attr_reader</span> <span class='symbeg'>:</span><span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_options'><a href="#options-instance_method" title="Bundler::Plugin::API::Source#options (method)">options</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'><a href="#name-instance_method" title="Bundler::Plugin::API::Source#name (method)">name</a></span>
  <span class='id identifier rubyid_attr_accessor'>attr_accessor</span> <span class='symbeg'>:</span><span class='id identifier rubyid_dependency_names'>dependency_names</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'><a href="#initialize-instance_method" title="Bundler::Plugin::API::Source#initialize (method)">initialize</a></span>(<span class='id identifier rubyid_opts'>opts</span>)
    <span class='ivar'>@options</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>
    <span class='ivar'>@dependency_names</span> <span class='op'>=</span> []
    <span class='ivar'>@uri</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>uri</span><span class='tstring_end'>&quot;</span></span>]
    <span class='ivar'>@type</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span>]
    <span class='ivar'>@name</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span>] <span class='op'>||</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'> at </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># This is used by the default `spec` method to constructs the
</span>  <span class='comment'># Specification objects for the gems and versions that can be installed
</span>  <span class='comment'># by this source plugin.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: If the spec method is overridden, this function is not necessary
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [Array&lt;String&gt;] paths of the gemspec files for gems that can
</span>  <span class='comment'>#                         be installed
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_fetch_gemspec_files'><a href="#fetch_gemspec_files-instance_method" title="Bundler::Plugin::API::Source#fetch_gemspec_files (method)">fetch_gemspec_files</a></span>
    []
  <span class='kw'>end</span>

  <span class='comment'># Options to be saved in the lockfile so that the source plugin is able
</span>  <span class='comment'># to check out same version of gem later.
</span>  <span class='comment'>#
</span>  <span class='comment'># There options are passed when the source plugin is created from the
</span>  <span class='comment'># lock file.
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [Hash]
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_options_to_lock'><a href="#options_to_lock-instance_method" title="Bundler::Plugin::API::Source#options_to_lock (method)">options_to_lock</a></span>
    {}
  <span class='kw'>end</span>

  <span class='comment'># Install the gem specified by the spec at appropriate path.
</span>  <span class='comment'># `install_path` provides a sufficient default, if the source can only
</span>  <span class='comment'># satisfy one gem,  but is not binding.
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [String] post installation message (if any)
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_install'><a href="#install-instance_method" title="Bundler::Plugin::API::Source#install (method)">install</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>)
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../MalformattedPlugin.html" title="Bundler::Plugin::MalformattedPlugin (class)">MalformattedPlugin</a></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Source plugins need to override the install method.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># It builds extensions, generates bins and installs them for the spec
</span>  <span class='comment'># provided.
</span>  <span class='comment'>#
</span>  <span class='comment'># It depends on `spec.loaded_from` to get full_gem_path. The source
</span>  <span class='comment'># plugins should set that.
</span>  <span class='comment'>#
</span>  <span class='comment'># It should be called in `install` after the plugin is done placing the
</span>  <span class='comment'># gem at correct install location.
</span>  <span class='comment'>#
</span>  <span class='comment'># It also runs Gem hooks `pre_install`, `post_build` and `post_install`
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_post_install'><a href="#post_install-instance_method" title="Bundler::Plugin::API::Source#post_install (method)">post_install</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_disable_exts'>disable_exts</span> <span class='op'>=</span> <span class='kw'>false</span>)
    <span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> { <span class='symbeg'>:</span><span class='id identifier rubyid_env_shebang'>env_shebang</span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_disable_extensions'>disable_extensions</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_disable_exts'>disable_exts</span> }
    <span class='id identifier rubyid_installer'>installer</span> <span class='op'>=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../Source.html" title="Bundler::Source (class)">Source</a></span><span class='op'>::</span><span class='const'><a href="../../Source/Path.html" title="Bundler::Source::Path (class)">Path</a></span><span class='op'>::</span><span class='const'><a href="../../Source/Path/Installer.html" title="Bundler::Source::Path::Installer (class)">Installer</a></span>.<span class='id identifier rubyid_new'><a href="../../Source/Path/Installer.html#new-class_method" title="Bundler::Source::Path::Installer.new (method)">new</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>)
    <span class='id identifier rubyid_installer'>installer</span>.<span class='id identifier rubyid_post_install'><a href="#post_install-instance_method" title="Bundler::Plugin::API::Source#post_install (method)">post_install</a></span>
  <span class='kw'>end</span>

  <span class='comment'># A default installation path to install a single gem. If the source
</span>  <span class='comment'># servers multiple gems, it&#39;s not of much use and the source should one
</span>  <span class='comment'># of its own.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span>
    <span class='ivar'>@install_path</span> <span class='op'>||=</span>
      <span class='kw'>begin</span>
        <span class='id identifier rubyid_base_name'>base_name</span> <span class='op'>=</span> <span class='const'>File</span>.<span class='id identifier rubyid_basename'>basename</span>(<span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../URI.html" title="Bundler::URI (module)">URI</a></span>.<span class='id identifier rubyid_parse'><a href="../../URI.html#parse-class_method" title="Bundler::URI.parse (method)">parse</a></span>(<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>).<span class='id identifier rubyid_normalize'>normalize</span>.<span class='id identifier rubyid_path'>path</span>)

        <span class='id identifier rubyid_gem_install_dir'><a href="#gem_install_dir-instance_method" title="Bundler::Plugin::API::Source#gem_install_dir (method)">gem_install_dir</a></span>.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_base_name'>base_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span>[<span class='int'>0</span><span class='op'>..</span><span class='int'>11</span>]<span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>)
      <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='comment'># Parses the gemspec files to find the specs for the gems that can be
</span>  <span class='comment'># satisfied by the source.
</span>  <span class='comment'>#
</span>  <span class='comment'># Few important points to keep in mind:
</span>  <span class='comment'>#   - If the gems are not installed then it shall return specs for all
</span>  <span class='comment'>#   the gems it can satisfy
</span>  <span class='comment'>#   - If gem is installed (that is to be detected by the plugin itself)
</span>  <span class='comment'>#   then it shall return at least the specs that are installed.
</span>  <span class='comment'>#   - The `loaded_from` for each of the specs shall be correct (it is
</span>  <span class='comment'>#   used to find the load path)
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [Bundler::Index] index containing the specs
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>
    <span class='id identifier rubyid_files'>files</span> <span class='op'>=</span> <span class='id identifier rubyid_fetch_gemspec_files'><a href="#fetch_gemspec_files-instance_method" title="Bundler::Plugin::API::Source#fetch_gemspec_files (method)">fetch_gemspec_files</a></span>

    <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../Index.html" title="Bundler::Index (class)">Index</a></span>.<span class='id identifier rubyid_build'><a href="../../Index.html#build-class_method" title="Bundler::Index.build (method)">build</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_index'><a href="../../Plugin.html#index-class_method" title="Bundler::Plugin.index (method)">index</a></span><span class='op'>|</span>
      <span class='id identifier rubyid_files'>files</span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_file'>file</span><span class='op'>|</span>
        <span class='kw'>next</span> <span class='kw'>unless</span> <span class='id identifier rubyid_spec'>spec</span> <span class='op'>=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_load_gemspec'><a href="../../../Bundler.html#load_gemspec-class_method" title="Bundler.load_gemspec (method)">load_gemspec</a></span>(<span class='id identifier rubyid_file'>file</span>)
        <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_rubygems'><a href="../../../Bundler.html#rubygems-class_method" title="Bundler.rubygems (method)">rubygems</a></span>.<span class='id identifier rubyid_set_installed_by_version'>set_installed_by_version</span>(<span class='id identifier rubyid_spec'>spec</span>)

        <span class='id identifier rubyid_spec'>spec</span>.<span class='id identifier rubyid_source'><a href="../API.html#source-class_method" title="Bundler::Plugin::API.source (method)">source</a></span> <span class='op'>=</span> <span class='kw'>self</span>
        <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_rubygems'><a href="../../../Bundler.html#rubygems-class_method" title="Bundler.rubygems (method)">rubygems</a></span>.<span class='id identifier rubyid_validate'>validate</span>(<span class='id identifier rubyid_spec'>spec</span>)

        <span class='id identifier rubyid_index'><a href="../../Plugin.html#index-class_method" title="Bundler::Plugin.index (method)">index</a></span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_spec'>spec</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='comment'># Set internal representation to fetch the gems/specs locally.
</span>  <span class='comment'>#
</span>  <span class='comment'># When this is called, the source should try to fetch the specs and
</span>  <span class='comment'># install from the local system.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_local!'><a href="#local!-instance_method" title="Bundler::Plugin::API::Source#local! (method)">local!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Set internal representation to fetch the gems/specs from remote.
</span>  <span class='comment'>#
</span>  <span class='comment'># When this is called, the source should try to fetch the specs and
</span>  <span class='comment'># install from remote path.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_remote!'><a href="#remote!-instance_method" title="Bundler::Plugin::API::Source#remote! (method)">remote!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Set internal representation to fetch the gems/specs from app cache.
</span>  <span class='comment'>#
</span>  <span class='comment'># When this is called, the source should try to fetch the specs and
</span>  <span class='comment'># install from the path provided by `app_cache_path`.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_cached!'><a href="#cached!-instance_method" title="Bundler::Plugin::API::Source#cached! (method)">cached!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># This is called to update the spec and installation.
</span>  <span class='comment'>#
</span>  <span class='comment'># If the source plugin is loaded from lockfile or otherwise, it shall
</span>  <span class='comment'># refresh the cache/specs (e.g. git sources can make a fresh clone).
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_unlock!'><a href="#unlock!-instance_method" title="Bundler::Plugin::API::Source#unlock! (method)">unlock!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Name of directory where plugin the is expected to cache the gems when
</span>  <span class='comment'># #cache is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># Also this name is matched against the directories in cache for pruning
</span>  <span class='comment'>#
</span>  <span class='comment'># This is used by `app_cache_path`
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_app_cache_dirname'><a href="#app_cache_dirname-instance_method" title="Bundler::Plugin::API::Source#app_cache_dirname (method)">app_cache_dirname</a></span>
    <span class='id identifier rubyid_base_name'>base_name</span> <span class='op'>=</span> <span class='const'>File</span>.<span class='id identifier rubyid_basename'>basename</span>(<span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../URI.html" title="Bundler::URI (module)">URI</a></span>.<span class='id identifier rubyid_parse'><a href="../../URI.html#parse-class_method" title="Bundler::URI.parse (method)">parse</a></span>(<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>).<span class='id identifier rubyid_normalize'>normalize</span>.<span class='id identifier rubyid_path'>path</span>)
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_base_name'>base_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># This method is called while caching to save copy of the gems that the
</span>  <span class='comment'># source can resolve to path provided by `app_cache_app`so that they can
</span>  <span class='comment'># be reinstalled from the cache without querying the remote (i.e. an
</span>  <span class='comment'># alternative to remote)
</span>  <span class='comment'>#
</span>  <span class='comment'># This is stored with the app and source plugins should try to provide
</span>  <span class='comment'># specs and install only from this cache when `cached!` is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># This cache is different from the internal caching that can be done
</span>  <span class='comment'># at sub paths of `cache_path` (from API). This can be though as caching
</span>  <span class='comment'># by bundler.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_cache'><a href="#cache-instance_method" title="Bundler::Plugin::API::Source#cache (method)">cache</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_custom_path'>custom_path</span> <span class='op'>=</span> <span class='kw'>nil</span>)
    <span class='id identifier rubyid_new_cache_path'>new_cache_path</span> <span class='op'>=</span> <span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span>)

    <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_rm_rf'><a href="../../FileUtils.html#rm_rf-class_method" title="Bundler::FileUtils.rm_rf (method)">rm_rf</a></span>(<span class='id identifier rubyid_new_cache_path'>new_cache_path</span>)
    <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_cp_r'><a href="../../FileUtils.html#cp_r-class_method" title="Bundler::FileUtils.cp_r (method)">cp_r</a></span>(<span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span><span class='comma'>,</span> <span class='id identifier rubyid_new_cache_path'>new_cache_path</span>)
    <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_touch'><a href="../../FileUtils.html#touch-class_method" title="Bundler::FileUtils.touch (method)">touch</a></span>(<span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>.bundlecache</span><span class='tstring_end'>&quot;</span></span>))
  <span class='kw'>end</span>

  <span class='comment'># This shall check if two source object represent the same source.
</span>  <span class='comment'>#
</span>  <span class='comment'># The comparison shall take place only on the attribute that can be
</span>  <span class='comment'># inferred from the options passed from Gemfile and not on attributes
</span>  <span class='comment'># that are used to pin down the gem to specific version (e.g. Git
</span>  <span class='comment'># sources should compare on branch and tag but not on commit hash)
</span>  <span class='comment'>#
</span>  <span class='comment'># The sources objects are constructed from Gemfile as well as from
</span>  <span class='comment'># lockfile. To converge the sources, it is necessary that they match.
</span>  <span class='comment'>#
</span>  <span class='comment'># The same applies for `eql?` and `hash`
</span>  <span class='kw'>def</span> <span class='op'>==</span>(<span class='id identifier rubyid_other'>other</span>)
    <span class='id identifier rubyid_other'>other</span>.<span class='id identifier rubyid_is_a?'>is_a?</span>(<span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span>) <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span> <span class='op'>==</span> <span class='id identifier rubyid_other'>other</span>.<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>
  <span class='kw'>end</span>

  <span class='comment'># When overriding `eql?` please preserve the behaviour as mentioned in
</span>  <span class='comment'># docstring for `==` method.
</span>  <span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_eql?'><a href="#eql%3F-instance_method" title="Bundler::Plugin::API::Source#eql? (method)">eql?</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='op'>==</span>

  <span class='comment'># When overriding `hash` please preserve the behaviour as mentioned in
</span>  <span class='comment'># docstring for `==` method, i.e. two methods equal by above comparison
</span>  <span class='comment'># should have same hash.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_hash'><a href="#hash-instance_method" title="Bundler::Plugin::API::Source#hash (method)">hash</a></span>
    [<span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span><span class='comma'>,</span> <span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>].<span class='id identifier rubyid_hash'><a href="#hash-instance_method" title="Bundler::Plugin::API::Source#hash (method)">hash</a></span>
  <span class='kw'>end</span>

  <span class='comment'># A helper method, not necessary if not used internally.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_installed?'><a href="#installed%3F-instance_method" title="Bundler::Plugin::API::Source#installed? (method)">installed?</a></span>
    <span class='const'>File</span>.<span class='id identifier rubyid_directory?'>directory?</span>(<span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span>)
  <span class='kw'>end</span>

  <span class='comment'># The full path where the plugin should cache the gem so that it can be
</span>  <span class='comment'># installed latter.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span> <span class='op'>=</span> <span class='kw'>nil</span>)
    <span class='ivar'>@app_cache_path</span> <span class='op'>||=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_app_cache'><a href="../../../Bundler.html#app_cache-class_method" title="Bundler.app_cache (method)">app_cache</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span>).<span class='id identifier rubyid_join'>join</span>(<span class='id identifier rubyid_app_cache_dirname'><a href="#app_cache_dirname-instance_method" title="Bundler::Plugin::API::Source#app_cache_dirname (method)">app_cache_dirname</a></span>)
  <span class='kw'>end</span>

  <span class='comment'># Used by definition.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_unmet_deps'><a href="#unmet_deps-instance_method" title="Bundler::Plugin::API::Source#unmet_deps (method)">unmet_deps</a></span>
    <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>.<span class='id identifier rubyid_unmet_dependency_names'>unmet_dependency_names</span>
  <span class='kw'>end</span>

  <span class='comment'># Used by definition.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_spec_names'><a href="#spec_names-instance_method" title="Bundler::Plugin::API::Source#spec_names (method)">spec_names</a></span>
    <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>.<span class='id identifier rubyid_spec_names'><a href="#spec_names-instance_method" title="Bundler::Plugin::API::Source#spec_names (method)">spec_names</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Used by definition.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_add_dependency_names'><a href="#add_dependency_names-instance_method" title="Bundler::Plugin::API::Source#add_dependency_names (method)">add_dependency_names</a></span>(<span class='id identifier rubyid_names'>names</span>)
    <span class='ivar'>@dependencies</span> <span class='op'>|=</span> <span class='const'>Array</span>(<span class='id identifier rubyid_names'>names</span>)
  <span class='kw'>end</span>

  <span class='comment'># NOTE: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_can_lock?'><a href="#can_lock%3F-instance_method" title="Bundler::Plugin::API::Source#can_lock? (method)">can_lock?</a></span>(<span class='id identifier rubyid_spec'>spec</span>)
    <span class='id identifier rubyid_spec'>spec</span>.<span class='id identifier rubyid_source'><a href="../API.html#source-class_method" title="Bundler::Plugin::API.source (method)">source</a></span> <span class='op'>==</span> <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='comment'># Generates the content to be entered into the lockfile.
</span>  <span class='comment'># Saves type and remote and also calls to `options_to_lock`.
</span>  <span class='comment'>#
</span>  <span class='comment'># Plugin should use `options_to_lock` to save information in lockfile
</span>  <span class='comment'># and not override this.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_lock'><a href="#to_lock-instance_method" title="Bundler::Plugin::API::Source#to_lock (method)">to_lock</a></span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>=</span> <span class='const'>String</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='const'><a href="../../LockfileParser.html" title="Bundler::LockfileParser (class)">LockfileParser</a></span><span class='op'>::</span><span class='const'><a href="../../LockfileParser.html#PLUGIN-constant" title="Bundler::LockfileParser::PLUGIN (constant)">PLUGIN</a></span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>)
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  remote: </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  type: </span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_options_to_lock'><a href="#options_to_lock-instance_method" title="Bundler::Plugin::API::Source#options_to_lock (method)">options_to_lock</a></span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_opt'>opt</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='op'>|</span>
      <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_opt'>opt</span><span class='embexpr_end'>}</span><span class='tstring_content'>: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_value'>value</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  specs:\n</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_to_s'><a href="#to_s-instance_method" title="Bundler::Plugin::API::Source#to_s (method)">to_s</a></span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>plugin source for </span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'> with uri </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_identifier'><a href="#identifier-instance_method" title="Bundler::Plugin::API::Source#identifier (method)">identifier</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_to_s'><a href="#to_s-instance_method" title="Bundler::Plugin::API::Source#to_s (method)">to_s</a></span>

  <span class='comment'># NOTE: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_include?'><a href="#include%3F-instance_method" title="Bundler::Plugin::API::Source#include? (method)">include?</a></span>(<span class='id identifier rubyid_other'>other</span>)
    <span class='id identifier rubyid_other'>other</span> <span class='op'>==</span> <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span>
    <span class='const'><a href="../../SharedHelpers.html" title="Bundler::SharedHelpers (module)">SharedHelpers</a></span>.<span class='id identifier rubyid_digest'><a href="../../SharedHelpers.html#digest-instance_method" title="Bundler::SharedHelpers#digest (method)">digest</a></span>(<span class='symbeg'>:</span><span class='const'>SHA1</span>).<span class='id identifier rubyid_hexdigest'>hexdigest</span>(<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>)
  <span class='kw'>end</span>

  <span class='comment'># NOTE: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_gem_install_dir'><a href="#gem_install_dir-instance_method" title="Bundler::Plugin::API::Source#gem_install_dir (method)">gem_install_dir</a></span>
    <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_install_path'><a href="../../../Bundler.html#install_path-class_method" title="Bundler.install_path (method)">install_path</a></span>
  <span class='kw'>end</span>

  <span class='comment'># It is used to obtain the full_gem_path.
</span>  <span class='comment'>#
</span>  <span class='comment'># spec&#39;s loaded_from path is expanded against this to get full_gem_path
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_root'><a href="../../../top-level-namespace.html" title="Top Level Namespace (root)">root</a></span>
    <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_root'><a href="../../../Bundler.html#root-class_method" title="Bundler.root (method)">root</a></span>
  <span class='kw'>end</span>

  <span class='comment'># @private
</span>  <span class='comment'># This API on source might not be stable, and for now we expect plugins
</span>  <span class='comment'># to download all specs in `#specs`, so we implement the method for
</span>  <span class='comment'># compatibility purposes and leave it undocumented (and don&#39;t support)
</span>  <span class='comment'># overriding it)
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_double_check_for'><a href="#double_check_for-instance_method" title="Bundler::Plugin::API::Source#double_check_for (method)">double_check_for</a></span>(<span class='op'>*</span>)<span class='semicolon'>;</span> <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="installed?-instance_method">
  <h3 class='signature ro'>
    #<strong>installed?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>A helper method, not necessary if not used internally.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L228-L230'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='228' data-end='230'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 228</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_installed?'>installed?</span>
  <span class='const'>File</span>.<span class='id identifier rubyid_directory?'>directory?</span>(<span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="name-instance_method">
  <h3 class='signature ro'>
    #<strong>name</strong>  &#x21d2; <code>String</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>String</code>)</span>
&mdash;    <div class='inline'>
<p>name that can be used to uniquely identify a source</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L41-L317'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='41' data-end='317'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 41</span></pre>
<pre class='code ruby'>

<span class='kw'>module</span> <span class='const'>Source</span>
  <span class='id identifier rubyid_attr_reader'>attr_reader</span> <span class='symbeg'>:</span><span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_options'><a href="#options-instance_method" title="Bundler::Plugin::API::Source#options (method)">options</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'>name</span>
  <span class='id identifier rubyid_attr_accessor'>attr_accessor</span> <span class='symbeg'>:</span><span class='id identifier rubyid_dependency_names'><a href="#dependency_names-instance_method" title="Bundler::Plugin::API::Source#dependency_names (method)">dependency_names</a></span>

  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'><a href="#initialize-instance_method" title="Bundler::Plugin::API::Source#initialize (method)">initialize</a></span>(<span class='id identifier rubyid_opts'>opts</span>)
    <span class='ivar'>@options</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>
    <span class='ivar'>@dependency_names</span> <span class='op'>=</span> []
    <span class='ivar'>@uri</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>uri</span><span class='tstring_end'>&quot;</span></span>]
    <span class='ivar'>@type</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span>]
    <span class='ivar'>@name</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span>] <span class='op'>||</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'> at </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># This is used by the default `spec` method to constructs the
</span>  <span class='comment'># Specification objects for the gems and versions that can be installed
</span>  <span class='comment'># by this source plugin.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: If the spec method is overridden, this function is not necessary
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [Array&lt;String&gt;] paths of the gemspec files for gems that can
</span>  <span class='comment'>#                         be installed
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_fetch_gemspec_files'><a href="#fetch_gemspec_files-instance_method" title="Bundler::Plugin::API::Source#fetch_gemspec_files (method)">fetch_gemspec_files</a></span>
    []
  <span class='kw'>end</span>

  <span class='comment'># Options to be saved in the lockfile so that the source plugin is able
</span>  <span class='comment'># to check out same version of gem later.
</span>  <span class='comment'>#
</span>  <span class='comment'># There options are passed when the source plugin is created from the
</span>  <span class='comment'># lock file.
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [Hash]
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_options_to_lock'><a href="#options_to_lock-instance_method" title="Bundler::Plugin::API::Source#options_to_lock (method)">options_to_lock</a></span>
    {}
  <span class='kw'>end</span>

  <span class='comment'># Install the gem specified by the spec at appropriate path.
</span>  <span class='comment'># `install_path` provides a sufficient default, if the source can only
</span>  <span class='comment'># satisfy one gem,  but is not binding.
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [String] post installation message (if any)
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_install'><a href="#install-instance_method" title="Bundler::Plugin::API::Source#install (method)">install</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>)
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../MalformattedPlugin.html" title="Bundler::Plugin::MalformattedPlugin (class)">MalformattedPlugin</a></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Source plugins need to override the install method.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># It builds extensions, generates bins and installs them for the spec
</span>  <span class='comment'># provided.
</span>  <span class='comment'>#
</span>  <span class='comment'># It depends on `spec.loaded_from` to get full_gem_path. The source
</span>  <span class='comment'># plugins should set that.
</span>  <span class='comment'>#
</span>  <span class='comment'># It should be called in `install` after the plugin is done placing the
</span>  <span class='comment'># gem at correct install location.
</span>  <span class='comment'>#
</span>  <span class='comment'># It also runs Gem hooks `pre_install`, `post_build` and `post_install`
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_post_install'><a href="#post_install-instance_method" title="Bundler::Plugin::API::Source#post_install (method)">post_install</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_disable_exts'>disable_exts</span> <span class='op'>=</span> <span class='kw'>false</span>)
    <span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> { <span class='symbeg'>:</span><span class='id identifier rubyid_env_shebang'>env_shebang</span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_disable_extensions'>disable_extensions</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_disable_exts'>disable_exts</span> }
    <span class='id identifier rubyid_installer'>installer</span> <span class='op'>=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../Source.html" title="Bundler::Source (class)">Source</a></span><span class='op'>::</span><span class='const'><a href="../../Source/Path.html" title="Bundler::Source::Path (class)">Path</a></span><span class='op'>::</span><span class='const'><a href="../../Source/Path/Installer.html" title="Bundler::Source::Path::Installer (class)">Installer</a></span>.<span class='id identifier rubyid_new'><a href="../../Source/Path/Installer.html#new-class_method" title="Bundler::Source::Path::Installer.new (method)">new</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>)
    <span class='id identifier rubyid_installer'>installer</span>.<span class='id identifier rubyid_post_install'><a href="#post_install-instance_method" title="Bundler::Plugin::API::Source#post_install (method)">post_install</a></span>
  <span class='kw'>end</span>

  <span class='comment'># A default installation path to install a single gem. If the source
</span>  <span class='comment'># servers multiple gems, it&#39;s not of much use and the source should one
</span>  <span class='comment'># of its own.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span>
    <span class='ivar'>@install_path</span> <span class='op'>||=</span>
      <span class='kw'>begin</span>
        <span class='id identifier rubyid_base_name'>base_name</span> <span class='op'>=</span> <span class='const'>File</span>.<span class='id identifier rubyid_basename'>basename</span>(<span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../URI.html" title="Bundler::URI (module)">URI</a></span>.<span class='id identifier rubyid_parse'><a href="../../URI.html#parse-class_method" title="Bundler::URI.parse (method)">parse</a></span>(<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>).<span class='id identifier rubyid_normalize'>normalize</span>.<span class='id identifier rubyid_path'>path</span>)

        <span class='id identifier rubyid_gem_install_dir'><a href="#gem_install_dir-instance_method" title="Bundler::Plugin::API::Source#gem_install_dir (method)">gem_install_dir</a></span>.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_base_name'>base_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span>[<span class='int'>0</span><span class='op'>..</span><span class='int'>11</span>]<span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>)
      <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='comment'># Parses the gemspec files to find the specs for the gems that can be
</span>  <span class='comment'># satisfied by the source.
</span>  <span class='comment'>#
</span>  <span class='comment'># Few important points to keep in mind:
</span>  <span class='comment'>#   - If the gems are not installed then it shall return specs for all
</span>  <span class='comment'>#   the gems it can satisfy
</span>  <span class='comment'>#   - If gem is installed (that is to be detected by the plugin itself)
</span>  <span class='comment'>#   then it shall return at least the specs that are installed.
</span>  <span class='comment'>#   - The `loaded_from` for each of the specs shall be correct (it is
</span>  <span class='comment'>#   used to find the load path)
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [Bundler::Index] index containing the specs
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>
    <span class='id identifier rubyid_files'>files</span> <span class='op'>=</span> <span class='id identifier rubyid_fetch_gemspec_files'><a href="#fetch_gemspec_files-instance_method" title="Bundler::Plugin::API::Source#fetch_gemspec_files (method)">fetch_gemspec_files</a></span>

    <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../Index.html" title="Bundler::Index (class)">Index</a></span>.<span class='id identifier rubyid_build'><a href="../../Index.html#build-class_method" title="Bundler::Index.build (method)">build</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_index'><a href="../../Plugin.html#index-class_method" title="Bundler::Plugin.index (method)">index</a></span><span class='op'>|</span>
      <span class='id identifier rubyid_files'>files</span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_file'>file</span><span class='op'>|</span>
        <span class='kw'>next</span> <span class='kw'>unless</span> <span class='id identifier rubyid_spec'>spec</span> <span class='op'>=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_load_gemspec'><a href="../../../Bundler.html#load_gemspec-class_method" title="Bundler.load_gemspec (method)">load_gemspec</a></span>(<span class='id identifier rubyid_file'>file</span>)
        <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_rubygems'><a href="../../../Bundler.html#rubygems-class_method" title="Bundler.rubygems (method)">rubygems</a></span>.<span class='id identifier rubyid_set_installed_by_version'>set_installed_by_version</span>(<span class='id identifier rubyid_spec'>spec</span>)

        <span class='id identifier rubyid_spec'>spec</span>.<span class='id identifier rubyid_source'><a href="../API.html#source-class_method" title="Bundler::Plugin::API.source (method)">source</a></span> <span class='op'>=</span> <span class='kw'>self</span>
        <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_rubygems'><a href="../../../Bundler.html#rubygems-class_method" title="Bundler.rubygems (method)">rubygems</a></span>.<span class='id identifier rubyid_validate'>validate</span>(<span class='id identifier rubyid_spec'>spec</span>)

        <span class='id identifier rubyid_index'><a href="../../Plugin.html#index-class_method" title="Bundler::Plugin.index (method)">index</a></span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_spec'>spec</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='comment'># Set internal representation to fetch the gems/specs locally.
</span>  <span class='comment'>#
</span>  <span class='comment'># When this is called, the source should try to fetch the specs and
</span>  <span class='comment'># install from the local system.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_local!'><a href="#local!-instance_method" title="Bundler::Plugin::API::Source#local! (method)">local!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Set internal representation to fetch the gems/specs from remote.
</span>  <span class='comment'>#
</span>  <span class='comment'># When this is called, the source should try to fetch the specs and
</span>  <span class='comment'># install from remote path.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_remote!'><a href="#remote!-instance_method" title="Bundler::Plugin::API::Source#remote! (method)">remote!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Set internal representation to fetch the gems/specs from app cache.
</span>  <span class='comment'>#
</span>  <span class='comment'># When this is called, the source should try to fetch the specs and
</span>  <span class='comment'># install from the path provided by `app_cache_path`.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_cached!'><a href="#cached!-instance_method" title="Bundler::Plugin::API::Source#cached! (method)">cached!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># This is called to update the spec and installation.
</span>  <span class='comment'>#
</span>  <span class='comment'># If the source plugin is loaded from lockfile or otherwise, it shall
</span>  <span class='comment'># refresh the cache/specs (e.g. git sources can make a fresh clone).
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_unlock!'><a href="#unlock!-instance_method" title="Bundler::Plugin::API::Source#unlock! (method)">unlock!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Name of directory where plugin the is expected to cache the gems when
</span>  <span class='comment'># #cache is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># Also this name is matched against the directories in cache for pruning
</span>  <span class='comment'>#
</span>  <span class='comment'># This is used by `app_cache_path`
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_app_cache_dirname'><a href="#app_cache_dirname-instance_method" title="Bundler::Plugin::API::Source#app_cache_dirname (method)">app_cache_dirname</a></span>
    <span class='id identifier rubyid_base_name'>base_name</span> <span class='op'>=</span> <span class='const'>File</span>.<span class='id identifier rubyid_basename'>basename</span>(<span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../URI.html" title="Bundler::URI (module)">URI</a></span>.<span class='id identifier rubyid_parse'><a href="../../URI.html#parse-class_method" title="Bundler::URI.parse (method)">parse</a></span>(<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>).<span class='id identifier rubyid_normalize'>normalize</span>.<span class='id identifier rubyid_path'>path</span>)
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_base_name'>base_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># This method is called while caching to save copy of the gems that the
</span>  <span class='comment'># source can resolve to path provided by `app_cache_app`so that they can
</span>  <span class='comment'># be reinstalled from the cache without querying the remote (i.e. an
</span>  <span class='comment'># alternative to remote)
</span>  <span class='comment'>#
</span>  <span class='comment'># This is stored with the app and source plugins should try to provide
</span>  <span class='comment'># specs and install only from this cache when `cached!` is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># This cache is different from the internal caching that can be done
</span>  <span class='comment'># at sub paths of `cache_path` (from API). This can be though as caching
</span>  <span class='comment'># by bundler.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_cache'><a href="#cache-instance_method" title="Bundler::Plugin::API::Source#cache (method)">cache</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_custom_path'>custom_path</span> <span class='op'>=</span> <span class='kw'>nil</span>)
    <span class='id identifier rubyid_new_cache_path'>new_cache_path</span> <span class='op'>=</span> <span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span>)

    <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_rm_rf'><a href="../../FileUtils.html#rm_rf-class_method" title="Bundler::FileUtils.rm_rf (method)">rm_rf</a></span>(<span class='id identifier rubyid_new_cache_path'>new_cache_path</span>)
    <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_cp_r'><a href="../../FileUtils.html#cp_r-class_method" title="Bundler::FileUtils.cp_r (method)">cp_r</a></span>(<span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span><span class='comma'>,</span> <span class='id identifier rubyid_new_cache_path'>new_cache_path</span>)
    <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_touch'><a href="../../FileUtils.html#touch-class_method" title="Bundler::FileUtils.touch (method)">touch</a></span>(<span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>.bundlecache</span><span class='tstring_end'>&quot;</span></span>))
  <span class='kw'>end</span>

  <span class='comment'># This shall check if two source object represent the same source.
</span>  <span class='comment'>#
</span>  <span class='comment'># The comparison shall take place only on the attribute that can be
</span>  <span class='comment'># inferred from the options passed from Gemfile and not on attributes
</span>  <span class='comment'># that are used to pin down the gem to specific version (e.g. Git
</span>  <span class='comment'># sources should compare on branch and tag but not on commit hash)
</span>  <span class='comment'>#
</span>  <span class='comment'># The sources objects are constructed from Gemfile as well as from
</span>  <span class='comment'># lockfile. To converge the sources, it is necessary that they match.
</span>  <span class='comment'>#
</span>  <span class='comment'># The same applies for `eql?` and `hash`
</span>  <span class='kw'>def</span> <span class='op'>==</span>(<span class='id identifier rubyid_other'>other</span>)
    <span class='id identifier rubyid_other'>other</span>.<span class='id identifier rubyid_is_a?'>is_a?</span>(<span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span>) <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span> <span class='op'>==</span> <span class='id identifier rubyid_other'>other</span>.<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>
  <span class='kw'>end</span>

  <span class='comment'># When overriding `eql?` please preserve the behaviour as mentioned in
</span>  <span class='comment'># docstring for `==` method.
</span>  <span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_eql?'><a href="#eql%3F-instance_method" title="Bundler::Plugin::API::Source#eql? (method)">eql?</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='op'>==</span>

  <span class='comment'># When overriding `hash` please preserve the behaviour as mentioned in
</span>  <span class='comment'># docstring for `==` method, i.e. two methods equal by above comparison
</span>  <span class='comment'># should have same hash.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_hash'><a href="#hash-instance_method" title="Bundler::Plugin::API::Source#hash (method)">hash</a></span>
    [<span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span><span class='comma'>,</span> <span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>].<span class='id identifier rubyid_hash'><a href="#hash-instance_method" title="Bundler::Plugin::API::Source#hash (method)">hash</a></span>
  <span class='kw'>end</span>

  <span class='comment'># A helper method, not necessary if not used internally.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_installed?'><a href="#installed%3F-instance_method" title="Bundler::Plugin::API::Source#installed? (method)">installed?</a></span>
    <span class='const'>File</span>.<span class='id identifier rubyid_directory?'>directory?</span>(<span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span>)
  <span class='kw'>end</span>

  <span class='comment'># The full path where the plugin should cache the gem so that it can be
</span>  <span class='comment'># installed latter.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span> <span class='op'>=</span> <span class='kw'>nil</span>)
    <span class='ivar'>@app_cache_path</span> <span class='op'>||=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_app_cache'><a href="../../../Bundler.html#app_cache-class_method" title="Bundler.app_cache (method)">app_cache</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span>).<span class='id identifier rubyid_join'>join</span>(<span class='id identifier rubyid_app_cache_dirname'><a href="#app_cache_dirname-instance_method" title="Bundler::Plugin::API::Source#app_cache_dirname (method)">app_cache_dirname</a></span>)
  <span class='kw'>end</span>

  <span class='comment'># Used by definition.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_unmet_deps'><a href="#unmet_deps-instance_method" title="Bundler::Plugin::API::Source#unmet_deps (method)">unmet_deps</a></span>
    <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>.<span class='id identifier rubyid_unmet_dependency_names'>unmet_dependency_names</span>
  <span class='kw'>end</span>

  <span class='comment'># Used by definition.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_spec_names'><a href="#spec_names-instance_method" title="Bundler::Plugin::API::Source#spec_names (method)">spec_names</a></span>
    <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>.<span class='id identifier rubyid_spec_names'><a href="#spec_names-instance_method" title="Bundler::Plugin::API::Source#spec_names (method)">spec_names</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Used by definition.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_add_dependency_names'><a href="#add_dependency_names-instance_method" title="Bundler::Plugin::API::Source#add_dependency_names (method)">add_dependency_names</a></span>(<span class='id identifier rubyid_names'>names</span>)
    <span class='ivar'>@dependencies</span> <span class='op'>|=</span> <span class='const'>Array</span>(<span class='id identifier rubyid_names'>names</span>)
  <span class='kw'>end</span>

  <span class='comment'># NOTE: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_can_lock?'><a href="#can_lock%3F-instance_method" title="Bundler::Plugin::API::Source#can_lock? (method)">can_lock?</a></span>(<span class='id identifier rubyid_spec'>spec</span>)
    <span class='id identifier rubyid_spec'>spec</span>.<span class='id identifier rubyid_source'><a href="../API.html#source-class_method" title="Bundler::Plugin::API.source (method)">source</a></span> <span class='op'>==</span> <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='comment'># Generates the content to be entered into the lockfile.
</span>  <span class='comment'># Saves type and remote and also calls to `options_to_lock`.
</span>  <span class='comment'>#
</span>  <span class='comment'># Plugin should use `options_to_lock` to save information in lockfile
</span>  <span class='comment'># and not override this.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_lock'><a href="#to_lock-instance_method" title="Bundler::Plugin::API::Source#to_lock (method)">to_lock</a></span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>=</span> <span class='const'>String</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='const'><a href="../../LockfileParser.html" title="Bundler::LockfileParser (class)">LockfileParser</a></span><span class='op'>::</span><span class='const'><a href="../../LockfileParser.html#PLUGIN-constant" title="Bundler::LockfileParser::PLUGIN (constant)">PLUGIN</a></span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>)
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  remote: </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  type: </span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_options_to_lock'><a href="#options_to_lock-instance_method" title="Bundler::Plugin::API::Source#options_to_lock (method)">options_to_lock</a></span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_opt'>opt</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='op'>|</span>
      <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_opt'>opt</span><span class='embexpr_end'>}</span><span class='tstring_content'>: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_value'>value</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  specs:\n</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_to_s'><a href="#to_s-instance_method" title="Bundler::Plugin::API::Source#to_s (method)">to_s</a></span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>plugin source for </span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'> with uri </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_identifier'><a href="#identifier-instance_method" title="Bundler::Plugin::API::Source#identifier (method)">identifier</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_to_s'><a href="#to_s-instance_method" title="Bundler::Plugin::API::Source#to_s (method)">to_s</a></span>

  <span class='comment'># NOTE: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_include?'><a href="#include%3F-instance_method" title="Bundler::Plugin::API::Source#include? (method)">include?</a></span>(<span class='id identifier rubyid_other'>other</span>)
    <span class='id identifier rubyid_other'>other</span> <span class='op'>==</span> <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span>
    <span class='const'><a href="../../SharedHelpers.html" title="Bundler::SharedHelpers (module)">SharedHelpers</a></span>.<span class='id identifier rubyid_digest'><a href="../../SharedHelpers.html#digest-instance_method" title="Bundler::SharedHelpers#digest (method)">digest</a></span>(<span class='symbeg'>:</span><span class='const'>SHA1</span>).<span class='id identifier rubyid_hexdigest'>hexdigest</span>(<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>)
  <span class='kw'>end</span>

  <span class='comment'># NOTE: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_gem_install_dir'><a href="#gem_install_dir-instance_method" title="Bundler::Plugin::API::Source#gem_install_dir (method)">gem_install_dir</a></span>
    <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_install_path'><a href="../../../Bundler.html#install_path-class_method" title="Bundler.install_path (method)">install_path</a></span>
  <span class='kw'>end</span>

  <span class='comment'># It is used to obtain the full_gem_path.
</span>  <span class='comment'>#
</span>  <span class='comment'># spec&#39;s loaded_from path is expanded against this to get full_gem_path
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_root'><a href="../../../top-level-namespace.html" title="Top Level Namespace (root)">root</a></span>
    <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_root'><a href="../../../Bundler.html#root-class_method" title="Bundler.root (method)">root</a></span>
  <span class='kw'>end</span>

  <span class='comment'># @private
</span>  <span class='comment'># This API on source might not be stable, and for now we expect plugins
</span>  <span class='comment'># to download all specs in `#specs`, so we implement the method for
</span>  <span class='comment'># compatibility purposes and leave it undocumented (and don&#39;t support)
</span>  <span class='comment'># overriding it)
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_double_check_for'><a href="#double_check_for-instance_method" title="Bundler::Plugin::API::Source#double_check_for (method)">double_check_for</a></span>(<span class='op'>*</span>)<span class='semicolon'>;</span> <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="options-instance_method">
  <h3 class='signature ro'>
    #<strong>options</strong>  &#x21d2; <code>String</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>String</code>)</span>
&mdash;    <div class='inline'>
<p>options passed during initialization (either from lockfile or Gemfile)</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L41-L317'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='41' data-end='317'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 41</span></pre>
<pre class='code ruby'>

<span class='kw'>module</span> <span class='const'>Source</span>
  <span class='id identifier rubyid_attr_reader'>attr_reader</span> <span class='symbeg'>:</span><span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_options'>options</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'><a href="#name-instance_method" title="Bundler::Plugin::API::Source#name (method)">name</a></span>
  <span class='id identifier rubyid_attr_accessor'>attr_accessor</span> <span class='symbeg'>:</span><span class='id identifier rubyid_dependency_names'><a href="#dependency_names-instance_method" title="Bundler::Plugin::API::Source#dependency_names (method)">dependency_names</a></span>

  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'><a href="#initialize-instance_method" title="Bundler::Plugin::API::Source#initialize (method)">initialize</a></span>(<span class='id identifier rubyid_opts'>opts</span>)
    <span class='ivar'>@options</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>
    <span class='ivar'>@dependency_names</span> <span class='op'>=</span> []
    <span class='ivar'>@uri</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>uri</span><span class='tstring_end'>&quot;</span></span>]
    <span class='ivar'>@type</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span>]
    <span class='ivar'>@name</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span>] <span class='op'>||</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'> at </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># This is used by the default `spec` method to constructs the
</span>  <span class='comment'># Specification objects for the gems and versions that can be installed
</span>  <span class='comment'># by this source plugin.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: If the spec method is overridden, this function is not necessary
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [Array&lt;String&gt;] paths of the gemspec files for gems that can
</span>  <span class='comment'>#                         be installed
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_fetch_gemspec_files'><a href="#fetch_gemspec_files-instance_method" title="Bundler::Plugin::API::Source#fetch_gemspec_files (method)">fetch_gemspec_files</a></span>
    []
  <span class='kw'>end</span>

  <span class='comment'># Options to be saved in the lockfile so that the source plugin is able
</span>  <span class='comment'># to check out same version of gem later.
</span>  <span class='comment'>#
</span>  <span class='comment'># There options are passed when the source plugin is created from the
</span>  <span class='comment'># lock file.
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [Hash]
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_options_to_lock'><a href="#options_to_lock-instance_method" title="Bundler::Plugin::API::Source#options_to_lock (method)">options_to_lock</a></span>
    {}
  <span class='kw'>end</span>

  <span class='comment'># Install the gem specified by the spec at appropriate path.
</span>  <span class='comment'># `install_path` provides a sufficient default, if the source can only
</span>  <span class='comment'># satisfy one gem,  but is not binding.
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [String] post installation message (if any)
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_install'><a href="#install-instance_method" title="Bundler::Plugin::API::Source#install (method)">install</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>)
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../MalformattedPlugin.html" title="Bundler::Plugin::MalformattedPlugin (class)">MalformattedPlugin</a></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Source plugins need to override the install method.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># It builds extensions, generates bins and installs them for the spec
</span>  <span class='comment'># provided.
</span>  <span class='comment'>#
</span>  <span class='comment'># It depends on `spec.loaded_from` to get full_gem_path. The source
</span>  <span class='comment'># plugins should set that.
</span>  <span class='comment'>#
</span>  <span class='comment'># It should be called in `install` after the plugin is done placing the
</span>  <span class='comment'># gem at correct install location.
</span>  <span class='comment'>#
</span>  <span class='comment'># It also runs Gem hooks `pre_install`, `post_build` and `post_install`
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_post_install'><a href="#post_install-instance_method" title="Bundler::Plugin::API::Source#post_install (method)">post_install</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_disable_exts'>disable_exts</span> <span class='op'>=</span> <span class='kw'>false</span>)
    <span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> { <span class='symbeg'>:</span><span class='id identifier rubyid_env_shebang'>env_shebang</span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_disable_extensions'>disable_extensions</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_disable_exts'>disable_exts</span> }
    <span class='id identifier rubyid_installer'>installer</span> <span class='op'>=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../Source.html" title="Bundler::Source (class)">Source</a></span><span class='op'>::</span><span class='const'><a href="../../Source/Path.html" title="Bundler::Source::Path (class)">Path</a></span><span class='op'>::</span><span class='const'><a href="../../Source/Path/Installer.html" title="Bundler::Source::Path::Installer (class)">Installer</a></span>.<span class='id identifier rubyid_new'><a href="../../Source/Path/Installer.html#new-class_method" title="Bundler::Source::Path::Installer.new (method)">new</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>)
    <span class='id identifier rubyid_installer'>installer</span>.<span class='id identifier rubyid_post_install'><a href="#post_install-instance_method" title="Bundler::Plugin::API::Source#post_install (method)">post_install</a></span>
  <span class='kw'>end</span>

  <span class='comment'># A default installation path to install a single gem. If the source
</span>  <span class='comment'># servers multiple gems, it&#39;s not of much use and the source should one
</span>  <span class='comment'># of its own.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span>
    <span class='ivar'>@install_path</span> <span class='op'>||=</span>
      <span class='kw'>begin</span>
        <span class='id identifier rubyid_base_name'>base_name</span> <span class='op'>=</span> <span class='const'>File</span>.<span class='id identifier rubyid_basename'>basename</span>(<span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../URI.html" title="Bundler::URI (module)">URI</a></span>.<span class='id identifier rubyid_parse'><a href="../../URI.html#parse-class_method" title="Bundler::URI.parse (method)">parse</a></span>(<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>).<span class='id identifier rubyid_normalize'>normalize</span>.<span class='id identifier rubyid_path'>path</span>)

        <span class='id identifier rubyid_gem_install_dir'><a href="#gem_install_dir-instance_method" title="Bundler::Plugin::API::Source#gem_install_dir (method)">gem_install_dir</a></span>.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_base_name'>base_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span>[<span class='int'>0</span><span class='op'>..</span><span class='int'>11</span>]<span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>)
      <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='comment'># Parses the gemspec files to find the specs for the gems that can be
</span>  <span class='comment'># satisfied by the source.
</span>  <span class='comment'>#
</span>  <span class='comment'># Few important points to keep in mind:
</span>  <span class='comment'>#   - If the gems are not installed then it shall return specs for all
</span>  <span class='comment'>#   the gems it can satisfy
</span>  <span class='comment'>#   - If gem is installed (that is to be detected by the plugin itself)
</span>  <span class='comment'>#   then it shall return at least the specs that are installed.
</span>  <span class='comment'>#   - The `loaded_from` for each of the specs shall be correct (it is
</span>  <span class='comment'>#   used to find the load path)
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [Bundler::Index] index containing the specs
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>
    <span class='id identifier rubyid_files'>files</span> <span class='op'>=</span> <span class='id identifier rubyid_fetch_gemspec_files'><a href="#fetch_gemspec_files-instance_method" title="Bundler::Plugin::API::Source#fetch_gemspec_files (method)">fetch_gemspec_files</a></span>

    <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../Index.html" title="Bundler::Index (class)">Index</a></span>.<span class='id identifier rubyid_build'><a href="../../Index.html#build-class_method" title="Bundler::Index.build (method)">build</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_index'><a href="../../Plugin.html#index-class_method" title="Bundler::Plugin.index (method)">index</a></span><span class='op'>|</span>
      <span class='id identifier rubyid_files'>files</span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_file'>file</span><span class='op'>|</span>
        <span class='kw'>next</span> <span class='kw'>unless</span> <span class='id identifier rubyid_spec'>spec</span> <span class='op'>=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_load_gemspec'><a href="../../../Bundler.html#load_gemspec-class_method" title="Bundler.load_gemspec (method)">load_gemspec</a></span>(<span class='id identifier rubyid_file'>file</span>)
        <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_rubygems'><a href="../../../Bundler.html#rubygems-class_method" title="Bundler.rubygems (method)">rubygems</a></span>.<span class='id identifier rubyid_set_installed_by_version'>set_installed_by_version</span>(<span class='id identifier rubyid_spec'>spec</span>)

        <span class='id identifier rubyid_spec'>spec</span>.<span class='id identifier rubyid_source'><a href="../API.html#source-class_method" title="Bundler::Plugin::API.source (method)">source</a></span> <span class='op'>=</span> <span class='kw'>self</span>
        <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_rubygems'><a href="../../../Bundler.html#rubygems-class_method" title="Bundler.rubygems (method)">rubygems</a></span>.<span class='id identifier rubyid_validate'>validate</span>(<span class='id identifier rubyid_spec'>spec</span>)

        <span class='id identifier rubyid_index'><a href="../../Plugin.html#index-class_method" title="Bundler::Plugin.index (method)">index</a></span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_spec'>spec</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='comment'># Set internal representation to fetch the gems/specs locally.
</span>  <span class='comment'>#
</span>  <span class='comment'># When this is called, the source should try to fetch the specs and
</span>  <span class='comment'># install from the local system.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_local!'><a href="#local!-instance_method" title="Bundler::Plugin::API::Source#local! (method)">local!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Set internal representation to fetch the gems/specs from remote.
</span>  <span class='comment'>#
</span>  <span class='comment'># When this is called, the source should try to fetch the specs and
</span>  <span class='comment'># install from remote path.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_remote!'><a href="#remote!-instance_method" title="Bundler::Plugin::API::Source#remote! (method)">remote!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Set internal representation to fetch the gems/specs from app cache.
</span>  <span class='comment'>#
</span>  <span class='comment'># When this is called, the source should try to fetch the specs and
</span>  <span class='comment'># install from the path provided by `app_cache_path`.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_cached!'><a href="#cached!-instance_method" title="Bundler::Plugin::API::Source#cached! (method)">cached!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># This is called to update the spec and installation.
</span>  <span class='comment'>#
</span>  <span class='comment'># If the source plugin is loaded from lockfile or otherwise, it shall
</span>  <span class='comment'># refresh the cache/specs (e.g. git sources can make a fresh clone).
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_unlock!'><a href="#unlock!-instance_method" title="Bundler::Plugin::API::Source#unlock! (method)">unlock!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Name of directory where plugin the is expected to cache the gems when
</span>  <span class='comment'># #cache is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># Also this name is matched against the directories in cache for pruning
</span>  <span class='comment'>#
</span>  <span class='comment'># This is used by `app_cache_path`
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_app_cache_dirname'><a href="#app_cache_dirname-instance_method" title="Bundler::Plugin::API::Source#app_cache_dirname (method)">app_cache_dirname</a></span>
    <span class='id identifier rubyid_base_name'>base_name</span> <span class='op'>=</span> <span class='const'>File</span>.<span class='id identifier rubyid_basename'>basename</span>(<span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../URI.html" title="Bundler::URI (module)">URI</a></span>.<span class='id identifier rubyid_parse'><a href="../../URI.html#parse-class_method" title="Bundler::URI.parse (method)">parse</a></span>(<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>).<span class='id identifier rubyid_normalize'>normalize</span>.<span class='id identifier rubyid_path'>path</span>)
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_base_name'>base_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># This method is called while caching to save copy of the gems that the
</span>  <span class='comment'># source can resolve to path provided by `app_cache_app`so that they can
</span>  <span class='comment'># be reinstalled from the cache without querying the remote (i.e. an
</span>  <span class='comment'># alternative to remote)
</span>  <span class='comment'>#
</span>  <span class='comment'># This is stored with the app and source plugins should try to provide
</span>  <span class='comment'># specs and install only from this cache when `cached!` is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># This cache is different from the internal caching that can be done
</span>  <span class='comment'># at sub paths of `cache_path` (from API). This can be though as caching
</span>  <span class='comment'># by bundler.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_cache'><a href="#cache-instance_method" title="Bundler::Plugin::API::Source#cache (method)">cache</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_custom_path'>custom_path</span> <span class='op'>=</span> <span class='kw'>nil</span>)
    <span class='id identifier rubyid_new_cache_path'>new_cache_path</span> <span class='op'>=</span> <span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span>)

    <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_rm_rf'><a href="../../FileUtils.html#rm_rf-class_method" title="Bundler::FileUtils.rm_rf (method)">rm_rf</a></span>(<span class='id identifier rubyid_new_cache_path'>new_cache_path</span>)
    <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_cp_r'><a href="../../FileUtils.html#cp_r-class_method" title="Bundler::FileUtils.cp_r (method)">cp_r</a></span>(<span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span><span class='comma'>,</span> <span class='id identifier rubyid_new_cache_path'>new_cache_path</span>)
    <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_touch'><a href="../../FileUtils.html#touch-class_method" title="Bundler::FileUtils.touch (method)">touch</a></span>(<span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>.bundlecache</span><span class='tstring_end'>&quot;</span></span>))
  <span class='kw'>end</span>

  <span class='comment'># This shall check if two source object represent the same source.
</span>  <span class='comment'>#
</span>  <span class='comment'># The comparison shall take place only on the attribute that can be
</span>  <span class='comment'># inferred from the options passed from Gemfile and not on attributes
</span>  <span class='comment'># that are used to pin down the gem to specific version (e.g. Git
</span>  <span class='comment'># sources should compare on branch and tag but not on commit hash)
</span>  <span class='comment'>#
</span>  <span class='comment'># The sources objects are constructed from Gemfile as well as from
</span>  <span class='comment'># lockfile. To converge the sources, it is necessary that they match.
</span>  <span class='comment'>#
</span>  <span class='comment'># The same applies for `eql?` and `hash`
</span>  <span class='kw'>def</span> <span class='op'>==</span>(<span class='id identifier rubyid_other'>other</span>)
    <span class='id identifier rubyid_other'>other</span>.<span class='id identifier rubyid_is_a?'>is_a?</span>(<span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span>) <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span> <span class='op'>==</span> <span class='id identifier rubyid_other'>other</span>.<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>
  <span class='kw'>end</span>

  <span class='comment'># When overriding `eql?` please preserve the behaviour as mentioned in
</span>  <span class='comment'># docstring for `==` method.
</span>  <span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_eql?'><a href="#eql%3F-instance_method" title="Bundler::Plugin::API::Source#eql? (method)">eql?</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='op'>==</span>

  <span class='comment'># When overriding `hash` please preserve the behaviour as mentioned in
</span>  <span class='comment'># docstring for `==` method, i.e. two methods equal by above comparison
</span>  <span class='comment'># should have same hash.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_hash'><a href="#hash-instance_method" title="Bundler::Plugin::API::Source#hash (method)">hash</a></span>
    [<span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span><span class='comma'>,</span> <span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>].<span class='id identifier rubyid_hash'><a href="#hash-instance_method" title="Bundler::Plugin::API::Source#hash (method)">hash</a></span>
  <span class='kw'>end</span>

  <span class='comment'># A helper method, not necessary if not used internally.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_installed?'><a href="#installed%3F-instance_method" title="Bundler::Plugin::API::Source#installed? (method)">installed?</a></span>
    <span class='const'>File</span>.<span class='id identifier rubyid_directory?'>directory?</span>(<span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span>)
  <span class='kw'>end</span>

  <span class='comment'># The full path where the plugin should cache the gem so that it can be
</span>  <span class='comment'># installed latter.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span> <span class='op'>=</span> <span class='kw'>nil</span>)
    <span class='ivar'>@app_cache_path</span> <span class='op'>||=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_app_cache'><a href="../../../Bundler.html#app_cache-class_method" title="Bundler.app_cache (method)">app_cache</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span>).<span class='id identifier rubyid_join'>join</span>(<span class='id identifier rubyid_app_cache_dirname'><a href="#app_cache_dirname-instance_method" title="Bundler::Plugin::API::Source#app_cache_dirname (method)">app_cache_dirname</a></span>)
  <span class='kw'>end</span>

  <span class='comment'># Used by definition.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_unmet_deps'><a href="#unmet_deps-instance_method" title="Bundler::Plugin::API::Source#unmet_deps (method)">unmet_deps</a></span>
    <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>.<span class='id identifier rubyid_unmet_dependency_names'>unmet_dependency_names</span>
  <span class='kw'>end</span>

  <span class='comment'># Used by definition.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_spec_names'><a href="#spec_names-instance_method" title="Bundler::Plugin::API::Source#spec_names (method)">spec_names</a></span>
    <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>.<span class='id identifier rubyid_spec_names'><a href="#spec_names-instance_method" title="Bundler::Plugin::API::Source#spec_names (method)">spec_names</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Used by definition.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_add_dependency_names'><a href="#add_dependency_names-instance_method" title="Bundler::Plugin::API::Source#add_dependency_names (method)">add_dependency_names</a></span>(<span class='id identifier rubyid_names'>names</span>)
    <span class='ivar'>@dependencies</span> <span class='op'>|=</span> <span class='const'>Array</span>(<span class='id identifier rubyid_names'>names</span>)
  <span class='kw'>end</span>

  <span class='comment'># NOTE: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_can_lock?'><a href="#can_lock%3F-instance_method" title="Bundler::Plugin::API::Source#can_lock? (method)">can_lock?</a></span>(<span class='id identifier rubyid_spec'>spec</span>)
    <span class='id identifier rubyid_spec'>spec</span>.<span class='id identifier rubyid_source'><a href="../API.html#source-class_method" title="Bundler::Plugin::API.source (method)">source</a></span> <span class='op'>==</span> <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='comment'># Generates the content to be entered into the lockfile.
</span>  <span class='comment'># Saves type and remote and also calls to `options_to_lock`.
</span>  <span class='comment'>#
</span>  <span class='comment'># Plugin should use `options_to_lock` to save information in lockfile
</span>  <span class='comment'># and not override this.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_lock'><a href="#to_lock-instance_method" title="Bundler::Plugin::API::Source#to_lock (method)">to_lock</a></span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>=</span> <span class='const'>String</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='const'><a href="../../LockfileParser.html" title="Bundler::LockfileParser (class)">LockfileParser</a></span><span class='op'>::</span><span class='const'><a href="../../LockfileParser.html#PLUGIN-constant" title="Bundler::LockfileParser::PLUGIN (constant)">PLUGIN</a></span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>)
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  remote: </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  type: </span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_options_to_lock'><a href="#options_to_lock-instance_method" title="Bundler::Plugin::API::Source#options_to_lock (method)">options_to_lock</a></span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_opt'>opt</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='op'>|</span>
      <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_opt'>opt</span><span class='embexpr_end'>}</span><span class='tstring_content'>: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_value'>value</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  specs:\n</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_to_s'><a href="#to_s-instance_method" title="Bundler::Plugin::API::Source#to_s (method)">to_s</a></span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>plugin source for </span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'> with uri </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_identifier'><a href="#identifier-instance_method" title="Bundler::Plugin::API::Source#identifier (method)">identifier</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_to_s'><a href="#to_s-instance_method" title="Bundler::Plugin::API::Source#to_s (method)">to_s</a></span>

  <span class='comment'># NOTE: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_include?'><a href="#include%3F-instance_method" title="Bundler::Plugin::API::Source#include? (method)">include?</a></span>(<span class='id identifier rubyid_other'>other</span>)
    <span class='id identifier rubyid_other'>other</span> <span class='op'>==</span> <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span>
    <span class='const'><a href="../../SharedHelpers.html" title="Bundler::SharedHelpers (module)">SharedHelpers</a></span>.<span class='id identifier rubyid_digest'><a href="../../SharedHelpers.html#digest-instance_method" title="Bundler::SharedHelpers#digest (method)">digest</a></span>(<span class='symbeg'>:</span><span class='const'>SHA1</span>).<span class='id identifier rubyid_hexdigest'>hexdigest</span>(<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>)
  <span class='kw'>end</span>

  <span class='comment'># NOTE: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_gem_install_dir'><a href="#gem_install_dir-instance_method" title="Bundler::Plugin::API::Source#gem_install_dir (method)">gem_install_dir</a></span>
    <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_install_path'><a href="../../../Bundler.html#install_path-class_method" title="Bundler.install_path (method)">install_path</a></span>
  <span class='kw'>end</span>

  <span class='comment'># It is used to obtain the full_gem_path.
</span>  <span class='comment'>#
</span>  <span class='comment'># spec&#39;s loaded_from path is expanded against this to get full_gem_path
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_root'><a href="../../../top-level-namespace.html" title="Top Level Namespace (root)">root</a></span>
    <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_root'><a href="../../../Bundler.html#root-class_method" title="Bundler.root (method)">root</a></span>
  <span class='kw'>end</span>

  <span class='comment'># @private
</span>  <span class='comment'># This API on source might not be stable, and for now we expect plugins
</span>  <span class='comment'># to download all specs in `#specs`, so we implement the method for
</span>  <span class='comment'># compatibility purposes and leave it undocumented (and don&#39;t support)
</span>  <span class='comment'># overriding it)
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_double_check_for'><a href="#double_check_for-instance_method" title="Bundler::Plugin::API::Source#double_check_for (method)">double_check_for</a></span>(<span class='op'>*</span>)<span class='semicolon'>;</span> <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="uri-instance_method">
  <h3 class='signature ro'>
    #<strong>uri</strong>  &#x21d2; <code>String</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>String</code>)</span>
&mdash;    <div class='inline'>
<p>the remote specified with <a href="../API.html#source-class_method" title="Bundler::Plugin::API.source (method)">Bundler::Plugin::API.source</a> block in Gemfile</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L41-L317'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='41' data-end='317'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 41</span></pre>
<pre class='code ruby'>

<span class='kw'>module</span> <span class='const'>Source</span>
  <span class='id identifier rubyid_attr_reader'>attr_reader</span> <span class='symbeg'>:</span><span class='id identifier rubyid_uri'>uri</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_options'><a href="#options-instance_method" title="Bundler::Plugin::API::Source#options (method)">options</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_name'><a href="#name-instance_method" title="Bundler::Plugin::API::Source#name (method)">name</a></span>
  <span class='id identifier rubyid_attr_accessor'>attr_accessor</span> <span class='symbeg'>:</span><span class='id identifier rubyid_dependency_names'><a href="#dependency_names-instance_method" title="Bundler::Plugin::API::Source#dependency_names (method)">dependency_names</a></span>

  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'><a href="#initialize-instance_method" title="Bundler::Plugin::API::Source#initialize (method)">initialize</a></span>(<span class='id identifier rubyid_opts'>opts</span>)
    <span class='ivar'>@options</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>
    <span class='ivar'>@dependency_names</span> <span class='op'>=</span> []
    <span class='ivar'>@uri</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>uri</span><span class='tstring_end'>&quot;</span></span>]
    <span class='ivar'>@type</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span>]
    <span class='ivar'>@name</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span>] <span class='op'>||</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'> at </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># This is used by the default `spec` method to constructs the
</span>  <span class='comment'># Specification objects for the gems and versions that can be installed
</span>  <span class='comment'># by this source plugin.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: If the spec method is overridden, this function is not necessary
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [Array&lt;String&gt;] paths of the gemspec files for gems that can
</span>  <span class='comment'>#                         be installed
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_fetch_gemspec_files'><a href="#fetch_gemspec_files-instance_method" title="Bundler::Plugin::API::Source#fetch_gemspec_files (method)">fetch_gemspec_files</a></span>
    []
  <span class='kw'>end</span>

  <span class='comment'># Options to be saved in the lockfile so that the source plugin is able
</span>  <span class='comment'># to check out same version of gem later.
</span>  <span class='comment'>#
</span>  <span class='comment'># There options are passed when the source plugin is created from the
</span>  <span class='comment'># lock file.
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [Hash]
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_options_to_lock'><a href="#options_to_lock-instance_method" title="Bundler::Plugin::API::Source#options_to_lock (method)">options_to_lock</a></span>
    {}
  <span class='kw'>end</span>

  <span class='comment'># Install the gem specified by the spec at appropriate path.
</span>  <span class='comment'># `install_path` provides a sufficient default, if the source can only
</span>  <span class='comment'># satisfy one gem,  but is not binding.
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [String] post installation message (if any)
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_install'><a href="#install-instance_method" title="Bundler::Plugin::API::Source#install (method)">install</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>)
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../MalformattedPlugin.html" title="Bundler::Plugin::MalformattedPlugin (class)">MalformattedPlugin</a></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Source plugins need to override the install method.</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># It builds extensions, generates bins and installs them for the spec
</span>  <span class='comment'># provided.
</span>  <span class='comment'>#
</span>  <span class='comment'># It depends on `spec.loaded_from` to get full_gem_path. The source
</span>  <span class='comment'># plugins should set that.
</span>  <span class='comment'>#
</span>  <span class='comment'># It should be called in `install` after the plugin is done placing the
</span>  <span class='comment'># gem at correct install location.
</span>  <span class='comment'>#
</span>  <span class='comment'># It also runs Gem hooks `pre_install`, `post_build` and `post_install`
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_post_install'><a href="#post_install-instance_method" title="Bundler::Plugin::API::Source#post_install (method)">post_install</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_disable_exts'>disable_exts</span> <span class='op'>=</span> <span class='kw'>false</span>)
    <span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> { <span class='symbeg'>:</span><span class='id identifier rubyid_env_shebang'>env_shebang</span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_disable_extensions'>disable_extensions</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_disable_exts'>disable_exts</span> }
    <span class='id identifier rubyid_installer'>installer</span> <span class='op'>=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../Source.html" title="Bundler::Source (class)">Source</a></span><span class='op'>::</span><span class='const'><a href="../../Source/Path.html" title="Bundler::Source::Path (class)">Path</a></span><span class='op'>::</span><span class='const'><a href="../../Source/Path/Installer.html" title="Bundler::Source::Path::Installer (class)">Installer</a></span>.<span class='id identifier rubyid_new'><a href="../../Source/Path/Installer.html#new-class_method" title="Bundler::Source::Path::Installer.new (method)">new</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>)
    <span class='id identifier rubyid_installer'>installer</span>.<span class='id identifier rubyid_post_install'><a href="#post_install-instance_method" title="Bundler::Plugin::API::Source#post_install (method)">post_install</a></span>
  <span class='kw'>end</span>

  <span class='comment'># A default installation path to install a single gem. If the source
</span>  <span class='comment'># servers multiple gems, it&#39;s not of much use and the source should one
</span>  <span class='comment'># of its own.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span>
    <span class='ivar'>@install_path</span> <span class='op'>||=</span>
      <span class='kw'>begin</span>
        <span class='id identifier rubyid_base_name'>base_name</span> <span class='op'>=</span> <span class='const'>File</span>.<span class='id identifier rubyid_basename'>basename</span>(<span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../URI.html" title="Bundler::URI (module)">URI</a></span>.<span class='id identifier rubyid_parse'><a href="../../URI.html#parse-class_method" title="Bundler::URI.parse (method)">parse</a></span>(<span class='id identifier rubyid_uri'>uri</span>).<span class='id identifier rubyid_normalize'>normalize</span>.<span class='id identifier rubyid_path'>path</span>)

        <span class='id identifier rubyid_gem_install_dir'><a href="#gem_install_dir-instance_method" title="Bundler::Plugin::API::Source#gem_install_dir (method)">gem_install_dir</a></span>.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_base_name'>base_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span>[<span class='int'>0</span><span class='op'>..</span><span class='int'>11</span>]<span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>)
      <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='comment'># Parses the gemspec files to find the specs for the gems that can be
</span>  <span class='comment'># satisfied by the source.
</span>  <span class='comment'>#
</span>  <span class='comment'># Few important points to keep in mind:
</span>  <span class='comment'>#   - If the gems are not installed then it shall return specs for all
</span>  <span class='comment'>#   the gems it can satisfy
</span>  <span class='comment'>#   - If gem is installed (that is to be detected by the plugin itself)
</span>  <span class='comment'>#   then it shall return at least the specs that are installed.
</span>  <span class='comment'>#   - The `loaded_from` for each of the specs shall be correct (it is
</span>  <span class='comment'>#   used to find the load path)
</span>  <span class='comment'>#
</span>  <span class='comment'># @return [Bundler::Index] index containing the specs
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>
    <span class='id identifier rubyid_files'>files</span> <span class='op'>=</span> <span class='id identifier rubyid_fetch_gemspec_files'><a href="#fetch_gemspec_files-instance_method" title="Bundler::Plugin::API::Source#fetch_gemspec_files (method)">fetch_gemspec_files</a></span>

    <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../Index.html" title="Bundler::Index (class)">Index</a></span>.<span class='id identifier rubyid_build'><a href="../../Index.html#build-class_method" title="Bundler::Index.build (method)">build</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_index'><a href="../../Plugin.html#index-class_method" title="Bundler::Plugin.index (method)">index</a></span><span class='op'>|</span>
      <span class='id identifier rubyid_files'>files</span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_file'>file</span><span class='op'>|</span>
        <span class='kw'>next</span> <span class='kw'>unless</span> <span class='id identifier rubyid_spec'>spec</span> <span class='op'>=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_load_gemspec'><a href="../../../Bundler.html#load_gemspec-class_method" title="Bundler.load_gemspec (method)">load_gemspec</a></span>(<span class='id identifier rubyid_file'>file</span>)
        <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_rubygems'><a href="../../../Bundler.html#rubygems-class_method" title="Bundler.rubygems (method)">rubygems</a></span>.<span class='id identifier rubyid_set_installed_by_version'>set_installed_by_version</span>(<span class='id identifier rubyid_spec'>spec</span>)

        <span class='id identifier rubyid_spec'>spec</span>.<span class='id identifier rubyid_source'><a href="../API.html#source-class_method" title="Bundler::Plugin::API.source (method)">source</a></span> <span class='op'>=</span> <span class='kw'>self</span>
        <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_rubygems'><a href="../../../Bundler.html#rubygems-class_method" title="Bundler.rubygems (method)">rubygems</a></span>.<span class='id identifier rubyid_validate'>validate</span>(<span class='id identifier rubyid_spec'>spec</span>)

        <span class='id identifier rubyid_index'><a href="../../Plugin.html#index-class_method" title="Bundler::Plugin.index (method)">index</a></span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_spec'>spec</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='comment'># Set internal representation to fetch the gems/specs locally.
</span>  <span class='comment'>#
</span>  <span class='comment'># When this is called, the source should try to fetch the specs and
</span>  <span class='comment'># install from the local system.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_local!'><a href="#local!-instance_method" title="Bundler::Plugin::API::Source#local! (method)">local!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Set internal representation to fetch the gems/specs from remote.
</span>  <span class='comment'>#
</span>  <span class='comment'># When this is called, the source should try to fetch the specs and
</span>  <span class='comment'># install from remote path.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_remote!'><a href="#remote!-instance_method" title="Bundler::Plugin::API::Source#remote! (method)">remote!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Set internal representation to fetch the gems/specs from app cache.
</span>  <span class='comment'>#
</span>  <span class='comment'># When this is called, the source should try to fetch the specs and
</span>  <span class='comment'># install from the path provided by `app_cache_path`.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_cached!'><a href="#cached!-instance_method" title="Bundler::Plugin::API::Source#cached! (method)">cached!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># This is called to update the spec and installation.
</span>  <span class='comment'>#
</span>  <span class='comment'># If the source plugin is loaded from lockfile or otherwise, it shall
</span>  <span class='comment'># refresh the cache/specs (e.g. git sources can make a fresh clone).
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_unlock!'><a href="#unlock!-instance_method" title="Bundler::Plugin::API::Source#unlock! (method)">unlock!</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Name of directory where plugin the is expected to cache the gems when
</span>  <span class='comment'># #cache is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># Also this name is matched against the directories in cache for pruning
</span>  <span class='comment'>#
</span>  <span class='comment'># This is used by `app_cache_path`
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_app_cache_dirname'><a href="#app_cache_dirname-instance_method" title="Bundler::Plugin::API::Source#app_cache_dirname (method)">app_cache_dirname</a></span>
    <span class='id identifier rubyid_base_name'>base_name</span> <span class='op'>=</span> <span class='const'>File</span>.<span class='id identifier rubyid_basename'>basename</span>(<span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../URI.html" title="Bundler::URI (module)">URI</a></span>.<span class='id identifier rubyid_parse'><a href="../../URI.html#parse-class_method" title="Bundler::URI.parse (method)">parse</a></span>(<span class='id identifier rubyid_uri'>uri</span>).<span class='id identifier rubyid_normalize'>normalize</span>.<span class='id identifier rubyid_path'>path</span>)
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_base_name'>base_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='comment'># This method is called while caching to save copy of the gems that the
</span>  <span class='comment'># source can resolve to path provided by `app_cache_app`so that they can
</span>  <span class='comment'># be reinstalled from the cache without querying the remote (i.e. an
</span>  <span class='comment'># alternative to remote)
</span>  <span class='comment'>#
</span>  <span class='comment'># This is stored with the app and source plugins should try to provide
</span>  <span class='comment'># specs and install only from this cache when `cached!` is called.
</span>  <span class='comment'>#
</span>  <span class='comment'># This cache is different from the internal caching that can be done
</span>  <span class='comment'># at sub paths of `cache_path` (from API). This can be though as caching
</span>  <span class='comment'># by bundler.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_cache'><a href="#cache-instance_method" title="Bundler::Plugin::API::Source#cache (method)">cache</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_custom_path'>custom_path</span> <span class='op'>=</span> <span class='kw'>nil</span>)
    <span class='id identifier rubyid_new_cache_path'>new_cache_path</span> <span class='op'>=</span> <span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span>)

    <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_rm_rf'><a href="../../FileUtils.html#rm_rf-class_method" title="Bundler::FileUtils.rm_rf (method)">rm_rf</a></span>(<span class='id identifier rubyid_new_cache_path'>new_cache_path</span>)
    <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_cp_r'><a href="../../FileUtils.html#cp_r-class_method" title="Bundler::FileUtils.cp_r (method)">cp_r</a></span>(<span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span><span class='comma'>,</span> <span class='id identifier rubyid_new_cache_path'>new_cache_path</span>)
    <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_touch'><a href="../../FileUtils.html#touch-class_method" title="Bundler::FileUtils.touch (method)">touch</a></span>(<span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>.bundlecache</span><span class='tstring_end'>&quot;</span></span>))
  <span class='kw'>end</span>

  <span class='comment'># This shall check if two source object represent the same source.
</span>  <span class='comment'>#
</span>  <span class='comment'># The comparison shall take place only on the attribute that can be
</span>  <span class='comment'># inferred from the options passed from Gemfile and not on attributes
</span>  <span class='comment'># that are used to pin down the gem to specific version (e.g. Git
</span>  <span class='comment'># sources should compare on branch and tag but not on commit hash)
</span>  <span class='comment'>#
</span>  <span class='comment'># The sources objects are constructed from Gemfile as well as from
</span>  <span class='comment'># lockfile. To converge the sources, it is necessary that they match.
</span>  <span class='comment'>#
</span>  <span class='comment'># The same applies for `eql?` and `hash`
</span>  <span class='kw'>def</span> <span class='op'>==</span>(<span class='id identifier rubyid_other'>other</span>)
    <span class='id identifier rubyid_other'>other</span>.<span class='id identifier rubyid_is_a?'>is_a?</span>(<span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span>) <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_uri'>uri</span> <span class='op'>==</span> <span class='id identifier rubyid_other'>other</span>.<span class='id identifier rubyid_uri'>uri</span>
  <span class='kw'>end</span>

  <span class='comment'># When overriding `eql?` please preserve the behaviour as mentioned in
</span>  <span class='comment'># docstring for `==` method.
</span>  <span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_eql?'><a href="#eql%3F-instance_method" title="Bundler::Plugin::API::Source#eql? (method)">eql?</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='op'>==</span>

  <span class='comment'># When overriding `hash` please preserve the behaviour as mentioned in
</span>  <span class='comment'># docstring for `==` method, i.e. two methods equal by above comparison
</span>  <span class='comment'># should have same hash.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_hash'><a href="#hash-instance_method" title="Bundler::Plugin::API::Source#hash (method)">hash</a></span>
    [<span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span><span class='comma'>,</span> <span class='id identifier rubyid_uri'>uri</span>].<span class='id identifier rubyid_hash'><a href="#hash-instance_method" title="Bundler::Plugin::API::Source#hash (method)">hash</a></span>
  <span class='kw'>end</span>

  <span class='comment'># A helper method, not necessary if not used internally.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_installed?'><a href="#installed%3F-instance_method" title="Bundler::Plugin::API::Source#installed? (method)">installed?</a></span>
    <span class='const'>File</span>.<span class='id identifier rubyid_directory?'>directory?</span>(<span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span>)
  <span class='kw'>end</span>

  <span class='comment'># The full path where the plugin should cache the gem so that it can be
</span>  <span class='comment'># installed latter.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span> <span class='op'>=</span> <span class='kw'>nil</span>)
    <span class='ivar'>@app_cache_path</span> <span class='op'>||=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_app_cache'><a href="../../../Bundler.html#app_cache-class_method" title="Bundler.app_cache (method)">app_cache</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span>).<span class='id identifier rubyid_join'>join</span>(<span class='id identifier rubyid_app_cache_dirname'><a href="#app_cache_dirname-instance_method" title="Bundler::Plugin::API::Source#app_cache_dirname (method)">app_cache_dirname</a></span>)
  <span class='kw'>end</span>

  <span class='comment'># Used by definition.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_unmet_deps'><a href="#unmet_deps-instance_method" title="Bundler::Plugin::API::Source#unmet_deps (method)">unmet_deps</a></span>
    <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>.<span class='id identifier rubyid_unmet_dependency_names'>unmet_dependency_names</span>
  <span class='kw'>end</span>

  <span class='comment'># Used by definition.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_spec_names'><a href="#spec_names-instance_method" title="Bundler::Plugin::API::Source#spec_names (method)">spec_names</a></span>
    <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>.<span class='id identifier rubyid_spec_names'><a href="#spec_names-instance_method" title="Bundler::Plugin::API::Source#spec_names (method)">spec_names</a></span>
  <span class='kw'>end</span>

  <span class='comment'># Used by definition.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_add_dependency_names'><a href="#add_dependency_names-instance_method" title="Bundler::Plugin::API::Source#add_dependency_names (method)">add_dependency_names</a></span>(<span class='id identifier rubyid_names'>names</span>)
    <span class='ivar'>@dependencies</span> <span class='op'>|=</span> <span class='const'>Array</span>(<span class='id identifier rubyid_names'>names</span>)
  <span class='kw'>end</span>

  <span class='comment'># NOTE: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_can_lock?'><a href="#can_lock%3F-instance_method" title="Bundler::Plugin::API::Source#can_lock? (method)">can_lock?</a></span>(<span class='id identifier rubyid_spec'>spec</span>)
    <span class='id identifier rubyid_spec'>spec</span>.<span class='id identifier rubyid_source'><a href="../API.html#source-class_method" title="Bundler::Plugin::API.source (method)">source</a></span> <span class='op'>==</span> <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='comment'># Generates the content to be entered into the lockfile.
</span>  <span class='comment'># Saves type and remote and also calls to `options_to_lock`.
</span>  <span class='comment'>#
</span>  <span class='comment'># Plugin should use `options_to_lock` to save information in lockfile
</span>  <span class='comment'># and not override this.
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_to_lock'><a href="#to_lock-instance_method" title="Bundler::Plugin::API::Source#to_lock (method)">to_lock</a></span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>=</span> <span class='const'>String</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='const'><a href="../../LockfileParser.html" title="Bundler::LockfileParser (class)">LockfileParser</a></span><span class='op'>::</span><span class='const'><a href="../../LockfileParser.html#PLUGIN-constant" title="Bundler::LockfileParser::PLUGIN (constant)">PLUGIN</a></span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>)
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  remote: </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  type: </span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
    <span class='id identifier rubyid_options_to_lock'><a href="#options_to_lock-instance_method" title="Bundler::Plugin::API::Source#options_to_lock (method)">options_to_lock</a></span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_opt'>opt</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='op'>|</span>
      <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_opt'>opt</span><span class='embexpr_end'>}</span><span class='tstring_content'>: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_value'>value</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  specs:\n</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_to_s'><a href="#to_s-instance_method" title="Bundler::Plugin::API::Source#to_s (method)">to_s</a></span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>plugin source for </span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'> with uri </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_identifier'><a href="#identifier-instance_method" title="Bundler::Plugin::API::Source#identifier (method)">identifier</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_to_s'><a href="#to_s-instance_method" title="Bundler::Plugin::API::Source#to_s (method)">to_s</a></span>

  <span class='comment'># NOTE: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_include?'><a href="#include%3F-instance_method" title="Bundler::Plugin::API::Source#include? (method)">include?</a></span>(<span class='id identifier rubyid_other'>other</span>)
    <span class='id identifier rubyid_other'>other</span> <span class='op'>==</span> <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span>
    <span class='const'><a href="../../SharedHelpers.html" title="Bundler::SharedHelpers (module)">SharedHelpers</a></span>.<span class='id identifier rubyid_digest'><a href="../../SharedHelpers.html#digest-instance_method" title="Bundler::SharedHelpers#digest (method)">digest</a></span>(<span class='symbeg'>:</span><span class='const'>SHA1</span>).<span class='id identifier rubyid_hexdigest'>hexdigest</span>(<span class='id identifier rubyid_uri'>uri</span>)
  <span class='kw'>end</span>

  <span class='comment'># NOTE: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_gem_install_dir'><a href="#gem_install_dir-instance_method" title="Bundler::Plugin::API::Source#gem_install_dir (method)">gem_install_dir</a></span>
    <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_install_path'><a href="../../../Bundler.html#install_path-class_method" title="Bundler.install_path (method)">install_path</a></span>
  <span class='kw'>end</span>

  <span class='comment'># It is used to obtain the full_gem_path.
</span>  <span class='comment'>#
</span>  <span class='comment'># spec&#39;s loaded_from path is expanded against this to get full_gem_path
</span>  <span class='comment'>#
</span>  <span class='comment'># Note: Do not override if you don&#39;t know what you are doing.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_root'><a href="../../../top-level-namespace.html" title="Top Level Namespace (root)">root</a></span>
    <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_root'><a href="../../../Bundler.html#root-class_method" title="Bundler.root (method)">root</a></span>
  <span class='kw'>end</span>

  <span class='comment'># @private
</span>  <span class='comment'># This API on source might not be stable, and for now we expect plugins
</span>  <span class='comment'># to download all specs in `#specs`, so we implement the method for
</span>  <span class='comment'># compatibility purposes and leave it undocumented (and don&#39;t support)
</span>  <span class='comment'># overriding it)
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_double_check_for'><a href="#double_check_for-instance_method" title="Bundler::Plugin::API::Source#double_check_for (method)">double_check_for</a></span>(<span class='op'>*</span>)<span class='semicolon'>;</span> <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="==-instance_method">
  <h3 class='signature  first'>
    #<strong>==</strong>(other)  
    <span class='aliases'>Also known as: <span class='names'>#eql?</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This shall check if two source object represent the same source.</p>

<p>The comparison shall take place only on the attribute that can be inferred from the options passed from Gemfile and not on attributes that are used to pin down the gem to specific version (e.g. Git sources should compare on branch and tag but not on commit hash)</p>

<p>The sources objects are constructed from Gemfile as well as from lockfile. To converge the sources, it is necessary that they match.</p>

<p>The same applies for <a href="#eql%3F-instance_method" title="Bundler::Plugin::API::Source#eql? (method)">#eql?</a> and <a href="#hash-instance_method" title="Bundler::Plugin::API::Source#hash (method)">#hash</a></p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L212-L214'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='212' data-end='214'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 212</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='op'>==</span>(<span class='id identifier rubyid_other'>other</span>)
  <span class='id identifier rubyid_other'>other</span>.<span class='id identifier rubyid_is_a?'>is_a?</span>(<span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span>) <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span> <span class='op'>==</span> <span class='id identifier rubyid_other'>other</span>.<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="add_dependency_names-instance_method">
  <h3 class='signature '>
    #<strong>add_dependency_names</strong>(names)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Used by definition.</p>

<p>Note: Do not override if you don’t know what you are doing.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L257-L259'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='257' data-end='259'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 257</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_add_dependency_names'>add_dependency_names</span>(<span class='id identifier rubyid_names'>names</span>)
  <span class='ivar'>@dependencies</span> <span class='op'>|=</span> <span class='const'>Array</span>(<span class='id identifier rubyid_names'>names</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="app_cache_dirname-instance_method">
  <h3 class='signature '>
    #<strong>app_cache_dirname</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Name of directory where plugin the is expected to cache the gems when <a href="#cache-instance_method" title="Bundler::Plugin::API::Source#cache (method)">#cache</a> is called.</p>

<p>Also this name is matched against the directories in cache for pruning</p>

<p>This is used by <a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">#app_cache_path</a></p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L177-L180'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='177' data-end='180'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 177</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_app_cache_dirname'>app_cache_dirname</span>
  <span class='id identifier rubyid_base_name'>base_name</span> <span class='op'>=</span> <span class='const'>File</span>.<span class='id identifier rubyid_basename'>basename</span>(<span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../URI.html" title="Bundler::URI (module)">URI</a></span>.<span class='id identifier rubyid_parse'><a href="../../URI.html#parse-class_method" title="Bundler::URI.parse (method)">parse</a></span>(<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>).<span class='id identifier rubyid_normalize'>normalize</span>.<span class='id identifier rubyid_path'>path</span>)
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_base_name'>base_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="app_cache_path-instance_method">
  <h3 class='signature '>
    #<strong>app_cache_path</strong>(custom_path = nil)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>The full path where the plugin should cache the gem so that it can be installed latter.</p>

<p>Note: Do not override if you don’t know what you are doing.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L236-L238'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='236' data-end='238'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 236</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_app_cache_path'>app_cache_path</span>(<span class='id identifier rubyid_custom_path'>custom_path</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='ivar'>@app_cache_path</span> <span class='op'>||=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_app_cache'><a href="../../../Bundler.html#app_cache-class_method" title="Bundler.app_cache (method)">app_cache</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span>).<span class='id identifier rubyid_join'>join</span>(<span class='id identifier rubyid_app_cache_dirname'><a href="#app_cache_dirname-instance_method" title="Bundler::Plugin::API::Source#app_cache_dirname (method)">app_cache_dirname</a></span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="cache-instance_method">
  <h3 class='signature '>
    #<strong>cache</strong>(spec, custom_path = nil)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This method is called while caching to save copy of the gems that the source can resolve to path provided by <code>app_cache_app</code>so that they can be reinstalled from the cache without querying the remote (i.e. an alternative to remote)</p>

<p>This is stored with the app and source plugins should try to provide specs and install only from this cache when <a href="#cached!-instance_method" title="Bundler::Plugin::API::Source#cached! (method)">#cached!</a> is called.</p>

<p>This cache is different from the internal caching that can be done at sub paths of <code>cache_path</code> (from <a href="../API.html" title="Bundler::Plugin::API (class)"><code>::Bundler::Plugin::API</code></a>). This can be though as caching by bundler.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L193-L199'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='193' data-end='199'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 193</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_cache'>cache</span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_custom_path'>custom_path</span> <span class='op'>=</span> <span class='kw'>nil</span>)
  <span class='id identifier rubyid_new_cache_path'>new_cache_path</span> <span class='op'>=</span> <span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>(<span class='id identifier rubyid_custom_path'>custom_path</span>)

  <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_rm_rf'><a href="../../FileUtils.html#rm_rf-class_method" title="Bundler::FileUtils.rm_rf (method)">rm_rf</a></span>(<span class='id identifier rubyid_new_cache_path'>new_cache_path</span>)
  <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_cp_r'><a href="../../FileUtils.html#cp_r-class_method" title="Bundler::FileUtils.cp_r (method)">cp_r</a></span>(<span class='id identifier rubyid_install_path'><a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">install_path</a></span><span class='comma'>,</span> <span class='id identifier rubyid_new_cache_path'>new_cache_path</span>)
  <span class='const'><a href="../../FileUtils.html" title="Bundler::FileUtils (module)">FileUtils</a></span>.<span class='id identifier rubyid_touch'><a href="../../FileUtils.html#touch-class_method" title="Bundler::FileUtils.touch (method)">touch</a></span>(<span class='id identifier rubyid_app_cache_path'><a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">app_cache_path</a></span>.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>.bundlecache</span><span class='tstring_end'>&quot;</span></span>))
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="cached!-instance_method">
  <h3 class='signature '>
    #<strong>cached!</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Set internal representation to fetch the gems/specs from app cache.</p>

<p>When this is called, the source should try to fetch the specs and install from the path provided by <a href="#app_cache_path-instance_method" title="Bundler::Plugin::API::Source#app_cache_path (method)">#app_cache_path</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L161-L162'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='161' data-end='162'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 161</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_cached!'>cached!</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="can_lock?-instance_method">
  <h3 class='signature '>
    #<strong>can_lock?</strong>(spec)  &#x21d2; <code>Boolean</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>NOTE: Do not override if you don’t know what you are doing.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L262-L264'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='262' data-end='264'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 262</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_can_lock?'>can_lock?</span>(<span class='id identifier rubyid_spec'>spec</span>)
  <span class='id identifier rubyid_spec'>spec</span>.<span class='id identifier rubyid_source'><a href="../API.html#source-class_method" title="Bundler::Plugin::API.source (method)">source</a></span> <span class='op'>==</span> <span class='kw'>self</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="double_check_for-instance_method">
  <h3 class='signature nodoc'>
    #<strong>double_check_for</strong>  
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
<div class='docstring'>
  <div class='discussion'>
    
<p>This API on source might not be stable, and for now we expect plugins to download all specs in <a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">#specs</a>, so we implement the method for compatibility purposes and leave it undocumented (and don’t support) overriding it)</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L316-L316'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='316' data-end='316'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 316</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_double_check_for'>double_check_for</span>(<span class='op'>*</span>)<span class='semicolon'>;</span> <span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="eql?-instance_method">
  <h3 class='signature '>
    #<strong>eql?</strong>(other)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#==-instance_method" title="Bundler::Plugin::API::Source#== (method)">#==</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L218-L218'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='218' data-end='218'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 218</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_eql?'>eql?</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='op'>==</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="fetch_gemspec_files-instance_method">
  <h3 class='signature '>
    #<strong>fetch_gemspec_files</strong>  &#x21d2; <code>Array</code>&lt;<code>String</code>&gt; 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This is used by the default <code>spec</code> method to constructs the Specification objects for the gems and versions that can be installed by this source plugin.</p>

<p>Note: If the spec method is overridden, this function is not necessary</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>Array</code>&lt;<code>String</code>&gt;)</span>
&mdash;    <div class='inline'>
<p>paths of the gemspec files for gems that can be installed</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L61-L63'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='61' data-end='63'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 61</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_fetch_gemspec_files'>fetch_gemspec_files</span>
  []
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="gem_install_dir-instance_method">
  <h3 class='signature '>
    #<strong>gem_install_dir</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>NOTE: Do not override if you don’t know what you are doing.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L298-L300'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='298' data-end='300'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 298</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_gem_install_dir'>gem_install_dir</span>
  <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_install_path'><a href="../../../Bundler.html#install_path-class_method" title="Bundler.install_path (method)">install_path</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="hash-instance_method">
  <h3 class='signature '>
    #<strong>hash</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>When overriding <code>hash</code> please preserve the behaviour as mentioned in docstring for <a href="#==-instance_method" title="Bundler::Plugin::API::Source#== (method)">#==</a> method, i.e. two methods equal by above comparison should have same hash.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L223-L225'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='223' data-end='225'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 223</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_hash'>hash</span>
  [<span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span><span class='comma'>,</span> <span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>].<span class='id identifier rubyid_hash'>hash</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="identifier-instance_method">
  <h3 class='signature '>
    #<strong>identifier</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#to_s-instance_method" title="Bundler::Plugin::API::Source#to_s (method)">#to_s</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L286-L286'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='286' data-end='286'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 286</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbeg'>:</span><span class='id identifier rubyid_identifier'>identifier</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_to_s'><a href="#to_s-instance_method" title="Bundler::Plugin::API::Source#to_s (method)">to_s</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="include?-instance_method">
  <h3 class='signature '>
    #<strong>include?</strong>(other)  &#x21d2; <code>Boolean</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>NOTE: Do not override if you don’t know what you are doing.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L289-L291'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='289' data-end='291'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 289</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_include?'>include?</span>(<span class='id identifier rubyid_other'>other</span>)
  <span class='id identifier rubyid_other'>other</span> <span class='op'>==</span> <span class='kw'>self</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="initialize-instance_method">
  <h3 class='signature '>
    #<strong>initialize</strong>(opts)  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L45-L51'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='45' data-end='51'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 45</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span>(<span class='id identifier rubyid_opts'>opts</span>)
  <span class='ivar'>@options</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>
  <span class='ivar'>@dependency_names</span> <span class='op'>=</span> []
  <span class='ivar'>@uri</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>uri</span><span class='tstring_end'>&quot;</span></span>]
  <span class='ivar'>@type</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>type</span><span class='tstring_end'>&quot;</span></span>]
  <span class='ivar'>@name</span> <span class='op'>=</span> <span class='id identifier rubyid_opts'>opts</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>name</span><span class='tstring_end'>&quot;</span></span>] <span class='op'>||</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'> at </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="install-instance_method">
  <h3 class='signature '>
    #<strong>install</strong>(spec, opts)  &#x21d2; <code>String</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Install the gem specified by the spec at appropriate path. <a href="#install_path-instance_method" title="Bundler::Plugin::API::Source#install_path (method)">#install_path</a> provides a sufficient default, if the source can only satisfy one gem,  but is not binding.</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<code>String</code>)</span>
&mdash;    <div class='inline'>
<p>post installation message (if any)</p>
</div>
  </li>
</ul>
<p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<a href="../MalformattedPlugin.html" title="Bundler::Plugin::MalformattedPlugin (class)">MalformattedPlugin</a>)</span>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L81-L83'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='81' data-end='83'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 81</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_install'>install</span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>)
  <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../MalformattedPlugin.html" title="Bundler::Plugin::MalformattedPlugin (class)">MalformattedPlugin</a></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Source plugins need to override the install method.</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="install_path-instance_method">
  <h3 class='signature '>
    #<strong>install_path</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>A default installation path to install a single gem. If the source servers multiple gems, it’s not of much use and the source should one of its own.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L106-L113'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='106' data-end='113'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 106</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_install_path'>install_path</span>
  <span class='ivar'>@install_path</span> <span class='op'>||=</span>
    <span class='kw'>begin</span>
      <span class='id identifier rubyid_base_name'>base_name</span> <span class='op'>=</span> <span class='const'>File</span>.<span class='id identifier rubyid_basename'>basename</span>(<span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../URI.html" title="Bundler::URI (module)">URI</a></span>.<span class='id identifier rubyid_parse'><a href="../../URI.html#parse-class_method" title="Bundler::URI.parse (method)">parse</a></span>(<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>).<span class='id identifier rubyid_normalize'>normalize</span>.<span class='id identifier rubyid_path'>path</span>)

      <span class='id identifier rubyid_gem_install_dir'><a href="#gem_install_dir-instance_method" title="Bundler::Plugin::API::Source#gem_install_dir (method)">gem_install_dir</a></span>.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_base_name'>base_name</span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_uri_hash'><a href="#uri_hash-instance_method" title="Bundler::Plugin::API::Source#uri_hash (method)">uri_hash</a></span>[<span class='int'>0</span><span class='op'>..</span><span class='int'>11</span>]<span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>)
    <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="local!-instance_method">
  <h3 class='signature '>
    #<strong>local!</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Set internal representation to fetch the gems/specs locally.</p>

<p>When this is called, the source should try to fetch the specs and install from the local system.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L147-L148'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='147' data-end='148'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 147</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_local!'>local!</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="options_to_lock-instance_method">
  <h3 class='signature '>
    #<strong>options_to_lock</strong>  &#x21d2; <code>Hash</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Options to be saved in the lockfile so that the source plugin is able to check out same version of gem later.</p>

<p>There options are passed when the source plugin is created from the lock file.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L72-L74'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='72' data-end='74'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 72</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_options_to_lock'>options_to_lock</span>
  {}
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="post_install-instance_method">
  <h3 class='signature '>
    #<strong>post_install</strong>(spec, disable_exts = false)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>It builds extensions, generates bins and installs them for the spec provided.</p>

<p>It depends on <code>spec.loaded_from</code> to get full_gem_path. The source plugins should set that.</p>

<p>It should be called in <a href="#install-instance_method" title="Bundler::Plugin::API::Source#install (method)">#install</a> after the plugin is done placing the gem at correct install location.</p>

<p>It also runs <a href="../../../Gem.html" title="Gem (module)"><code>::Gem</code></a> hooks <code>pre_install</code>, <code>post_build</code> and <code>post_install</code></p>

<p>Note: Do not override if you don’t know what you are doing.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L97-L101'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='97' data-end='101'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 97</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_post_install'>post_install</span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_disable_exts'>disable_exts</span> <span class='op'>=</span> <span class='kw'>false</span>)
  <span class='id identifier rubyid_opts'>opts</span> <span class='op'>=</span> { <span class='symbeg'>:</span><span class='id identifier rubyid_env_shebang'>env_shebang</span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_disable_extensions'>disable_extensions</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_disable_exts'>disable_exts</span> }
  <span class='id identifier rubyid_installer'>installer</span> <span class='op'>=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../Source.html" title="Bundler::Source (class)">Source</a></span><span class='op'>::</span><span class='const'><a href="../../Source/Path.html" title="Bundler::Source::Path (class)">Path</a></span><span class='op'>::</span><span class='const'><a href="../../Source/Path/Installer.html" title="Bundler::Source::Path::Installer (class)">Installer</a></span>.<span class='id identifier rubyid_new'><a href="../../Source/Path/Installer.html#new-class_method" title="Bundler::Source::Path::Installer.new (method)">new</a></span>(<span class='id identifier rubyid_spec'>spec</span><span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>)
  <span class='id identifier rubyid_installer'>installer</span>.<span class='id identifier rubyid_post_install'>post_install</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="remote!-instance_method">
  <h3 class='signature '>
    #<strong>remote!</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Set internal representation to fetch the gems/specs from remote.</p>

<p>When this is called, the source should try to fetch the specs and install from remote path.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L154-L155'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='154' data-end='155'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 154</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_remote!'>remote!</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="root-instance_method">
  <h3 class='signature '>
    #<strong>root</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>It is used to obtain the full_gem_path.</p>

<p>spec’s loaded_from path is expanded against this to get full_gem_path</p>

<p>Note: Do not override if you don’t know what you are doing.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L307-L309'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='307' data-end='309'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 307</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_root'><a href="../../../top-level-namespace.html" title="Top Level Namespace (root)">root</a></span>
  <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_root'><a href="../../../Bundler.html#root-class_method" title="Bundler.root (method)">root</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="spec_names-instance_method">
  <h3 class='signature '>
    #<strong>spec_names</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Used by definition.</p>

<p>Note: Do not override if you don’t know what you are doing.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L250-L252'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='250' data-end='252'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 250</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_spec_names'>spec_names</span>
  <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>.<span class='id identifier rubyid_spec_names'>spec_names</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="specs-instance_method">
  <h3 class='signature '>
    #<strong>specs</strong>  &#x21d2; <a href="../../Index.html" title="Bundler::Index (class)">Bundler::Index</a> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Parses the gemspec files to find the specs for the gems that can be satisfied by the source.</p>

<p>Few important points to keep in mind:</p>

<pre class="code ruby"><code class="ruby"><span class='op'>-</span> <span class='const'>If</span> <span class='id identifier rubyid_the'>the</span> <span class='id identifier rubyid_gems'>gems</span> <span class='id identifier rubyid_are'>are</span> <span class='kw'>not</span> <span class='id identifier rubyid_installed'>installed</span> <span class='kw'>then</span> <span class='id identifier rubyid_it'>it</span> <span class='id identifier rubyid_shall'>shall</span> <span class='kw'>return</span> <span class='id identifier rubyid_specs'>specs</span> <span class='kw'>for</span> <span class='id identifier rubyid_all'>all</span>
<span class='id identifier rubyid_the'>the</span> <span class='id identifier rubyid_gems'>gems</span> <span class='id identifier rubyid_it'>it</span> <span class='id identifier rubyid_can'>can</span> <span class='id identifier rubyid_satisfy'>satisfy</span>
<span class='op'>-</span> <span class='const'>If</span> <span class='id identifier rubyid_gem'>gem</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_installed'>installed</span> (<span class='id identifier rubyid_that'>that</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_to'>to</span> <span class='id identifier rubyid_be'>be</span> <span class='id identifier rubyid_detected'>detected</span> <span class='id identifier rubyid_by'>by</span> <span class='id identifier rubyid_the'>the</span> <span class='id identifier rubyid_plugin'>plugin</span> <span class='id identifier rubyid_itself'>itself</span>)
<span class='kw'>then</span> <span class='id identifier rubyid_it'>it</span> <span class='id identifier rubyid_shall'>shall</span> <span class='kw'>return</span> <span class='id identifier rubyid_at'>at</span> <span class='id identifier rubyid_least'>least</span> <span class='id identifier rubyid_the'>the</span> <span class='id identifier rubyid_specs'>specs</span> <span class='id identifier rubyid_that'>that</span> <span class='id identifier rubyid_are'>are</span> <span class='id identifier rubyid_installed'>installed</span>.
<span class='op'>-</span> <span class='const'>The</span> {<span class='id identifier rubyid_loaded_from'>loaded_from</span>} <span class='kw'>for</span> <span class='id identifier rubyid_each'>each</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_the'>the</span> <span class='id identifier rubyid_specs'>specs</span> <span class='id identifier rubyid_shall'>shall</span> <span class='id identifier rubyid_be'>be</span> <span class='id identifier rubyid_correct'>correct</span> (<span class='id identifier rubyid_it'>it</span> <span class='id identifier rubyid_is'>is</span>
<span class='id identifier rubyid_used'>used</span> <span class='id identifier rubyid_to'>to</span> <span class='id identifier rubyid_find'>find</span> <span class='id identifier rubyid_the'>the</span> <span class='id identifier rubyid_load'><a href="../../../Bundler.html#load-class_method" title="Bundler.load (method)">load</a></span> <span class='id identifier rubyid_path'>path</span>)</code></pre>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Returns:</p>
<ul class='return'>
  <li>
    <span class='type'>(<a href="../../Index.html" title="Bundler::Index (class)">Bundler::Index</a>)</span>
&mdash;    <div class='inline'>
<p>index containing the specs</p>
</div>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L127-L141'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='127' data-end='141'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 127</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_specs'>specs</span>
  <span class='id identifier rubyid_files'>files</span> <span class='op'>=</span> <span class='id identifier rubyid_fetch_gemspec_files'><a href="#fetch_gemspec_files-instance_method" title="Bundler::Plugin::API::Source#fetch_gemspec_files (method)">fetch_gemspec_files</a></span>

  <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span><span class='op'>::</span><span class='const'><a href="../../Index.html" title="Bundler::Index (class)">Index</a></span>.<span class='id identifier rubyid_build'><a href="../../Index.html#build-class_method" title="Bundler::Index.build (method)">build</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_index'><a href="../../Plugin.html#index-class_method" title="Bundler::Plugin.index (method)">index</a></span><span class='op'>|</span>
    <span class='id identifier rubyid_files'>files</span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_file'>file</span><span class='op'>|</span>
      <span class='kw'>next</span> <span class='kw'>unless</span> <span class='id identifier rubyid_spec'>spec</span> <span class='op'>=</span> <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_load_gemspec'><a href="../../../Bundler.html#load_gemspec-class_method" title="Bundler.load_gemspec (method)">load_gemspec</a></span>(<span class='id identifier rubyid_file'>file</span>)
      <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_rubygems'><a href="../../../Bundler.html#rubygems-class_method" title="Bundler.rubygems (method)">rubygems</a></span>.<span class='id identifier rubyid_set_installed_by_version'>set_installed_by_version</span>(<span class='id identifier rubyid_spec'>spec</span>)

      <span class='id identifier rubyid_spec'>spec</span>.<span class='id identifier rubyid_source'><a href="../API.html#source-class_method" title="Bundler::Plugin::API.source (method)">source</a></span> <span class='op'>=</span> <span class='kw'>self</span>
      <span class='const'><a href="../../../Bundler.html" title="Bundler (module)">Bundler</a></span>.<span class='id identifier rubyid_rubygems'><a href="../../../Bundler.html#rubygems-class_method" title="Bundler.rubygems (method)">rubygems</a></span>.<span class='id identifier rubyid_validate'>validate</span>(<span class='id identifier rubyid_spec'>spec</span>)

      <span class='id identifier rubyid_index'><a href="../../Plugin.html#index-class_method" title="Bundler::Plugin.index (method)">index</a></span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_spec'>spec</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="to_lock-instance_method">
  <h3 class='signature '>
    #<strong>to_lock</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Generates the content to be entered into the lockfile. Saves type and remote and also calls to <a href="#options_to_lock-instance_method" title="Bundler::Plugin::API::Source#options_to_lock (method)">#options_to_lock</a>.</p>

<p><a href="../../Plugin.html" title="Bundler::Plugin (module)"><code>::Bundler::Plugin</code></a> should use <a href="#options_to_lock-instance_method" title="Bundler::Plugin::API::Source#options_to_lock (method)">#options_to_lock</a> to save information in lockfile and not override this.</p>

<p>Note: Do not override if you don’t know what you are doing.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L273-L281'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='273' data-end='281'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 273</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_to_lock'>to_lock</span>
  <span class='id identifier rubyid_out'>out</span> <span class='op'>=</span> <span class='const'>String</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='const'><a href="../../LockfileParser.html" title="Bundler::LockfileParser (class)">LockfileParser</a></span><span class='op'>::</span><span class='const'><a href="../../LockfileParser.html#PLUGIN-constant" title="Bundler::LockfileParser::PLUGIN (constant)">PLUGIN</a></span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>)
  <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  remote: </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  type: </span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_options_to_lock'><a href="#options_to_lock-instance_method" title="Bundler::Plugin::API::Source#options_to_lock (method)">options_to_lock</a></span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_opt'>opt</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='op'>|</span>
    <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_opt'>opt</span><span class='embexpr_end'>}</span><span class='tstring_content'>: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_value'>value</span><span class='embexpr_end'>}</span><span class='tstring_content'>\n</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_out'>out</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  specs:\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="to_s-instance_method">
  <h3 class='signature '>
    #<strong>to_s</strong>  
    <span class='aliases'>Also known as: <span class='names'>#identifier</span></span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L283-L285'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='283' data-end='285'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 283</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_to_s'>to_s</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>plugin source for </span><span class='embexpr_beg'>#{</span><span class='ivar'>@type</span><span class='embexpr_end'>}</span><span class='tstring_content'> with uri </span><span class='embexpr_beg'>#{</span><span class='ivar'>@uri</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="unlock!-instance_method">
  <h3 class='signature '>
    #<strong>unlock!</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This is called to update the spec and installation.</p>

<p>If the source plugin is loaded from lockfile or otherwise, it shall refresh the cache/specs (e.g. git sources can make a fresh clone).</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L168-L169'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='168' data-end='169'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 168</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_unlock!'>unlock!</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="unmet_deps-instance_method">
  <h3 class='signature '>
    #<strong>unmet_deps</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Used by definition.</p>

<p>Note: Do not override if you don’t know what you are doing.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L243-L245'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='243' data-end='245'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 243</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_unmet_deps'>unmet_deps</span>
  <span class='id identifier rubyid_specs'><a href="#specs-instance_method" title="Bundler::Plugin::API::Source#specs (method)">specs</a></span>.<span class='id identifier rubyid_unmet_dependency_names'>unmet_dependency_names</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="uri_hash-instance_method">
  <h3 class='signature '>
    #<strong>uri_hash</strong>  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/lib/bundler/plugin/api/source.rb#L293-L295'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='293' data-end='295'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/bundler/plugin/api/source.rb', line 293</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_uri_hash'>uri_hash</span>
  <span class='const'><a href="../../SharedHelpers.html" title="Bundler::SharedHelpers (module)">SharedHelpers</a></span>.<span class='id identifier rubyid_digest'><a href="../../SharedHelpers.html#digest-instance_method" title="Bundler::SharedHelpers#digest (method)">digest</a></span>(<span class='symbeg'>:</span><span class='const'>SHA1</span>).<span class='id identifier rubyid_hexdigest'>hexdigest</span>(<span class='id identifier rubyid_uri'><a href="#uri-instance_method" title="Bundler::Plugin::API::Source#uri (method)">uri</a></span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>