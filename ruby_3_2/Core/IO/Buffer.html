<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: IO::Buffer &mdash; Core Ruby-3.2.4 p170</title>

<link rel='stylesheet'  type='text/css' href='../../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "IO::Buffer",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../../'>Ruby-3.2.4</a> &raquo; 
      <a href='../'>Core</a> &raquo; 
      <a href='../_index.html#alpha_B'>Index (B)</a> &raquo; 
        <a href="../IO.html" title="IO (class)">IO</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>Buffer&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: IO::Buffer</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Namespace Children</td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Exceptions:</div>
      <div class='box_11'>
          <a href="Buffer/AccessError.html" title="IO::Buffer::AccessError (class)"><code>AccessError</code></a>,
        <a href="Buffer/AllocationError.html" title="IO::Buffer::AllocationError (class)"><code>AllocationError</code></a>,
        <a href="Buffer/InvalidatedError.html" title="IO::Buffer::InvalidatedError (class)"><code>InvalidatedError</code></a>,
        <a href="Buffer/LockedError.html" title="IO::Buffer::LockedError (class)"><code>LockedError</code></a>,
        <a href="Buffer/MaskError.html" title="IO::Buffer::MaskError (class)"><code>MaskError</code></a>      </div>
    </td></tr>
    <tr><td class='box_h' colspan='2'>Super Chains via Extension / Inclusion / Inheritance</td></tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Instance Chain:</div>
        <div class='box_22'>
          self,
          <a href="../Comparable.html" title="Comparable (module)"><code>::Comparable</code></a>
        </div>
      </td>
    </tr>
    <tr>
      <td id='t2_inherits' class='box_2'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'><a href="../Object.html" title="Object (class)">Object</a></span>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2 o'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3243'>io_buffer.c</a><span class='defines'>,<br /><a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3240'>io_buffer.c</a></span>
      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p><code>Buffer</code> is a low-level efficient buffer for input/output. There are three ways of using buffer:</p>
<ul><li>
<p>Create an empty buffer with <a href="#new-class_method" title="IO::Buffer.new (method)">.new</a>, fill it with data using <a href="#copy-instance_method" title="IO::Buffer#copy (method)">#copy</a> or #set_value, #set_string, get data with #get_string;</p>
</li><li>
<p>Create a buffer mapped to some string with <a href="#for-class_method" title="IO::Buffer.for (method)">.for</a>, then it could be used both for reading with #get_string or #get_value, and writing (writing will change the source string, too);</p>
</li><li>
<p>Create a buffer mapped to some file with <a href="#map-class_method" title="IO::Buffer.map (method)">.map</a>, then it could be used for reading and writing the underlying file.</p>
</li></ul>

<p>Interaction with string and file memory is performed by efficient low-level C mechanisms like <code>memcpy</code>.</p>

<p>The class is meant to be an utility for implementing more high-level mechanisms like <code>Fiber::SchedulerInterface#io_read</code> and <code>Fiber::SchedulerInterface#io_write</code>.</p>

<p><strong>Examples of usage:</strong></p>

<p>Empty buffer:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="IO::Buffer.new (method)">new</a></span>(<span class='int'>8</span>)  <span class='comment'># create empty 8-byte buffer
</span><span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000555f5d1a5c50+8 INTERNAL&gt;
</span><span class='comment'># ...
</span><span class='id identifier rubyid_buffer'>buffer</span>
<span class='comment'># =&gt;
</span><span class='comment'># &lt;IO::Buffer 0x0000555f5d156ab0+8 INTERNAL&gt;
</span><span class='comment'># 0x00000000  00 00 00 00 00 00 00 00
</span><span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_string'><a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">set_string</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>2</span>) <span class='comment'># put there bytes of the &quot;test&quot; string, starting from offset 2
</span><span class='comment'># =&gt; 4
</span><span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_get_string'><a href="#get_string-instance_method" title="IO::Buffer#get_string (method)">get_string</a></span>  <span class='comment'># get the result
</span><span class='comment'># =&gt; &quot;\x00\x00test\x00\x00&quot;</span></code></pre>

<p>Buffer from string:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_string'>string</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>data</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='id identifier rubyid_string'>string</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x00007f3f02be9b18+4 SLICE&gt;
</span><span class='comment'># ...
</span><span class='id identifier rubyid_buffer'>buffer</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x00007f3f02be9b18+4 SLICE&gt;
</span><span class='comment'># 0x00000000  64 61 74 61                                     data
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_get_string'><a href="#get_string-instance_method" title="IO::Buffer#get_string (method)">get_string</a></span>(<span class='int'>2</span>)  <span class='comment'># read content starting from offset 2
</span><span class='comment'># =&gt; &quot;ta&quot;
</span><span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_string'><a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">set_string</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>---</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>1</span>) <span class='comment'># write content, starting from offset 1
</span><span class='comment'># =&gt; 3
</span><span class='id identifier rubyid_buffer'>buffer</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x00007f3f02be9b18+4 SLICE&gt;
</span><span class='comment'># 0x00000000  64 2d 2d 2d                                     d---
</span><span class='id identifier rubyid_string'>string</span>  <span class='comment'># original string changed, too
</span><span class='comment'># =&gt; &quot;d---&quot;</span></code></pre>

<p>Buffer from file:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_write'><a href="../IO.html#write-class_method" title="IO.write (method)">write</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test.txt</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test data</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; 9
</span><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_map'><a href="#map-class_method" title="IO::Buffer.map (method)">map</a></span>(<span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_open'><a href="../File.html#open-class_method" title="File.open (method)">open</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test.txt</span><span class='tstring_end'>&#39;</span></span>))
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x00007f3f0768c000+9 MAPPED IMMUTABLE&gt;
</span><span class='comment'># ...
</span><span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_get_string'><a href="#get_string-instance_method" title="IO::Buffer#get_string (method)">get_string</a></span>(<span class='int'>5</span><span class='comma'>,</span> <span class='int'>2</span>) <span class='comment'># read 2 bytes, starting from offset 5
</span><span class='comment'># =&gt; &quot;da&quot;
</span><span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_string'><a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">set_string</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>---</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>1</span>) <span class='comment'># attempt to write
</span><span class='comment'># in `set_string&#39;: Buffer is not writable! (IO::Buffer::AccessError)
</span>
<span class='comment'># To create writable file-mapped buffer
</span><span class='comment'># Open file for read-write, pass size, offset, and flags=0
</span><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_map'><a href="#map-class_method" title="IO::Buffer.map (method)">map</a></span>(<span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_open'><a href="../File.html#open-class_method" title="File.open (method)">open</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test.txt</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>r+</span><span class='tstring_end'>&#39;</span></span>)<span class='comma'>,</span> <span class='int'>9</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='int'>0</span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_string'><a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">set_string</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>---</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>1</span>)
<span class='comment'># =&gt; 3 -- bytes written
</span><span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_read'><a href="../IO.html#read-class_method" title="IO.read (method)">read</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test.txt</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; &quot;t--- data&quot;</span></code></pre>

<p><strong>The class is experimental and the interface is subject to change.</strong></p>

  </div>
</div>
</div>
<h2 id='t2_cnst' class='h2_sum'>Constant Summary</h2>
<div>
<ul class='constants summary full'>
  <li>
    <span id='BIG_ENDIAN-constant' class='summary_signature'>BIG_ENDIAN =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3292'># File 'io_buffer.c', line 3292</a>    <pre class='code c'><span class='const'>RB_INT2NUM</span>(<span class='const'>RB_IO_BUFFER_BIG_ENDIAN</span>)</pre>
  </li>
  <li>
    <span id='DEFAULT_SIZE-constant' class='summary_signature'>DEFAULT_SIZE =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3265'># File 'io_buffer.c', line 3265</a>    <pre class='code c'><span class='const'>SIZET2NUM</span>(<span class='const'>RUBY_IO_BUFFER_DEFAULT_SIZE</span>)</pre>
  </li>
  <li>
    <span id='EXTERNAL-constant' class='summary_signature'>EXTERNAL =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>Flags:</p>

  </div>
</div>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3282'># File 'io_buffer.c', line 3282</a>    <pre class='code c'><span class='const'>RB_INT2NUM</span>(<span class='const'>RB_IO_BUFFER_EXTERNAL</span>)</pre>
  </li>
  <li>
    <span id='HOST_ENDIAN-constant' class='summary_signature'>HOST_ENDIAN =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3293'># File 'io_buffer.c', line 3293</a>    <pre class='code c'><span class='const'>RB_INT2NUM</span>(<span class='const'>RB_IO_BUFFER_HOST_ENDIAN</span>)</pre>
  </li>
  <li>
    <span id='INTERNAL-constant' class='summary_signature'>INTERNAL =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3283'># File 'io_buffer.c', line 3283</a>    <pre class='code c'><span class='const'>RB_INT2NUM</span>(<span class='const'>RB_IO_BUFFER_INTERNAL</span>)</pre>
  </li>
  <li>
    <span id='LITTLE_ENDIAN-constant' class='summary_signature'>LITTLE_ENDIAN =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>Endian:</p>

  </div>
</div>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3291'># File 'io_buffer.c', line 3291</a>    <pre class='code c'><span class='const'>RB_INT2NUM</span>(<span class='const'>RB_IO_BUFFER_LITTLE_ENDIAN</span>)</pre>
  </li>
  <li>
    <span id='LOCKED-constant' class='summary_signature'>LOCKED =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3286'># File 'io_buffer.c', line 3286</a>    <pre class='code c'><span class='const'>RB_INT2NUM</span>(<span class='const'>RB_IO_BUFFER_LOCKED</span>)</pre>
  </li>
  <li>
    <span id='MAPPED-constant' class='summary_signature'>MAPPED =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3284'># File 'io_buffer.c', line 3284</a>    <pre class='code c'><span class='const'>RB_INT2NUM</span>(<span class='const'>RB_IO_BUFFER_MAPPED</span>)</pre>
  </li>
  <li>
    <span id='NETWORK_ENDIAN-constant' class='summary_signature'>NETWORK_ENDIAN =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3294'># File 'io_buffer.c', line 3294</a>    <pre class='code c'><span class='const'>RB_INT2NUM</span>(<span class='const'>RB_IO_BUFFER_NETWORK_ENDIAN</span>)</pre>
  </li>
  <li>
    <span id='PAGE_SIZE-constant' class='summary_signature'>PAGE_SIZE =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>Efficient sizing of mapped buffers:</p>

  </div>
</div>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3264'># File 'io_buffer.c', line 3264</a>    <pre class='code c'><span class='const'>SIZET2NUM</span>(<span class='const'>RUBY_IO_BUFFER_PAGE_SIZE</span>)</pre>
  </li>
  <li>
    <span id='PRIVATE-constant' class='summary_signature'>PRIVATE =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3287'># File 'io_buffer.c', line 3287</a>    <pre class='code c'><span class='const'>RB_INT2NUM</span>(<span class='const'>RB_IO_BUFFER_PRIVATE</span>)</pre>
  </li>
  <li>
    <span id='READONLY-constant' class='summary_signature'>READONLY =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3288'># File 'io_buffer.c', line 3288</a>    <pre class='code c'><span class='const'>RB_INT2NUM</span>(<span class='const'>RB_IO_BUFFER_READONLY</span>)</pre>
  </li>
  <li>
    <span id='SHARED-constant' class='summary_signature'>SHARED =</span>
    <br/>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3285'># File 'io_buffer.c', line 3285</a>    <pre class='code c'><span class='const'>RB_INT2NUM</span>(<span class='const'>RB_IO_BUFFER_SHARED</span>)</pre>
  </li>
</ul>
</div>

<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#for-class_method" title="for (class method)">.<strong>for</strong>(string)  &#x21d2; Buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Creates a <code>Buffer</code> from the given string’s memory.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#map-class_method" title="map (class method)">.<strong>map</strong>(file, [size, [offset, [flags]]])  &#x21d2; Buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Create an <code>Buffer</code> for reading from <code>file</code> by memory-mapping the file.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#new-class_method" title="new (class method)">.<strong>new</strong>([size = DEFAULT_SIZE, [flags)  &#x21d2; Buffer </a>
    </span>
    <span class='note title constructor'>constructor</span>
    <div class='summary_desc'>
      <div class='inline'><p>Create a new zero-filled <code>Buffer</code> of <a href="#size-instance_method" title="IO::Buffer#size (method)">#size</a> bytes.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#size_of-class_method" title="size_of (class method)">.<strong>size_of</strong>(data_type)  &#x21d2; byte size </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the size of the given data type(s) in bytes.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_attribute_summary'>Instance Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature ro'>
      <a href="#empty%3F-instance_method" title="#empty? (instance method)">#<strong>empty?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>If the buffer has 0 size: it is created by <a href="#new-class_method" title="IO::Buffer.new (method)">.new</a> with size 0, or with <a href="#for-class_method" title="IO::Buffer.for (method)">.for</a> from an empty string.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#external%3F-instance_method" title="#external? (instance method)">#<strong>external?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>The buffer is <em>external</em> if it references the memory which is not allocated or mapped by the buffer itself.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#internal%3F-instance_method" title="#internal? (instance method)">#<strong>internal?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>If the buffer is <em>internal</em>, meaning it references memory allocated by the buffer itself.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#locked-instance_method" title="#locked (instance method)">#<strong>locked</strong>  </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Allows to process a buffer in exclusive way, for concurrency-safety.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#locked%3F-instance_method" title="#locked? (instance method)">#<strong>locked?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>If the buffer is <em>locked</em>, meaning it is inside <a href="#locked-instance_method" title="IO::Buffer#locked (method)">#locked</a> block execution.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#mapped%3F-instance_method" title="#mapped? (instance method)">#<strong>mapped?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>If the buffer is <em>mapped</em>, meaning it references memory mapped by the buffer.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#null%3F-instance_method" title="#null? (instance method)">#<strong>null?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>If the buffer was freed with <a href="#free-instance_method" title="IO::Buffer#free (method)">#free</a> or was never allocated in the first place.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#readonly%3F-instance_method" title="#readonly? (instance method)">#<strong>readonly?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>If the buffer is <em>read only</em>, meaning the buffer cannot be modified using <a href="#set_value-instance_method" title="IO::Buffer#set_value (method)">#set_value</a>, <a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">#set_string</a> or <a href="#copy-instance_method" title="IO::Buffer#copy (method)">#copy</a> and similar.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#shared%3F-instance_method" title="#shared? (instance method)">#<strong>shared?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>If the buffer is <em>shared</em>, meaning it references memory that can be shared with other processes (and thus might change without being modified locally).</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#valid%3F-instance_method" title="#valid? (instance method)">#<strong>valid?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns whether the buffer data is accessible.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- instance_attribute_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#&-instance_method" title="#&amp; (instance method)">#<strong>&amp;</strong>(mask)  &#x21d2; Buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Generate a new buffer the same size as the source by applying the binary AND operation to the source, using the mask, repeating as necessary.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#<=>-instance_method" title="#&lt;=&gt; (instance method)">#<strong>&lt;=&gt;</strong>(other)  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Buffers are compared by size and exact contents of the memory they are referencing using <code>memcmp</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#%5E-instance_method" title="#^ (instance method)">#<strong>^</strong>(mask)  &#x21d2; Buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Generate a new buffer the same size as the source by applying the binary XOR operation to the source, using the mask, repeating as necessary.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#and!-instance_method" title="#and! (instance method)">#<strong>and!</strong>(mask)  &#x21d2; Buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Modify the source buffer in place by applying the binary AND operation to the source, using the mask, repeating as necessary.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#clear-instance_method" title="#clear (instance method)">#<strong>clear</strong>(value = 0, [offset, [length]])  &#x21d2; self </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Fill buffer with <code>value</code>, starting with <code>offset</code> and going for <code>length</code> bytes.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#copy-instance_method" title="#copy (instance method)">#<strong>copy</strong>(source, [offset, [length, [source_offset]]])  &#x21d2; size </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Efficiently copy data from a source <code>Buffer</code> into the buffer, at <code>offset</code> using <code>memcpy</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#free-instance_method" title="#free (instance method)">#<strong>free</strong>  &#x21d2; self </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>If the buffer references memory, release it back to the operating system.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#get_string-instance_method" title="#get_string (instance method)">#<strong>get_string</strong>([offset, [length, [encoding]]])  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Read a chunk or all of the buffer into a string, in the specified <code>encoding</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#get_value-instance_method" title="#get_value (instance method)">#<strong>get_value</strong>(data_type, offset)  &#x21d2; Numeric </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Read from buffer a value of <code>type</code> at <code>offset</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#get_values-instance_method" title="#get_values (instance method)">#<strong>get_values</strong>(data_types, offset)  &#x21d2; Array </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Similar to <a href="#get_value-instance_method" title="IO::Buffer#get_value (method)">#get_value</a>, except that it can handle multiple data types and returns an array of values.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#hexdump-instance_method" title="#hexdump (instance method)">#<strong>hexdump</strong>  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#not!-instance_method" title="#not! (instance method)">#<strong>not!</strong>  &#x21d2; Buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Modify the source buffer in place by applying the binary NOT operation to the source.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#or!-instance_method" title="#or! (instance method)">#<strong>or!</strong>(mask)  &#x21d2; Buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Modify the source buffer in place by applying the binary OR operation to the source, using the mask, repeating as necessary.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#read-instance_method" title="#read (instance method)">#<strong>read</strong>(io, length, [offset])  &#x21d2; read length, -errno </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Read at most <code>length</code> bytes from <code>io</code> into the buffer, starting at <code>offset</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#resize-instance_method" title="#resize (instance method)">#<strong>resize</strong>(new_size)  &#x21d2; self </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Resizes a buffer to a <code>new_size</code> bytes, preserving its content.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#set_string-instance_method" title="#set_string (instance method)">#<strong>set_string</strong>(string, [offset, [length, [source_offset]]])  &#x21d2; size </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Efficiently copy data from a source <a href="../String.html" title="String (class)"><code>::String</code></a> into the buffer, at <code>offset</code> using <code>memcpy</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#set_value-instance_method" title="#set_value (instance method)">#<strong>set_value</strong>(type, offset, value)  &#x21d2; offset </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Write to a buffer a <code>value</code> of <code>type</code> at <code>offset</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#set_values-instance_method" title="#set_values (instance method)">#<strong>set_values</strong>(data_types, offset, values)  &#x21d2; offset </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Write <a href="#values-instance_method" title="IO::Buffer#values (method)">#values</a> of <code>data_types</code> at <code>offset</code> to the buffer.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#size-instance_method" title="#size (instance method)">#<strong>size</strong>  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the size of the buffer that was explicitly set (on creation with <a href="#new-class_method" title="IO::Buffer.new (method)">.new</a> or on <a href="#resize-instance_method" title="IO::Buffer#resize (method)">#resize</a>), or deduced on buffer’s creation from string or file.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#slice-instance_method" title="#slice (instance method)">#<strong>slice</strong>([offset = 0, [length]])  &#x21d2; Buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Produce another <code>Buffer</code> which is a slice (or view into) the current one starting at <code>offset</code> bytes and going for <code>length</code> bytes.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#to_s-instance_method" title="#to_s (instance method)">#<strong>to_s</strong>  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Short representation of the buffer.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#transfer-instance_method" title="#transfer (instance method)">#<strong>transfer</strong>  &#x21d2; Buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Transfers ownership to a new buffer, deallocating the current one.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#values-instance_method" title="#values (instance method)">#<strong>values</strong>(data_type, [offset, [count]])  &#x21d2; Array </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns an array of values of <code>data_type</code> starting from <code>offset</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#write-instance_method" title="#write (instance method)">#<strong>write</strong>(io, length, [offset])  &#x21d2; written length, -errno </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Writes <code>length</code> bytes from buffer into <code>io</code>, starting at <code>offset</code> in the buffer.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#xor!-instance_method" title="#xor! (instance method)">#<strong>xor!</strong>(mask)  &#x21d2; Buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Modify the source buffer in place by applying the binary XOR operation to the source, using the mask, repeating as necessary.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#%7C-instance_method" title="#| (instance method)">#<strong>|</strong>(mask)  &#x21d2; Buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Generate a new buffer the same size as the source by applying the binary OR operation to the source, using the mask, repeating as necessary.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#~-instance_method" title="#~ (instance method)">#<strong>~</strong>  &#x21d2; Buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Generate a new buffer the same size as the source by applying the binary NOT operation to the source.</p></div>
    </div>
  </li>
</ul>

<h3 class='inherited'><a href="../Comparable.html" title="Comparable (module)"><code>::Comparable</code></a> - Included</h3>
<div class='inherited'><table class='inherited'>
  <tbody>
    <tr class='i_ds'>
      <td><a class='i_m ' href="../Comparable.html#<-instance_method" title="Comparable#&lt; (method)">#<</a></td>
      <td><div class='inline'><p>Compares two objects based on the receiver’s <a href="#<=>-instance_method" title="IO::Buffer#&lt;=&gt; (method)">#&lt;=&gt;</a> method, returning true if it returns a value less than 0.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="../Comparable.html#<=-instance_method" title="Comparable#&lt;= (method)">#<=</a></td>
      <td><div class='inline'><p>Compares two objects based on the receiver’s <a href="#<=>-instance_method" title="IO::Buffer#&lt;=&gt; (method)">#&lt;=&gt;</a> method, returning true if it returns a value less than or equal to 0.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="../Comparable.html#==-instance_method" title="Comparable#== (method)">#==</a></td>
      <td><div class='inline'><p>Compares two objects based on the receiver’s <a href="#<=>-instance_method" title="IO::Buffer#&lt;=&gt; (method)">#&lt;=&gt;</a> method, returning true if it returns 0.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="../Comparable.html#>-instance_method" title="Comparable#&gt; (method)">#></a></td>
      <td><div class='inline'><p>Compares two objects based on the receiver’s <a href="#<=>-instance_method" title="IO::Buffer#&lt;=&gt; (method)">#&lt;=&gt;</a> method, returning true if it returns a value greater than 0.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="../Comparable.html#>=-instance_method" title="Comparable#&gt;= (method)">#>=</a></td>
      <td><div class='inline'><p>Compares two objects based on the receiver’s <a href="#<=>-instance_method" title="IO::Buffer#&lt;=&gt; (method)">#&lt;=&gt;</a> method, returning true if it returns a value greater than or equal to 0.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="../Comparable.html#between%3F-instance_method" title="Comparable#between? (method)">#between?</a></td>
      <td><div class='inline'><p>Returns <code>false</code> if <em>obj</em> <a href="#<=>-instance_method" title="IO::Buffer#&lt;=&gt; (method)">#&lt;=&gt;</a> <em>min</em> is less than zero or if <em>obj</em> <a href="#<=>-instance_method" title="IO::Buffer#&lt;=&gt; (method)">#&lt;=&gt;</a> <em>max</em> is greater than zero, <code>true</code> otherwise.</p></div></td>
    </tr>
    <tr class='i_ds'>
      <td><a class='i_m ' href="../Comparable.html#clamp-instance_method" title="Comparable#clamp (method)">#clamp</a></td>
      <td><div class='inline'><p>In <code>(min, max)</code> form, returns <em>min</em> if <em>obj</em> <a href="#<=>-instance_method" title="IO::Buffer#&lt;=&gt; (method)">#&lt;=&gt;</a> <em>min</em> is less than zero, <em>max</em> if <em>obj</em> <a href="#<=>-instance_method" title="IO::Buffer#&lt;=&gt; (method)">#&lt;=&gt;</a> <em>max</em> is greater than zero, and <em>obj</em> otherwise.</p></div></td>
    </tr>
  </tbody>
</table></div>
</div>  <!-- instance_method_summary -->
<h2 id='Constructor_Details' class='y_details'>Constructor Details</h2>

  <section class='method_details first' id="new-class_method">
  <h3 class='signature  first'>
    .<strong>new</strong>([size = DEFAULT_SIZE, [flags)  &#x21d2; <code>Buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Create a new zero-filled <code>Buffer</code> of <a href="#size-instance_method" title="IO::Buffer#size (method)">#size</a> bytes. By default, the buffer will be <em>internal</em>: directly allocated chunk of the memory. But if the requested <a href="#size-instance_method" title="IO::Buffer#size (method)">#size</a> is more than OS-specific <a href="#PAGE_SIZE-constant" title="IO::Buffer::PAGE_SIZE (constant)">PAGE_SIZE</a>, the buffer would be allocated using the virtual memory mechanism (anonymous <code>mmap</code> on Unix, <code>VirtualAlloc</code> on Windows). The behavior can be forced by passing <a href="#MAPPED-constant" title="IO::Buffer::MAPPED (constant)">MAPPED</a> as a second parameter.</p>

<p>Examples</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_new'>new</span>(<span class='int'>4</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x000055b34497ea10+4 INTERNAL&gt;
</span><span class='comment'># 0x00000000  00 00 00 00                                     ....
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_get_string'><a href="#get_string-instance_method" title="IO::Buffer#get_string (method)">get_string</a></span>(<span class='int'>0</span><span class='comma'>,</span> <span class='int'>1</span>) <span class='comment'># =&gt; &quot;\x00&quot;
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_string'><a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">set_string</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>test</span><span class='tstring_end'>&quot;</span></span>)
<span class='id identifier rubyid_buffer'>buffer</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x000055b34497ea10+4 INTERNAL&gt;
</span><span class='comment'># 0x00000000  74 65 73 74                                     test</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L563-L593'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='563' data-end='593'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 563</span></pre>
<pre class='code cpp'>

VALUE
rb_io_buffer_initialize(int argc, VALUE *argv, VALUE self)
{
    io_buffer_experimental();

    rb_check_arity(argc, 0, 2);

    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    size_t size;

    if (argc &gt; 0) {
        size = RB_NUM2SIZE(argv[0]);
    }
    else {
        size = RUBY_IO_BUFFER_DEFAULT_SIZE;
    }

    enum rb_io_buffer_flags flags = 0;
    if (argc &gt;= 2) {
        flags = RB_NUM2UINT(argv[1]);
    }
    else {
        flags |= io_flags_for_size(size);
    }

    io_buffer_initialize(data, NULL, size, flags, Qnil);

    return self;
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Class Method Details</h2>
<section class='method_details first' id="for-class_method">
  <h3 class='signature  first'>
    <div class='inline-block'>
      <span class='overload'>.<strong>for</strong>(string)  &#x21d2; <code>Buffer</code> </span>
      <span class='overload'>.<strong>for</strong>(string) {|io_buffer| ... } </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Creates a <code>Buffer</code> from the given string’s memory. Without a block a frozen internal copy of the string is created efficiently and used as the buffer source. When a block is provided, the buffer is associated directly with the string’s internal data and updating the buffer will update the string.</p>

<p>Until <a href="#free-instance_method" title="IO::Buffer#free (method)">#free</a> is invoked on the buffer, either explicitly or via the garbage collector, the source string will be locked and cannot be modified.</p>

<p>If the string is frozen, it will create a read-only buffer which cannot be modified. If the string is shared, it may trigger a copy-on-write when using the block form.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_string'>string</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'>for</span>(<span class='id identifier rubyid_string'>string</span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_external?'><a href="#external%3F-instance_method" title="IO::Buffer#external? (method)">external?</a></span> <span class='comment'>#=&gt; true
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_get_string'><a href="#get_string-instance_method" title="IO::Buffer#get_string (method)">get_string</a></span>(<span class='int'>0</span><span class='comma'>,</span> <span class='int'>1</span>)
<span class='comment'># =&gt; &quot;t&quot;
</span><span class='id identifier rubyid_string'>string</span>
<span class='comment'># =&gt; &quot;best&quot;
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_resize'><a href="#resize-instance_method" title="IO::Buffer#resize (method)">resize</a></span>(<span class='int'>100</span>)
<span class='comment'># in `resize&#39;: Cannot resize external buffer! (IO::Buffer::AccessError)
</span>
<span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'>for</span>(<span class='id identifier rubyid_string'>string</span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_buffer'>buffer</span><span class='op'>|</span>
  <span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_string'><a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">set_string</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>T</span><span class='tstring_end'>&quot;</span></span>)
  <span class='id identifier rubyid_string'>string</span>
  <span class='comment'># =&gt; &quot;Test&quot;
</span><span class='kw'>end</span></code></pre>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L391-L413'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='391' data-end='413'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 391</span></pre>
<pre class='code cpp'>

VALUE
rb_io_buffer_type_for(VALUE klass, VALUE string)
{
    StringValue(string);

    // If the string is frozen, both code paths are okay.
    // If the string is not frozen, if a block is not given, it must be frozen.
    if (rb_block_given_p()) {
        struct io_buffer_for_yield_instance_arguments arguments = {
            .klass = klass,
            .string = string,
            .instance = Qnil,
            .flags = 0,
        };

        return rb_ensure(io_buffer_for_yield_instance, (VALUE)&amp;arguments, io_buffer_for_yield_instance_ensure, (VALUE)&amp;arguments);
    }
    else {
        // This internally returns the source string if it&#39;s already frozen.
        string = rb_str_tmp_frozen_acquire(string);
        return io_buffer_for_make_instance(klass, string, RB_IO_BUFFER_READONLY);
    }
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="map-class_method">
  <h3 class='signature '>
    .<strong>map</strong>(file, [size, [offset, [flags]]])  &#x21d2; <code>Buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Create an <code>Buffer</code> for reading from <code>file</code> by memory-mapping the file. <code>file_io</code> should be a <a href="../File.html" title="File (class)"><code>::File</code></a> instance, opened for reading.</p>

<p>Optional <a href="#size-instance_method" title="IO::Buffer#size (method)">#size</a> and <code>offset</code> of mapping can be specified.</p>

<p>By default, the buffer would be immutable (read only); to create a writable mapping, you need to open a file in read-write mode, and explicitly pass <code>flags</code> argument without <code>IO::Buffer::IMMUTABLE</code>.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_write'><a href="../IO.html#write-class_method" title="IO.write (method)">write</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test.txt</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span>)

<span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_map'>map</span>(<span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_open'><a href="../File.html#open-class_method" title="File.open (method)">open</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test.txt</span><span class='tstring_end'>&#39;</span></span>)<span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span><span class='op'>::</span><span class='const'><a href="#READONLY-constant" title="IO::Buffer::READONLY (constant)">READONLY</a></span>)
<span class='comment'># =&gt; #&lt;IO::Buffer 0x00000001014a0000+4 MAPPED READONLY&gt;
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_readonly?'><a href="#readonly%3F-instance_method" title="IO::Buffer#readonly? (method)">readonly?</a></span>   <span class='comment'># =&gt; true
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_get_string'><a href="#get_string-instance_method" title="IO::Buffer#get_string (method)">get_string</a></span>
<span class='comment'># =&gt; &quot;test&quot;
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_string'><a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">set_string</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>b</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>0</span>)
<span class='comment'># `set_string&#39;: Buffer is not writable! (IO::Buffer::AccessError)
</span>
<span class='comment'># create read/write mapping: length 4 bytes, offset 0, flags 0
</span><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_map'>map</span>(<span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_open'><a href="../File.html#open-class_method" title="File.open (method)">open</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test.txt</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>r+</span><span class='tstring_end'>&#39;</span></span>)<span class='comma'>,</span> <span class='int'>4</span><span class='comma'>,</span> <span class='int'>0</span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_string'><a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">set_string</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>b</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>0</span>)
<span class='comment'># =&gt; 1
</span>
<span class='comment'># Check it
</span><span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_read'><a href="../IO.html#read-class_method" title="IO.read (method)">read</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test.txt</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; &quot;best&quot;</span></code></pre>

<p>Note that some operating systems may not have cache coherency between mapped buffers and file reads.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L484-L524'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='484' data-end='524'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 484</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_map(int argc, VALUE *argv, VALUE klass)
{
    rb_check_arity(argc, 1, 4);

    // We might like to handle a string path?
    VALUE io = argv[0];

    size_t size;
    if (argc &gt;= 2 &amp;&amp; !RB_NIL_P(argv[1])) {
        size = RB_NUM2SIZE(argv[1]);
    }
    else {
        rb_off_t file_size = rb_file_size(io);

        // Compiler can confirm that we handled file_size &lt; 0 case:
        if (file_size &lt; 0) {
            rb_raise(rb_eArgError, &quot;Invalid negative file size!&quot;);
        }
        // Here, we assume that file_size is positive:
        else if ((uintmax_t)file_size &gt; SIZE_MAX) {
            rb_raise(rb_eArgError, &quot;File larger than address space!&quot;);
        }
        else {
            // This conversion should be safe:
            size = (size_t)file_size;
        }
    }

    rb_off_t offset = 0;
    if (argc &gt;= 3) {
        offset = NUM2OFFT(argv[2]);
    }

    enum rb_io_buffer_flags flags = 0;
    if (argc &gt;= 4) {
        flags = RB_NUM2UINT(argv[3]);
    }

    return rb_io_buffer_map(io, size, offset, flags);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="size_of-class_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>.<strong>size_of</strong>(data_type)  &#x21d2; <code>byte</code> <a href="#size-instance_method" title="IO::Buffer#size (method)">size</a> </span>
      <span class='overload'>.<strong>size_of</strong>(array of data_type)  &#x21d2; <code>byte</code> <a href="#size-instance_method" title="IO::Buffer#size (method)">size</a> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the size of the given data type(s) in bytes.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_size_of'>size_of</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_u32'>u32</span>) <span class='comment'># =&gt; 4
</span><span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_size_of'>size_of</span>([<span class='symbeg'>:</span><span class='id identifier rubyid_u32'>u32</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_u32'>u32</span>]) <span class='comment'># =&gt; 8</span></code></pre>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L1621-L1633'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1621' data-end='1633'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 1621</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_size_of(VALUE klass, VALUE data_type)
{
    if (RB_TYPE_P(data_type, T_ARRAY)) {
        size_t total = 0;
        for (long i = 0; i &lt; RARRAY_LEN(data_type); i++) {
            total += io_buffer_data_type_size(RB_SYM2ID(RARRAY_AREF(data_type, i)));
        }
        return SIZET2NUM(total);
    } else {
        return SIZET2NUM(io_buffer_data_type_size(RB_SYM2ID(data_type)));
    }
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Attribute Details</h2>
<section class='method_details first' id="empty?-instance_method">
  <h3 class='signature ro first'>
    #<strong>empty?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>If the buffer has 0 size: it is created by <a href="#new-class_method" title="IO::Buffer.new (method)">.new</a> with size 0, or with <a href="#for-class_method" title="IO::Buffer.for (method)">.for</a> from an empty string. (Note that empty files can’t be mapped, so the buffer created with <a href="#map-class_method" title="IO::Buffer.map (method)">.map</a> will never be empty.)</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L824-L831'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='824' data-end='831'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 824</span></pre>
<pre class='code cpp'>

static VALUE
rb_io_buffer_empty_p(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    return RBOOL(data-&gt;size == 0);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="external?-instance_method">
  <h3 class='signature ro'>
    #<strong>external?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>The buffer is <em>external</em> if it references the memory which is not allocated or mapped by the buffer itself.</p>

<p>A buffer created using <a href="#for-class_method" title="IO::Buffer.for (method)">.for</a> has an external reference to the string’s memory.</p>

<p>External buffer can’t be resized.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L844-L851'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='844' data-end='851'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 844</span></pre>
<pre class='code cpp'>

static VALUE
rb_io_buffer_external_p(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    return RBOOL(data-&gt;flags &amp; RB_IO_BUFFER_EXTERNAL);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="internal?-instance_method">
  <h3 class='signature ro'>
    #<strong>internal?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>If the buffer is <em>internal</em>, meaning it references memory allocated by the buffer itself.</p>

<p>An internal buffer is not associated with any external memory (e.g. string) or file mapping.</p>

<p>Internal buffers are created using <a href="#new-class_method" title="IO::Buffer.new (method)">.new</a> and is the default when the requested size is less than the <a href="#PAGE_SIZE-constant" title="IO::Buffer::PAGE_SIZE (constant)">PAGE_SIZE</a> and it was not requested to be mapped on creation.</p>

<p>Internal buffers can be resized, and such an operation will typically invalidate all slices, but not always.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L869-L876'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='869' data-end='876'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 869</span></pre>
<pre class='code cpp'>

static VALUE
rb_io_buffer_internal_p(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    return RBOOL(data-&gt;flags &amp; RB_IO_BUFFER_INTERNAL);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="locked-instance_method">
  <h3 class='signature ro'>
    #<strong>locked</strong>   <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Allows to process a buffer in exclusive way, for concurrency-safety. While the block is performed, the buffer is considered locked, and no other code can enter the lock. Also, locked buffer can’t be changed with <a href="#resize-instance_method" title="IO::Buffer#resize (method)">#resize</a> or <a href="#free-instance_method" title="IO::Buffer#free (method)">#free</a>.</p>

<p>The following operations acquire a lock: <a href="#resize-instance_method" title="IO::Buffer#resize (method)">#resize</a>, <a href="#free-instance_method" title="IO::Buffer#free (method)">#free</a>.</p>

<p>Locking is not thread safe. It is designed as a safety net around non-blocking system calls. You can only share a buffer between threads with appropriate synchronisation techniques.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="IO::Buffer.new (method)">new</a></span>(<span class='int'>4</span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_locked?'><a href="#locked%3F-instance_method" title="IO::Buffer#locked? (method)">locked?</a></span> <span class='comment'>#=&gt; false
</span>
<span class='const'><a href="../Fiber.html" title="Fiber (class)">Fiber</a></span>.<span class='id identifier rubyid_schedule'><a href="../Fiber.html#schedule-class_method" title="Fiber.schedule (method)">schedule</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_locked'>locked</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_write'><a href="#write-instance_method" title="IO::Buffer#write (method)">write</a></span>(<span class='id identifier rubyid_io'>io</span>) <span class='comment'># theoretical system call interface
</span>  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='const'><a href="../Fiber.html" title="Fiber (class)">Fiber</a></span>.<span class='id identifier rubyid_schedule'><a href="../Fiber.html#schedule-class_method" title="Fiber.schedule (method)">schedule</a></span> <span class='kw'>do</span>
  <span class='comment'># in `locked&#39;: Buffer already locked! (IO::Buffer::LockedError)
</span>  <span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_locked'>locked</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_string'><a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">set_string</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>test</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='int'>0</span>)
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L1040-L1057'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1040' data-end='1057'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 1040</span></pre>
<pre class='code cpp'>

VALUE
rb_io_buffer_locked(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    if (data-&gt;flags &amp; RB_IO_BUFFER_LOCKED) {
        rb_raise(rb_eIOBufferLockedError, &quot;Buffer already locked!&quot;);
    }

    data-&gt;flags |= RB_IO_BUFFER_LOCKED;

    VALUE result = rb_yield(self);

    data-&gt;flags &amp;= ~RB_IO_BUFFER_LOCKED;

    return result;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="locked?-instance_method">
  <h3 class='signature ro'>
    #<strong>locked?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>If the buffer is <em>locked</em>, meaning it is inside <a href="#locked-instance_method" title="IO::Buffer#locked (method)">#locked</a> block execution. Locked buffer can’t be resized or freed, and another lock can’t be acquired on it.</p>

<p>Locking is not thread safe, but is a semantic used to ensure buffers don’t move while being used by a system call.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_locked'><a href="#locked-instance_method" title="IO::Buffer#locked (method)">locked</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_write'><a href="#write-instance_method" title="IO::Buffer#write (method)">write</a></span>(<span class='id identifier rubyid_io'>io</span>) <span class='comment'># theoretical system call interface
</span><span class='kw'>end</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L932-L939'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='932' data-end='939'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 932</span></pre>
<pre class='code cpp'>

static VALUE
rb_io_buffer_locked_p(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    return RBOOL(data-&gt;flags &amp; RB_IO_BUFFER_LOCKED);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="mapped?-instance_method">
  <h3 class='signature ro'>
    #<strong>mapped?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>If the buffer is <em>mapped</em>, meaning it references memory mapped by the buffer.</p>

<p>Mapped buffers are either anonymous, if created by <a href="#new-class_method" title="IO::Buffer.new (method)">.new</a> with the <a href="#MAPPED-constant" title="IO::Buffer::MAPPED (constant)">MAPPED</a> flag or if the size was at least <a href="#PAGE_SIZE-constant" title="IO::Buffer::PAGE_SIZE (constant)">PAGE_SIZE</a>, or backed by a file if created with <a href="#map-class_method" title="IO::Buffer.map (method)">.map</a>.</p>

<p>Mapped buffers can usually be resized, and such an operation will typically invalidate all slices, but not always.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L891-L898'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='891' data-end='898'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 891</span></pre>
<pre class='code cpp'>

static VALUE
rb_io_buffer_mapped_p(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    return RBOOL(data-&gt;flags &amp; RB_IO_BUFFER_MAPPED);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="null?-instance_method">
  <h3 class='signature ro'>
    #<strong>null?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>If the buffer was freed with <a href="#free-instance_method" title="IO::Buffer#free (method)">#free</a> or was never allocated in the first place.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L808-L815'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='808' data-end='815'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 808</span></pre>
<pre class='code cpp'>

static VALUE
rb_io_buffer_null_p(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    return RBOOL(data-&gt;base == NULL);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="readonly?-instance_method">
  <h3 class='signature ro'>
    #<strong>readonly?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>If the buffer is <em>read only</em>, meaning the buffer cannot be modified using <a href="#set_value-instance_method" title="IO::Buffer#set_value (method)">#set_value</a>, <a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">#set_string</a> or <a href="#copy-instance_method" title="IO::Buffer#copy (method)">#copy</a> and similar.</p>

<p>Frozen strings and read-only files create read-only buffers.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L958-L962'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='958' data-end='962'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 958</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_readonly_p(VALUE self)
{
    return RBOOL(rb_io_buffer_readonly_p(self));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="shared?-instance_method">
  <h3 class='signature ro'>
    #<strong>shared?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>If the buffer is <em>shared</em>, meaning it references memory that can be shared with other processes (and thus might change without being modified locally).</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L907-L914'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='907' data-end='914'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 907</span></pre>
<pre class='code cpp'>

static VALUE
rb_io_buffer_shared_p(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    return RBOOL(data-&gt;flags &amp; RB_IO_BUFFER_SHARED);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="valid?-instance_method">
  <h3 class='signature ro'>
    #<strong>valid?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns whether the buffer data is accessible.</p>

<p>A buffer becomes invalid if it is a slice of another buffer which has been freed.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L793-L800'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='793' data-end='800'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 793</span></pre>
<pre class='code cpp'>

static VALUE
rb_io_buffer_valid_p(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    return RBOOL(io_buffer_validate(data));
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="&-instance_method">
  <h3 class='signature  first'>
    #<strong>&amp;</strong>(mask)  &#x21d2; <code>Buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Generate a new buffer the same size as the source by applying the binary AND operation to the source, using the mask, repeating as necessary.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>1234567890</span><span class='tstring_end'>&quot;</span></span>) <span class='op'>&amp;</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xFF\x00\x00\xFF</span><span class='tstring_end'>&quot;</span></span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x00005589b2758480+4 INTERNAL&gt;
</span><span class='comment'># 0x00000000  31 00 00 34 35 00 00 38 39 00                   1..45..89.</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L2827-L2845'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2827' data-end='2845'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 2827</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_and(VALUE self, VALUE mask)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    struct rb_io_buffer *mask_data = NULL;
    TypedData_Get_Struct(mask, struct rb_io_buffer, &amp;rb_io_buffer_type, mask_data);

    io_buffer_check_mask(mask_data);

    VALUE output = rb_io_buffer_new(NULL, data-&gt;size, io_flags_for_size(data-&gt;size));
    struct rb_io_buffer *output_data = NULL;
    TypedData_Get_Struct(output, struct rb_io_buffer, &amp;rb_io_buffer_type, output_data);

    memory_and(output_data-&gt;base, data-&gt;base, data-&gt;size, mask_data-&gt;base, mask_data-&gt;size);

    return output;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="<=>-instance_method">
  <h3 class='signature '>
    #<strong>&lt;=&gt;</strong>(other)  &#x21d2; <code>Boolean</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Buffers are compared by size and exact contents of the memory they are referencing using <code>memcmp</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L1456-L1474'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1456' data-end='1474'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 1456</span></pre>
<pre class='code cpp'>

static VALUE
rb_io_buffer_compare(VALUE self, VALUE other)
{
    const void *ptr1, *ptr2;
    size_t size1, size2;

    rb_io_buffer_get_bytes_for_reading(self, &amp;ptr1, &amp;size1);
    rb_io_buffer_get_bytes_for_reading(other, &amp;ptr2, &amp;size2);

    if (size1 &lt; size2) {
        return RB_INT2NUM(-1);
    }

    if (size1 &gt; size2) {
        return RB_INT2NUM(1);
    }

    return RB_INT2NUM(memcmp(ptr1, ptr2, size1));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="^-instance_method">
  <h3 class='signature '>
    #<strong>^</strong>(mask)  &#x21d2; <code>Buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Generate a new buffer the same size as the source by applying the binary XOR operation to the source, using the mask, repeating as necessary.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>1234567890</span><span class='tstring_end'>&quot;</span></span>) <span class='op'>^</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xFF\x00\x00\xFF</span><span class='tstring_end'>&quot;</span></span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x000055a2d5d10480+10 INTERNAL&gt;
</span><span class='comment'># 0x00000000  ce 32 33 cb ca 36 37 c7 c6 30                   .23..67..0</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L2907-L2925'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2907' data-end='2925'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 2907</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_xor(VALUE self, VALUE mask)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    struct rb_io_buffer *mask_data = NULL;
    TypedData_Get_Struct(mask, struct rb_io_buffer, &amp;rb_io_buffer_type, mask_data);

    io_buffer_check_mask(mask_data);

    VALUE output = rb_io_buffer_new(NULL, data-&gt;size, io_flags_for_size(data-&gt;size));
    struct rb_io_buffer *output_data = NULL;
    TypedData_Get_Struct(output, struct rb_io_buffer, &amp;rb_io_buffer_type, output_data);

    memory_xor(output_data-&gt;base, data-&gt;base, data-&gt;size, mask_data-&gt;base, mask_data-&gt;size);

    return output;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="and!-instance_method">
  <h3 class='signature '>
    #<strong>and!</strong>(mask)  &#x21d2; <code>Buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Modify the source buffer in place by applying the binary AND operation to the source, using the mask, repeating as necessary.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_source'>source</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>1234567890</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_dup'><a href="../Object.html#dup-instance_method" title="Object#dup (method)">dup</a></span> <span class='comment'># Make a read/write copy.
</span><span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x000056307a0d0c20+10 INTERNAL&gt;
</span><span class='comment'># 0x00000000  31 32 33 34 35 36 37 38 39 30                   1234567890
</span>
<span class='id identifier rubyid_source'>source</span>.<span class='id identifier rubyid_and!'>and!</span>(<span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xFF\x00\x00\xFF</span><span class='tstring_end'>&quot;</span></span>))
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x000056307a0d0c20+10 INTERNAL&gt;
</span><span class='comment'># 0x00000000  31 00 00 34 35 00 00 38 39 00                   1..45..89.</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3004-L3023'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3004' data-end='3023'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 3004</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_and_inplace(VALUE self, VALUE mask)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    struct rb_io_buffer *mask_data = NULL;
    TypedData_Get_Struct(mask, struct rb_io_buffer, &amp;rb_io_buffer_type, mask_data);

    io_buffer_check_mask(mask_data);
    io_buffer_check_overlaps(data, mask_data);

    void *base;
    size_t size;
    io_buffer_get_bytes_for_writing(data, &amp;base, &amp;size);

    memory_and_inplace(base, size, mask_data-&gt;base, mask_data-&gt;size);

    return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="clear-instance_method">
  <h3 class='signature '>
    #<strong>clear</strong>(value = 0, [offset, [length]])  &#x21d2; <code>self</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Fill buffer with <code>value</code>, starting with <code>offset</code> and going for <code>length</code> bytes.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt;
</span><span class='comment'>#   &lt;IO::Buffer 0x00007fca40087c38+4 SLICE&gt;
</span><span class='comment'>#   0x00000000  74 65 73 74         test
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_clear'>clear</span>
<span class='comment'># =&gt;
</span><span class='comment'>#   &lt;IO::Buffer 0x00007fca40087c38+4 SLICE&gt;
</span><span class='comment'>#   0x00000000  00 00 00 00         ....
</span>
<span class='id identifier rubyid_buf'>buf</span>.<span class='id identifier rubyid_clear'>clear</span>(<span class='int'>1</span>) <span class='comment'># fill with 1
</span><span class='comment'># =&gt;
</span><span class='comment'>#   &lt;IO::Buffer 0x00007fca40087c38+4 SLICE&gt;
</span><span class='comment'>#   0x00000000  01 01 01 01         ....
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_clear'>clear</span>(<span class='int'>2</span><span class='comma'>,</span> <span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>) <span class='comment'># fill with 2, starting from offset 1, for 2 bytes
</span><span class='comment'># =&gt;
</span><span class='comment'>#   &lt;IO::Buffer 0x00007fca40087c38+4 SLICE&gt;
</span><span class='comment'>#   0x00000000  01 02 02 01         ....
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_clear'>clear</span>(<span class='int'>2</span><span class='comma'>,</span> <span class='int'>1</span>) <span class='comment'># fill with 2, starting from offset 1
</span><span class='comment'># =&gt;
</span><span class='comment'>#   &lt;IO::Buffer 0x00007fca40087c38+4 SLICE&gt;
</span><span class='comment'>#   0x00000000  01 02 02 02         ....</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L2326-L2355'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2326' data-end='2355'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 2326</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_clear(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 0, 3);

    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    uint8_t value = 0;
    if (argc &gt;= 1) {
        value = NUM2UINT(argv[0]);
    }

    size_t offset = 0;
    if (argc &gt;= 2) {
        offset = NUM2SIZET(argv[1]);
    }

    size_t length;
    if (argc &gt;= 3) {
        length = NUM2SIZET(argv[2]);
    }
    else {
        length = data-&gt;size - offset;
    }

    rb_io_buffer_clear(self, value, offset, length);

    return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="copy-instance_method">
  <h3 class='signature '>
    #<strong>copy</strong>(source, [offset, [length, [source_offset]]])  &#x21d2; <a href="#size-instance_method" title="IO::Buffer#size (method)">size</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Efficiently copy data from a source <code>Buffer</code> into the buffer, at <code>offset</code> using <code>memcpy</code>. For copying <a href="../String.html" title="String (class)"><code>::String</code></a> instances, see <a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">#set_string</a>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="IO::Buffer.new (method)">new</a></span>(<span class='int'>32</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000555f5ca22520+32 INTERNAL&gt;
</span><span class='comment'># 0x00000000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
</span><span class='comment'># 0x00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................  *
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_copy'>copy</span>(<span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>test</span><span class='tstring_end'>&quot;</span></span>)<span class='comma'>,</span> <span class='int'>8</span>)
<span class='comment'># =&gt; 4 -- size of data copied
</span><span class='id identifier rubyid_buffer'>buffer</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000555f5cf8fe40+32 INTERNAL&gt;
</span><span class='comment'># 0x00000000  00 00 00 00 00 00 00 00 74 65 73 74 00 00 00 00 ........test....
</span><span class='comment'># 0x00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ *</span></code></pre>

<p><code>#copy</code> can be used to put data into strings associated with buffer:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_string'>string</span><span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>data:    </span><span class='tstring_end'>&quot;</span></span>
<span class='comment'># =&gt; &quot;data:    &quot;
</span><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='id identifier rubyid_string'>string</span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_copy'>copy</span>(<span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>test</span><span class='tstring_end'>&quot;</span></span>)<span class='comma'>,</span> <span class='int'>5</span>)
<span class='comment'># =&gt; 4
</span><span class='id identifier rubyid_string'>string</span>
<span class='comment'># =&gt; &quot;data:test&quot;</span></code></pre>

<p>Attempt to copy into a read-only buffer will fail:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_write'><a href="../IO.html#write-class_method" title="IO.write (method)">write</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test.txt</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_map'><a href="#map-class_method" title="IO::Buffer.map (method)">map</a></span>(<span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_open'><a href="../File.html#open-class_method" title="File.open (method)">open</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test.txt</span><span class='tstring_end'>&#39;</span></span>)<span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span><span class='op'>::</span><span class='const'><a href="#READONLY-constant" title="IO::Buffer::READONLY (constant)">READONLY</a></span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_copy'>copy</span>(<span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>test</span><span class='tstring_end'>&quot;</span></span>)<span class='comma'>,</span> <span class='int'>8</span>)
<span class='comment'># in `copy&#39;: Buffer is not writable! (IO::Buffer::AccessError)</span></code></pre>

<p>See <a href="#map-class_method" title="IO::Buffer.map (method)">.map</a> for details of creation of mutable file mappings, this will work:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_map'><a href="#map-class_method" title="IO::Buffer.map (method)">map</a></span>(<span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_open'><a href="../File.html#open-class_method" title="File.open (method)">open</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test.txt</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>r+</span><span class='tstring_end'>&#39;</span></span>))
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_copy'>copy</span>(<span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>boom</span><span class='tstring_end'>&quot;</span></span>)<span class='comma'>,</span> <span class='int'>0</span>)
<span class='comment'># =&gt; 4
</span><span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_read'><a href="../IO.html#read-class_method" title="IO.read (method)">read</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test.txt</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; &quot;boom&quot;</span></code></pre>

<p>Attempt to copy the data which will need place outside of buffer’s bounds will fail:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="IO::Buffer.new (method)">new</a></span>(<span class='int'>2</span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_copy'>copy</span>(<span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span>)<span class='comma'>,</span> <span class='int'>0</span>)
<span class='comment'># in `copy&#39;: Specified offset+length exceeds source size! (ArgumentError)</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L2174-L2189'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2174' data-end='2189'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 2174</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_copy(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, 4);

    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    VALUE source = argv[0];
    const void *source_base;
    size_t source_size;

    rb_io_buffer_get_bytes_for_reading(source, &amp;source_base, &amp;source_size);

    return io_buffer_copy_from(data, source_base, source_size, argc-1, argv+1);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="free-instance_method">
  <h3 class='signature '>
    #<strong>free</strong>  &#x21d2; <code>self</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>If the buffer references memory, release it back to the operating system.</p>
<ul><li>
<p>for a <em>mapped</em> buffer (e.g. from file): unmap.</p>
</li><li>
<p>for a buffer created from scratch: free memory.</p>
</li><li>
<p>for a buffer created from string: undo the association.</p>
</li></ul>

<p>After the buffer is freed, no further operations can’t be performed on it.</p>

<p>You can resize a freed buffer to re-allocate it.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_free'>free</span>
<span class='comment'># =&gt; #&lt;IO::Buffer 0x0000000000000000+0 NULL&gt;
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_get_value'><a href="#get_value-instance_method" title="IO::Buffer#get_value (method)">get_value</a></span>(<span class='symbeg'>:</span><span class='const'>U8</span><span class='comma'>,</span> <span class='int'>0</span>)
<span class='comment'># in `get_value&#39;: The buffer is not allocated! (IO::Buffer::AllocationError)
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_get_string'><a href="#get_string-instance_method" title="IO::Buffer#get_string (method)">get_string</a></span>
<span class='comment'># in `get_string&#39;: The buffer is not allocated! (IO::Buffer::AllocationError)
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_null?'><a href="#null%3F-instance_method" title="IO::Buffer#null? (method)">null?</a></span>
<span class='comment'># =&gt; true</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L1086-L1099'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1086' data-end='1099'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 1086</span></pre>
<pre class='code cpp'>

VALUE
rb_io_buffer_free(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    if (data-&gt;flags &amp; RB_IO_BUFFER_LOCKED) {
        rb_raise(rb_eIOBufferLockedError, &quot;Buffer is locked!&quot;);
    }

    io_buffer_free(data);

    return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="get_string-instance_method">
  <h3 class='signature '>
    #<strong>get_string</strong>([offset, [length, [encoding]]])  &#x21d2; <a href="../String.html" title="String (class)">String</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Read a chunk or all of the buffer into a string, in the specified <code>encoding</code>. If no encoding is provided <code>Encoding::BINARY</code> is used.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_get_string'>get_string</span>
<span class='comment'># =&gt; &quot;test&quot;
</span><span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_get_string'>get_string</span>(<span class='int'>2</span>)
<span class='comment'># =&gt; &quot;st&quot;
</span><span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_get_string'>get_string</span>(<span class='int'>2</span><span class='comma'>,</span> <span class='int'>1</span>)
<span class='comment'># =&gt; &quot;s&quot;</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L2205-L2239'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2205' data-end='2239'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 2205</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_get_string(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 0, 3);

    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    const void *base;
    size_t size;
    io_buffer_get_bytes_for_reading(data, &amp;base, &amp;size);

    size_t offset = 0;
    size_t length = size;
    rb_encoding *encoding = rb_ascii8bit_encoding();

    if (argc &gt;= 1) {
        offset = NUM2SIZET(argv[0]);
    }

    if (argc &gt;= 2 &amp;&amp; !RB_NIL_P(argv[1])) {
        length = NUM2SIZET(argv[1]);
    }
    else {
        length = size - offset;
    }

    if (argc &gt;= 3) {
        encoding = rb_find_encoding(argv[2]);
    }

    io_buffer_validate_range(data, offset, length);

    return rb_enc_str_new((const char*)base + offset, length, encoding);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="get_value-instance_method">
  <h3 class='signature '>
    #<strong>get_value</strong>(data_type, offset)  &#x21d2; <a href="../Numeric.html" title="Numeric (class)">Numeric</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Read from buffer a value of <code>type</code> at <code>offset</code>. <code>data_type</code> should be one of symbols:</p>
<ul><li>
<p><code>:U8</code>: unsigned integer, 1 byte</p>
</li><li>
<p><code>:S8</code>: signed integer, 1 byte</p>
</li><li>
<p><code>:u16</code>: unsigned integer, 2 bytes, little-endian</p>
</li><li>
<p><code>:U16</code>: unsigned integer, 2 bytes, big-endian</p>
</li><li>
<p><code>:s16</code>: signed integer, 2 bytes, little-endian</p>
</li><li>
<p><code>:S16</code>: signed integer, 2 bytes, big-endian</p>
</li><li>
<p><code>:u32</code>: unsigned integer, 4 bytes, little-endian</p>
</li><li>
<p><code>:U32</code>: unsigned integer, 4 bytes, big-endian</p>
</li><li>
<p><code>:s32</code>: signed integer, 4 bytes, little-endian</p>
</li><li>
<p><code>:S32</code>: signed integer, 4 bytes, big-endian</p>
</li><li>
<p><code>:u64</code>: unsigned integer, 8 bytes, little-endian</p>
</li><li>
<p><code>:U64</code>: unsigned integer, 8 bytes, big-endian</p>
</li><li>
<p><code>:s64</code>: signed integer, 8 bytes, little-endian</p>
</li><li>
<p><code>:S64</code>: signed integer, 8 bytes, big-endian</p>
</li><li>
<p><code>:f32</code>: float, 4 bytes, little-endian</p>
</li><li>
<p><code>:F32</code>: float, 4 bytes, big-endian</p>
</li><li>
<p><code>:f64</code>: double, 8 bytes, little-endian</p>
</li><li>
<p><code>:F64</code>: double, 8 bytes, big-endian</p>
</li></ul>

<p>A data type refers specifically to the type of binary data that is stored in the buffer. For example, a <code>:u32</code> data type is a 32-bit unsigned integer in little-endian format.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_string'>string</span> <span class='op'>=</span> [<span class='float'>1.5</span>].<span class='id identifier rubyid_pack'>pack</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>f</span><span class='tstring_end'>&#39;</span></span>)
<span class='comment'># =&gt; &quot;\x00\x00\xC0?&quot;
</span><span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='id identifier rubyid_string'>string</span>).<span class='id identifier rubyid_get_value'>get_value</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_f32'>f32</span><span class='comma'>,</span> <span class='int'>0</span>)
<span class='comment'># =&gt; 1.5</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L1702-L1712'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1702' data-end='1712'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 1702</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_get_value(VALUE self, VALUE type, VALUE _offset)
{
    const void *base;
    size_t size;
    size_t offset = NUM2SIZET(_offset);

    rb_io_buffer_get_bytes_for_reading(self, &amp;base, &amp;size);

    return rb_io_buffer_get_value(base, size, RB_SYM2ID(type), &amp;offset);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="get_values-instance_method">
  <h3 class='signature '>
    #<strong>get_values</strong>(data_types, offset)  &#x21d2; <a href="../Array.html" title="Array (class)">Array</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Similar to <a href="#get_value-instance_method" title="IO::Buffer#get_value (method)">#get_value</a>, except that it can handle multiple data types and returns an array of values.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_string'>string</span> <span class='op'>=</span> [<span class='float'>1.5</span><span class='comma'>,</span> <span class='float'>2.5</span>].<span class='id identifier rubyid_pack'>pack</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>ff</span><span class='tstring_end'>&#39;</span></span>)
<span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='id identifier rubyid_string'>string</span>).<span class='id identifier rubyid_get_values'>get_values</span>([<span class='symbeg'>:</span><span class='id identifier rubyid_f32'>f32</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_f32'>f32</span>]<span class='comma'>,</span> <span class='int'>0</span>)
<span class='comment'># =&gt; [1.5, 2.5]</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L1726-L1748'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1726' data-end='1748'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 1726</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_get_values(VALUE self, VALUE data_types, VALUE _offset)
{
    size_t offset = NUM2SIZET(_offset);

    const void *base;
    size_t size;
    rb_io_buffer_get_bytes_for_reading(self, &amp;base, &amp;size);

    if (!RB_TYPE_P(data_types, T_ARRAY)) {
        rb_raise(rb_eArgError, &quot;Argument data_types should be an array!&quot;);
    }

    VALUE array = rb_ary_new_capa(RARRAY_LEN(data_types));

    for (long i = 0; i &lt; RARRAY_LEN(data_types); i++) {
        VALUE type = rb_ary_entry(data_types, i);
        VALUE value = rb_io_buffer_get_value(base, size, RB_SYM2ID(type), &amp;offset);
        rb_ary_push(array, value);
    }

    return array;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="hexdump-instance_method">
  <h3 class='signature '>
    #<strong>hexdump</strong>  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L735-L750'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='735' data-end='750'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 735</span></pre>
<pre class='code cpp'>

static VALUE
rb_io_buffer_hexdump(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    VALUE result = Qnil;

    if (io_buffer_validate(data) &amp;&amp; data-&gt;base) {
        result = rb_str_buf_new(data-&gt;size*3 + (data-&gt;size/16)*12 + 1);

        io_buffer_hexdump(result, 16, data-&gt;base, data-&gt;size, 1);
    }

    return result;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="not!-instance_method">
  <h3 class='signature '>
    #<strong>not!</strong>  &#x21d2; <code>Buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Modify the source buffer in place by applying the binary NOT operation to the source.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_source'>source</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>1234567890</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_dup'><a href="../Object.html#dup-instance_method" title="Object#dup (method)">dup</a></span> <span class='comment'># Make a read/write copy.
</span><span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x000056307a33a450+10 INTERNAL&gt;
</span><span class='comment'># 0x00000000  31 32 33 34 35 36 37 38 39 30                   1234567890
</span>
<span class='id identifier rubyid_source'>source</span>.<span class='id identifier rubyid_not!'>not!</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x000056307a33a450+10 INTERNAL&gt;
</span><span class='comment'># 0x00000000  ce cd cc cb ca c9 c8 c7 c6 cf                   ..........</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3142-L3155'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3142' data-end='3155'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 3142</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_not_inplace(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    void *base;
    size_t size;
    io_buffer_get_bytes_for_writing(data, &amp;base, &amp;size);

    memory_not_inplace(base, size);

    return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="or!-instance_method">
  <h3 class='signature '>
    #<strong>or!</strong>(mask)  &#x21d2; <code>Buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Modify the source buffer in place by applying the binary OR operation to the source, using the mask, repeating as necessary.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_source'>source</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>1234567890</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_dup'><a href="../Object.html#dup-instance_method" title="Object#dup (method)">dup</a></span> <span class='comment'># Make a read/write copy.
</span><span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x000056307a272350+10 INTERNAL&gt;
</span><span class='comment'># 0x00000000  31 32 33 34 35 36 37 38 39 30                   1234567890
</span>
<span class='id identifier rubyid_source'>source</span>.<span class='id identifier rubyid_or!'>or!</span>(<span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xFF\x00\x00\xFF</span><span class='tstring_end'>&quot;</span></span>))
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x000056307a272350+10 INTERNAL&gt;
</span><span class='comment'># 0x00000000  ff 32 33 ff ff 36 37 ff ff 30                   .23..67..0</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3050-L3069'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3050' data-end='3069'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 3050</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_or_inplace(VALUE self, VALUE mask)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    struct rb_io_buffer *mask_data = NULL;
    TypedData_Get_Struct(mask, struct rb_io_buffer, &amp;rb_io_buffer_type, mask_data);

    io_buffer_check_mask(mask_data);
    io_buffer_check_overlaps(data, mask_data);

    void *base;
    size_t size;
    io_buffer_get_bytes_for_writing(data, &amp;base, &amp;size);

    memory_or_inplace(base, size, mask_data-&gt;base, mask_data-&gt;size);

    return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="read-instance_method">
  <h3 class='signature '>
    #<strong>read</strong>(io, length, [offset])  &#x21d2; read <code>length</code>, -<code>errno</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Read at most <code>length</code> bytes from <code>io</code> into the buffer, starting at <code>offset</code>. If an error occurs, return <code>-errno</code>.</p>

<p>If <code>offset</code> is not given, read from the beginning of the buffer.</p>

<p>If <code>length</code> is 0, read nothing.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span>) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_buffer'>buffer</span><span class='op'>|</span>
  <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_buffer'>buffer</span>
  <span class='comment'># =&gt;
</span>  <span class='comment'># &lt;IO::Buffer 0x00007fca40087c38+4 SLICE&gt;
</span>  <span class='comment'># 0x00000000  74 65 73 74         test
</span>  <span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_read'>read</span>(<span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_open'><a href="../File.html#open-class_method" title="File.open (method)">open</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>/dev/urandom</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rb</span><span class='tstring_end'>&#39;</span></span>)<span class='comma'>,</span> <span class='int'>2</span>)
  <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_buffer'>buffer</span>
  <span class='comment'># =&gt;
</span>  <span class='comment'># &lt;IO::Buffer 0x00007f3bc65f2a58+4 EXTERNAL SLICE&gt;
</span>  <span class='comment'># 0x00000000  05 35 73 74         .5st
</span><span class='kw'>end</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L2454-L2476'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2454' data-end='2476'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 2454</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_read(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 2, 3);

    VALUE io = argv[0];

    if (rb_int_negative_p(argv[1])) {
        rb_raise(rb_eArgError, &quot;Length can&#39;t be negative!&quot;);
    }
    size_t length = NUM2SIZET(argv[1]);

    size_t offset = 0;
    if (argc &gt;= 3) {
        if (rb_int_negative_p(argv[2])) {
            rb_raise(rb_eArgError, &quot;Offset can&#39;t be negative!&quot;);
        }

        offset = NUM2SIZET(argv[2]);
    }

    return rb_io_buffer_read(self, io, length, offset);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="resize-instance_method">
  <h3 class='signature '>
    #<strong>resize</strong>(new_size)  &#x21d2; <code>self</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Resizes a buffer to a <code>new_size</code> bytes, preserving its content. Depending on the old and new size, the memory area associated with the buffer might be either extended, or rellocated at different address with content being copied.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="IO::Buffer.new (method)">new</a></span>(<span class='int'>4</span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_string'><a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">set_string</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>test</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='int'>0</span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_resize'>resize</span>(<span class='int'>8</span>) <span class='comment'># resize to 8 bytes
</span><span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000555f5d1a1630+8 INTERNAL&gt;
</span><span class='comment'># 0x00000000  74 65 73 74 00 00 00 00                         test....</span></code></pre>

<p>External buffer (created with <a href="#for-class_method" title="IO::Buffer.for (method)">.for</a>), and locked buffer can not be resized.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L1442-L1448'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1442' data-end='1448'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 1442</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_resize(VALUE self, VALUE size)
{
    rb_io_buffer_resize(self, NUM2SIZET(size));

    return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="set_string-instance_method">
  <h3 class='signature '>
    #<strong>set_string</strong>(string, [offset, [length, [source_offset]]])  &#x21d2; <a href="#size-instance_method" title="IO::Buffer#size (method)">size</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Efficiently copy data from a source <a href="../String.html" title="String (class)"><code>::String</code></a> into the buffer, at <code>offset</code> using <code>memcpy</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buf'>buf</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="IO::Buffer.new (method)">new</a></span>(<span class='int'>8</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000557412714a20+8 INTERNAL&gt;
</span><span class='comment'># 0x00000000  00 00 00 00 00 00 00 00                         ........
</span>
<span class='comment'># set data starting from offset 1, take 2 bytes starting from string&#39;s
</span><span class='comment'># second
</span><span class='id identifier rubyid_buf'>buf</span>.<span class='id identifier rubyid_set_string'>set_string</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>1</span>)
<span class='comment'># =&gt; 2
</span><span class='id identifier rubyid_buf'>buf</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000557412714a20+8 INTERNAL&gt;
</span><span class='comment'># 0x00000000  00 65 73 00 00 00 00 00                         .es.....</span></code></pre>

<p>See also <a href="#copy-instance_method" title="IO::Buffer#copy (method)">#copy</a> for examples of how buffer writing might be used for changing associated strings and files.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L2264-L2278'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2264' data-end='2278'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 2264</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_set_string(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, 4);

    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    VALUE string = rb_str_to_str(argv[0]);

    const void *source_base = RSTRING_PTR(string);
    size_t source_size = RSTRING_LEN(string);

    return io_buffer_copy_from(data, source_base, source_size, argc-1, argv+1);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="set_value-instance_method">
  <h3 class='signature '>
    #<strong>set_value</strong>(type, offset, value)  &#x21d2; <code>offset</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Write to a buffer a <code>value</code> of <code>type</code> at <code>offset</code>. <code>type</code> should be one of symbols described in <a href="#get_value-instance_method" title="IO::Buffer#get_value (method)">#get_value</a>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="IO::Buffer.new (method)">new</a></span>(<span class='int'>8</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL&gt;
</span><span class='comment'># 0x00000000  00 00 00 00 00 00 00 00
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_value'>set_value</span>(<span class='symbeg'>:</span><span class='const'>U8</span><span class='comma'>,</span> <span class='int'>1</span><span class='comma'>,</span> <span class='int'>111</span>)
<span class='comment'># =&gt; 1
</span>
<span class='id identifier rubyid_buffer'>buffer</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL&gt;
</span><span class='comment'># 0x00000000  00 6f 00 00 00 00 00 00                         .o......</span></code></pre>

<p>Note that if the <code>type</code> is integer and <code>value</code> is <a href="../Float.html" title="Float (class)"><code>::Float</code></a>, the implicit truncation is performed:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="IO::Buffer.new (method)">new</a></span>(<span class='int'>8</span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_value'>set_value</span>(<span class='symbeg'>:</span><span class='const'>U32</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> <span class='float'>2.5</span>)

<span class='id identifier rubyid_buffer'>buffer</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL&gt;
</span><span class='comment'># 0x00000000  00 00 00 02 00 00 00 00
</span><span class='comment'>#                      ^^ the same as if we&#39;d pass just integer 2</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L1969-L1981'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1969' data-end='1981'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 1969</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_set_value(VALUE self, VALUE type, VALUE _offset, VALUE value)
{
    void *base;
    size_t size;
    size_t offset = NUM2SIZET(_offset);

    rb_io_buffer_get_bytes_for_writing(self, &amp;base, &amp;size);

    rb_io_buffer_set_value(base, size, RB_SYM2ID(type), &amp;offset, value);

    return SIZET2NUM(offset);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="set_values-instance_method">
  <h3 class='signature '>
    #<strong>set_values</strong>(data_types, offset, values)  &#x21d2; <code>offset</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Write <a href="#values-instance_method" title="IO::Buffer#values (method)">#values</a> of <code>data_types</code> at <code>offset</code> to the buffer. <code>data_types</code> should be an array of symbols as described in <a href="#get_value-instance_method" title="IO::Buffer#get_value (method)">#get_value</a>. <a href="#values-instance_method" title="IO::Buffer#values (method)">#values</a> should be an array of values to write.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="IO::Buffer.new (method)">new</a></span>(<span class='int'>8</span>)
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_set_values'>set_values</span>([<span class='symbeg'>:</span><span class='const'>U8</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='const'>U16</span>]<span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>])
<span class='id identifier rubyid_buffer'>buffer</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x696f717561746978+8 INTERNAL&gt;
</span><span class='comment'># 0x00000000  01 00 02 00 00 00 00 00                         ........</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L1999-L2027'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1999' data-end='2027'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 1999</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_set_values(VALUE self, VALUE data_types, VALUE _offset, VALUE values)
{
    if (!RB_TYPE_P(data_types, T_ARRAY)) {
        rb_raise(rb_eArgError, &quot;Argument data_types should be an array!&quot;);
    }

    if (!RB_TYPE_P(values, T_ARRAY)) {
        rb_raise(rb_eArgError, &quot;Argument values should be an array!&quot;);
    }

    if (RARRAY_LEN(data_types) != RARRAY_LEN(values)) {
        rb_raise(rb_eArgError, &quot;Argument data_types and values should have the same length!&quot;);
    }

    size_t offset = NUM2SIZET(_offset);

    void *base;
    size_t size;
    rb_io_buffer_get_bytes_for_writing(self, &amp;base, &amp;size);

    for (long i = 0; i &lt; RARRAY_LEN(data_types); i++) {
        VALUE type = rb_ary_entry(data_types, i);
        VALUE value = rb_ary_entry(values, i);
        rb_io_buffer_set_value(base, size, RB_SYM2ID(type), &amp;offset, value);
    }

    return SIZET2NUM(offset);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="size-instance_method">
  <h3 class='signature '>
    #<strong>size</strong>  &#x21d2; <a href="../Integer.html" title="Integer (class)">Integer</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the size of the buffer that was explicitly set (on creation with <a href="#new-class_method" title="IO::Buffer.new (method)">.new</a> or on <a href="#resize-instance_method" title="IO::Buffer#resize (method)">#resize</a>), or deduced on buffer’s creation from string or file.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L776-L783'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='776' data-end='783'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 776</span></pre>
<pre class='code cpp'>

VALUE
rb_io_buffer_size(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    return SIZET2NUM(data-&gt;size);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="slice-instance_method">
  <h3 class='signature '>
    #<strong>slice</strong>([offset = 0, [length]])  &#x21d2; <code>Buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Produce another <code>Buffer</code> which is a slice (or view into) the current one starting at <code>offset</code> bytes and going for <code>length</code> bytes.</p>

<p>The slicing happens without copying of memory, and the slice keeps being associated with the original buffer’s source (string, or file), if any.</p>

<p>If the offset is not given, it will be zero. If the offset is negative, it will raise an <a href="../ArgumentError.html" title="ArgumentError (class)"><code>::ArgumentError</code></a>.</p>

<p>If the length is not given, the slice will be as long as the original buffer minus the specified offset. If the length is negative, it will raise an <a href="../ArgumentError.html" title="ArgumentError (class)"><code>::ArgumentError</code></a>.</p>

<p>Raises RuntimeError if the <code>offset</code>length&lt;/tt&gt; is out of the current buffer’s bounds.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_string'>string</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='id identifier rubyid_string'>string</span>)

<span class='id identifier rubyid_slice'>slice</span> <span class='op'>=</span> <span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_slice'>slice</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000000108338e68+4 SLICE&gt;
</span><span class='comment'># 0x00000000  74 65 73 74                                     test
</span>
<span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_slice'>slice</span>(<span class='int'>2</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000000108338e6a+2 SLICE&gt;
</span><span class='comment'># 0x00000000  73 74                                           st
</span>
<span class='id identifier rubyid_slice'>slice</span> <span class='op'>=</span> <span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_slice'>slice</span>(<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x00007fc3d34ebc49+2 SLICE&gt;
</span><span class='comment'># 0x00000000  65 73                                           es
</span>
<span class='comment'># Put &quot;o&quot; into 0s position of the slice
</span><span class='id identifier rubyid_slice'>slice</span>.<span class='id identifier rubyid_set_string'><a href="#set_string-instance_method" title="IO::Buffer#set_string (method)">set_string</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>o</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>0</span>)
<span class='id identifier rubyid_slice'>slice</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x00007fc3d34ebc49+2 SLICE&gt;
</span><span class='comment'># 0x00000000  6f 73                                           os
</span>
<span class='comment'># it is also visible at position 1 of the original buffer
</span><span class='id identifier rubyid_buffer'>buffer</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x00007fc3d31e2d80+4 SLICE&gt;
</span><span class='comment'># 0x00000000  74 6f 73 74                                     tost
</span>
<span class='comment'># ...and original string
</span><span class='id identifier rubyid_string'>string</span>
<span class='comment'># =&gt; tost</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L1191-L1220'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1191' data-end='1220'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 1191</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_slice(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 0, 2);

    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    size_t offset = 0, length = 0;

    if (argc &gt; 0) {
        if (rb_int_negative_p(argv[0])) {
            rb_raise(rb_eArgError, &quot;Offset can&#39;t be negative!&quot;);
        }

        offset = NUM2SIZET(argv[0]);
    }

    if (argc &gt; 1) {
        if (rb_int_negative_p(argv[1])) {
            rb_raise(rb_eArgError, &quot;Length can&#39;t be negative!&quot;);
        }

        length = NUM2SIZET(argv[1]);
    } else {
        length = data-&gt;size - offset;
    }

    return rb_io_buffer_slice(data, self, offset, length);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="to_s-instance_method">
  <h3 class='signature '>
    #<strong>to_s</strong>  &#x21d2; <a href="../String.html" title="String (class)">String</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Short representation of the buffer. It includes the address, size and symbolic flags. This format is subject to change.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_puts'><a href="../IO.html#puts-instance_method" title="IO#puts (method)">puts</a></span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="IO::Buffer.new (method)">new</a></span>(<span class='int'>4</span>) <span class='comment'># uses to_s internally
</span><span class='comment'># #&lt;IO::Buffer 0x000055769f41b1a0+4 INTERNAL&gt;</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L645-L693'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='645' data-end='693'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 645</span></pre>
<pre class='code cpp'>

VALUE
rb_io_buffer_to_s(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    VALUE result = rb_str_new_cstr(&quot;#&lt;&quot;);

    rb_str_append(result, rb_class_name(CLASS_OF(self)));
    rb_str_catf(result, &quot; %p+%&quot;PRIdSIZE, data-&gt;base, data-&gt;size);

    if (data-&gt;base == NULL) {
        rb_str_cat2(result, &quot; NULL&quot;);
    }

    if (data-&gt;flags &amp; RB_IO_BUFFER_EXTERNAL) {
        rb_str_cat2(result, &quot; EXTERNAL&quot;);
    }

    if (data-&gt;flags &amp; RB_IO_BUFFER_INTERNAL) {
        rb_str_cat2(result, &quot; INTERNAL&quot;);
    }

    if (data-&gt;flags &amp; RB_IO_BUFFER_MAPPED) {
        rb_str_cat2(result, &quot; MAPPED&quot;);
    }

    if (data-&gt;flags &amp; RB_IO_BUFFER_SHARED) {
        rb_str_cat2(result, &quot; SHARED&quot;);
    }

    if (data-&gt;flags &amp; RB_IO_BUFFER_LOCKED) {
        rb_str_cat2(result, &quot; LOCKED&quot;);
    }

    if (data-&gt;flags &amp; RB_IO_BUFFER_READONLY) {
        rb_str_cat2(result, &quot; READONLY&quot;);
    }

    if (data-&gt;source != Qnil) {
        rb_str_cat2(result, &quot; SLICE&quot;);
    }

    if (!io_buffer_validate(data)) {
        rb_str_cat2(result, &quot; INVALID&quot;);
    }

    return rb_str_cat2(result, &quot;&gt;&quot;);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="transfer-instance_method">
  <h3 class='signature '>
    #<strong>transfer</strong>  &#x21d2; <code>Buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Transfers ownership to a new buffer, deallocating the current one.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_buffer'>buffer</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="IO::Buffer.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_other'>other</span> <span class='op'>=</span> <span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_transfer'>transfer</span>
<span class='id identifier rubyid_other'>other</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x00007f136a15f7b0+4 SLICE&gt;
</span><span class='comment'># 0x00000000  74 65 73 74                                     test
</span><span class='id identifier rubyid_buffer'>buffer</span>
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000000000000000+0 NULL&gt;
</span><span class='id identifier rubyid_buffer'>buffer</span>.<span class='id identifier rubyid_null?'><a href="#null%3F-instance_method" title="IO::Buffer#null? (method)">null?</a></span>
<span class='comment'># =&gt; true</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L1318-L1336'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1318' data-end='1336'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 1318</span></pre>
<pre class='code cpp'>

VALUE
rb_io_buffer_transfer(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    if (data-&gt;flags &amp; RB_IO_BUFFER_LOCKED) {
        rb_raise(rb_eIOBufferLockedError, &quot;Cannot transfer ownership of locked buffer!&quot;);
    }

    VALUE instance = rb_io_buffer_type_allocate(rb_class_of(self));
    struct rb_io_buffer *transferred;
    TypedData_Get_Struct(instance, struct rb_io_buffer, &amp;rb_io_buffer_type, transferred);

    *transferred = *data;
    io_buffer_zero(data);

    return instance;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="values-instance_method">
  <h3 class='signature '>
    #<strong>values</strong>(data_type, [offset, [count]])  &#x21d2; <a href="../Array.html" title="Array (class)">Array</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns an array of values of <code>data_type</code> starting from <code>offset</code>.</p>

<p>If <code>count</code> is given, only <code>count</code> values will be returned.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello World</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_values'>values</span>(<span class='symbeg'>:</span><span class='const'>U8</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>2</span>)
<span class='comment'># =&gt; [108, 108]</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L1820-L1857'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1820' data-end='1857'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 1820</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_values(int argc, VALUE *argv, VALUE self)
{
    const void *base;
    size_t size;

    rb_io_buffer_get_bytes_for_reading(self, &amp;base, &amp;size);

    ID data_type;
    if (argc &gt;= 1) {
        data_type = RB_SYM2ID(argv[0]);
    } else {
        data_type = RB_IO_BUFFER_DATA_TYPE_U8;
    }

    size_t offset;
    if (argc &gt;= 2) {
        offset = NUM2SIZET(argv[1]);
    } else {
        offset = 0;
    }

    size_t count;
    if (argc &gt;= 3) {
        count = NUM2SIZET(argv[2]);
    } else {
        count = (size - offset) / io_buffer_data_type_size(data_type);
    }

    VALUE array = rb_ary_new_capa(count);

    for (size_t i = 0; i &lt; count; i++) {
        VALUE value = rb_io_buffer_get_value(base, size, data_type, &amp;offset);
        rb_ary_push(array, value);
    }

    return array;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="write-instance_method">
  <h3 class='signature '>
    #<strong>write</strong>(io, length, [offset])  &#x21d2; <code>written</code> <code>length</code>, -<code>errno</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Writes <code>length</code> bytes from buffer into <code>io</code>, starting at <code>offset</code> in the buffer. If an error occurs, return <code>-errno</code>.</p>

<p>If <code>offset</code> is not given, the bytes are taken from the beginning of the buffer.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_out'>out</span> <span class='op'>=</span> <span class='const'><a href="../File.html" title="File (class)">File</a></span>.<span class='id identifier rubyid_open'><a href="../File.html#open-class_method" title="File.open (method)">open</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>output.txt</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>wb</span><span class='tstring_end'>&#39;</span></span>)
<span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>1234567</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_write'>write</span>(<span class='id identifier rubyid_out'>out</span><span class='comma'>,</span> <span class='int'>3</span>)</code></pre>

<p>This leads to <code>123</code> being written into <code>output.txt</code></p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L2663-L2685'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2663' data-end='2685'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 2663</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_write(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 2, 3);

    VALUE io = argv[0];

    if (rb_int_negative_p(argv[1])) {
        rb_raise(rb_eArgError, &quot;Length can&#39;t be negative!&quot;);
    }
    size_t length = NUM2SIZET(argv[1]);

    size_t offset = 0;
    if (argc &gt;= 3) {
        if (rb_int_negative_p(argv[2])) {
            rb_raise(rb_eArgError, &quot;Offset can&#39;t be negative!&quot;);
        }

        offset = NUM2SIZET(argv[2]);
    }

    return rb_io_buffer_write(self, io, length, offset);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="xor!-instance_method">
  <h3 class='signature '>
    #<strong>xor!</strong>(mask)  &#x21d2; <code>Buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Modify the source buffer in place by applying the binary XOR operation to the source, using the mask, repeating as necessary.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_source'>source</span> <span class='op'>=</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>1234567890</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_dup'><a href="../Object.html#dup-instance_method" title="Object#dup (method)">dup</a></span> <span class='comment'># Make a read/write copy.
</span><span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x000056307a25b3e0+10 INTERNAL&gt;
</span><span class='comment'># 0x00000000  31 32 33 34 35 36 37 38 39 30                   1234567890
</span>
<span class='id identifier rubyid_source'>source</span>.<span class='id identifier rubyid_xor!'>xor!</span>(<span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xFF\x00\x00\xFF</span><span class='tstring_end'>&quot;</span></span>))
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x000056307a25b3e0+10 INTERNAL&gt;
</span><span class='comment'># 0x00000000  ce 32 33 cb ca 36 37 c7 c6 30                   .23..67..0</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L3096-L3115'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3096' data-end='3115'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 3096</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_xor_inplace(VALUE self, VALUE mask)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    struct rb_io_buffer *mask_data = NULL;
    TypedData_Get_Struct(mask, struct rb_io_buffer, &amp;rb_io_buffer_type, mask_data);

    io_buffer_check_mask(mask_data);
    io_buffer_check_overlaps(data, mask_data);

    void *base;
    size_t size;
    io_buffer_get_bytes_for_writing(data, &amp;base, &amp;size);

    memory_xor_inplace(base, size, mask_data-&gt;base, mask_data-&gt;size);

    return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="|-instance_method">
  <h3 class='signature '>
    #<strong>|</strong>(mask)  &#x21d2; <code>Buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Generate a new buffer the same size as the source by applying the binary OR operation to the source, using the mask, repeating as necessary.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>1234567890</span><span class='tstring_end'>&quot;</span></span>) <span class='op'>|</span> <span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xFF\x00\x00\xFF</span><span class='tstring_end'>&quot;</span></span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x0000561785ae3480+10 INTERNAL&gt;
</span><span class='comment'># 0x00000000  ff 32 33 ff ff 36 37 ff ff 30                   .23..67..0</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L2867-L2885'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2867' data-end='2885'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 2867</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_or(VALUE self, VALUE mask)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    struct rb_io_buffer *mask_data = NULL;
    TypedData_Get_Struct(mask, struct rb_io_buffer, &amp;rb_io_buffer_type, mask_data);

    io_buffer_check_mask(mask_data);

    VALUE output = rb_io_buffer_new(NULL, data-&gt;size, io_flags_for_size(data-&gt;size));
    struct rb_io_buffer *output_data = NULL;
    TypedData_Get_Struct(output, struct rb_io_buffer, &amp;rb_io_buffer_type, output_data);

    memory_or(output_data-&gt;base, data-&gt;base, data-&gt;size, mask_data-&gt;base, mask_data-&gt;size);

    return output;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="~-instance_method">
  <h3 class='signature '>
    #<strong>~</strong>  &#x21d2; <code>Buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Generate a new buffer the same size as the source by applying the binary NOT operation to the source.</p>

<pre class="code ruby"><code class="ruby"><span class='op'>~</span><span class='const'><a href="../IO.html" title="IO (class)">IO</a></span><span class='op'>::</span><span class='const'>Buffer</span>.<span class='id identifier rubyid_for'><a href="#for-class_method" title="IO::Buffer.for (method)">for</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>1234567890</span><span class='tstring_end'>&quot;</span></span>)
<span class='comment'># =&gt;
</span><span class='comment'># #&lt;IO::Buffer 0x000055a5ac42f120+10 INTERNAL&gt;
</span><span class='comment'># 0x00000000  ce cd cc cb ca c9 c8 c7 c6 cf                   ..........</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_4/io_buffer.c#L2947-L2960'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2947' data-end='2960'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'io_buffer.c', line 2947</span></pre>
<pre class='code cpp'>

static VALUE
io_buffer_not(VALUE self)
{
    struct rb_io_buffer *data = NULL;
    TypedData_Get_Struct(self, struct rb_io_buffer, &amp;rb_io_buffer_type, data);

    VALUE output = rb_io_buffer_new(NULL, data-&gt;size, io_flags_for_size(data-&gt;size));
    struct rb_io_buffer *output_data = NULL;
    TypedData_Get_Struct(output, struct rb_io_buffer, &amp;rb_io_buffer_type, output_data);

    memory_not(output_data-&gt;base, data-&gt;base, data-&gt;size);

    return output;
}
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>