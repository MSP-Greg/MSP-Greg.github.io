<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: Regexp &mdash; Core  Ruby-3.2.9 p265</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Regexp",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../.'>Ruby-3.2.9</a> &raquo; 
      <a href='.'>Core</a> &raquo; 
      <a href='_index.html#alpha_R'>Index (R)</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>Regexp&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: Regexp</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Namespace Children</td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Exceptions:</div>
      <div class='box_11'>
          <a href="Regexp/TimeoutError.html" title="Regexp::TimeoutError (class)"><code>TimeoutError</code></a>      </div>
    </td></tr>
    <tr>
      <td id='t2_inherits' class='box_2'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'><a href="Object.html" title="Object (class)">Object</a></span>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2 o'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4721'>re.c</a><span class='defines'>,<br /><a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/encoding.c#L1159'>encoding.c</a>,<br/> <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4697'>re.c</a></span>
      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p>Regular expressions (<em>regexp</em>s) are patterns which describe the contents of a string. They’re used for testing whether a string contains a given pattern, or extracting the portions that match. They are created with the <code>/</code><em>pat</em><code>/</code> and <code>%r{</code><em>pat</em><code>}</code> literals or the <a href="#new-class_method" title="Regexp.new (method)">.new</a> constructor.</p>

<p>A regexp is usually delimited with forward slashes (<code>/</code>). For example:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>hay</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>   <span class='comment'>#=&gt; 0
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>y</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;y&quot;&gt;</span></code></pre>

<p>If a string contains the pattern it is said to <em>match</em>. A literal string matches itself.</p>

<p>Here ‘haystack’ does not contain the pattern ‘needle’, so it doesn’t match:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>needle</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'>#=&gt; nil</span></code></pre>

<p>Here ‘haystack’ contains the pattern ‘hay’, so it matches:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>hay</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>)    <span class='comment'>#=&gt; #&lt;MatchData &quot;hay&quot;&gt;</span></code></pre>

<p>Specifically, <code>/st/</code> requires that the string contains the letter <em>s</em> followed by the letter <em>t</em>, so it matches <em>haystack</em>, also.</p>

<p>Note that any <code>Regexp</code> matching will raise a <a href="RuntimeError.html" title="RuntimeError (class)"><code>::RuntimeError</code></a> if timeout is set and exceeded. See <code>“Timeout”</code> section in detail.</p>

<h3 id="label-Regexp+Interpolation">Regexp Interpolation</h3>

<p>A regexp may contain interpolated strings; trivially:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_foo'>foo</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>bar</span><span class='tstring_end'>&#39;</span></span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_foo'>foo</span><span class='embexpr_end'>}</span><span class='regexp_end'>/</span></span> <span class='comment'># =&gt; /bar/</span></code></pre>

<h3 id="label-7B-3D~-7D+and+-7BRegexp-23match-7D"><a href="#=~-instance_method" title="Regexp#=~ (method)">#=~</a> and <a href="#match-instance_method" title="Regexp#match (method)">#match</a></h3>

<p>Pattern matching may be achieved by using <a href="#=~-instance_method" title="Regexp#=~ (method)">#=~</a> operator or <a href="#match-instance_method" title="Regexp#match (method)">#match</a> method.</p>

<h4 id="label-7B-3D~-7D+Operator"><a href="#=~-instance_method" title="Regexp#=~ (method)">#=~</a> Operator</h4>

<p><a href="#=~-instance_method" title="Regexp#=~ (method)">#=~</a> is Ruby’s basic pattern-matching operator.  When one operand is a regular expression and the other is a string then the regular expression is used as a pattern to match against the string.  (This operator is equivalently defined by <code>Regexp</code> and <a href="String.html" title="String (class)"><code>::String</code></a> so the order of <a href="String.html" title="String (class)"><code>::String</code></a> and <code>Regexp</code> do not matter. Other classes may have different implementations of <a href="#=~-instance_method" title="Regexp#=~ (method)">#=~</a>.)  If a match is found, the operator returns index of first match in string, otherwise it returns <code>nil</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>hay</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>   <span class='comment'>#=&gt; 0
</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>hay</span><span class='regexp_end'>/</span></span>   <span class='comment'>#=&gt; 0
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a</span><span class='regexp_end'>/</span></span>   <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>   <span class='comment'>#=&gt; 1
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>u</span><span class='regexp_end'>/</span></span>   <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>   <span class='comment'>#=&gt; nil</span></code></pre>

<p>Using <a href="#=~-instance_method" title="Regexp#=~ (method)">#=~</a> operator with a <a href="String.html" title="String (class)"><code>::String</code></a> and <code>Regexp</code> the <code>$~</code> global variable is set after a successful match.  <code>$~</code> holds a <a href="MatchData.html" title="MatchData (class)"><code>::MatchData</code></a> object. <a href="#last_match-class_method" title="Regexp.last_match (method)">.last_match</a> is equivalent to <code>$~</code>.</p>

<h4 id="label-7BRegexp-23match-7D+Method"><a href="#match-instance_method" title="Regexp#match (method)">#match</a> Method</h4>

<p>The <a href="#match-instance_method" title="Regexp#match (method)">#match</a> method returns a <a href="MatchData.html" title="MatchData (class)"><code>::MatchData</code></a> object:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>st</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>)   <span class='comment'>#=&gt; #&lt;MatchData &quot;st&quot;&gt;</span></code></pre>

<h3 id="label-Metacharacters+and+Escapes">Metacharacters and Escapes</h3>

<p>The following are <em>metacharacters</em> <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>.</code>, <code>?</code>, <code>+</code>, <code>*</code>. They have a specific meaning when appearing in a pattern. To match them literally they must be backslash-escaped. To match a backslash literally, backslash-escape it: <code>\\</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>1 \+ 2 = 3\?</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Does 1 + 2 = 3?</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;1 + 2 = 3?&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a\\\\b</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a\\\\b</span><span class='tstring_end'>&#39;</span></span>)                    <span class='comment'>#=&gt; #&lt;MatchData &quot;a\\b&quot;&gt;</span></code></pre>

<p>Patterns behave like double-quoted strings and can contain the same backslash escapes (the meaning of <code>\s</code> is different, however, see <a href="#label-Character+Classes">below</a>).</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\s\u{6771 4eac 90fd}</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Go to 東京都</span><span class='tstring_end'>&quot;</span></span>)
    <span class='comment'>#=&gt; #&lt;MatchData &quot; 東京都&quot;&gt;</span></code></pre>

<p>Arbitrary Ruby expressions can be embedded into patterns with the <code>#{...}</code> construct.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_place'>place</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>東京都</span><span class='tstring_end'>&quot;</span></span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_place'>place</span><span class='embexpr_end'>}</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Go to 東京都</span><span class='tstring_end'>&quot;</span></span>)
    <span class='comment'>#=&gt; #&lt;MatchData &quot;東京都&quot;&gt;</span></code></pre>

<h3 id="label-Character+Classes">Character Classes</h3>

<p>A <em>character class</em> is delimited with square brackets (<code>[</code>, <code>]</code>) and lists characters that may appear at that point in the match. <code>/[ab]/</code> means <em>a</em> or <em>b</em>, as opposed to <code>/ab/</code> which means <em>a</em> followed by <em>b</em>.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>W[aeiou]rd</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Word</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;Word&quot;&gt;</span></code></pre>

<p>Within a character class the hyphen (<code>-</code>) is a metacharacter denoting an inclusive range of characters. <code>[abcd]</code> is equivalent to <code>[a-d]</code>. A range can be followed by another range, so <code>[abcdwxyz]</code> is equivalent to <code>[a-dw-z]</code>. The order in which ranges or individual characters appear inside a character class is irrelevant.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[0-9a-f]</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>9f</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;9&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[9f]</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>9f</span><span class='tstring_end'>&#39;</span></span>)     <span class='comment'>#=&gt; #&lt;MatchData &quot;9&quot;&gt;</span></code></pre>

<p>If the first character of a character class is a caret (<code>^</code>) the class is inverted: it matches any character <em>except</em> those named.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[^a-eg-z]</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>f</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;f&quot;&gt;</span></code></pre>

<p>A character class may contain another character class. By itself this isn’t useful because <code>[a-z[0-9]]</code> describes the same set as <code>[a-z0-9]</code>. However, character classes also support the <code>&amp;&amp;</code> operator which performs set intersection on its arguments. The two can be combined as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[a-w&amp;&amp;[^c-g]z]</span><span class='regexp_end'>/</span></span> <span class='comment'># ([a-w] AND ([^c-g] OR z))</span></code></pre>

<p>This is equivalent to:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[abh-w]</span><span class='regexp_end'>/</span></span></code></pre>

<p>The following metacharacters also behave like character classes:</p>
<ul><li>
<p><code>/./</code> - Any character except a newline.</p>
</li><li>
<p><code>/./m</code> - Any character (the <code>m</code> modifier enables multiline mode)</p>
</li><li>
<p><code>/\w/</code> - A word character (<code>[a-zA-Z0-9_]</code>)</p>
</li><li>
<p><code>/\W/</code> - A non-word character (<code>[^a-zA-Z0-9_]</code>). Please take a look at <a href="https://bugs.ruby-lang.org/issues/4044" target="_parent" title="Bug #4044">Bug #4044</a> if using <code>/\W/</code> with the <code>/i</code> modifier.</p>
</li><li>
<p><code>/\d/</code> - A digit character (<code>[0-9]</code>)</p>
</li><li>
<p><code>/\D/</code> - A non-digit character (<code>[^0-9]</code>)</p>
</li><li>
<p><code>/\h/</code> - A hexdigit character (<code>[0-9a-fA-F]</code>)</p>
</li><li>
<p><code>/\H/</code> - A non-hexdigit character (<code>[^0-9a-fA-F]</code>)</p>
</li><li>
<p><code>/\s/</code> - A whitespace character: <code>/[ \t\r\n\f\v]/</code></p>
</li><li>
<p><code>/\S/</code> - A non-whitespace character: <code>/[^ \t\r\n\f\v]/</code></p>
</li><li>
<p><code>/\R/</code> - A linebreak: <code>\n</code>, <code>\v</code>, <code>\f</code>, <code>\r</code> <code>\u0085</code> (NEXT LINE), <code>\u2028</code> (LINE SEPARATOR), <code>\u2029</code> (PARAGRAPH SEPARATOR) or <code>\r\n</code>.</p>
</li></ul>

<p>POSIX <em>bracket expressions</em> are also similar to character classes. They provide a portable alternative to the above, with the added benefit that they encompass non-ASCII characters. For instance, <code>/\d/</code> matches only the ASCII decimal digits (0-9); whereas <code>/[[:digit:]]/</code> matches any character in the Unicode <em>Nd</em> category.</p>
<ul><li>
<p><code>/[[:alnum:]]/</code> - Alphabetic and numeric character</p>
</li><li>
<p><code>/[[:alpha:]]/</code> - Alphabetic character</p>
</li><li>
<p><code>/[[:blank:]]/</code> - Space or tab</p>
</li><li>
<p><code>/[[:cntrl:]]/</code> - Control character</p>
</li><li>
<p><code>/[[:digit:]]/</code> - Digit</p>
</li><li>
<p><code>/[[:graph:]]/</code> - Non-blank character (excludes spaces, control characters, and similar)</p>
</li><li>
<p><code>/[[:lower:]]/</code> - Lowercase alphabetical character</p>
</li><li>
<p><code>/[[:print:]]/</code> - Like [:graph:], but includes the space character</p>
</li><li>
<p><code>/[[:punct:]]/</code> - Punctuation character</p>
</li><li>
<p><code>/[[:space:]]/</code> - Whitespace character (<code>[:blank:]</code>, newline, carriage return, etc.)</p>
</li><li>
<p><code>/[[:upper:]]/</code> - Uppercase alphabetical</p>
</li><li>
<p><code>/[[:xdigit:]]/</code> - Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)</p>
</li></ul>

<p>Ruby also supports the following non-POSIX character classes:</p>
<ul><li>
<p><code>/[[:word:]]/</code> - A character in one of the following Unicode general categories <em>Letter</em>, <em>Mark</em>, <em>Number</em>, <em>Connector_Punctuation</em></p>
</li><li>
<p><code>/[[:ascii:]]/</code> - A character in the ASCII character set</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># U+06F2 is &quot;EXTENDED ARABIC-INDIC DIGIT TWO&quot;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[[:digit:]]</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\u06F2</span><span class='tstring_end'>&quot;</span></span>)    <span class='comment'>#=&gt; #&lt;MatchData &quot;\u{06F2}&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[[:upper:]][[:lower:]]</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;He&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[[:xdigit:]][[:xdigit:]]</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>A6</span><span class='tstring_end'>&quot;</span></span>)  <span class='comment'>#=&gt; #&lt;MatchData &quot;A6&quot;&gt;</span></code></pre>
</li></ul>

<h3 id="label-Repetition">Repetition</h3>

<p>The constructs described so far match a single character. They can be followed by a repetition metacharacter to specify how many times they need to occur. Such metacharacters are called <em>quantifiers</em>.</p>
<ul><li>
<p><code>*</code> - Zero or more times</p>
</li><li>
<p><code>+</code> - One or more times</p>
</li><li>
<p><code>?</code> - Zero or one times (optional)</p>
</li><li>
<p><code>{</code><em>n</em><code>}</code> - Exactly <em>n</em> times</p>
</li><li>
<p><code>{</code><em>n</em><code>,}</code> - <em>n</em> or more times</p>
</li><li>
<p><code>{,</code><em>m</em><code>}</code> - <em>m</em> or less times</p>
</li><li>
<p><code>{</code><em>n</em><code>,</code><em>m</em><code>}</code> - At least <em>n</em> and at most <em>m</em> times</p>
</li></ul>

<p>At least one uppercase character (‘H’), at least one lowercase character (‘e’), two ‘l’ characters, then one ‘o’:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[[:upper:]][[:lower:]]l{2}o</span><span class='regexp_end'>/</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;Hello&quot;&gt;</span></code></pre>

<h4 id="label-Greedy+Match">Greedy Match</h4>

<p>Repetition is <em>greedy</em> by default: as many occurrences as possible are matched while still allowing the overall match to succeed. By contrast, <em>lazy</em> matching makes the minimal amount of matches necessary for overall success. Most greedy metacharacters can be made lazy by following them with <code>?</code>. For the <code>{n}</code> pattern, because it specifies an exact number of characters to match and not a variable number of characters, the <code>?</code> metacharacter instead makes the repeated pattern optional.</p>

<p>Both patterns below match the string. The first uses a greedy quantifier so ‘.+’ matches ‘&lt;a&gt;&lt;b&gt;’; the second uses a lazy quantifier so ‘.+?’ matches ‘&lt;a&gt;’:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>&lt;.+&gt;</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>&lt;a&gt;&lt;b&gt;</span><span class='tstring_end'>&quot;</span></span>)  <span class='comment'>#=&gt; #&lt;MatchData &quot;&lt;a&gt;&lt;b&gt;&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>&lt;.+?&gt;</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>&lt;a&gt;&lt;b&gt;</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;&lt;a&gt;&quot;&gt;</span></code></pre>

<h4 id="label-Possessive+Match">Possessive Match</h4>

<p>A quantifier followed by <code>+</code> matches <em>possessively</em>: once it has matched it does not backtrack. They behave like greedy quantifiers, but having matched they refuse to “give up” their match even if this jeopardises the overall match.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>&lt;.*&gt;&lt;.+&gt;</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>&lt;a&gt;&lt;b&gt;</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;&lt;a&gt;&lt;b&gt;&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>&lt;.*&gt;&lt;.&gt;</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>&lt;a&gt;&lt;b&gt;</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; nil
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>&lt;.*&gt;&lt;.++&gt;</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>&lt;a&gt;&lt;b&gt;</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; nil</span></code></pre>

<h3 id="label-Capturing">Capturing</h3>

<p>Parentheses can be used for <em>capturing</em>. The text enclosed by the <em>n</em>th group of parentheses can be subsequently referred to with <em>n</em>. Within a pattern use the <em>backreference</em> <code>\n</code> (e.g. <code>\1</code>); outside of the pattern use <code>n</code> (e.g. <code>1</code>).</p>

<p>In this example, <code>&#39;at&#39;</code> is captured by the first group of parentheses, then referred to later with <code>\1</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[csh](..) [csh]\1 in</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>The cat sat in the hat</span><span class='tstring_end'>&quot;</span></span>)
    <span class='comment'>#=&gt; #&lt;MatchData &quot;cat sat in&quot; 1:&quot;at&quot;&gt;</span></code></pre>

<p><a href="#match-instance_method" title="Regexp#match (method)">#match</a> returns a <a href="MatchData.html" title="MatchData (class)"><code>::MatchData</code></a> object which makes the captured text available with its <code>#[]</code> method:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[csh](..) [csh]\1 in</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>The cat sat in the hat</span><span class='tstring_end'>&quot;</span></span>)[<span class='int'>1</span>] <span class='comment'>#=&gt; &#39;at&#39;</span></code></pre>

<p>While Ruby supports an arbitrary number of numbered captured groups, only groups 1-9 are supported using the <code>\n</code> backreference syntax.</p>

<p>Ruby also supports <code>\0</code> as a special backreference, which references the entire matched string.  This is also available at <code>0</code>.  Note that the <code>\0</code> backreference cannot be used inside the regexp, as backreferences can only be used after the end of the capture group, and the <code>\0</code> backreference uses the implicit capture group of the entire match.  However, you can use this backreference when doing substitution:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>The cat sat in the hat</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_gsub'>gsub</span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[csh]at</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>\0s</span><span class='tstring_end'>&#39;</span></span>)
  <span class='comment'># =&gt; &quot;The cats sats in the hats&quot;</span></code></pre>

<h4 id="label-Named+Captures">Named Captures</h4>

<p>Capture groups can be referred to by name when defined with the <code>(?&lt;</code><em>name</em><code>&gt;)</code> or <code>(?&#39;</code><em>name</em><code>&#39;)</code> constructs.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\$(?&lt;dollars&gt;\d)\.(?&lt;cents&gt;\d)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$3.67</span><span class='tstring_end'>&quot;</span></span>)
    <span class='comment'>#=&gt; #&lt;MatchData &quot;$3.67&quot; dollars:&quot;3&quot; cents:&quot;67&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\$(?&lt;dollars&gt;\d)\.(?&lt;cents&gt;\d)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$3.67</span><span class='tstring_end'>&quot;</span></span>)[<span class='symbeg'>:</span><span class='id identifier rubyid_dollars'>dollars</span>] <span class='comment'>#=&gt; &quot;3&quot;</span></code></pre>

<p>Named groups can be backreferenced with <code>\k&lt;</code><em>name</em><code>&gt;</code>, where <em>name</em> is the group name.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;vowel&gt;[aeiou]).\k&lt;vowel&gt;.\k&lt;vowel&gt;</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>ototomy</span><span class='tstring_end'>&#39;</span></span>)
    <span class='comment'>#=&gt; #&lt;MatchData &quot;ototo&quot; vowel:&quot;o&quot;&gt;</span></code></pre>

<p><strong>Note</strong>: A regexp can’t use named backreferences and numbered backreferences simultaneously. Also, if a named capture is used in a regexp, then parentheses used for grouping which would otherwise result in a unnamed capture are treated as non-capturing.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(\w)(\w)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ab</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_captures'>captures</span> <span class='comment'># =&gt; [&quot;a&quot;, &quot;b&quot;]
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(\w)(\w)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ab</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_named_captures'><a href="#named_captures-instance_method" title="Regexp#named_captures (method)">named_captures</a></span> <span class='comment'># =&gt; {}
</span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;c&gt;\w)(\w)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ab</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_captures'>captures</span> <span class='comment'># =&gt; [&quot;a&quot;]
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;c&gt;\w)(\w)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ab</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_named_captures'><a href="#named_captures-instance_method" title="Regexp#named_captures (method)">named_captures</a></span> <span class='comment'># =&gt; {&quot;c&quot;=&gt;&quot;a&quot;}</span></code></pre>

<p>When named capture groups are used with a literal regexp on the left-hand side of an expression and the <a href="#=~-instance_method" title="Regexp#=~ (method)">#=~</a> operator, the captured text is also assigned to local variables with corresponding names.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\$(?&lt;dollars&gt;\d)\.(?&lt;cents&gt;\d)</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$3.67</span><span class='tstring_end'>&quot;</span></span> <span class='comment'>#=&gt; 0
</span><span class='id identifier rubyid_dollars'>dollars</span> <span class='comment'>#=&gt; &quot;3&quot;</span></code></pre>

<h3 id="label-Grouping">Grouping</h3>

<p>Parentheses also <em>group</em> the terms they enclose, allowing them to be quantified as one <em>atomic</em> whole.</p>

<p>The pattern below matches a vowel followed by 2 word characters:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[aeiou]\w{2}</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Caenorhabditis elegans</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;aen&quot;&gt;</span></code></pre>

<p>Whereas the following pattern matches a vowel followed by a word character, twice, i.e. <code>[aeiou]\w[aeiou]\w</code>: ‘enor’.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>([aeiou]\w){2}</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Caenorhabditis elegans</span><span class='tstring_end'>&quot;</span></span>)
    <span class='comment'>#=&gt; #&lt;MatchData &quot;enor&quot; 1:&quot;or&quot;&gt;</span></code></pre>

<p>The <code>(?:</code>…<code>)</code> construct provides grouping without capturing. That is, it combines the terms it contains into an atomic whole without creating a backreference. This benefits performance at the slight expense of readability.</p>

<p>The first group of parentheses captures ‘n’ and the second ‘ti’. The second group is referred to later with the backreference <code>\2</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>I(n)ves(ti)ga\2ons</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Investigations</span><span class='tstring_end'>&quot;</span></span>)
    <span class='comment'>#=&gt; #&lt;MatchData &quot;Investigations&quot; 1:&quot;n&quot; 2:&quot;ti&quot;&gt;</span></code></pre>

<p>The first group of parentheses is now made non-capturing with ‘?:’, so it still matches ‘n’, but doesn’t create the backreference. Thus, the backreference <code>\1</code> now refers to ‘ti’.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>I(?:n)ves(ti)ga\1ons</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Investigations</span><span class='tstring_end'>&quot;</span></span>)
    <span class='comment'>#=&gt; #&lt;MatchData &quot;Investigations&quot; 1:&quot;ti&quot;&gt;</span></code></pre>

<h4 id="label-Atomic+Grouping">Atomic Grouping</h4>

<p>Grouping can be made <em>atomic</em> with <code>(?&gt;</code><em>pat</em><code>)</code>. This causes the subexpression <em>pat</em> to be matched independently of the rest of the expression such that what it matches becomes fixed for the remainder of the match, unless the entire subexpression must be abandoned and subsequently revisited. In this way <em>pat</em> is treated as a non-divisible whole. Atomic grouping is typically used to optimise patterns so as to prevent the regular expression engine from backtracking needlessly.</p>

<p>The <code>&quot;</code> in the pattern below matches the first character of the string, then <code>.*</code> matches <em>Quote“</em>. This causes the overall match to fail, so the text matched by <code>.*</code> is backtracked by one position, which leaves the final character of the string available to match <code>&quot;</code></p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>&quot;.*&quot;</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>&quot;Quote&quot;</span><span class='tstring_end'>&#39;</span></span>)     <span class='comment'>#=&gt; #&lt;MatchData &quot;\&quot;Quote\&quot;&quot;&gt;</span></code></pre>

<p>If <code>.*</code> is grouped atomically, it refuses to backtrack <em>Quote“</em>, even though this means that the overall match fails</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>&quot;(?&gt;.*)&quot;</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>&quot;Quote&quot;</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'>#=&gt; nil</span></code></pre>

<h3 id="label-Subexpression+Calls">Subexpression Calls</h3>

<p>The <code>\g&lt;</code><em>name</em><code>&gt;</code> syntax matches the previous subexpression named <em>name</em>, which can be a group name or number, again. This differs from backreferences in that it re-executes the group rather than simply trying to re-match the same text.</p>

<p>This pattern matches a <em>(</em> character and assigns it to the <code>paren</code> group, tries to call that the <code>paren</code> sub-expression again but fails, then matches a literal <em>)</em>:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A(?&lt;paren&gt;\(\g&lt;paren&gt;*\))*\z</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>()</span><span class='tstring_end'>&#39;</span></span>

<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A(?&lt;paren&gt;\(\g&lt;paren&gt;*\))*\z</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>(())</span><span class='tstring_end'>&#39;</span></span> <span class='comment'>#=&gt; 0
</span><span class='comment'># ^1
</span><span class='comment'>#      ^2
</span><span class='comment'>#           ^3
</span><span class='comment'>#                 ^4
</span><span class='comment'>#      ^5
</span><span class='comment'>#           ^6
</span><span class='comment'>#                      ^7
</span><span class='comment'>#                       ^8
</span><span class='comment'>#                       ^9
</span><span class='comment'>#                           ^10</span></code></pre>
<ol><li>
<p>Matches at the beginning of the string, i.e. before the first character.</p>
</li><li>
<p>Enters a named capture group called <code>paren</code></p>
</li><li>
<p>Matches a literal <em>(</em>, the first character in the string</p>
</li><li>
<p>Calls the <code>paren</code> group again, i.e. recurses back to the second step</p>
</li><li>
<p>Re-enters the <code>paren</code> group</p>
</li><li>
<p>Matches a literal <em>(</em>, the second character in the string</p>
</li><li>
<p>Try to call <code>paren</code> a third time, but fail because doing so would prevent an overall successful match</p>
</li><li>
<p>Match a literal <em>)</em>, the third character in the string. Marks the end of the second recursive call</p>
</li><li>
<p>Match a literal <em>)</em>, the fourth character in the string</p>
</li><li>
<p>Match the end of the string</p>
</li></ol>

<h3 id="label-Alternation">Alternation</h3>

<p>The vertical bar metacharacter (<code>|</code>) combines several expressions into a single one that matches any of the expressions. Each expression is an <em>alternative</em>.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\w(and|or)\w</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Feliformia</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;form&quot; 1:&quot;or&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\w(and|or)\w</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>furandi</span><span class='tstring_end'>&quot;</span></span>)    <span class='comment'>#=&gt; #&lt;MatchData &quot;randi&quot; 1:&quot;and&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\w(and|or)\w</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dissemblance</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; nil</span></code></pre>

<h3 id="label-Character+Properties">Character Properties</h3>

<p>The <code>\p{}</code> construct matches characters with the named property, much like POSIX bracket classes.</p>
<ul><li>
<p><code>/\p{Alnum}/</code> - Alphabetic and numeric character</p>
</li><li>
<p><code>/\p{Alpha}/</code> - Alphabetic character</p>
</li><li>
<p><code>/\p{Blank}/</code> - Space or tab</p>
</li><li>
<p><code>/\p{Cntrl}/</code> - Control character</p>
</li><li>
<p><code>/\p{Digit}/</code> - Digit</p>
</li><li>
<p><code>/\p{Emoji}/</code> - Unicode emoji</p>
</li><li>
<p><code>/\p{Graph}/</code> - Non-blank character (excludes spaces, control characters, and similar)</p>
</li><li>
<p><code>/\p{Lower}/</code> - Lowercase alphabetical character</p>
</li><li>
<p><code>/\p{Print}/</code> - Like <code>\p{Graph}</code>, but includes the space character</p>
</li><li>
<p><code>/\p{Punct}/</code> - Punctuation character</p>
</li><li>
<p><code>/\p{Space}/</code> - Whitespace character (<code>[:blank:]</code>, newline, carriage return, etc.)</p>
</li><li>
<p><code>/\p{Upper}/</code> - Uppercase alphabetical</p>
</li><li>
<p><code>/\p{XDigit}/</code> - Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)</p>
</li><li>
<p><code>/\p{Word}/</code> - A member of one of the following Unicode general category <em>Letter</em>, <em>Mark</em>, <em>Number</em>, <em>Connector_Punctuation</em></p>
</li><li>
<p><code>/\p{ASCII}/</code> - A character in the ASCII character set</p>
</li><li>
<p><code>/\p{Any}/</code> - Any Unicode character (including unassigned characters)</p>
</li><li>
<p><code>/\p{Assigned}/</code> - An assigned character</p>
</li></ul>

<p>A Unicode character’s <em>General Category</em> value can also be matched with <code>\p{</code><em>Ab</em><code>}</code> where <em>Ab</em> is the category’s abbreviation as described below:</p>
<ul><li>
<p><code>/\p{L}/</code> - ‘Letter’</p>
</li><li>
<p><code>/\p{Ll}/</code> - ‘Letter: Lowercase’</p>
</li><li>
<p><code>/\p{Lm}/</code> - ‘Letter: Mark’</p>
</li><li>
<p><code>/\p{Lo}/</code> - ‘Letter: Other’</p>
</li><li>
<p><code>/\p{Lt}/</code> - ‘Letter: Titlecase’</p>
</li><li>
<p><code>/\p{Lu}/</code> - ‘Letter: Uppercase</p>
</li><li>
<p><code>/\p{Lo}/</code> - ‘Letter: Other’</p>
</li><li>
<p><code>/\p{M}/</code> - ‘Mark’</p>
</li><li>
<p><code>/\p{Mn}/</code> - ‘Mark: Nonspacing’</p>
</li><li>
<p><code>/\p{Mc}/</code> - ‘Mark: Spacing Combining’</p>
</li><li>
<p><code>/\p{Me}/</code> - ‘Mark: Enclosing’</p>
</li><li>
<p><code>/\p{N}/</code> - ‘Number’</p>
</li><li>
<p><code>/\p{Nd}/</code> - ‘Number: Decimal Digit’</p>
</li><li>
<p><code>/\p{Nl}/</code> - ‘Number: Letter’</p>
</li><li>
<p><code>/\p{No}/</code> - ‘Number: Other’</p>
</li><li>
<p><code>/\p{P}/</code> - ‘Punctuation’</p>
</li><li>
<p><code>/\p{Pc}/</code> - ‘Punctuation: Connector’</p>
</li><li>
<p><code>/\p{Pd}/</code> - ‘Punctuation: Dash’</p>
</li><li>
<p><code>/\p{Ps}/</code> - ‘Punctuation: Open’</p>
</li><li>
<p><code>/\p{Pe}/</code> - ‘Punctuation: Close’</p>
</li><li>
<p><code>/\p{Pi}/</code> - ‘Punctuation: Initial Quote’</p>
</li><li>
<p><code>/\p{Pf}/</code> - ‘Punctuation: Final Quote’</p>
</li><li>
<p><code>/\p{Po}/</code> - ‘Punctuation: Other’</p>
</li><li>
<p><code>/\p{S}/</code> - ‘Symbol’</p>
</li><li>
<p><code>/\p{Sm}/</code> - ‘Symbol: Math’</p>
</li><li>
<p><code>/\p{Sc}/</code> - ‘Symbol: Currency’</p>
</li><li>
<p><code>/\p{Sc}/</code> - ‘Symbol: Currency’</p>
</li><li>
<p><code>/\p{Sk}/</code> - ‘Symbol: Modifier’</p>
</li><li>
<p><code>/\p{So}/</code> - ‘Symbol: Other’</p>
</li><li>
<p><code>/\p{Z}/</code> - ‘Separator’</p>
</li><li>
<p><code>/\p{Zs}/</code> - ‘Separator: Space’</p>
</li><li>
<p><code>/\p{Zl}/</code> - ‘Separator: Line’</p>
</li><li>
<p><code>/\p{Zp}/</code> - ‘Separator: Paragraph’</p>
</li><li>
<p><code>/\p{C}/</code> - ‘Other’</p>
</li><li>
<p><code>/\p{Cc}/</code> - ‘Other: Control’</p>
</li><li>
<p><code>/\p{Cf}/</code> - ‘Other: Format’</p>
</li><li>
<p><code>/\p{Cn}/</code> - ‘Other: Not Assigned’</p>
</li><li>
<p><code>/\p{Co}/</code> - ‘Other: Private Use’</p>
</li><li>
<p><code>/\p{Cs}/</code> - ‘Other: Surrogate’</p>
</li></ul>

<p>Lastly, <code>\p{}</code> matches a character’s Unicode <em>script</em>. The following scripts are supported: <em>Arabic</em>, <em>Armenian</em>, <em>Balinese</em>, <em>Bengali</em>, <em>Bopomofo</em>, <em>Braille</em>, <em>Buginese</em>, <em>Buhid</em>, <em>Canadian_Aboriginal</em>, <em>Carian</em>, <em>Cham</em>, <em>Cherokee</em>, <em>Common</em>, <em>Coptic</em>, <em>Cuneiform</em>, <em>Cypriot</em>, <em>Cyrillic</em>, <em>Deseret</em>, <em>Devanagari</em>, <em>Ethiopic</em>, <em>Georgian</em>, <em>Glagolitic</em>, <em>Gothic</em>, <em>Greek</em>, <em>Gujarati</em>, <em>Gurmukhi</em>, <em>Han</em>, <em>Hangul</em>, <em>Hanunoo</em>, <em>Hebrew</em>, <em>Hiragana</em>, <em>Inherited</em>, <em>Kannada</em>, <em>Katakana</em>, <em>Kayah_Li</em>, <em>Kharoshthi</em>, <em>Khmer</em>, <em>Lao</em>, <em>Latin</em>, <em>Lepcha</em>, <em>Limbu</em>, <em>Linear_B</em>, <em>Lycian</em>, <em>Lydian</em>, <em>Malayalam</em>, <em>Mongolian</em>, <em>Myanmar</em>, <em>New_Tai_Lue</em>, <em>Nko</em>, <em>Ogham</em>, <em>Ol_Chiki</em>, <em>Old_Italic</em>, <em>Old_Persian</em>, <em>Oriya</em>, <em>Osmanya</em>, <em>Phags_Pa</em>, <em>Phoenician</em>, <em>Rejang</em>, <em>Runic</em>, <em>Saurashtra</em>, <em>Shavian</em>, <em>Sinhala</em>, <em>Sundanese</em>, <em>Syloti_Nagri</em>, <em>Syriac</em>, <em>Tagalog</em>, <em>Tagbanwa</em>, <em>Tai_Le</em>, <em>Tamil</em>, <em>Telugu</em>, <em>Thaana</em>, <em>Thai</em>, <em>Tibetan</em>, <em>Tifinagh</em>, <em>Ugaritic</em>, <em>Vai</em>, and <em>Yi</em>.</p>

<p>Unicode codepoint U+06E9 is named “ARABIC PLACE OF SAJDAH” and belongs to the Arabic script:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\p{Arabic}</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\u06E9</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;\u06E9&quot;&gt;</span></code></pre>

<p>All character properties can be inverted by prefixing their name with a caret (<code>^</code>).</p>

<p>Letter ‘A’ is not in the Unicode Ll (Letter; Lowercase) category, so this match succeeds:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\p{^Ll}</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>A</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;A&quot;&gt;</span></code></pre>

<h3 id="label-Anchors">Anchors</h3>

<p>Anchors are metacharacter that match the zero-width positions between characters, <em>anchoring</em> the match to a specific position.</p>
<ul><li>
<p><code>^</code> - Matches beginning of line</p>
</li><li>
<p><code>$</code> - Matches end of line</p>
</li><li>
<p><code>\A</code> - Matches beginning of string.</p>
</li><li>
<p><code>\Z</code> - Matches end of string. If string ends with a newline, it matches just before newline</p>
</li><li>
<p><code>\z</code> - Matches end of string</p>
</li><li>
<p><code>\G</code> - Matches first matching position:</p>

<p>In methods like <a href="String.html#gsub-instance_method" title="String#gsub (method)">String#gsub</a> and <a href="String.html#scan-instance_method" title="String#scan (method)">String#scan</a>, it changes on each iteration. It initially matches the beginning of subject, and in each following iteration it matches where the last match finished.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>    a b c</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_gsub'>gsub</span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'> </span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>_</span><span class='tstring_end'>&#39;</span></span>)    <span class='comment'>#=&gt; &quot;____a_b_c&quot;
</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>    a b c</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_gsub'>gsub</span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\G </span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>_</span><span class='tstring_end'>&#39;</span></span>)  <span class='comment'>#=&gt; &quot;____a b c&quot;</span></code></pre>

<p>In methods like <a href="#match-instance_method" title="Regexp#match (method)">#match</a> and <a href="String.html#match-instance_method" title="String#match (method)">String#match</a> that take an (optional) offset, it matches where the search begins.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hello, world</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>,</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='int'>3</span>)    <span class='comment'>#=&gt; #&lt;MatchData &quot;,&quot;&gt;
</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hello, world</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\G,</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='int'>3</span>)  <span class='comment'>#=&gt; nil</span></code></pre>
</li><li>
<p><code>\b</code> - Matches word boundaries when outside brackets; backspace (0x08) when inside brackets</p>
</li><li>
<p><code>\B</code> - Matches non-word boundaries</p>
</li><li>
<p><code>(?=</code><em>pat</em><code>)</code> - <em>Positive lookahead</em> assertion: ensures that the following characters match <em>pat</em>, but doesn’t include those characters in the matched text</p>
</li><li>
<p><code>(?!</code><em>pat</em><code>)</code> - <em>Negative lookahead</em> assertion: ensures that the following characters do not match <em>pat</em>, but doesn’t include those characters in the matched text</p>
</li><li>
<p><code>(?&lt;=</code><em>pat</em><code>)</code> - <em>Positive lookbehind</em> assertion: ensures that the preceding characters match <em>pat</em>, but doesn’t include those characters in the matched text</p>
</li><li>
<p><code>(?&lt;!</code><em>pat</em><code>)</code> - <em>Negative lookbehind</em> assertion: ensures that the preceding characters do not match <em>pat</em>, but doesn’t include those characters in the matched text</p>
</li><li>
<p><code>\K</code> - <em>Match reset</em>: the matched content preceding <code>\K</code> in the regexp is excluded from the result.  For example, the following two regexps are almost equivalent:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>ab\Kc</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span>     <span class='comment'>#=&gt; 0
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;=ab)c</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span>  <span class='comment'>#=&gt; 2</span></code></pre>

<p>These match same string and <em>$&amp;</em> equals <code>&quot;c&quot;</code>, while the matched position is different.</p>

<p>As are the following two regexps:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(a)\K(b)\Kc</span><span class='regexp_end'>/</span></span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;=(?&lt;=(a))(b))c</span><span class='regexp_end'>/</span></span></code></pre>
</li></ul>

<p>If a pattern isn’t anchored it can begin at any point in the string:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>real</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>surrealist</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;real&quot;&gt;</span></code></pre>

<p>Anchoring the pattern to the beginning of the string forces the match to start there. ‘real’ doesn’t occur at the beginning of the string, so now the match fails:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\Areal</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>surrealist</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; nil</span></code></pre>

<p>The match below fails because although ‘Demand’ contains ‘and’, the pattern does not occur at a word boundary.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\band</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Demand</span><span class='tstring_end'>&quot;</span></span>)</code></pre>

<p>Whereas in the following example ‘and’ has been anchored to a non-word boundary so instead of matching the first ‘and’ it matches from the fourth letter of ‘demand’ instead:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\Band.+</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Supply and demand curve</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;and curve&quot;&gt;</span></code></pre>

<p>The pattern below uses positive lookahead and positive lookbehind to match text appearing in  tags without including the tags in the match:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;=&lt;b&gt;)\w+(?=&lt;\/b&gt;)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Fortune favours the &lt;b&gt;bold&lt;/b&gt;</span><span class='tstring_end'>&quot;</span></span>)
    <span class='comment'>#=&gt; #&lt;MatchData &quot;bold&quot;&gt;</span></code></pre>

<h3 id="label-Options">Options</h3>

<p>The end delimiter for a regexp can be followed by one or more single-letter options which control how the pattern can match.</p>
<ul><li>
<p><code>/pat/i</code> - Ignore case</p>
</li><li>
<p><code>/pat/m</code> - Treat a newline as a character matched by <code>.</code></p>
</li><li>
<p><code>/pat/x</code> - Ignore whitespace and comments in the pattern</p>
</li><li>
<p><code>/pat/o</code> - Perform <code>#{}</code> interpolation only once</p>
</li></ul>

<p><code>i</code>, <code>m</code>, and <code>x</code> can also be applied on the subexpression level with the <code>(?</code><em>on</em><code>-</code><em>off</em><code>)</code> construct, which enables options <em>on</em>, and disables options <em>off</em> for the expression enclosed by the parentheses:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a(?i:b)c</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>aBc</span><span class='tstring_end'>&#39;</span></span>)   <span class='comment'>#=&gt; #&lt;MatchData &quot;aBc&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a(?-i:b)c</span><span class='regexp_end'>/i</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>ABC</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'>#=&gt; nil</span></code></pre>

<p>Additionally, these options can also be toggled for the remainder of the pattern:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a(?i)bc</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>abC</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;abC&quot;&gt;</span></code></pre>

<p>Options may also be used with <a href="#new-class_method" title="Regexp.new (method)">.new</a>:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#IGNORECASE-constant" title="Regexp::IGNORECASE (constant)">IGNORECASE</a></span>)                     <span class='comment'>#=&gt; /abc/i
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#MULTILINE-constant" title="Regexp::MULTILINE (constant)">MULTILINE</a></span>)                      <span class='comment'>#=&gt; /abc/m
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc # Comment</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#EXTENDED-constant" title="Regexp::EXTENDED (constant)">EXTENDED</a></span>)             <span class='comment'>#=&gt; /abc # Comment/x
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#IGNORECASE-constant" title="Regexp::IGNORECASE (constant)">IGNORECASE</a></span> <span class='op'>|</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#MULTILINE-constant" title="Regexp::MULTILINE (constant)">MULTILINE</a></span>) <span class='comment'>#=&gt; /abc/mi
</span>
<span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>i</span><span class='tstring_end'>&quot;</span></span>)           <span class='comment'>#=&gt; /abc/i
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>m</span><span class='tstring_end'>&quot;</span></span>)           <span class='comment'>#=&gt; /abc/m
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc # Comment</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>x</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'>#=&gt; /abc # Comment/x
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>im</span><span class='tstring_end'>&quot;</span></span>)          <span class='comment'>#=&gt; /abc/mi</span></code></pre>

<h3 id="label-Free-Spacing+Mode+and+Comments">Free-Spacing Mode and Comments</h3>

<p>As mentioned above, the <code>x</code> option enables <em>free-spacing</em> mode. Literal white space inside the pattern is ignored, and the octothorpe (<code>#</code>) character introduces a comment until the end of the line. This allows the components of the pattern to be organized in a potentially more readable fashion.</p>

<p>A contrived pattern to match a number with optional decimal places:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_float_pat'>float_pat</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A
    [[:digit:]]+ # 1 or more digits before the decimal point
    (\.          # Decimal point
        [[:digit:]]+ # 1 or more digits after the decimal point
    )? # The decimal point and following digits are optional
\Z</span><span class='regexp_end'>/x</span></span>
<span class='id identifier rubyid_float_pat'>float_pat</span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>3.14</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;3.14&quot; 1:&quot;.14&quot;&gt;</span></code></pre>

<p>There are a number of strategies for matching whitespace:</p>
<ul><li>
<p>Use a pattern such as <code>\s</code> or <code>\p{Space}</code>.</p>
</li><li>
<p>Use escaped whitespace such as <code>\ </code>, i.e. a space preceded by a backslash.</p>
</li><li>
<p>Use a character class such as <code>[ ]</code>.</p>
</li></ul>

<p>Comments can be included in a non-<code>x</code> pattern with the <code>(?#</code><em>comment</em><code>)</code> construct, where <em>comment</em> is arbitrary text ignored by the regexp engine.</p>

<p>Comments in regexp literals cannot include unescaped terminator characters.</p>

<h3 id="label-Encoding">Encoding</h3>

<p>Regular expressions are assumed to use the source encoding. This can be overridden with one of the following modifiers.</p>
<ul><li>
<p><code>/</code><em>pat</em><code>/u</code> - UTF-8</p>
</li><li>
<p><code>/</code><em>pat</em><code>/e</code> - EUC-JP</p>
</li><li>
<p><code>/</code><em>pat</em><code>/s</code> - Windows-31J</p>
</li><li>
<p><code>/</code><em>pat</em><code>/n</code> - ASCII-8BIT</p>
</li></ul>

<p>A regexp can be matched against a string when they either share an encoding, or the regexp’s encoding is <em>US-ASCII</em> and the string’s encoding is ASCII-compatible.</p>

<p>If a match between incompatible encodings is attempted an <a href="Encoding/CompatibilityError.html" title="Encoding::CompatibilityError (class)"><code>::Encoding::CompatibilityError</code></a> exception is raised.</p>

<p>The <a href="#fixed_encoding%3F-instance_method" title="Regexp#fixed_encoding? (method)">#fixed_encoding?</a> predicate indicates whether the regexp has a <em>fixed</em> encoding, that is one incompatible with ASCII. A regexp’s encoding can be explicitly fixed by supplying <a href="#FIXEDENCODING-constant" title="Regexp::FIXEDENCODING (constant)">FIXEDENCODING</a> as the second argument of <a href="#new-class_method" title="Regexp.new (method)">.new</a>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_force_encoding'>force_encoding</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>iso-8859-1</span><span class='tstring_end'>&quot;</span></span>)<span class='comma'>,</span><span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#FIXEDENCODING-constant" title="Regexp::FIXEDENCODING (constant)">FIXEDENCODING</a></span>)
<span class='id identifier rubyid_r'>r</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a\u3042</span><span class='tstring_end'>&quot;</span></span>
   <span class='comment'># raises Encoding::CompatibilityError: incompatible encoding regexp match
</span>   <span class='comment'>#         (ISO-8859-1 regexp with UTF-8 string)</span></code></pre>

<h3 id="label-Regexp+Global+Variables">Regexp Global Variables</h3>

<p>Pattern matching sets some global variables :</p>
<ul><li>
<p><code>$~</code> is equivalent to <code>Regexp.last_match;</code></p>
</li><li>
<p><code>$&amp;</code> contains the complete matched text;</p>
</li><li>
<p><code>$`</code> contains string before match;</p>
</li><li>
<p><code>$&#39;</code> contains string after match;</p>
</li><li>
<p><code>$1</code>, <code>$2</code> and so on contain text matching first, second, etc capture group;</p>
</li><li>
<p><code>$+</code> contains last capture group.</p>
</li></ul>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_m'>m</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>s(\w{2}).*(c)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'>#=&gt; #&lt;MatchData &quot;stac&quot; 1:&quot;ta&quot; 2:&quot;c&quot;&gt;
</span><span class='gvar'>$~</span>                                    <span class='comment'>#=&gt; #&lt;MatchData &quot;stac&quot; 1:&quot;ta&quot; 2:&quot;c&quot;&gt;
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_last_match'><a href="#last_match-class_method" title="Regexp.last_match (method)">last_match</a></span>                     <span class='comment'>#=&gt; #&lt;MatchData &quot;stac&quot; 1:&quot;ta&quot; 2:&quot;c&quot;&gt;
</span>
<span class='backref'>$&amp;</span>      <span class='comment'>#=&gt; &quot;stac&quot;
</span>        <span class='comment'># same as m[0]
</span><span class='backref'>$`</span>      <span class='comment'>#=&gt; &quot;hay&quot;
</span>        <span class='comment'># same as m.pre_match
</span><span class='backref'>$&#39;</span>      <span class='comment'>#=&gt; &quot;k&quot;
</span>        <span class='comment'># same as m.post_match
</span><span class='backref'>$1</span>      <span class='comment'>#=&gt; &quot;ta&quot;
</span>        <span class='comment'># same as m[1]
</span><span class='backref'>$2</span>      <span class='comment'>#=&gt; &quot;c&quot;
</span>        <span class='comment'># same as m[2]
</span><span class='backref'>$3</span>      <span class='comment'>#=&gt; nil
</span>        <span class='comment'># no third group in pattern
</span><span class='backref'>$+</span>      <span class='comment'>#=&gt; &quot;c&quot;
</span>        <span class='comment'># same as m[-1]</span></code></pre>

<p>These global variables are thread-local and method-local variables.</p>

<h3 id="label-Performance">Performance</h3>

<p>Certain pathological combinations of constructs can lead to abysmally bad performance.</p>

<p>Consider a string of 25 <em>a</em>s, a <em>d</em>, 4 <em>a</em>s, and a <em>c</em>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>25</span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>d</span><span class='tstring_end'>&#39;</span></span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>4</span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>c</span><span class='tstring_end'>&#39;</span></span>
<span class='comment'>#=&gt; &quot;aaaaaaaaaaaaaaaaaaaaaaaaadaaaac&quot;</span></code></pre>

<p>The following patterns match instantly as you would expect:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(b|a)</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span> <span class='comment'>#=&gt; 0
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(b|a+)</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span> <span class='comment'>#=&gt; 0
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(b|a+)*</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span> <span class='comment'>#=&gt; 0</span></code></pre>

<p>However, the following pattern takes appreciably longer:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(b|a+)*c</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span> <span class='comment'>#=&gt; 26</span></code></pre>

<p>This happens because an atom in the regexp is quantified by both an immediate <code>+</code> and an enclosing <code>*</code> with nothing to differentiate which is in control of any particular character. The nondeterminism that results produces super-linear performance. (Consult <em>Mastering Regular Expressions</em> (3rd ed.), pp 222, by <em>Jeffery Friedl</em>, for an in-depth analysis). This particular case can be fixed by use of atomic grouping, which prevents the unnecessary backtracking:</p>

<pre class="code ruby"><code class="ruby">(<span class='id identifier rubyid_start'>start</span> <span class='op'>=</span> <span class='const'><a href="Time.html" title="Time (class)">Time</a></span>.<span class='id identifier rubyid_now'><a href="Time.html#now-class_method" title="Time.now (method)">now</a></span>) <span class='op'>&amp;&amp;</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(b|a+)*c</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span> <span class='op'>&amp;&amp;</span> (<span class='const'><a href="Time.html" title="Time (class)">Time</a></span>.<span class='id identifier rubyid_now'><a href="Time.html#now-class_method" title="Time.now (method)">now</a></span> <span class='op'>-</span> <span class='id identifier rubyid_start'>start</span>)
   <span class='comment'>#=&gt; 24.702736882
</span>(<span class='id identifier rubyid_start'>start</span> <span class='op'>=</span> <span class='const'><a href="Time.html" title="Time (class)">Time</a></span>.<span class='id identifier rubyid_now'><a href="Time.html#now-class_method" title="Time.now (method)">now</a></span>) <span class='op'>&amp;&amp;</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&gt;b|a+)*c</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span> <span class='op'>&amp;&amp;</span> (<span class='const'><a href="Time.html" title="Time (class)">Time</a></span>.<span class='id identifier rubyid_now'><a href="Time.html#now-class_method" title="Time.now (method)">now</a></span> <span class='op'>-</span> <span class='id identifier rubyid_start'>start</span>)
   <span class='comment'>#=&gt; 0.000166571</span></code></pre>

<p>A similar case is typified by the following example, which takes approximately 60 seconds to execute for me:</p>

<p>Match a string of 29 <em>a</em>s against a pattern of 29 optional <em>a</em>s followed by 29 mandatory <em>a</em>s:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a?</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>29</span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>29</span>) <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>29</span></code></pre>

<p>The 29 optional <em>a</em>s match the string, but this prevents the 29 mandatory <em>a</em>s that follow from matching. Ruby must then backtrack repeatedly so as to satisfy as many of the optional matches as it can while still matching the mandatory 29. It is plain to us that none of the optional matches can succeed, but this fact unfortunately eludes Ruby.</p>

<p>The best way to improve performance is to significantly reduce the amount of backtracking needed.  For this case, instead of individually matching 29 optional <em>a</em>s, a range of optional <em>a</em>s can be matched all at once with <em>a<code>0,29</code></em>:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a{0,29}</span><span class='tstring_end'>&#39;</span></span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>29</span>) <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>29</span></code></pre>

<h3 id="label-Timeout">Timeout</h3>

<p>There are two APIs to set timeout. One is <a href="#timeout=-class_method" title="Regexp.timeout= (method)">.timeout=</a>, which is process-global configuration of timeout for <code>Regexp</code> matching.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_timeout'><a href="#timeout-class_method" title="Regexp.timeout (method)">timeout</a></span> <span class='op'>=</span> <span class='int'>3</span>
<span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>25</span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>d</span><span class='tstring_end'>&#39;</span></span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>4</span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>c</span><span class='tstring_end'>&#39;</span></span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(b|a+)*c</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span>  <span class='comment'>#=&gt; This raises an exception in three seconds</span></code></pre>

<p>The other is timeout keyword of <a href="#new-class_method" title="Regexp.new (method)">.new</a>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_re'>re</span> <span class='op'>=</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>(b|a+)*c</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>timeout:</span> <span class='int'>3</span>)
<span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>25</span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>d</span><span class='tstring_end'>&#39;</span></span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>4</span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>c</span><span class='tstring_end'>&#39;</span></span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(b|a+)*c</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span>  <span class='comment'>#=&gt; This raises an exception in three seconds</span></code></pre>

<p>When using Regexps to process untrusted input, you should use the timeout feature to avoid excessive backtracking. Otherwise, a malicious user can provide input to <code>Regexp</code> causing Denial-of-Service attack. Note that the timeout is not set by default because an appropriate limit highly depends on an application requirement and context.</p>

  </div>
</div>
</div>
<h2 id='t2_cnst' class='h2_sum'>Constant Summary</h2>
<div>
<ul class='constants summary full'>
  <li>
    <span id='EXTENDED-constant' class='summary_signature'>EXTENDED =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>see <a href="#options-instance_method" title="Regexp#options (method)">#options</a> and <a href="#new-class_method" title="Regexp.new (method)">.new</a></p>

  </div>
</div>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4759'># File 're.c', line 4759</a>    <pre class='code c'><span class='const'>INT2FIX</span>(<span class='const'>ONIG_OPTION_EXTEND</span>)</pre>
  </li>
  <li>
    <span id='FIXEDENCODING-constant' class='summary_signature'>FIXEDENCODING =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>see <a href="#options-instance_method" title="Regexp#options (method)">#options</a> and <a href="#new-class_method" title="Regexp.new (method)">.new</a></p>

  </div>
</div>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4763'># File 're.c', line 4763</a>    <pre class='code c'><span class='const'>INT2FIX</span>(<span class='const'>ARG_ENCODING_FIXED</span>)</pre>
  </li>
  <li>
    <span id='IGNORECASE-constant' class='summary_signature'>IGNORECASE =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>see <a href="#options-instance_method" title="Regexp#options (method)">#options</a> and <a href="#new-class_method" title="Regexp.new (method)">.new</a></p>

  </div>
</div>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4757'># File 're.c', line 4757</a>    <pre class='code c'><span class='const'>INT2FIX</span>(<span class='const'>ONIG_OPTION_IGNORECASE</span>)</pre>
  </li>
  <li>
    <span id='MULTILINE-constant' class='summary_signature'>MULTILINE =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>see <a href="#options-instance_method" title="Regexp#options (method)">#options</a> and <a href="#new-class_method" title="Regexp.new (method)">.new</a></p>

  </div>
</div>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4761'># File 're.c', line 4761</a>    <pre class='code c'><span class='const'>INT2FIX</span>(<span class='const'>ONIG_OPTION_MULTILINE</span>)</pre>
  </li>
  <li>
    <span id='NOENCODING-constant' class='summary_signature'>NOENCODING =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>see <a href="#options-instance_method" title="Regexp#options (method)">#options</a> and <a href="#new-class_method" title="Regexp.new (method)">.new</a></p>

  </div>
</div>
    <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4765'># File 're.c', line 4765</a>    <pre class='code c'><span class='const'>INT2FIX</span>(<span class='const'>ARG_ENCODING_NONE</span>)</pre>
  </li>
</ul>
</div>

<h2 class='h2_sum' id='class_attribute_summary'>Class Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature rw'>
      <a href="#timeout-class_method" title="timeout (class method)">.<strong>timeout</strong>  &#x21d2; Float<sup>?</sup> </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>It returns the current default timeout interval for <code>Regexp</code> matching in second.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#timeout=-class_method" title="timeout= (class method)">.<strong>timeout=</strong>(float or nil)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>It sets the default timeout interval for <code>Regexp</code> matching in second.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- class_attribute_summary -->

<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#compile-class_method" title=".compile (class method)">.<strong>compile</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#new-class_method" title="Regexp.new (method)">.new</a></p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#escape-class_method" title="escape (class method)">.<strong>escape</strong>(string)  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#quote-class_method" title="Regexp.quote (method)">.quote</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#last_match-class_method" title="last_match (class method)">.<strong>last_match</strong>  &#x21d2; MatchData<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>With no argument, returns the value of <code>$!</code>, which is the result of the most recent pattern match (see <code><code>Regexp</code> Global Variables</code>):</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#linear_time%3F-class_method" title="linear_time? (class method)">.<strong>linear_time?</strong>(re)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns <code>true</code> if matching against <code>re</code> can be done in linear time to the input string.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#new-class_method" title="new (class method)">.<strong>new</strong>(string, options = 0, timeout: nil)  &#x21d2; Regexp </a>
    </span>
    <span class='note title constructor'>constructor</span>
    <div class='summary_desc'>
      <div class='inline'><p>With argument <code>string</code> given, returns a new regexp with the given string and options:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#escape-class_method" title="escape (class method)">.<strong>escape</strong>(string)  &#x21d2; String </a>
      (also: .escape)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns a new string that escapes any characters that have special meaning in a regular expression:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#try_convert-class_method" title="try_convert (class method)">.<strong>try_convert</strong>(object)  &#x21d2; Regexp<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns <code>object</code> if it is a regexp:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#union-class_method" title="union (class method)">.<strong>union</strong>(*patterns)  &#x21d2; Regexp </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns a new regexp that is the union of the given patterns:</p></div>
    </div>
  </li>
</ul>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_attribute_summary'>Instance Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature ro'>
      <a href="#casefold%3F-instance_method" title="#casefold? (instance method)">#<strong>casefold?</strong>  </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns <code>true</code> if the case-insensitivity flag in <code>self</code> is set, <code>false</code> otherwise:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#fixed_encoding%3F-instance_method" title="#fixed_encoding? (instance method)">#<strong>fixed_encoding?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns <code>false</code> if <code>self</code> is applicable to a string with any ASCII-compatible encoding; otherwise returns <code>true</code>:</p></div>
    </div>
  </li>
</ul>
</div>  <!-- instance_attribute_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#==-instance_method" title="#== (instance method)">#<strong>==</strong>(object)  &#x21d2; Boolean </a>
      (also: #eql?)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns <code>true</code> if <code>object</code> is another Regexp whose pattern, flags, and encoding are the same as <code>self</code>, <code>false</code> otherwise:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#===-instance_method" title="#=== (instance method)">#<strong>===</strong>(string)  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns <code>true</code> if <code>self</code> finds a match in <code>string</code>:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#=~-instance_method" title="#=~ (instance method)">#<strong>=~</strong>(string)  &#x21d2; Integer<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the integer index (in characters) of the first match for <code>self</code> and <code>string</code>, or <code>nil</code> if none; also sets the <code>Regexp Global Variables</code>:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#encoding-instance_method" title="#encoding (instance method)">#<strong>encoding</strong>  &#x21d2; Encoding </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the <a href="Encoding.html" title="Encoding (class)"><code>::Encoding</code></a> object that represents the encoding of obj.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#eql%3F-instance_method" title="#eql? (instance method)">#<strong>eql?</strong>(object)  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#==-instance_method" title="Regexp#== (method)">#==</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#hash-instance_method" title="#hash (instance method)">#<strong>hash</strong>  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the integer hash value for <code>self</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#inspect-instance_method" title="#inspect (instance method)">#<strong>inspect</strong>  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns a nicely-formatted string representation of <code>self</code>:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#match-instance_method" title="#match (instance method)">#<strong>match</strong>(string, offset = 0)  &#x21d2; MatchData<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>With no block given, returns the <a href="MatchData.html" title="MatchData (class)"><code>::MatchData</code></a> object that describes the match, if any, or <code>nil</code> if none; the search begins at the given character <code>offset</code> in <code>string</code>:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#match%3F-instance_method" title="#match? (instance method)">#<strong>match?</strong>(string)  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns <code>true</code> or <code>false</code> to indicate whether the regexp is matched or not without updating $~ and other related variables.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#named_captures-instance_method" title="#named_captures (instance method)">#<strong>named_captures</strong>  &#x21d2; Hash </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns a hash representing named captures of <code>self</code> (see <code>Named Captures</code>):</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#names-instance_method" title="#names (instance method)">#<strong>names</strong>  &#x21d2; array_of_names </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns an array of names of captures (see <code>Named Captures</code>):</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#options-instance_method" title="#options (instance method)">#<strong>options</strong>  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns an integer whose bits show the options set in <code>self</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#source-instance_method" title="#source (instance method)">#<strong>source</strong>  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the original string of <code>self</code>:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#timeout-instance_method" title="#timeout (instance method)">#<strong>timeout</strong>  &#x21d2; Float<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>It returns the timeout interval for <code>Regexp</code> matching in second.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#to_s-instance_method" title="#to_s (instance method)">#<strong>to_s</strong>  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns a string showing the options and string of <code>self</code>:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#~-instance_method" title="#~ (instance method)">#<strong>~</strong>(rxp)  &#x21d2; Integer<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Equivalent to <code><em>rxp</em> =~ $_</code>:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature nodoc'>
      <a href="#initialize_copy-instance_method" title="#initialize_copy (instance method)">#<strong>initialize_copy</strong>(re)  </a>
    </span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
</ul>
</div>  <!-- instance_method_summary -->
<h2 id='Constructor_Details' class='y_details'>Constructor Details</h2>

  <section class='method_details first' id="new-class_method">
  <h3 class='signature  first'>
    <div class='inline-block'>
      <span class='overload'>.<strong>new</strong>(string, options = 0, timeout: nil)  &#x21d2; <code>Regexp</code> </span>
      <span class='overload'>.<strong>new</strong>(regexp, timeout: nil)  &#x21d2; <code>Regexp</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>With argument <code>string</code> given, returns a new regexp with the given string and options:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># =&gt; /foo/
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_source'><a href="#source-instance_method" title="Regexp#source (method)">source</a></span>              <span class='comment'># =&gt; &quot;foo&quot;
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_options'><a href="#options-instance_method" title="Regexp#options (method)">options</a></span>             <span class='comment'># =&gt; 0</span></code></pre>

<p>Optional argument <a href="#options-instance_method" title="Regexp#options (method)">#options</a> is one of the following:</p>
<ul><li>
<p>A String of options:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>i</span><span class='tstring_end'>&#39;</span></span>)  <span class='comment'># =&gt; /foo/i
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>im</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># =&gt; /foo/im</span></code></pre>
</li><li>
<p>The logical OR of one or more of the constants Regexp::EXTENDED, Regexp::IGNORECASE, Regexp::MULTILINE, and Regexp::NOENCODING:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#IGNORECASE-constant" title="Regexp::IGNORECASE (constant)">IGNORECASE</a></span>) <span class='comment'># =&gt; /foo/i
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#EXTENDED-constant" title="Regexp::EXTENDED (constant)">EXTENDED</a></span>)   <span class='comment'># =&gt; /foo/x
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#MULTILINE-constant" title="Regexp::MULTILINE (constant)">MULTILINE</a></span>)  <span class='comment'># =&gt; /foo/m
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#NOENCODING-constant" title="Regexp::NOENCODING (constant)">NOENCODING</a></span>)  <span class='comment'># =&gt; /foo/n
</span><span class='id identifier rubyid_flags'>flags</span> <span class='op'>=</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#IGNORECASE-constant" title="Regexp::IGNORECASE (constant)">IGNORECASE</a></span> <span class='op'>|</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#EXTENDED-constant" title="Regexp::EXTENDED (constant)">EXTENDED</a></span> <span class='op'>|</span>  <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#MULTILINE-constant" title="Regexp::MULTILINE (constant)">MULTILINE</a></span>
<span class='const'>Regexp</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_flags'>flags</span>)              <span class='comment'># =&gt; /foo/mix</span></code></pre>
</li><li>
<p><code>nil</code> or <code>false</code>, which is ignored.</p>
</li></ul>

<p>If optional keyword argument <a href="#timeout-class_method" title="Regexp.timeout (method)">.timeout</a> is given, its float value overrides the timeout interval for the class, <a href="#timeout-class_method" title="Regexp.timeout (method)">.timeout</a>. If <code>nil</code> is passed as +timeout, it uses the timeout interval for the class, <a href="#timeout-class_method" title="Regexp.timeout (method)">.timeout</a>.</p>

<p>With argument <code>regexp</code> given, returns a new regexp. The source, options, timeout are the same as <code>regexp</code>. <a href="#options-instance_method" title="Regexp#options (method)">#options</a> and <code>n_flag</code> arguments are ineffective.  The timeout can be overridden by <a href="#timeout-class_method" title="Regexp.timeout (method)">.timeout</a> keyword.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_options'><a href="#options-instance_method" title="Regexp#options (method)">options</a></span> <span class='op'>=</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#MULTILINE-constant" title="Regexp::MULTILINE (constant)">MULTILINE</a></span>
<span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_new'>new</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_options'><a href="#options-instance_method" title="Regexp#options (method)">options</a></span><span class='comma'>,</span> <span class='label'>timeout:</span> <span class='float'>1.1</span>) <span class='comment'># =&gt; /foo/m
</span><span class='id identifier rubyid_r2'>r2</span> <span class='op'>=</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_new'>new</span>(<span class='id identifier rubyid_r'>r</span>)                           <span class='comment'># =&gt; /foo/m
</span><span class='id identifier rubyid_r2'>r2</span>.<span class='id identifier rubyid_timeout'><a href="#timeout-class_method" title="Regexp.timeout (method)">timeout</a></span>                                   <span class='comment'># =&gt; 1.1
</span><span class='id identifier rubyid_r3'>r3</span> <span class='op'>=</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_new'>new</span>(<span class='id identifier rubyid_r'>r</span><span class='comma'>,</span> <span class='label'>timeout:</span> <span class='float'>3.14</span>)            <span class='comment'># =&gt; /foo/m
</span><span class='id identifier rubyid_r3'>r3</span>.<span class='id identifier rubyid_timeout'><a href="#timeout-class_method" title="Regexp.timeout (method)">timeout</a></span>                                   <span class='comment'># =&gt; 3.14</span></code></pre>

<p><a href="#compile-class_method" title="Regexp.compile (method)">.compile</a> is an alias for <code>new</code>.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L3916-L3927'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3916' data-end='3927'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 3916</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_initialize_m(int argc, VALUE *argv, VALUE self)
{
    struct reg_init_args args;

    reg_extract_args(argc, argv, &amp;args);
    reg_init_args(self, args.str, args.enc, args.flags);

    set_timeout(&amp;RREGEXP_PTR(self)-&gt;timelimit, args.timeout);

    return self;
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Class Attribute Details</h2>
<section class='method_details first' id="timeout-class_method">
  <h3 class='signature rw first'>
    .<strong>timeout</strong>  &#x21d2; <a href="Float.html" title="Float (class)">Float</a><sup>?</sup>  <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>It returns the current default timeout interval for <code>Regexp</code> matching in second. <code>nil</code> means no default timeout configuration.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4625-L4631'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4625' data-end='4631'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 4625</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_s_timeout_get(VALUE dummy)
{
    double d = hrtime2double(rb_reg_match_time_limit);
    if (d == 0.0) return Qnil;
    return DBL2NUM(d);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="timeout=-class_method">
  <h3 class='signature rw'>
    .<strong>timeout=</strong>(float or nil)   <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>It sets the default timeout interval for <code>Regexp</code> matching in second. <code>nil</code> means no default timeout configuration. This configuration is process-global. If you want to set timeout for each <code>Regexp</code>, use <a href="#timeout-class_method" title="Regexp.timeout (method)">.timeout</a> keyword for <a href="#new-class_method" title="Regexp.new (method)">.new</a>.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_timeout'><a href="#timeout-class_method" title="Regexp.timeout (method)">timeout</a></span> <span class='op'>=</span> <span class='int'>1</span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^a*b?a*$</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a</span><span class='tstring_end'>&quot;</span></span> <span class='op'>*</span> <span class='int'>100000</span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>x</span><span class='tstring_end'>&quot;</span></span> <span class='comment'>#=&gt; regexp match timeout (RuntimeError)</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4646-L4654'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4646' data-end='4654'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 4646</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_s_timeout_set(VALUE dummy, VALUE timeout)
{
    rb_ractor_ensure_main_ractor(&quot;can not access Regexp.timeout from non-main Ractors&quot;);

    set_timeout(&amp;rb_reg_match_time_limit, timeout);

    return timeout;
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Class Method Details</h2>
<section class='method_details first' id="compile-class_method">
  <h3 class='signature  first'>
    .<strong>compile</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#new-class_method" title="Regexp.new (method)">.new</a></p>

  </div>
</div>
  <span class='link_repo'>[ <a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4723'>GitHub</a> ]</span>

</section>

<section class='method_details' id="escape-class_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>.<strong>escape</strong>(string)  &#x21d2; <a href="String.html" title="String (class)">String</a> </span>
      <span class='overload'>.<strong>escape</strong>(string)  &#x21d2; <a href="String.html" title="String (class)">String</a> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#quote-class_method" title="Regexp.quote (method)">.quote</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="last_match-class_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>.<strong>last_match</strong>  &#x21d2; <a href="MatchData.html" title="MatchData (class)">MatchData</a><sup>?</sup> </span>
      <span class='overload'>.<strong>last_match</strong>(n)  &#x21d2; <a href="String.html" title="String (class)">String</a><sup>?</sup> </span>
      <span class='overload'>.<strong>last_match</strong>(name)  &#x21d2; <a href="String.html" title="String (class)">String</a><sup>?</sup> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>With no argument, returns the value of <code>$!</code>, which is the result of the most recent pattern match (see <code><code>Regexp</code> Global Variables</code>):</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>c(.)t</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>cat</span><span class='tstring_end'>&#39;</span></span>  <span class='comment'># =&gt; 0
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_last_match'>last_match</span> <span class='comment'># =&gt; #&lt;MatchData &quot;cat&quot; 1:&quot;a&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>      <span class='comment'># =&gt; nil
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_last_match'>last_match</span> <span class='comment'># =&gt; nil</span></code></pre>

<p>With non-negative integer argument <code>n</code>, returns the _n_th field in the matchdata, if any, or nil if none:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>c(.)t</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>cat</span><span class='tstring_end'>&#39;</span></span>     <span class='comment'># =&gt; 0
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_last_match'>last_match</span>(<span class='int'>0</span>) <span class='comment'># =&gt; &quot;cat&quot;
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_last_match'>last_match</span>(<span class='int'>1</span>) <span class='comment'># =&gt; &quot;a&quot;
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_last_match'>last_match</span>(<span class='int'>2</span>) <span class='comment'># =&gt; nil</span></code></pre>

<p>With negative integer argument <code>n</code>, counts backwards from the last field:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_last_match'>last_match</span>(<span class='op'>-</span><span class='int'>1</span>)       <span class='comment'># =&gt; &quot;a&quot;</span></code></pre>

<p>With string or symbol argument <code>name</code>, returns the string value for the named capture, if any:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;lhs&gt;\w)\s*=\s*(?&lt;rhs&gt;\w)</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>var = val</span><span class='tstring_end'>&#39;</span></span>
<span class='const'>Regexp</span>.<span class='id identifier rubyid_last_match'>last_match</span>        <span class='comment'># =&gt; #&lt;MatchData &quot;var = val&quot; lhs:&quot;var&quot;rhs:&quot;val&quot;&gt;
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_last_match'>last_match</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_lhs'>lhs</span>)  <span class='comment'># =&gt; &quot;var&quot;
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_last_match'>last_match</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rhs</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># =&gt; &quot;val&quot;
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_last_match'>last_match</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># Raises IndexError.</span></code></pre>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4562-L4573'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4562' data-end='4573'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 4562</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_s_last_match(int argc, VALUE *argv, VALUE _)
{
    if (rb_check_arity(argc, 0, 1) == 1) {
        VALUE match = rb_backref_get();
        int n;
        if (NIL_P(match)) return Qnil;
        n = match_backref_number(match, argv[0]);
        return rb_reg_nth_match(n, match);
    }
    return match_getter();
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="linear_time?-class_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>.<strong>linear_time?</strong>(re)  </span>
      <span class='overload'>.<strong>linear_time?</strong>(string, options = 0)  </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns <code>true</code> if matching against <code>re</code> can be done in linear time to the input string.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_linear_time?'>linear_time?</span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>re</span><span class='regexp_end'>/</span></span>) <span class='comment'># =&gt; true</span></code></pre>

<p>Note that this is a property of the ruby interpreter, not of the argument regular expression.  Identical regexp can or cannot run in linear time depending on your ruby binary.  Neither forward nor backward compatibility is guaranteed about the return value of this method.  Our current algorithm is (*1) but this is subject to change in the future.  Alternative implementations can also behave differently.  They might always return false for everything.</p>

<p>(*1): <a href="https://doi.org/10.1109/SP40001.2021.00032">doi.org/10.1109/SP40001.2021.00032</a></p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4339-L4350'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4339' data-end='4350'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 4339</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_s_linear_time_p(int argc, VALUE *argv, VALUE self)
{
    struct reg_init_args args;
    VALUE re = reg_extract_args(argc, argv, &amp;args);

    if (NIL_P(re)) {
        re = reg_init_args(rb_reg_alloc(), args.str, args.enc, args.flags);
    }

    return RBOOL(onig_check_linear_time(RREGEXP_PTR(re)));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="quote-class_method">
  <h3 class='signature '>
    .<strong>escape</strong>(string)  &#x21d2; <a href="String.html" title="String (class)">String</a>     <span class='aliases'>Also known as: <span class='names'>.escape</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns a new string that escapes any characters that have special meaning in a regular expression:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_escape'><a href="#escape-class_method" title="Regexp.escape (method)">escape</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>\*?{}.</span><span class='tstring_end'>&#39;</span></span>)      <span class='comment'># =&gt; &quot;\\\\\\*\\?\\{\\}\\.&quot;</span></code></pre>

<p>For any string <code>s</code>, this call returns a <a href="MatchData.html" title="MatchData (class)"><code>::MatchData</code></a> object:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='const'>Regexp</span>.<span class='id identifier rubyid_escape'><a href="#escape-class_method" title="Regexp.escape (method)">escape</a></span>(<span class='id identifier rubyid_s'>s</span>)) <span class='comment'># =&gt; /\\\\\\\*\\\?\\\{\\\}\\\./
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='id identifier rubyid_s'>s</span>)                       <span class='comment'># =&gt; #&lt;MatchData &quot;\\\\\\*\\?\\{\\}\\.&quot;&gt;</span></code></pre>

<p><code>quote</code> is an alias for <a href="#escape-class_method" title="Regexp.escape (method)">.escape</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4111-L4115'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4111' data-end='4115'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 4111</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_s_quote(VALUE c, VALUE str)
{
    return rb_reg_quote(reg_operand(str, TRUE));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="try_convert-class_method">
  <h3 class='signature '>
    .<strong>try_convert</strong>(object)  &#x21d2; <code>Regexp</code><sup>?</sup>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns <code>object</code> if it is a regexp:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_try_convert'>try_convert</span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>re</span><span class='regexp_end'>/</span></span>) <span class='comment'># =&gt; /re/</span></code></pre>

<p>Otherwise if <code>object</code> responds to <code>:to_regexp</code>, calls <code>object.to_regexp</code> and returns the result.</p>

<p>Returns <code>nil</code> if <code>object</code> does not respond to <code>:to_regexp</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_try_convert'>try_convert</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>re</span><span class='tstring_end'>&#39;</span></span>) <span class='comment'># =&gt; nil</span></code></pre>

<p>Raises an exception unless <code>object.to_regexp</code> returns a regexp.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4153-L4157'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4153' data-end='4157'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 4153</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_s_try_convert(VALUE dummy, VALUE re)
{
    return rb_check_regexp_type(re);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="union-class_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>.<strong>union</strong>(*patterns)  &#x21d2; <code>Regexp</code> </span>
      <span class='overload'>.<strong>union</strong>(array_of_patterns)  &#x21d2; <code>Regexp</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns a new regexp that is the union of the given patterns:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_union'>union</span>(<span class='qwords'><span class='qwords_beg'>%w[</span><span class='tstring_content'>cat</span><span class='words_sep'> </span><span class='tstring_content'>dog</span><span class='tstring_end'>]</span></span>)      <span class='comment'># =&gt; /cat|dog/
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>cat</span><span class='tstring_end'>&#39;</span></span>)      <span class='comment'># =&gt; #&lt;MatchData &quot;cat&quot;&gt;
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>dog</span><span class='tstring_end'>&#39;</span></span>)      <span class='comment'># =&gt; #&lt;MatchData &quot;dog&quot;&gt;
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match'><a href="#match-instance_method" title="Regexp#match (method)">match</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>cog</span><span class='tstring_end'>&#39;</span></span>)      <span class='comment'># =&gt; nil</span></code></pre>

<p>For each pattern that is a string, <code>Regexp.new(pattern)</code> is used:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_union'>union</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>penzance</span><span class='tstring_end'>&#39;</span></span>)             <span class='comment'># =&gt; /penzance/
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_union'>union</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a+b*c</span><span class='tstring_end'>&#39;</span></span>)                <span class='comment'># =&gt; /a\+b\*c/
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_union'>union</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>skiing</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>sledding</span><span class='tstring_end'>&#39;</span></span>)   <span class='comment'># =&gt; /skiing|sledding/
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_union'>union</span>([<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>skiing</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>sledding</span><span class='tstring_end'>&#39;</span></span>]) <span class='comment'># =&gt; /skiing|sledding/</span></code></pre>

<p>For each pattern that is a regexp, it is used as is, including its flags:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_union'>union</span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/i</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>bar</span><span class='regexp_end'>/m</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>baz</span><span class='regexp_end'>/x</span></span>)
<span class='comment'># =&gt; /(?i-mx:foo)|(?m-ix:bar)|(?x-mi:baz)/
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_union'>union</span>([<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/i</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>bar</span><span class='regexp_end'>/m</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>baz</span><span class='regexp_end'>/x</span></span>])
<span class='comment'># =&gt; /(?i-mx:foo)|(?m-ix:bar)|(?x-mi:baz)/</span></code></pre>

<p>With no arguments, returns <code>/(?!)/</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span>.<span class='id identifier rubyid_union'>union</span> <span class='comment'># =&gt; /(?!)/</span></code></pre>

<p>If any regexp pattern contains captures, the behavior is unspecified.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4307-L4316'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4307' data-end='4316'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 4307</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_s_union_m(VALUE self, VALUE args)
{
    VALUE v;
    if (RARRAY_LEN(args) == 1 &amp;&amp;
        !NIL_P(v = rb_check_array_type(rb_ary_entry(args, 0)))) {
        return rb_reg_s_union(self, v);
    }
    return rb_reg_s_union(self, args);
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Attribute Details</h2>
<section class='method_details first' id="casefold?-instance_method">
  <h3 class='signature ro first'>
    #<strong>casefold?</strong>   <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns <code>true</code> if the case-insensitivity flag in <code>self</code> is set, <code>false</code> otherwise:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_casefold?'>casefold?</span>           <span class='comment'># =&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a</span><span class='regexp_end'>/i</span></span>.<span class='id identifier rubyid_casefold?'>casefold?</span>          <span class='comment'># =&gt; true
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?i:a)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_casefold?'>casefold?</span>      <span class='comment'># =&gt; false</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L737-L742'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='737' data-end='742'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 737</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_casefold_p(VALUE re)
{
    rb_reg_check(re);
    return RBOOL(RREGEXP_PTR(re)-&gt;options &amp; ONIG_OPTION_IGNORECASE);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="fixed_encoding?-instance_method">
  <h3 class='signature ro'>
    #<strong>fixed_encoding?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns <code>false</code> if <code>self</code> is applicable to a string with any ASCII-compatible encoding; otherwise returns <code>true</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a</span><span class='regexp_end'>/</span></span>                                          <span class='comment'># =&gt; /a/
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_fixed_encoding?'>fixed_encoding?</span>                               <span class='comment'># =&gt; false
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match?'><a href="#match%3F-instance_method" title="Regexp#match? (method)">match?</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\u{6666} a</span><span class='tstring_end'>&quot;</span></span>)                          <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match?'><a href="#match%3F-instance_method" title="Regexp#match? (method)">match?</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xa1\xa2 a</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_force_encoding'>force_encoding</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span>)) <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match?'><a href="#match%3F-instance_method" title="Regexp#match? (method)">match?</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_force_encoding'>force_encoding</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span>))        <span class='comment'># =&gt; true
</span>
<span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a</span><span class='regexp_end'>/u</span></span>                                        <span class='comment'># =&gt; /a/
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_fixed_encoding?'>fixed_encoding?</span>                               <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match?'><a href="#match%3F-instance_method" title="Regexp#match? (method)">match?</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\u{6666} a</span><span class='tstring_end'>&quot;</span></span>)                          <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match?'><a href="#match%3F-instance_method" title="Regexp#match? (method)">match?</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xa1\xa2</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_force_encoding'>force_encoding</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span>))   <span class='comment'># Raises exception.
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match?'><a href="#match%3F-instance_method" title="Regexp#match? (method)">match?</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_force_encoding'>force_encoding</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span>))        <span class='comment'># =&gt; true
</span>
<span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\u{6666}</span><span class='regexp_end'>/</span></span>                                  <span class='comment'># =&gt; /\u{6666}/
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_fixed_encoding?'>fixed_encoding?</span>                               <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_encoding'><a href="#encoding-instance_method" title="Regexp#encoding (method)">encoding</a></span>                                      <span class='comment'># =&gt; #&lt;Encoding:UTF-8&gt;
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match?'><a href="#match%3F-instance_method" title="Regexp#match? (method)">match?</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\u{6666} a</span><span class='tstring_end'>&quot;</span></span>)                          <span class='comment'># =&gt; true
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match?'><a href="#match%3F-instance_method" title="Regexp#match? (method)">match?</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xa1\xa2</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_force_encoding'>force_encoding</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span>))   <span class='comment'># Raises exception.
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_match?'><a href="#match%3F-instance_method" title="Regexp#match? (method)">match?</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_force_encoding'>force_encoding</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span>))        <span class='comment'># =&gt; false</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L1527-L1531'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1527' data-end='1531'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 1527</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_fixed_encoding_p(VALUE re)
{
    return RBOOL(FL_TEST(re, KCODE_FIXED));
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="==-instance_method">
  <h3 class='signature  first'>
    #<strong>==</strong>(object)  &#x21d2; <code>Boolean</code>     <span class='aliases'>Also known as: <span class='names'>#eql?</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns <code>true</code> if <code>object</code> is another Regexp whose pattern, flags, and encoding are the same as <code>self</code>, <code>false</code> otherwise:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/</span></span> <span class='op'>==</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>)                          <span class='comment'># =&gt; true
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/</span></span> <span class='op'>==</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/i</span></span>                                     <span class='comment'># =&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/</span></span> <span class='op'>==</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>food</span><span class='tstring_end'>&#39;</span></span>)                         <span class='comment'># =&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/</span></span> <span class='op'>==</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_force_encoding'>force_encoding</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span>)) <span class='comment'># =&gt; false</span></code></pre>

<p><a href="#eql%3F-instance_method" title="Regexp#eql? (method)">#eql?</a> is an alias for <code>==</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L3436-L3447'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3436' data-end='3447'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 3436</span></pre>
<pre class='code cpp'>

VALUE
rb_reg_equal(VALUE re1, VALUE re2)
{
    if (re1 == re2) return Qtrue;
    if (!RB_TYPE_P(re2, T_REGEXP)) return Qfalse;
    rb_reg_check(re1); rb_reg_check(re2);
    if (FL_TEST(re1, KCODE_FIXED) != FL_TEST(re2, KCODE_FIXED)) return Qfalse;
    if (RREGEXP_PTR(re1)-&gt;options != RREGEXP_PTR(re2)-&gt;options) return Qfalse;
    if (RREGEXP_SRC_LEN(re1) != RREGEXP_SRC_LEN(re2)) return Qfalse;
    if (ENCODING_GET(re1) != ENCODING_GET(re2)) return Qfalse;
    return RBOOL(memcmp(RREGEXP_SRC_PTR(re1), RREGEXP_SRC_PTR(re2), RREGEXP_SRC_LEN(re1)) == 0);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="===-instance_method">
  <h3 class='signature '>
    #<strong>===</strong>(string)  &#x21d2; <code>Boolean</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns <code>true</code> if <code>self</code> finds a match in <code>string</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^[a-z]*$</span><span class='regexp_end'>/</span></span> <span class='op'>===</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>HELLO</span><span class='tstring_end'>&#39;</span></span> <span class='comment'># =&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^[A-Z]*$</span><span class='regexp_end'>/</span></span> <span class='op'>===</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>HELLO</span><span class='tstring_end'>&#39;</span></span> <span class='comment'># =&gt; true</span></code></pre>

<p>This method is called in case statements:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>HELLO</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>case</span> <span class='id identifier rubyid_s'>s</span>
<span class='kw'>when</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A[a-z]*\z</span><span class='regexp_end'>/</span></span><span class='semicolon'>;</span> <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Lower case\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>when</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A[A-Z]*\z</span><span class='regexp_end'>/</span></span><span class='semicolon'>;</span> <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Upper case\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span>               <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Mixed case\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span> <span class='comment'># =&gt; &quot;Upper case&quot;</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L3629-L3641'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3629' data-end='3641'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 3629</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_eqq(VALUE re, VALUE str)
{
    long start;

    str = reg_operand(str, FALSE);
    if (NIL_P(str)) {
        rb_backref_set(Qnil);
        return Qfalse;
    }
    start = rb_reg_search(re, str, 0, 0);
    return RBOOL(start &gt;= 0);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="=~-instance_method">
  <h3 class='signature '>
    #<strong>=~</strong>(string)  &#x21d2; <a href="Integer.html" title="Integer (class)">Integer</a><sup>?</sup>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the integer index (in characters) of the first match for <code>self</code> and <code>string</code>, or <code>nil</code> if none; also sets the <code>Regexp Global Variables</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>at</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>input data</span><span class='tstring_end'>&#39;</span></span> <span class='comment'># =&gt; 7
</span><span class='gvar'>$~</span>                   <span class='comment'># =&gt; #&lt;MatchData &quot;at&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>ax</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>input data</span><span class='tstring_end'>&#39;</span></span> <span class='comment'># =&gt; nil
</span><span class='gvar'>$~</span>                   <span class='comment'># =&gt; nil</span></code></pre>

<p>Assigns named captures to local variables of the same names if and only if <code>self</code>:</p>
<ul><li>
<p>Is a regexp literal; see <code>Regexp Literals</code>.</p>
</li><li>
<p>Does not contain interpolations; see <code>Regexp Interpolation</code>.</p>
</li><li>
<p>Is at the left of the expression.</p>
</li></ul>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;lhs&gt;\w)\s*=\s*(?&lt;rhs&gt;\w)</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>  x = y  </span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_lhs'>lhs</span> <span class='comment'># =&gt; &quot;x&quot;
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_rhs'>rhs</span> <span class='comment'># =&gt; &quot;y&quot;</span></code></pre>

<p>Assigns <code>nil</code> if not matched:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;lhs&gt;\w)\s*=\s*(?&lt;rhs&gt;\w)</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>  x = </span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_lhs'>lhs</span> <span class='comment'># =&gt; nil
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_rhs'>rhs</span> <span class='comment'># =&gt; nil</span></code></pre>

<p>Does not make local variable assignments if <code>self</code> is not a regexp literal:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;foo&gt;\w)\s*=\s*(?&lt;foo&gt;\w)</span><span class='regexp_end'>/</span></span>
<span class='id identifier rubyid_r'>r</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>  x = y  </span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_foo'>foo</span> <span class='comment'># Undefined local variable
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_bar'>bar</span> <span class='comment'># Undefined local variable</span></code></pre>

<p>The assignment does not occur if the regexp is not at the left:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>  x = y  </span><span class='tstring_end'>&#39;</span></span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;foo&gt;\w)\s*=\s*(?&lt;foo&gt;\w)</span><span class='regexp_end'>/</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_foo'>foo</span><span class='comma'>,</span> <span class='id identifier rubyid_foo'>foo</span> <span class='comment'># Undefined local variables</span></code></pre>

<p>A regexp interpolation, <code>#{}</code>, also disables the assignment:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;foo&gt;\w+)</span><span class='regexp_end'>/</span></span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;foo&gt;\w+)\s*=\s*</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_r'>r</span><span class='embexpr_end'>}</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>x = y</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_foo'>foo</span> <span class='comment'># Undefined local variable</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L3600-L3607'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3600' data-end='3607'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 3600</span></pre>
<pre class='code cpp'>

VALUE
rb_reg_match(VALUE re, VALUE str)
{
    long pos = reg_match_pos(re, &amp;str, 0, NULL);
    if (pos &lt; 0) return Qnil;
    pos = rb_str_sublen(str, pos);
    return LONG2FIX(pos);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="encoding-instance_method">
  <h3 class='signature '>
    #<strong>encoding</strong>  &#x21d2; <a href="Encoding.html" title="Encoding (class)">Encoding</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the <a href="Encoding.html" title="Encoding (class)"><code>::Encoding</code></a> object that represents the encoding of obj.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/encoding.c#L1159-L1167'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1159' data-end='1167'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'encoding.c', line 1159</span></pre>
<pre class='code cpp'>

VALUE
rb_obj_encoding(VALUE obj)
{
    int idx = rb_enc_get_index(obj);
    if (idx &lt; 0) {
        rb_raise(rb_eTypeError, &quot;unknown encoding&quot;);
    }
    return rb_enc_from_encoding_index(idx &amp; ENC_INDEX_MASK);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="eql?-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>==</strong>(object)  &#x21d2; <code>Boolean</code> </span>
      <span class='overload'>#<strong>eql?</strong>(object)  &#x21d2; <code>Boolean</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#==-instance_method" title="Regexp#== (method)">#==</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="hash-instance_method">
  <h3 class='signature '>
    #<strong>hash</strong>  &#x21d2; <a href="Integer.html" title="Integer (class)">Integer</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the integer hash value for <code>self</code>.</p>

<p>Related: <a href="Object.html#hash-instance_method" title="Object#hash (method)">Object#hash</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L3401-L3406'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3401' data-end='3406'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 3401</span></pre>
<pre class='code cpp'>

VALUE
rb_reg_hash(VALUE re)
{
    st_index_t hashval = reg_hash(re);
    return ST2FIX(hashval);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="initialize_copy-instance_method">
  <h3 class='signature nodoc'>
    #<strong>initialize_copy</strong>(re)  
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4353-L4359'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4353' data-end='4359'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 4353</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_init_copy(VALUE copy, VALUE re)
{
    if (!OBJ_INIT_COPY(copy, re)) return copy;
    rb_reg_check(re);
    return rb_reg_init_str(copy, RREGEXP_SRC(re), rb_reg_options(re));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="inspect-instance_method">
  <h3 class='signature '>
    #<strong>inspect</strong>  &#x21d2; <a href="String.html" title="String (class)">String</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns a nicely-formatted string representation of <code>self</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>ab+c</span><span class='regexp_end'>/ix</span></span>.<span class='id identifier rubyid_inspect'>inspect</span> <span class='comment'># =&gt; &quot;/ab+c/ix&quot;</span></code></pre>

<p>Related: <a href="#to_s-instance_method" title="Regexp#to_s (method)">#to_s</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L520-L527'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='520' data-end='527'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 520</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_inspect(VALUE re)
{
    if (!RREGEXP_PTR(re) || !RREGEXP_SRC(re) || !RREGEXP_SRC_PTR(re)) {
        return rb_any_to_s(re);
    }
    return rb_reg_desc(RREGEXP_SRC_PTR(re), RREGEXP_SRC_LEN(re), re);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="match-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>match</strong>(string, offset = 0)  &#x21d2; <a href="MatchData.html" title="MatchData (class)">MatchData</a><sup>?</sup> </span>
      <span class='overload'>#<strong>match</strong>(string, offset = 0) {|matchdata| ... } &#x21d2; <a href="Object.html" title="Object (class)">Object</a> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>With no block given, returns the <a href="MatchData.html" title="MatchData (class)"><code>::MatchData</code></a> object that describes the match, if any, or <code>nil</code> if none; the search begins at the given character <code>offset</code> in <code>string</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abra</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>abracadabra</span><span class='tstring_end'>&#39;</span></span>)      <span class='comment'># =&gt; #&lt;MatchData &quot;abra&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abra</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>abracadabra</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>4</span>)   <span class='comment'># =&gt; #&lt;MatchData &quot;abra&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abra</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>abracadabra</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>8</span>)   <span class='comment'># =&gt; nil
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abra</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>abracadabra</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>800</span>) <span class='comment'># =&gt; nil
</span>
<span class='id identifier rubyid_string'>string</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\u{5d0 5d1 5e8 5d0}cadabra</span><span class='tstring_end'>&quot;</span></span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abra</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='id identifier rubyid_string'>string</span><span class='comma'>,</span> <span class='int'>7</span>)          <span class='comment'>#=&gt; #&lt;MatchData &quot;abra&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abra</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='id identifier rubyid_string'>string</span><span class='comma'>,</span> <span class='int'>8</span>)          <span class='comment'>#=&gt; nil
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abra</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='id identifier rubyid_string'>string</span>.<span class='id identifier rubyid_b'>b</span><span class='comma'>,</span> <span class='int'>8</span>)        <span class='comment'>#=&gt; #&lt;MatchData &quot;abra&quot;&gt;</span></code></pre>

<p>With a block given, calls the block if and only if a match is found; returns the block’s value:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abra</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>abracadabra</span><span class='tstring_end'>&#39;</span></span>) {<span class='op'>|</span><span class='id identifier rubyid_matchdata'>matchdata</span><span class='op'>|</span> <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_matchdata'>matchdata</span> }
<span class='comment'># =&gt; #&lt;MatchData &quot;abra&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abra</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>abracadabra</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>4</span>) {<span class='op'>|</span><span class='id identifier rubyid_matchdata'>matchdata</span><span class='op'>|</span> <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_matchdata'>matchdata</span> }
<span class='comment'># =&gt; #&lt;MatchData &quot;abra&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abra</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>abracadabra</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>8</span>) {<span class='op'>|</span><span class='id identifier rubyid_matchdata'>matchdata</span><span class='op'>|</span> <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_matchdata'>matchdata</span> }
<span class='comment'># =&gt; nil
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abra</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>abracadabra</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>8</span>) {<span class='op'>|</span><span class='id identifier rubyid_marchdata'>marchdata</span><span class='op'>|</span> <span class='id identifier rubyid_fail'>fail</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Cannot happen</span><span class='tstring_end'>&#39;</span></span> }
<span class='comment'># =&gt; nil</span></code></pre>

<p>Output (from the first two blocks above):</p>

<pre class="code ruby"><code class="ruby"><span class='comment'>#&lt;MatchData &quot;abra&quot;&gt;
</span><span class='comment'>#&lt;MatchData &quot;abra&quot;&gt;
</span>
 <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(.)(.)(.)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span>)[<span class='int'>2</span>] <span class='comment'># =&gt; &quot;b&quot;
</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(.)(.)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match'>match</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='int'>1</span>)[<span class='int'>2</span>] <span class='comment'># =&gt; &quot;c&quot;</span></code></pre>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L3716-L3739'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3716' data-end='3739'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 3716</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_match_m(int argc, VALUE *argv, VALUE re)
{
    VALUE result = Qnil, str, initpos;
    long pos;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;str, &amp;initpos) == 2) {
        pos = NUM2LONG(initpos);
    }
    else {
        pos = 0;
    }

    pos = reg_match_pos(re, &amp;str, pos, &amp;result);
    if (pos &lt; 0) {
        rb_backref_set(Qnil);
        return Qnil;
    }
    rb_match_busy(result);
    if (!NIL_P(result) &amp;&amp; rb_block_given_p()) {
        return rb_yield(result);
    }
    return result;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="match?-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>match?</strong>(string)  &#x21d2; <code>Boolean</code> </span>
      <span class='overload'>#<strong>match?</strong>(string, offset = 0)  &#x21d2; <code>Boolean</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns <code>true</code> or <code>false</code> to indicate whether the regexp is matched or not without updating $~ and other related variables. If the second parameter is present, it specifies the position in the string to begin the search.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>R...</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match?'>match?</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Ruby</span><span class='tstring_end'>&quot;</span></span>)    <span class='comment'># =&gt; true
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>R...</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match?'>match?</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Ruby</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='int'>1</span>) <span class='comment'># =&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>P...</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_match?'>match?</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Ruby</span><span class='tstring_end'>&quot;</span></span>)    <span class='comment'># =&gt; false
</span><span class='backref'>$&amp;</span>                       <span class='comment'># =&gt; nil</span></code></pre>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L3757-L3762'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3757' data-end='3762'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 3757</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_match_m_p(int argc, VALUE *argv, VALUE re)
{
    long pos = rb_check_arity(argc, 1, 2) &gt; 1 ? NUM2LONG(argv[1]) : 0;
    return rb_reg_match_p(re, argv[0], pos);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="named_captures-instance_method">
  <h3 class='signature '>
    #<strong>named_captures</strong>  &#x21d2; <a href="Hash.html" title="Hash (class)">Hash</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns a hash representing named captures of <code>self</code> (see <code>Named Captures</code>):</p>
<ul><li>
<p>Each key is the name of a named capture.</p>
</li><li>
<p>Each value is an array of integer indexes for that named capture.</p>
</li></ul>

<p>Examples:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;foo&gt;.)(?&lt;bar&gt;.)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_named_captures'>named_captures</span> <span class='comment'># =&gt; {&quot;foo&quot;=&gt;[1], &quot;bar&quot;=&gt;[2]}
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;foo&gt;.)(?&lt;foo&gt;.)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_named_captures'>named_captures</span> <span class='comment'># =&gt; {&quot;foo&quot;=&gt;[1, 2]}
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(.)(.)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_named_captures'>named_captures</span>             <span class='comment'># =&gt; {}</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L855-L862'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='855' data-end='862'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 855</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_named_captures(VALUE re)
{
    regex_t *reg = (rb_reg_check(re), RREGEXP_PTR(re));
    VALUE hash = rb_hash_new_with_size(onig_number_of_names(reg));
    onig_foreach_name(reg, reg_named_captures_iter, (void*)hash);
    return hash;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="names-instance_method">
  <h3 class='signature '>
    #<strong>names</strong>  &#x21d2; <code>array_of_names</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns an array of names of captures (see <code>Named Captures</code>):</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_names'>names</span> <span class='comment'># =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;foo&gt;.)(?&lt;foo&gt;.)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_names'>names</span>          <span class='comment'># =&gt; [&quot;foo&quot;]
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(.)(.)</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_names'>names</span>                      <span class='comment'># =&gt; []</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L811-L819'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='811' data-end='819'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 811</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_names(VALUE re)
{
    VALUE ary;
    rb_reg_check(re);
    ary = rb_ary_new_capa(onig_number_of_names(RREGEXP_PTR(re)));
    onig_foreach_name(RREGEXP_PTR(re), reg_names_iter, (void*)ary);
    return ary;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="options-instance_method">
  <h3 class='signature '>
    #<strong>options</strong>  &#x21d2; <a href="Integer.html" title="Integer (class)">Integer</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns an integer whose bits show the options set in <code>self</code>.</p>

<p>The option bits are:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#IGNORECASE-constant" title="Regexp::IGNORECASE (constant)">IGNORECASE</a></span> <span class='comment'># =&gt; 1
</span><span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#EXTENDED-constant" title="Regexp::EXTENDED (constant)">EXTENDED</a></span>   <span class='comment'># =&gt; 2
</span><span class='const'>Regexp</span><span class='op'>::</span><span class='const'><a href="#MULTILINE-constant" title="Regexp::MULTILINE (constant)">MULTILINE</a></span>  <span class='comment'># =&gt; 4</span></code></pre>

<p>Examples:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_options'>options</span>    <span class='comment'># =&gt; 0
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/i</span></span>.<span class='id identifier rubyid_options'>options</span>   <span class='comment'># =&gt; 1
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/x</span></span>.<span class='id identifier rubyid_options'>options</span>   <span class='comment'># =&gt; 2
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/m</span></span>.<span class='id identifier rubyid_options'>options</span>   <span class='comment'># =&gt; 4
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/mix</span></span>.<span class='id identifier rubyid_options'>options</span> <span class='comment'># =&gt; 7</span></code></pre>

<p>Note that additional bits may be set in the returned integer; these are maintained internally internally in <code>self</code>, are ignored if passed to <a href="#new-class_method" title="Regexp.new (method)">.new</a>, and may be ignored by the caller:</p>

<p>Returns the set of bits corresponding to the options used when creating this regexp (see <a href="#new-class_method" title="Regexp.new (method)">.new</a> for details). Note that additional bits may be set in the returned options: these are used internally by the regular expression code. These extra bits are ignored if the options are passed to <a href="#new-class_method" title="Regexp.new (method)">.new</a>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\xa1\xa2</span><span class='regexp_end'>/e</span></span>                 <span class='comment'># =&gt; /\xa1\xa2/
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_source'><a href="#source-instance_method" title="Regexp#source (method)">source</a></span>                        <span class='comment'># =&gt; &quot;\\xa1\\xa2&quot;
</span><span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_options'>options</span>                       <span class='comment'># =&gt; 16
</span><span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_source'><a href="#source-instance_method" title="Regexp#source (method)">source</a></span><span class='comma'>,</span> <span class='id identifier rubyid_r'>r</span>.<span class='id identifier rubyid_options'>options</span>) <span class='comment'># =&gt; /\xa1\xa2/</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L782-L787'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='782' data-end='787'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 782</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_options_m(VALUE re)
{
    int options = rb_reg_options(re);
    return INT2NUM(options);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="source-instance_method">
  <h3 class='signature '>
    #<strong>source</strong>  &#x21d2; <a href="String.html" title="String (class)">String</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the original string of <code>self</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>ab+c</span><span class='regexp_end'>/ix</span></span>.<span class='id identifier rubyid_source'>source</span> <span class='comment'># =&gt; &quot;ab+c&quot;</span></code></pre>

<p><code>Regexp</code> escape sequences are retained:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\x20\+</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_source'>source</span>  <span class='comment'># =&gt; &quot;\\x20\\+&quot;</span></code></pre>

<p>Lexer escape characters are not retained:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\/</span><span class='regexp_end'>/</span></span>.<span class='id identifier rubyid_source'>source</span>  <span class='comment'># =&gt; &quot;/&quot;</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L499-L507'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='499' data-end='507'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 499</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_source(VALUE re)
{
    VALUE str;

    rb_reg_check(re);
    str = rb_str_dup(RREGEXP_SRC(re));
    return str;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="timeout-instance_method">
  <h3 class='signature '>
    #<strong>timeout</strong>  &#x21d2; <a href="Float.html" title="Float (class)">Float</a><sup>?</sup>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>It returns the timeout interval for <code>Regexp</code> matching in second. <code>nil</code> means no default timeout configuration.</p>

<p>This configuration is per-object. The global configuration set by <a href="#timeout=-class_method" title="Regexp.timeout= (method)">.timeout=</a> is ignored if per-object configuration is set.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_re'>re</span> <span class='op'>=</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>^a*b?a*$</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>timeout:</span> <span class='int'>1</span>)
<span class='id identifier rubyid_re'>re</span>.<span class='id identifier rubyid_timeout'>timeout</span>               <span class='comment'>#=&gt; 1.0
</span><span class='id identifier rubyid_re'>re</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a</span><span class='tstring_end'>&quot;</span></span> <span class='op'>*</span> <span class='int'>100000</span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>x</span><span class='tstring_end'>&quot;</span></span> <span class='comment'>#=&gt; regexp match timeout (RuntimeError)</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L4671-L4678'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4671' data-end='4678'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 4671</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_timeout_get(VALUE re)
{
    rb_reg_check(re);
    double d = hrtime2double(RREGEXP_PTR(re)-&gt;timelimit);
    if (d == 0.0) return Qnil;
    return DBL2NUM(d);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="to_s-instance_method">
  <h3 class='signature '>
    #<strong>to_s</strong>  &#x21d2; <a href="String.html" title="String (class)">String</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns a string showing the options and string of <code>self</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r0'>r0</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>ab+c</span><span class='regexp_end'>/ix</span></span>
<span class='id identifier rubyid_s0'>s0</span> <span class='op'>=</span> <span class='id identifier rubyid_r0'>r0</span>.<span class='id identifier rubyid_to_s'>to_s</span> <span class='comment'># =&gt; &quot;(?ix-m:ab+c)&quot;</span></code></pre>

<p>The returned string may be used as an argument to <a href="#new-class_method" title="Regexp.new (method)">.new</a>, or as interpolated text for a <code><code>Regexp</code> literal</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r1'>r1</span> <span class='op'>=</span> <span class='const'>Regexp</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Regexp.new (method)">new</a></span>(<span class='id identifier rubyid_s0'>s0</span>) <span class='comment'># =&gt; /(?ix-m:ab+c)/
</span><span class='id identifier rubyid_r2'>r2</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_s0'>s0</span><span class='embexpr_end'>}</span><span class='regexp_end'>/</span></span>        <span class='comment'># =&gt; /(?ix-m:ab+c)/</span></code></pre>

<p>Note that <code>r1</code> and <code>r2</code> are not equal to <code>r0</code> because their original strings are different:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r0'>r0</span> <span class='op'>==</span> <span class='id identifier rubyid_r1'>r1</span>  <span class='comment'># =&gt; false
</span><span class='id identifier rubyid_r0'>r0</span>.<span class='id identifier rubyid_source'><a href="#source-instance_method" title="Regexp#source (method)">source</a></span> <span class='comment'># =&gt; &quot;ab+c&quot;
</span><span class='id identifier rubyid_r1'>r1</span>.<span class='id identifier rubyid_source'><a href="#source-instance_method" title="Regexp#source (method)">source</a></span> <span class='comment'># =&gt; &quot;(?ix-m:ab+c)&quot;</span></code></pre>

<p>Related: <a href="#inspect-instance_method" title="Regexp#inspect (method)">#inspect</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L558-L562'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='558' data-end='562'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 558</span></pre>
<pre class='code cpp'>

static VALUE
rb_reg_to_s(VALUE re)
{
    return rb_reg_str_with_term(re, &#39;/&#39;);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="~-instance_method">
  <h3 class='signature '>
    #<strong>~</strong>(rxp)  &#x21d2; <a href="Integer.html" title="Integer (class)">Integer</a><sup>?</sup>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Equivalent to <code><em>rxp</em> =~ $_</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='gvar'>$_</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>input data</span><span class='tstring_end'>&quot;</span></span>
<span class='op'>~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>at</span><span class='regexp_end'>/</span></span> <span class='comment'># =&gt; 7</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v3_2_9/re.c#L3655-L3672'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3655' data-end='3672'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 're.c', line 3655</span></pre>
<pre class='code cpp'>

VALUE
rb_reg_match2(VALUE re)
{
    long start;
    VALUE line = rb_lastline_get();

    if (!RB_TYPE_P(line, T_STRING)) {
        rb_backref_set(Qnil);
        return Qnil;
    }

    start = rb_reg_search(re, line, 0, 0);
    if (start &lt; 0) {
        return Qnil;
    }
    start = rb_str_sublen(line, start);
    return LONG2FIX(start);
}
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>