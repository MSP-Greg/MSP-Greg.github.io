<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Extension &mdash; Ruby-3.2.4</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "extension",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Ruby-3.2.4</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Extension&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="file_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>

<p># extension.rdoc -  -*- RDoc -*- created at: Mon Aug  7 16:45:54 JST 1995</p>

<h1 id="label-Creating+Extension+Libraries+for+Ruby">Creating Extension Libraries for Ruby</h1>

<p>This document explains how to make extension libraries for Ruby.</p>

<h2 id="label-Basic+Knowledge">Basic Knowledge</h2>

<p>In C, variables have types and data do not have types.  In contrast, Ruby variables do not have a static type, and data themselves have types, so data will need to be converted between the languages.</p>

<p>Data in Ruby are represented by the C type ‘VALUE’.  Each VALUE data has its data type.</p>

<p>To retrieve C data from a VALUE, you need to:</p>
<ol><li>
<p>Identify the VALUE’s data type</p>
</li><li>
<p>Convert the VALUE into C data</p>
</li></ol>

<p>Converting to the wrong data type may cause serious problems.</p>

<h3 id="label-Data+Types">Data Types</h3>

<p>The Ruby interpreter has the following data types:</p>
<dl class="rdoc-list note-list"><dt>T_NIL       
<dd>
<p>nil</p>
</dd><dt>T_OBJECT    
<dd>
<p>ordinary object</p>
</dd><dt>T_CLASS     
<dd>
<p>class</p>
</dd><dt>T_MODULE    
<dd>
<p>module</p>
</dd><dt>T_FLOAT     
<dd>
<p>floating point number</p>
</dd><dt>T_STRING    
<dd>
<p>string</p>
</dd><dt>T_REGEXP    
<dd>
<p>regular expression</p>
</dd><dt>T_ARRAY     
<dd>
<p>array</p>
</dd><dt>T_HASH      
<dd>
<p>associative array</p>
</dd><dt>T_STRUCT    
<dd>
<p>(Ruby) structure</p>
</dd><dt>T_BIGNUM    
<dd>
<p>multi precision integer</p>
</dd><dt>T_FIXNUM    
<dd>
<p>Fixnum(31bit or 63bit integer)</p>
</dd><dt>T_COMPLEX   
<dd>
<p>complex number</p>
</dd><dt>T_RATIONAL  
<dd>
<p>rational number</p>
</dd><dt>T_FILE      
<dd>
<p>IO</p>
</dd><dt>T_TRUE      
<dd>
<p>true</p>
</dd><dt>T_FALSE     
<dd>
<p>false</p>
</dd><dt>T_DATA      
<dd>
<p>data</p>
</dd><dt>T_SYMBOL    
<dd>
<p>symbol</p>
</dd></dl>

<p>In addition, there are several other types used internally:</p>
<dl class="rdoc-list note-list"><dt>T_ICLASS    
<dd>
<p>included module</p>
</dd><dt>T_MATCH     
<dd>
<p>MatchData object</p>
</dd><dt>T_UNDEF     
<dd>
<p>undefined</p>
</dd><dt>T_NODE      
<dd>
<p>syntax tree node</p>
</dd><dt>T_ZOMBIE    
<dd>
<p>object awaiting finalization</p>
</dd></dl>

<p>Most of the types are represented by C structures.</p>

<h3 id="label-Check+Data+Type+of+the+VALUE">Check Data Type of the VALUE</h3>

<p>The macro TYPE() defined in ruby.h shows the data type of the VALUE. TYPE() returns the constant number T_XXXX described above.  To handle data types, your code will look something like this:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_switch'>switch</span> (<span class='const'>TYPE</span>(<span class='id identifier rubyid_obj'>obj</span>)) {
  <span class='kw'>case</span> <span class='const'>T_FIXNUM</span><span class='op'>:</span>
    <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* process Fixnum *</span><span class='regexp_end'>/</span></span>
    <span class='kw'>break</span><span class='semicolon'>;</span>
  <span class='kw'>case</span> <span class='const'>T_STRING</span><span class='op'>:</span>
    <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* process String *</span><span class='regexp_end'>/</span></span>
    <span class='kw'>break</span><span class='semicolon'>;</span>
  <span class='kw'>case</span> <span class='const'>T_ARRAY</span><span class='op'>:</span>
    <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* process Array *</span><span class='regexp_end'>/</span></span>
    <span class='kw'>break</span><span class='semicolon'>;</span>
  <span class='id identifier rubyid_default'>default</span><span class='op'>:</span>
    <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* raise exception *</span><span class='regexp_end'>/</span></span>
    <span class='id identifier rubyid_rb_raise'>rb_raise</span>(<span class='id identifier rubyid_rb_eTypeError'>rb_eTypeError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>not valid value</span><span class='tstring_end'>&quot;</span></span>)<span class='semicolon'>;</span>
    <span class='kw'>break</span><span class='semicolon'>;</span>
}</code></pre>

<p>There is the data type check function</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='const'>Check_Type</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_type'>type</span>)</code></pre>

<p>which raises an exception if the VALUE does not have the type specified.</p>

<p>There are also faster check macros for fixnums and nil.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>FIXNUM_P</span>(<span class='id identifier rubyid_obj'>obj</span>)
<span class='const'>NIL_P</span>(<span class='id identifier rubyid_obj'>obj</span>)</code></pre>

<h3 id="label-Convert+VALUE+into+C+Data">Convert VALUE into C Data</h3>

<p>The data for type T_NIL, T_FALSE, T_TRUE are nil, false, true respectively.  They are singletons for the data type. The equivalent C constants are: Qnil, Qfalse, Qtrue. RTEST() will return true if a VALUE is neither Qfalse nor Qnil. If you need to differentiate Qfalse from Qnil, specifically test against Qfalse.</p>

<p>The T_FIXNUM data is a 31bit or 63bit length fixed integer. This size depends on the size of long: if long is 32bit then T_FIXNUM is 31bit, if long is 64bit then T_FIXNUM is 63bit. T_FIXNUM can be converted to a C integer by using the FIX2INT() macro or FIX2LONG().  Though you have to check that the data is really FIXNUM before using them, they are faster.  FIX2LONG() never raises exceptions, but FIX2INT() raises RangeError if the result is bigger or smaller than the size of int. There are also NUM2INT() and NUM2LONG() which converts any Ruby numbers into C integers.  These macros include a type check, so an exception will be raised if the conversion failed.  NUM2DBL() can be used to retrieve the double float value in the same way.</p>

<p>You can use the macros StringValue() and StringValuePtr() to get a char* from a VALUE. StringValue(var) replaces var’s value with the result of “var.to_str()”. StringValuePtr(var) does the same replacement and returns the char* representation of var.  These macros will skip the replacement if var is a String.  Notice that the macros take only the lvalue as their argument, to change the value of var in place.</p>

<p>You can also use the macro named StringValueCStr(). This is just like StringValuePtr(), but always adds a NUL character at the end of the result. If the result contains a NUL character, this macro causes the ArgumentError exception. StringValuePtr() doesn’t guarantee the existence of a NUL at the end of the result, and the result may contain NUL.</p>

<p>Other data types have corresponding C structures, e.g. struct RArray for T_ARRAY etc. The VALUE of the type which has the corresponding structure can be cast to retrieve the pointer to the struct.  The casting macro will be of the form RXXXX for each data type; for instance, RARRAY(obj).  See “ruby.h”.  However, we do not recommend to access RXXXX data directly because these data structures are complex. Use corresponding rb_xxx() functions to access the internal struct. For example, to access an entry of array, use rb_ary_entry(ary, offset) and rb_ary_store(ary, offset, obj).</p>

<p>There are some accessing macros for structure members, for example ‘RSTRING_LEN(str)’ to get the size of the Ruby String object.  The allocated region can be accessed by ‘RSTRING_PTR(str)’.</p>

<p>Notice: Do not change the value of the structure directly, unless you are responsible for the result.  This ends up being the cause of interesting bugs.</p>

<h3 id="label-Convert+C+Data+into+VALUE">Convert C Data into VALUE</h3>

<p>To convert C data to Ruby values:</p>
<dl class="rdoc-list note-list"><dt>FIXNUM 
<dd>
<p>left shift 1 bit, and turn on its least significant bit (LSB).</p>
</dd><dt>Other pointer values 
<dd>
<p>cast to VALUE.</p>
</dd></dl>

<p>You can determine whether a VALUE is a pointer or not by checking its LSB.</p>

<p>Notice: Ruby does not allow arbitrary pointer values to be a VALUE.  They should be pointers to the structures which Ruby knows about.  The known structures are defined in &lt;ruby.h&gt;.</p>

<p>To convert C numbers to Ruby values, use these macros:</p>
<dl class="rdoc-list note-list"><dt>INT2FIX() 
<dd>
<p>for integers within 31bits.</p>
</dd><dt>INT2NUM() 
<dd>
<p>for arbitrary sized integers.</p>
</dd></dl>

<p>INT2NUM() converts an integer into a Bignum if it is out of the FIXNUM range, but is a bit slower.</p>

<h3 id="label-Manipulating+Ruby+Data">Manipulating Ruby Data</h3>

<p>As I already mentioned, it is not recommended to modify an object’s internal structure.  To manipulate objects, use the functions supplied by the Ruby interpreter. Some (not all) of the useful functions are listed below:</p>

<h4 id="label-String+Functions">String Functions</h4>
<dl class="rdoc-list note-list"><dt>rb_str_new(const char *ptr, long len) 
<dd>
<p>Creates a new Ruby string.</p>
</dd><dt>rb_str_new2(const char *ptr) 
<dt>rb_str_new_cstr(const char *ptr) 
<dd>
<p>Creates a new Ruby string from a C string.  This is equivalent to rb_str_new(ptr, strlen(ptr)).</p>
</dd><dt>rb_str_new_literal(const char *ptr) 
<dd>
<p>Creates a new Ruby string from a C string literal.</p>
</dd><dt>rb_sprintf(const char *format, …) 
<dt>rb_vsprintf(const char *format, va_list ap) 
<dd>
<p>Creates a new Ruby string with printf(3) format.</p>

<p>Note: In the format string, “%”PRIsVALUE can be used for Object#to_s (or Object#inspect if ‘+’ flag is set) output (and related argument must be a VALUE).  Since it conflicts with “%i”, for integers in format strings, use “%d”.</p>
</dd><dt>rb_str_append(VALUE str1, VALUE str2) 
<dd>
<p>Appends Ruby string str2 to Ruby string str1.</p>
</dd><dt>rb_str_cat(VALUE str, const char *ptr, long len) 
<dd>
<p>Appends len bytes of data from ptr to the Ruby string.</p>
</dd><dt>rb_str_cat2(VALUE str, const char* ptr) 
<dt>rb_str_cat_cstr(VALUE str, const char* ptr) 
<dd>
<p>Appends C string ptr to Ruby string str.  This function is equivalent to rb_str_cat(str, ptr, strlen(ptr)).</p>
</dd><dt>rb_str_catf(VALUE str, const char* format, …) 
<dt>rb_str_vcatf(VALUE str, const char* format, va_list ap) 
<dd>
<p>Appends C string format and successive arguments to Ruby string str according to a printf-like format.  These functions are equivalent to rb_str_append(str, rb_sprintf(format, …)) and rb_str_append(str, rb_vsprintf(format, ap)), respectively.</p>
</dd><dt>rb_enc_str_new(const char *ptr, long len, rb_encoding *enc) 
<dt>rb_enc_str_new_cstr(const char *ptr, rb_encoding *enc) 
<dd>
<p>Creates a new Ruby string with the specified encoding.</p>
</dd><dt>rb_enc_str_new_literal(const char *ptr, rb_encoding *enc) 
<dd>
<p>Creates a new Ruby string from a C string literal with the specified encoding.</p>
</dd><dt>rb_usascii_str_new(const char *ptr, long len) 
<dt>rb_usascii_str_new_cstr(const char *ptr) 
<dd>
<p>Creates a new Ruby string with encoding US-ASCII.</p>
</dd><dt>rb_usascii_str_new_literal(const char *ptr) 
<dd>
<p>Creates a new Ruby string from a C string literal with encoding US-ASCII.</p>
</dd><dt>rb_utf8_str_new(const char *ptr, long len) 
<dt>rb_utf8_str_new_cstr(const char *ptr) 
<dd>
<p>Creates a new Ruby string with encoding UTF-8.</p>
</dd><dt>rb_utf8_str_new_literal(const char *ptr) 
<dd>
<p>Creates a new Ruby string from a C string literal with encoding UTF-8.</p>
</dd><dt>rb_str_resize(VALUE str, long len) 
<dd>
<p>Resizes a Ruby string to len bytes.  If str is not modifiable, this function raises an exception.  The length of str must be set in advance.  If len is less than the old length the content beyond len bytes is discarded, else if len is greater than the old length the content beyond the old length bytes will not be preserved but will be garbage.  Note that RSTRING_PTR(str) may change by calling this function.</p>
</dd><dt>rb_str_set_len(VALUE str, long len) 
<dd>
<p>Sets the length of a Ruby string.  If str is not modifiable, this function raises an exception.  This function preserves the content up to len bytes, regardless RSTRING_LEN(str).  len must not exceed the capacity of str.</p>
</dd><dt>rb_str_modify(VALUE str) 
<dd>
<p>Prepares a Ruby string to modify.  If str is not modifiable, this function raises an exception, or if the buffer of str is shared, this function allocates new buffer to make it unshared.  Always you MUST call this function before modifying the contents using RSTRING_PTR and/or rb_str_set_len.</p>
</dd></dl>

<h4 id="label-Array+Functions">Array Functions</h4>
<dl class="rdoc-list note-list"><dt>rb_ary_new() 
<dd>
<p>Creates an array with no elements.</p>
</dd><dt>rb_ary_new2(long len) 
<dt>rb_ary_new_capa(long len) 
<dd>
<p>Creates an array with no elements, allocating internal buffer for len elements.</p>
</dd><dt>rb_ary_new3(long n, …) 
<dt>rb_ary_new_from_args(long n, …) 
<dd>
<p>Creates an n-element array from the arguments.</p>
</dd><dt>rb_ary_new4(long n, VALUE *elts) 
<dt>rb_ary_new_from_values(long n, VALUE *elts) 
<dd>
<p>Creates an n-element array from a C array.</p>
</dd><dt>rb_ary_to_ary(VALUE obj) 
<dd>
<p>Converts the object into an array. Equivalent to Object#to_ary.</p>
</dd></dl>

<p>There are many functions to operate an array.  They may dump core if other types are given.</p>
<dl class="rdoc-list note-list"><dt>rb_ary_aref(int argc, const VALUE *argv, VALUE ary) 
<dd>
<p>Equivalent to Array#[].</p>
</dd><dt>rb_ary_entry(VALUE ary, long offset) 
<dd>
<p><a href=“offset”>ary</a></p>
</dd><dt>rb_ary_store(VALUE ary, long offset, VALUE obj) 
<dd>
<p><a href=“offset”>ary</a> = obj</p>
</dd><dt>rb_ary_subseq(VALUE ary, long beg, long len) 
<dd>
<p>ary[beg, len]</p>
</dd><dt>rb_ary_push(VALUE ary, VALUE val) 
<dt>rb_ary_pop(VALUE ary) 
<dt>rb_ary_shift(VALUE ary) 
<dt>rb_ary_unshift(VALUE ary, VALUE val) 
<dd>
<p>ary.push, ary.pop, ary.shift, ary.unshift</p>
</dd><dt>rb_ary_cat(VALUE ary, const VALUE *ptr, long len) 
<dd>
<p>Appends len elements of objects from ptr to the array.</p>
</dd></dl>

<h2 id="label-Extending+Ruby+with+C">Extending Ruby with C</h2>

<h3 id="label-Adding+New+Features+to+Ruby">Adding New Features to Ruby</h3>

<p>You can add new features (classes, methods, etc.) to the Ruby interpreter.  Ruby provides APIs for defining the following things:</p>
<ul><li>
<p>Classes, Modules</p>
</li><li>
<p>Methods, Singleton Methods</p>
</li><li>
<p>Constants</p>
</li></ul>

<h4 id="label-Class+and+Module+Definition">Class and Module Definition</h4>

<p>To define a class or module, use the functions below:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_rb_define_class'>rb_define_class</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='kw'>super</span>)
<span class='const'>VALUE</span> <span class='id identifier rubyid_rb_define_module'>rb_define_module</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span>)</code></pre>

<p>These functions return the newly created class or module.  You may want to save this reference into a variable to use later.</p>

<p>To define nested classes or modules, use the functions below:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_rb_define_class_under'>rb_define_class_under</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_outer'>outer</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='kw'>super</span>)
<span class='const'>VALUE</span> <span class='id identifier rubyid_rb_define_module_under'>rb_define_module_under</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_outer'>outer</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span>)</code></pre>

<h4 id="label-Method+and+Singleton+Method+Definition">Method and Singleton Method Definition</h4>

<p>To define methods or singleton methods, use these functions:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_method'>rb_define_method</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span>
                      <span class='const'>VALUE</span> (<span class='op'>*</span><span class='id identifier rubyid_func'>func</span>)(<span class='const'>ANYARGS</span>)<span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_argc'>argc</span>)

<span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_singleton_method'>rb_define_singleton_method</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_object'>object</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span>
                                <span class='const'>VALUE</span> (<span class='op'>*</span><span class='id identifier rubyid_func'>func</span>)(<span class='const'>ANYARGS</span>)<span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_argc'>argc</span>)</code></pre>

<p>The ‘argc’ represents the number of the arguments to the C function, which must be less than 17.  But I doubt you’ll need that many.</p>

<p>If ‘argc’ is negative, it specifies the calling sequence, not number of the arguments.</p>

<p>If argc is -1, the function will be called as:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_func'>func</span>(<span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_argc'>argc</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_argv'>argv</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='id identifier rubyid_obj'>obj</span>)</code></pre>

<p>where argc is the actual number of arguments, argv is the C array of the arguments, and obj is the receiver.</p>

<p>If argc is -2, the arguments are passed in a Ruby array. The function will be called like:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_func'>func</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_obj'>obj</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='id identifier rubyid_args'>args</span>)</code></pre>

<p>where obj is the receiver, and args is the Ruby array containing actual arguments.</p>

<p>There are some more functions to define methods. One takes an ID as the name of method to be defined. See also ID or Symbol below.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_method_id'>rb_define_method_id</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='const'>ID</span> <span class='id identifier rubyid_name'>name</span><span class='comma'>,</span>
                         <span class='const'>VALUE</span> (<span class='op'>*</span><span class='id identifier rubyid_func'>func</span>)(<span class='const'>ANYARGS</span>)<span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_argc'>argc</span>)</code></pre>

<p>There are two functions to define private/protected methods:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_private_method'>rb_define_private_method</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span>
                              <span class='const'>VALUE</span> (<span class='op'>*</span><span class='id identifier rubyid_func'>func</span>)(<span class='const'>ANYARGS</span>)<span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_argc'>argc</span>)
<span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_protected_method'>rb_define_protected_method</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span>
                                <span class='const'>VALUE</span> (<span class='op'>*</span><span class='id identifier rubyid_func'>func</span>)(<span class='const'>ANYARGS</span>)<span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_argc'>argc</span>)</code></pre>

<p>At last, rb_define_module_function defines a module function, which are private AND singleton methods of the module. For example, sqrt is a module function defined in the Math module. It can be called in the following way:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Math</span>.<span class='id identifier rubyid_sqrt'>sqrt</span>(<span class='int'>4</span>)</code></pre>

<p>or</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_include'>include</span> <span class='const'>Math</span>
<span class='id identifier rubyid_sqrt'>sqrt</span>(<span class='int'>4</span>)</code></pre>

<p>To define module functions, use:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_module_function'>rb_define_module_function</span>(<span class='const'>VALUE</span> <span class='kw'>module</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span>
                               <span class='const'>VALUE</span> (<span class='op'>*</span><span class='id identifier rubyid_func'>func</span>)(<span class='const'>ANYARGS</span>)<span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_argc'>argc</span>)</code></pre>

<p>In addition, function-like methods, which are private methods defined in the Kernel module, can be defined using:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_global_function'>rb_define_global_function</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='const'>VALUE</span> (<span class='op'>*</span><span class='id identifier rubyid_func'>func</span>)(<span class='const'>ANYARGS</span>)<span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_argc'>argc</span>)</code></pre>

<p>To define an alias for the method,</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_alias'>rb_define_alias</span>(<span class='const'>VALUE</span> <span class='kw'>module</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span><span class='op'>*</span> <span class='id identifier rubyid_new'>new</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span><span class='op'>*</span> <span class='id identifier rubyid_old'>old</span>)<span class='semicolon'>;</span></code></pre>

<p>To define a reader/writer for an attribute,</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_attr'>rb_define_attr</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_read'>read</span><span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_write'>write</span>)</code></pre>

<p>To define and undefine the ‘allocate’ class method,</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_alloc_func'>rb_define_alloc_func</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='const'>VALUE</span> (<span class='op'>*</span><span class='id identifier rubyid_func'>func</span>)(<span class='const'>VALUE</span> <span class='id identifier rubyid_klass'>klass</span>))<span class='semicolon'>;</span>
<span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_undef_alloc_func'>rb_undef_alloc_func</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_klass'>klass</span>)<span class='semicolon'>;</span></code></pre>

<p>func has to take the klass as the argument and return a newly allocated instance.  This instance should be as empty as possible, without any expensive (including external) resources.</p>

<p>If you are overriding an existing method of any ancestor of your class, you may rely on:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_rb_call_super'>rb_call_super</span>(<span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_argc'>argc</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_argv'>argv</span>)</code></pre>

<p>To specify whether keyword arguments are passed when calling super:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_rb_call_super_kw'>rb_call_super_kw</span>(<span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_argc'>argc</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_argv'>argv</span><span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_kw_splat'>kw_splat</span>)</code></pre>

<p><code>kw_splat</code> can have these possible values (used by all methods that accept <code>kw_splat</code> argument):</p>
<dl class="rdoc-list note-list"><dt>RB_NO_KEYWORDS 
<dd>
<p>Do not pass keywords</p>
</dd><dt>RB_PASS_KEYWORDS 
<dd>
<p>Pass keywords, final argument should be a hash of keywords</p>
</dd><dt>RB_PASS_CALLED_KEYWORDS 
<dd>
<p>Pass keywords if current method was called with keywords, useful for argument delegation</p>
</dd></dl>

<p>To achieve the receiver of the current scope (if no other way is available), you can use:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_rb_current_receiver'>rb_current_receiver</span>(<span class='id identifier rubyid_void'>void</span>)</code></pre>

<h4 id="label-Constant+Definition">Constant Definition</h4>

<p>We have 2 functions to define constants:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_const'>rb_define_const</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='id identifier rubyid_val'>val</span>)
<span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_global_const'>rb_define_global_const</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='id identifier rubyid_val'>val</span>)</code></pre>

<p>The former is to define a constant under specified class/module.  The latter is to define a global constant.</p>

<h3 id="label-Use+Ruby+Features+from+C">Use Ruby Features from C</h3>

<p>There are several ways to invoke Ruby’s features from C code.</p>

<h4 id="label-Evaluate+Ruby+Programs+in+a+String">Evaluate Ruby Programs in a String</h4>

<p>The easiest way to use Ruby’s functionality from a C program is to evaluate the string as Ruby program.  This function will do the job:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_rb_eval_string'>rb_eval_string</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_str'>str</span>)</code></pre>

<p>Evaluation is done under the current context, thus current local variables of the innermost method (which is defined by Ruby) can be accessed.</p>

<p>Note that the evaluation can raise an exception. There is a safer function:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_rb_eval_string_protect'>rb_eval_string_protect</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_str'>str</span><span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='op'>*</span><span class='id identifier rubyid_state'>state</span>)</code></pre>

<p>It returns nil when an error occurred. Moreover, *state is zero if str was successfully evaluated, or nonzero otherwise.</p>

<h4 id="label-ID+or+Symbol">ID or Symbol</h4>

<p>You can invoke methods directly, without parsing the string.  First I need to explain about ID.  ID is the integer number to represent Ruby’s identifiers such as variable names.  The Ruby data type corresponding to ID is Symbol.  It can be accessed from Ruby in the form:</p>

<pre class="code ruby"><code class="ruby"><span class='symbeg'>:</span><span class='const'>Identifier</span></code></pre>

<p>or</p>

<pre class="code ruby"><code class="ruby"><span class='symbeg'>:&quot;</span><span class='tstring_content'>any kind of string</span><span class='tstring_end'>&quot;</span></span></code></pre>

<p>You can get the ID value from a string within C code by using</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_rb_intern'>rb_intern</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span>)
<span class='id identifier rubyid_rb_intern_str'>rb_intern_str</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_name'>name</span>)</code></pre>

<p>You can retrieve ID from Ruby object (Symbol or String) given as an argument by using</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_rb_to_id'>rb_to_id</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_symbol'>symbol</span>)
<span class='id identifier rubyid_rb_check_id'>rb_check_id</span>(<span class='id identifier rubyid_volatile'>volatile</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span>)
<span class='id identifier rubyid_rb_check_id_cstr'>rb_check_id_cstr</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_long'>long</span> <span class='id identifier rubyid_len'>len</span><span class='comma'>,</span> <span class='id identifier rubyid_rb_encoding'>rb_encoding</span> <span class='op'>*</span><span class='id identifier rubyid_enc'>enc</span>)</code></pre>

<p>These functions try to convert the argument to a String if it was not a Symbol nor a String.  The second function stores the converted result into *name, and returns 0 if the string is not a known symbol. After this function returned a non-zero value, *name is always a Symbol or a String, otherwise it is a String if the result is 0. The third function takes NUL-terminated C string, not Ruby VALUE.</p>

<p>You can retrieve Symbol from Ruby object (Symbol or String) given as an argument by using</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_rb_to_symbol'>rb_to_symbol</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_name'>name</span>)
<span class='id identifier rubyid_rb_check_symbol'>rb_check_symbol</span>(<span class='id identifier rubyid_volatile'>volatile</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_namep'>namep</span>)
<span class='id identifier rubyid_rb_check_symbol_cstr'>rb_check_symbol_cstr</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_ptr'>ptr</span><span class='comma'>,</span> <span class='id identifier rubyid_long'>long</span> <span class='id identifier rubyid_len'>len</span><span class='comma'>,</span> <span class='id identifier rubyid_rb_encoding'>rb_encoding</span> <span class='op'>*</span><span class='id identifier rubyid_enc'>enc</span>)</code></pre>

<p>These functions are similar to above functions except that these return a Symbol instead of an ID.</p>

<p>You can convert C ID to Ruby Symbol by using</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='const'>ID2SYM</span>(<span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span>)</code></pre>

<p>and to convert Ruby Symbol object to ID, use</p>

<pre class="code ruby"><code class="ruby"><span class='const'>ID</span> <span class='const'>SYM2ID</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_symbol'>symbol</span>)</code></pre>

<h4 id="label-Invoke+Ruby+Method+from+C">Invoke Ruby Method from C</h4>

<p>To invoke methods directly, you can use the function below</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_rb_funcall'>rb_funcall</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_recv'>recv</span><span class='comma'>,</span> <span class='const'>ID</span> <span class='id identifier rubyid_mid'>mid</span><span class='comma'>,</span> <span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_argc'>argc</span><span class='comma'>,</span> <span class='op'>...</span>)</code></pre>

<p>This function invokes a method on the recv, with the method name specified by the symbol mid.</p>

<h4 id="label-Accessing+the+Variables+and+Constants">Accessing the Variables and Constants</h4>

<p>You can access class variables and instance variables using access functions.  Also, global variables can be shared between both environments.  There’s no way to access Ruby’s local variables.</p>

<p>The functions to access/modify instance variables are below:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_rb_ivar_get'>rb_ivar_get</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_obj'>obj</span><span class='comma'>,</span> <span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span>)
<span class='const'>VALUE</span> <span class='id identifier rubyid_rb_ivar_set'>rb_ivar_set</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_obj'>obj</span><span class='comma'>,</span> <span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='id identifier rubyid_val'>val</span>)</code></pre>

<p>id must be the symbol, which can be retrieved by rb_intern().</p>

<p>To access the constants of the class/module:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_rb_const_get'>rb_const_get</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_obj'>obj</span><span class='comma'>,</span> <span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span>)</code></pre>

<p>See also Constant Definition above.</p>

<h2 id="label-Information+Sharing+Between+Ruby+and+C">Information Sharing Between Ruby and C</h2>

<h3 id="label-Ruby+Constants+That+Can+Be+Accessed+From+C">Ruby Constants That Can Be Accessed From C</h3>

<p>As stated in section 1.3, the following Ruby constants can be referred from C.</p>
<dl class="rdoc-list note-list"><dt>Qtrue 
<dt>Qfalse 
<dd>
<p>Boolean values.  Qfalse is false in C also (i.e. 0).</p>
</dd><dt>Qnil 
<dd>
<p>Ruby nil in C scope.</p>
</dd></dl>

<h3 id="label-Global+Variables+Shared+Between+C+and+Ruby">Global Variables Shared Between C and Ruby</h3>

<p>Information can be shared between the two environments using shared global variables.  To define them, you can use functions listed below:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_variable'>rb_define_variable</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_var'>var</span>)</code></pre>

<p>This function defines the variable which is shared by both environments. The value of the global variable pointed to by ‘var’ can be accessed through Ruby’s global variable named ‘name’.</p>

<p>You can define read-only (from Ruby, of course) variables using the function below.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_readonly_variable'>rb_define_readonly_variable</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_var'>var</span>)</code></pre>

<p>You can define hooked variables.  The accessor functions (getter and setter) are called on access to the hooked variables.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_hooked_variable'>rb_define_hooked_variable</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_var'>var</span><span class='comma'>,</span>
                               <span class='const'>VALUE</span> (<span class='op'>*</span><span class='id identifier rubyid_getter'>getter</span>)()<span class='comma'>,</span> <span class='id identifier rubyid_void'>void</span> (<span class='op'>*</span><span class='id identifier rubyid_setter'>setter</span>)())</code></pre>

<p>If you need to supply either setter or getter, just supply 0 for the hook you don’t need.  If both hooks are 0, rb_define_hooked_variable() works just like rb_define_variable().</p>

<p>The prototypes of the getter and setter functions are as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> (<span class='op'>*</span><span class='id identifier rubyid_getter'>getter</span>)(<span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_var'>var</span>)<span class='semicolon'>;</span>
<span class='id identifier rubyid_void'>void</span> (<span class='op'>*</span><span class='id identifier rubyid_setter'>setter</span>)(<span class='const'>VALUE</span> <span class='id identifier rubyid_val'>val</span><span class='comma'>,</span> <span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_var'>var</span>)<span class='semicolon'>;</span></code></pre>

<p>Also you can define a Ruby global variable without a corresponding C variable.  The value of the variable will be set/get only by hooks.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_define_virtual_variable'>rb_define_virtual_variable</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span>
                                <span class='const'>VALUE</span> (<span class='op'>*</span><span class='id identifier rubyid_getter'>getter</span>)()<span class='comma'>,</span> <span class='id identifier rubyid_void'>void</span> (<span class='op'>*</span><span class='id identifier rubyid_setter'>setter</span>)())</code></pre>

<p>The prototypes of the getter and setter functions are as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> (<span class='op'>*</span><span class='id identifier rubyid_getter'>getter</span>)(<span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span>)<span class='semicolon'>;</span>
<span class='id identifier rubyid_void'>void</span> (<span class='op'>*</span><span class='id identifier rubyid_setter'>setter</span>)(<span class='const'>VALUE</span> <span class='id identifier rubyid_val'>val</span><span class='comma'>,</span> <span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span>)<span class='semicolon'>;</span></code></pre>

<h3 id="label-Encapsulate+C+Data+into+a+Ruby+Object">Encapsulate C Data into a Ruby Object</h3>

<p>Sometimes you need to expose your struct in the C world as a Ruby object. In a situation like this, making use of the TypedData_XXX macro family, the pointer to the struct and the Ruby object can be mutually converted.</p>

<p>– The old (non-Typed) Data_XXX macro family has been deprecated. In the future version of Ruby, it is possible old macros will not work. ++</p>

<h4 id="label-C+struct+to+Ruby+object">C struct to Ruby object</h4>

<p>You can convert sval, a pointer to your struct, into a Ruby object with the next macro.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>TypedData_Wrap_Struct</span>(<span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='id identifier rubyid_data_type'>data_type</span><span class='comma'>,</span> <span class='id identifier rubyid_sval'>sval</span>)</code></pre>

<p>TypedData_Wrap_Struct() returns a created Ruby object as a VALUE.</p>

<p>The klass argument is the class for the object.  The klass should derive from rb_cObject, and the allocator must be set by calling rb_define_alloc_func or rb_undef_alloc_func.</p>

<p>data_type is a pointer to a const rb_data_type_t which describes how Ruby should manage the struct.</p>

<p>rb_data_type_t is defined like this.  Let’s take a look at each member of the struct.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_typedef'>typedef</span> <span class='id identifier rubyid_struct'>struct</span> <span class='id identifier rubyid_rb_data_type_struct'>rb_data_type_struct</span> <span class='id identifier rubyid_rb_data_type_t'>rb_data_type_t</span><span class='semicolon'>;</span>

<span class='id identifier rubyid_struct'>struct</span> <span class='id identifier rubyid_rb_data_type_struct'>rb_data_type_struct</span> {
    <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_wrap_struct_name'>wrap_struct_name</span><span class='semicolon'>;</span>
    <span class='id identifier rubyid_struct'>struct</span> {
        <span class='id identifier rubyid_void'>void</span> (<span class='op'>*</span><span class='id identifier rubyid_dmark'>dmark</span>)(<span class='id identifier rubyid_void'>void</span><span class='op'>*</span>)<span class='semicolon'>;</span>
        <span class='id identifier rubyid_void'>void</span> (<span class='op'>*</span><span class='id identifier rubyid_dfree'>dfree</span>)(<span class='id identifier rubyid_void'>void</span><span class='op'>*</span>)<span class='semicolon'>;</span>
        <span class='id identifier rubyid_size_t'>size_t</span> (<span class='op'>*</span><span class='id identifier rubyid_dsize'>dsize</span>)(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_void'>void</span> <span class='op'>*</span>)<span class='semicolon'>;</span>
        <span class='id identifier rubyid_void'>void</span> (<span class='op'>*</span><span class='id identifier rubyid_dcompact'>dcompact</span>)(<span class='id identifier rubyid_void'>void</span><span class='op'>*</span>)<span class='semicolon'>;</span>
        <span class='id identifier rubyid_void'>void</span> <span class='op'>*</span><span class='id identifier rubyid_reserved'>reserved</span>[<span class='int'>1</span>]<span class='semicolon'>;</span>
    } <span class='id identifier rubyid_function'>function</span><span class='semicolon'>;</span>
    <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_rb_data_type_t'>rb_data_type_t</span> <span class='op'>*</span><span class='id identifier rubyid_parent'>parent</span><span class='semicolon'>;</span>
    <span class='id identifier rubyid_void'>void</span> <span class='op'>*</span><span class='id identifier rubyid_data'>data</span><span class='semicolon'>;</span>
    <span class='const'>VALUE</span> <span class='id identifier rubyid_flags'>flags</span><span class='semicolon'>;</span>
}<span class='semicolon'>;</span></code></pre>

<p>wrap_struct_name is an identifier of this instance of the struct. It is basically used for collecting and emitting statistics. So the identifier must be unique in the process, but doesn’t need to be valid as a C or Ruby identifier.</p>

<p>These dmark / dfree functions are invoked during GC execution.  No object allocations are allowed during it, so do not allocate ruby objects inside them.</p>

<p>dmark is a function to mark Ruby objects referred from your struct. It must mark all references from your struct with rb_gc_mark or its family if your struct keeps such references.</p>

<p>– Note that it is recommended to avoid such a reference. ++</p>

<p>dfree is a function to free the pointer allocation. If this is RUBY_DEFAULT_FREE, the pointer will be just freed.</p>

<p>dsize calculates memory consumption in bytes by the struct. Its parameter is a pointer to your struct. You can pass 0 as dsize if it is hard to implement such a function. But it is still recommended to avoid 0.</p>

<p>dcompact is invoked when memory compaction took place. Referred Ruby objects that were marked by rb_gc_mark_movable() can here be updated per rb_gc_location().</p>

<p>You have to fill reserved with 0.</p>

<p>parent can point to another C type definition that the Ruby object is inherited from. Then TypedData_Get_Struct() does also accept derived objects.</p>

<p>You can fill “data” with an arbitrary value for your use. Ruby does nothing with the member.</p>

<p>flags is a bitwise-OR of the following flag values. Since they require deep understanding of garbage collector in Ruby, you can just set 0 to flags if you are not sure.</p>
<dl class="rdoc-list note-list"><dt>RUBY_TYPED_FREE_IMMEDIATELY 
<dd>
<p>This flag makes the garbage collector immediately invoke dfree() during GC when it need to free your struct. You can specify this flag if the dfree never unlocks Ruby’s internal lock (GVL).</p>

<p>If this flag is not set, Ruby defers invocation of dfree() and invokes dfree() at the same time as finalizers.</p>
</dd><dt>RUBY_TYPED_WB_PROTECTED 
<dd>
<p>It shows that implementation of the object supports write barriers. If this flag is set, Ruby is better able to do garbage collection of the object.</p>

<p>When it is set, however, you are responsible for putting write barriers in all implementations of methods of that object as appropriate. Otherwise Ruby might crash while running.</p>

<p>More about write barriers can be found in “Generational GC” in Appendix D.</p>
</dd><dt>RUBY_TYPED_FROZEN_SHAREABLE 
<dd>
<p>This flag indicates that the object is shareable object if the object is frozen. See Appendix F more details.</p>

<p>If this flag is not set, the object can not become a shareable object by Ractor.make_shareable() method.</p>
</dd></dl>

<p>You can allocate and wrap the structure in one step.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>TypedData_Make_Struct</span>(<span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='id identifier rubyid_data_type'>data_type</span><span class='comma'>,</span> <span class='id identifier rubyid_sval'>sval</span>)</code></pre>

<p>This macro returns an allocated Data object, wrapping the pointer to the structure, which is also allocated.  This macro works like:</p>

<pre class="code ruby"><code class="ruby">(<span class='id identifier rubyid_sval'>sval</span> <span class='op'>=</span> <span class='const'>ZALLOC</span>(<span class='id identifier rubyid_type'>type</span>)<span class='comma'>,</span> <span class='const'>TypedData_Wrap_Struct</span>(<span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='id identifier rubyid_data_type'>data_type</span><span class='comma'>,</span> <span class='id identifier rubyid_sval'>sval</span>))</code></pre>

<p>Arguments klass and data_type work like their counterparts in TypedData_Wrap_Struct().  A pointer to the allocated structure will be assigned to sval, which should be a pointer of the type specified.</p>

<h4 id="label-Ruby+object+to+C+struct">Ruby object to C struct</h4>

<p>To retrieve the C pointer from the Data object, use the macro TypedData_Get_Struct().</p>

<pre class="code ruby"><code class="ruby"><span class='const'>TypedData_Get_Struct</span>(<span class='id identifier rubyid_obj'>obj</span><span class='comma'>,</span> <span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_data_type'>data_type</span><span class='comma'>,</span> <span class='id identifier rubyid_sval'>sval</span>)</code></pre>

<p>A pointer to the structure will be assigned to the variable sval.</p>

<p>See the example below for details.</p>

<h2 id="label-Example+-+Creating+the+dbm+Extension">Example - Creating the dbm Extension</h2>

<p>OK, here’s the example of making an extension library.  This is the extension to access DBMs.  The full source is included in the ext/ directory in the Ruby’s source tree.</p>

<h3 id="label-Make+the+Directory">Make the Directory</h3>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>% </span><span class='tstring_content'>mkdir</span><span class='tstring_end'> </span></span><span class='id identifier rubyid_ext'>ext</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>dbm</span></code></pre>

<p>Make a directory for the extension library under ext directory.</p>

<h3 id="label-Design+the+Library">Design the Library</h3>

<p>You need to design the library features, before making it.</p>

<h3 id="label-Write+the+C+Code">Write the C Code</h3>

<p>You need to write C code for your extension library.  If your library has only one source file, choosing “LIBRARY.c” as a file name is preferred.  On the other hand, in case your library has multiple source files, avoid choosing “LIBRARY.c” for a file name.  It may conflict with an intermediate file “LIBRARY.o” on some platforms. Note that some functions in mkmf library described below generate a file “conftest.c” for checking with compilation.  You shouldn’t choose “conftest.c” as a name of a source file.</p>

<p>Ruby will execute the initializing function named “Init_LIBRARY” in the library.  For example, “Init_dbm()” will be executed when loading the library.</p>

<p>Here’s the example of an initializing function.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'>#include &lt;ruby.h&gt;
</span><span class='id identifier rubyid_void'>void</span>
<span class='const'>Init_dbm</span>(<span class='id identifier rubyid_void'>void</span>)
{
    <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* define DBM class *</span><span class='regexp_end'>/</span></span>
    <span class='const'>VALUE</span> <span class='id identifier rubyid_cDBM'>cDBM</span> <span class='op'>=</span> <span class='id identifier rubyid_rb_define_class'>rb_define_class</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>DBM</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_rb_cObject'>rb_cObject</span>)<span class='semicolon'>;</span>
    <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* Redefine DBM.allocate
    rb_define_alloc_func(cDBM, fdbm_alloc);
    </span><span class='regexp_end'>/</span></span><span class='op'>*</span> <span class='const'>DBM</span> <span class='id identifier rubyid_includes'>includes</span> <span class='const'>Enumerable</span> <span class='kw'>module</span> <span class='op'>*</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>
    rb_include_module(cDBM, rb_mEnumerable);

    </span><span class='regexp_end'>/</span></span><span class='op'>*</span> <span class='const'>DBM</span> <span class='id identifier rubyid_has'>has</span> <span class='kw'>class</span> <span class='id identifier rubyid_method'>method</span> <span class='id identifier rubyid_open'>open</span>()<span class='op'>:</span> <span class='id identifier rubyid_arguments'>arguments</span> <span class='id identifier rubyid_are'>are</span> <span class='id identifier rubyid_received'>received</span> <span class='id identifier rubyid_as'>as</span> <span class='const'>C</span> <span class='id identifier rubyid_array'>array</span> <span class='op'>*</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>
    rb_define_singleton_method(cDBM, &quot;open&quot;, fdbm_s_open, -1);

    </span><span class='regexp_end'>/</span></span><span class='op'>*</span> <span class='const'>DBM</span> <span class='id identifier rubyid_instance'>instance</span> <span class='id identifier rubyid_method'>method</span> <span class='id identifier rubyid_close'>close</span>()<span class='op'>:</span> <span class='id identifier rubyid_no'>no</span> <span class='id identifier rubyid_args'>args</span> <span class='op'>*</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>
    rb_define_method(cDBM, &quot;close&quot;, fdbm_close, 0);
    </span><span class='regexp_end'>/</span></span><span class='op'>*</span> <span class='const'>DBM</span> <span class='id identifier rubyid_instance'>instance</span> <span class='id identifier rubyid_method'>method</span> []<span class='op'>:</span> <span class='int'>1</span> <span class='id identifier rubyid_argument'>argument</span> <span class='op'>*</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>
    rb_define_method(cDBM, &quot;[]&quot;, fdbm_aref, 1);

    </span><span class='regexp_end'>/</span></span><span class='op'>*</span> <span class='op'>...</span> <span class='op'>*</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>

    </span><span class='regexp_end'>/</span></span><span class='op'>*</span> <span class='const'>ID</span> <span class='kw'>for</span> <span class='id identifier rubyid_a'>a</span> <span class='id identifier rubyid_instance'>instance</span> <span class='id identifier rubyid_variable'>variable</span> <span class='id identifier rubyid_to'>to</span> <span class='id identifier rubyid_store'>store</span> <span class='const'>DBM</span> <span class='id identifier rubyid_data'>data</span> <span class='op'>*</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>
    id_dbm = rb_intern(&quot;dbm&quot;);
}</span></code></pre>

<p>The dbm extension wraps the dbm struct in the C environment using TypedData_Make_Struct.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_struct'>struct</span> <span class='id identifier rubyid_dbmdata'>dbmdata</span> {
    <span class='id identifier rubyid_int'>int</span>  <span class='id identifier rubyid_di_size'>di_size</span><span class='semicolon'>;</span>
    <span class='const'>DBM</span> <span class='op'>*</span><span class='id identifier rubyid_di_dbm'>di_dbm</span><span class='semicolon'>;</span>
}<span class='semicolon'>;</span>

<span class='id identifier rubyid_static'>static</span> <span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_rb_data_type_t'>rb_data_type_t</span> <span class='id identifier rubyid_dbm_type'>dbm_type</span> <span class='op'>=</span> {
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dbm</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>
    {<span class='int'>0</span><span class='comma'>,</span> <span class='id identifier rubyid_free_dbm'>free_dbm</span><span class='comma'>,</span> <span class='id identifier rubyid_memsize_dbm'>memsize_dbm</span><span class='comma'>,</span>}<span class='comma'>,</span>
    <span class='int'>0</span><span class='comma'>,</span> <span class='int'>0</span><span class='comma'>,</span>
    <span class='const'>RUBY_TYPED_FREE_IMMEDIATELY</span><span class='comma'>,</span>
}<span class='semicolon'>;</span>

<span class='id identifier rubyid_static'>static</span> <span class='const'>VALUE</span>
<span class='id identifier rubyid_fdbm_alloc'>fdbm_alloc</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_klass'>klass</span>)
{
    <span class='id identifier rubyid_struct'>struct</span> <span class='id identifier rubyid_dbmdata'>dbmdata</span> <span class='op'>*</span><span class='id identifier rubyid_dbmp'>dbmp</span><span class='semicolon'>;</span>
    <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* Allocate T_DATA object and C struct and fill struct with zero bytes *</span><span class='regexp_end'>/</span></span>
    <span class='kw'>return</span> <span class='const'>TypedData_Make_Struct</span>(<span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='id identifier rubyid_struct'>struct</span> <span class='id identifier rubyid_dbmdata'>dbmdata</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_dbm_type'>dbm_type</span><span class='comma'>,</span> <span class='id identifier rubyid_dbmp'>dbmp</span>)<span class='semicolon'>;</span>
}</code></pre>

<p>This code wraps the dbmdata structure into a Ruby object.  We avoid wrapping DBM* directly, because we want to cache size information. Since Object.allocate allocates an ordinary T_OBJECT type (instead of T_DATA), it’s important to either use rb_define_alloc_func() to overwrite it or rb_undef_alloc_func() to delete it.</p>

<p>To retrieve the dbmdata structure from a Ruby object, we define the following macro:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'>#define GetDBM(obj, dbmp) do {\
</span>    <span class='const'>TypedData_Get_Struct</span>((<span class='id identifier rubyid_obj'>obj</span>)<span class='comma'>,</span> <span class='id identifier rubyid_struct'>struct</span> <span class='id identifier rubyid_dbmdata'>dbmdata</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_dbm_type'>dbm_type</span><span class='comma'>,</span> (<span class='id identifier rubyid_dbmp'>dbmp</span>))<span class='semicolon'>;</span>\
    <span class='kw'>if</span> ((<span class='id identifier rubyid_dbmp'>dbmp</span>) <span class='op'>==</span> <span class='int'>0</span>) <span class='id identifier rubyid_closed_dbm'>closed_dbm</span>()<span class='semicolon'>;</span>\
    <span class='kw'>if</span> ((<span class='id identifier rubyid_dbmp'>dbmp</span>)<span class='tlambda'>-&gt;</span><span class='id identifier rubyid_di_dbm'>di_dbm</span> <span class='op'>==</span> <span class='int'>0</span>) <span class='id identifier rubyid_closed_dbm'>closed_dbm</span>()<span class='semicolon'>;</span>\
<span class='embexpr_end'>}</span> <span class='kw'>while</span> (<span class='int'>0</span>)</code></pre>

<p>This sort of complicated macro does the retrieving and close checking for the DBM.</p>

<p>There are three kinds of way to receive method arguments.  First, methods with a fixed number of arguments receive arguments like this:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_static'>static</span> <span class='const'>VALUE</span>
<span class='id identifier rubyid_fdbm_aref'>fdbm_aref</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_obj'>obj</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='id identifier rubyid_keystr'>keystr</span>)
{
    <span class='id identifier rubyid_struct'>struct</span> <span class='id identifier rubyid_dbmdata'>dbmdata</span> <span class='op'>*</span><span class='id identifier rubyid_dbmp'>dbmp</span><span class='semicolon'>;</span>
    <span class='const'>GetDBM</span>(<span class='id identifier rubyid_obj'>obj</span><span class='comma'>,</span> <span class='id identifier rubyid_dbmp'>dbmp</span>)<span class='semicolon'>;</span>
    <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* Use dbmp to access the key *</span><span class='regexp_end'>/</span></span>
    <span class='id identifier rubyid_dbm_fetch'>dbm_fetch</span>(<span class='id identifier rubyid_dbmp'>dbmp</span><span class='tlambda'>-&gt;</span><span class='id identifier rubyid_di_dbm'>di_dbm</span><span class='comma'>,</span> <span class='const'>StringValueCStr</span>(<span class='id identifier rubyid_keystr'>keystr</span>))<span class='semicolon'>;</span>
    <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* ... *</span><span class='regexp_end'>/</span></span>
}</code></pre>

<p>The first argument of the C function is the self, the rest are the arguments to the method.</p>

<p>Second, methods with an arbitrary number of arguments receive arguments like this:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_static'>static</span> <span class='const'>VALUE</span>
<span class='id identifier rubyid_fdbm_s_open'>fdbm_s_open</span>(<span class='id identifier rubyid_int'>int</span> <span class='id identifier rubyid_argc'>argc</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_argv'>argv</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='id identifier rubyid_klass'>klass</span>)
{
    <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* ... *</span><span class='regexp_end'>/</span></span>
    <span class='kw'>if</span> (<span class='id identifier rubyid_rb_scan_args'>rb_scan_args</span>(<span class='id identifier rubyid_argc'>argc</span><span class='comma'>,</span> <span class='id identifier rubyid_argv'>argv</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>11</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_file'>file</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_vmode'>vmode</span>) <span class='op'>==</span> <span class='int'>1</span>) {
        <span class='id identifier rubyid_mode'>mode</span> <span class='op'>=</span> <span class='int'>0666</span><span class='semicolon'>;</span>          <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* default value *</span><span class='regexp_end'>/</span></span>
    }
    <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* ... *</span><span class='regexp_end'>/</span></span>
}</code></pre>

<p>The first argument is the number of method arguments, the second argument is the C array of the method arguments, and the third argument is the receiver of the method.</p>

<p>You can use the function rb_scan_args() to check and retrieve the arguments.  The third argument is a string that specifies how to capture method arguments and assign them to the following VALUE references.</p>

<p>You can just check the argument number with rb_check_arity(), this is handy in the case you want to treat the arguments as a list.</p>

<p>The following is an example of a method that takes arguments by Ruby’s array:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_static'>static</span> <span class='const'>VALUE</span>
<span class='id identifier rubyid_thread_initialize'>thread_initialize</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_thread'>thread</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='id identifier rubyid_args'>args</span>)
{
    <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* ... *</span><span class='regexp_end'>/</span></span>
}</code></pre>

<p>The first argument is the receiver, the second one is the Ruby array which contains the arguments to the method.</p>

<p><strong>Notice</strong>: GC should know about global variables which refer to Ruby’s objects, but are not exported to the Ruby world.  You need to protect them by</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_global_variable'>rb_global_variable</span>(<span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_var'>var</span>)</code></pre>

<p>or the objects themselves by</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_gc_register_mark_object'>rb_gc_register_mark_object</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_object'>object</span>)</code></pre>

<h3 id="label-Prepare+extconf.rb">Prepare extconf.rb</h3>

<p>If the file named extconf.rb exists, it will be executed to generate Makefile.</p>

<p>extconf.rb is the file for checking compilation conditions etc.  You need to put</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>mkmf</span><span class='tstring_end'>&#39;</span></span></code></pre>

<p>at the top of the file.  You can use the functions below to check various conditions.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_append_cppflags'>append_cppflags</span>(<span class='id identifier rubyid_array'>array</span><span class='op'>-</span><span class='id identifier rubyid_of'>of</span><span class='op'>-</span><span class='id identifier rubyid_flags'>flags</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opt'>opt</span>])<span class='op'>:</span> <span class='id identifier rubyid_append'>append</span> <span class='id identifier rubyid_each'>each</span> <span class='id identifier rubyid_flag'>flag</span> <span class='id identifier rubyid_to'>to</span> <span class='gvar'>$CPPFLAGS</span> <span class='kw'>if</span> <span class='id identifier rubyid_usable'>usable</span>
<span class='id identifier rubyid_append_cflags'>append_cflags</span>(<span class='id identifier rubyid_array'>array</span><span class='op'>-</span><span class='id identifier rubyid_of'>of</span><span class='op'>-</span><span class='id identifier rubyid_flags'>flags</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opt'>opt</span>])<span class='op'>:</span> <span class='id identifier rubyid_append'>append</span> <span class='id identifier rubyid_each'>each</span> <span class='id identifier rubyid_flag'>flag</span> <span class='id identifier rubyid_to'>to</span> <span class='gvar'>$CFLAGS</span> <span class='kw'>if</span> <span class='id identifier rubyid_usable'>usable</span>
<span class='id identifier rubyid_append_ldflags'>append_ldflags</span>(<span class='id identifier rubyid_array'>array</span><span class='op'>-</span><span class='id identifier rubyid_of'>of</span><span class='op'>-</span><span class='id identifier rubyid_flags'>flags</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opt'>opt</span>])<span class='op'>:</span> <span class='id identifier rubyid_append'>append</span> <span class='id identifier rubyid_each'>each</span> <span class='id identifier rubyid_flag'>flag</span> <span class='id identifier rubyid_to'>to</span> <span class='gvar'>$LDFLAGS</span> <span class='kw'>if</span> <span class='id identifier rubyid_usable'>usable</span>
<span class='id identifier rubyid_have_macro'>have_macro</span>(<span class='id identifier rubyid_macro'>macro</span>[<span class='comma'>,</span> <span class='id identifier rubyid_headers'>headers</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opt'>opt</span>]])<span class='op'>:</span> <span class='id identifier rubyid_check'>check</span> <span class='id identifier rubyid_whether'>whether</span> <span class='id identifier rubyid_macro'>macro</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_defined'>defined</span>
<span class='id identifier rubyid_have_library'>have_library</span>(<span class='id identifier rubyid_lib'>lib</span>[<span class='comma'>,</span> <span class='id identifier rubyid_func'>func</span>[<span class='comma'>,</span> <span class='id identifier rubyid_headers'>headers</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opt'>opt</span>]]])<span class='op'>:</span> <span class='id identifier rubyid_check'>check</span> <span class='id identifier rubyid_whether'>whether</span> <span class='id identifier rubyid_library'>library</span> <span class='id identifier rubyid_containing'>containing</span> <span class='id identifier rubyid_function'>function</span> <span class='id identifier rubyid_exists'>exists</span>
<span class='id identifier rubyid_find_library'>find_library</span>(<span class='id identifier rubyid_lib'>lib</span>[<span class='comma'>,</span> <span class='id identifier rubyid_func'>func</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_paths'>paths</span>])<span class='op'>:</span> <span class='id identifier rubyid_find'>find</span> <span class='id identifier rubyid_library'>library</span> <span class='id identifier rubyid_from'>from</span> <span class='id identifier rubyid_paths'>paths</span>
<span class='id identifier rubyid_have_func'>have_func</span>(<span class='id identifier rubyid_func'>func</span>[<span class='comma'>,</span> <span class='id identifier rubyid_headers'>headers</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opt'>opt</span>])<span class='op'>:</span> <span class='id identifier rubyid_check'>check</span> <span class='id identifier rubyid_whether'>whether</span> <span class='id identifier rubyid_function'>function</span> <span class='id identifier rubyid_exists'>exists</span>
<span class='id identifier rubyid_have_var'>have_var</span>(<span class='id identifier rubyid_var'>var</span>[<span class='comma'>,</span> <span class='id identifier rubyid_headers'>headers</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opt'>opt</span>]])<span class='op'>:</span> <span class='id identifier rubyid_check'>check</span> <span class='id identifier rubyid_whether'>whether</span> <span class='id identifier rubyid_variable'>variable</span> <span class='id identifier rubyid_exists'>exists</span>
<span class='id identifier rubyid_have_header'>have_header</span>(<span class='id identifier rubyid_header'>header</span>[<span class='comma'>,</span> <span class='id identifier rubyid_preheaders'>preheaders</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opt'>opt</span>]])<span class='op'>:</span> <span class='id identifier rubyid_check'>check</span> <span class='id identifier rubyid_whether'>whether</span> <span class='id identifier rubyid_header'>header</span> <span class='id identifier rubyid_file'>file</span> <span class='id identifier rubyid_exists'>exists</span>
<span class='id identifier rubyid_find_header'>find_header</span>(<span class='id identifier rubyid_header'>header</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_paths'>paths</span>)<span class='op'>:</span> <span class='id identifier rubyid_find'>find</span> <span class='id identifier rubyid_header'>header</span> <span class='id identifier rubyid_from'>from</span> <span class='id identifier rubyid_paths'>paths</span>
<span class='id identifier rubyid_have_framework'>have_framework</span>(<span class='id identifier rubyid_fw'>fw</span>)<span class='op'>:</span> <span class='id identifier rubyid_check'>check</span> <span class='id identifier rubyid_whether'>whether</span> <span class='id identifier rubyid_framework'>framework</span> <span class='id identifier rubyid_exists'>exists</span> (<span class='kw'>for</span> <span class='const'>MacOS</span> <span class='const'>X</span>)
<span class='id identifier rubyid_have_struct_member'>have_struct_member</span>(<span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='id identifier rubyid_member'>member</span>[<span class='comma'>,</span> <span class='id identifier rubyid_headers'>headers</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opt'>opt</span>]])<span class='op'>:</span> <span class='id identifier rubyid_check'>check</span> <span class='id identifier rubyid_whether'>whether</span> <span class='id identifier rubyid_struct'>struct</span> <span class='id identifier rubyid_has'>has</span> <span class='id identifier rubyid_member'>member</span>
<span class='id identifier rubyid_have_type'>have_type</span>(<span class='id identifier rubyid_type'>type</span>[<span class='comma'>,</span> <span class='id identifier rubyid_headers'>headers</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opt'>opt</span>]])<span class='op'>:</span> <span class='id identifier rubyid_check'>check</span> <span class='id identifier rubyid_whether'>whether</span> <span class='id identifier rubyid_type'>type</span> <span class='id identifier rubyid_exists'>exists</span>
<span class='id identifier rubyid_find_type'>find_type</span>(<span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='id identifier rubyid_opt'>opt</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_headers'>headers</span>)<span class='op'>:</span> <span class='id identifier rubyid_check'>check</span> <span class='id identifier rubyid_whether'>whether</span> <span class='id identifier rubyid_type'>type</span> <span class='id identifier rubyid_exists'>exists</span> <span class='kw'>in</span> <span class='id identifier rubyid_headers'>headers</span>
<span class='id identifier rubyid_have_const'>have_const</span>(<span class='id identifier rubyid_const'>const</span>[<span class='comma'>,</span> <span class='id identifier rubyid_headers'>headers</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opt'>opt</span>]])<span class='op'>:</span> <span class='id identifier rubyid_check'>check</span> <span class='id identifier rubyid_whether'>whether</span> <span class='id identifier rubyid_constant'>constant</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_defined'>defined</span>
<span class='id identifier rubyid_check_sizeof'>check_sizeof</span>(<span class='id identifier rubyid_type'>type</span>[<span class='comma'>,</span> <span class='id identifier rubyid_headers'>headers</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>]])<span class='op'>:</span> <span class='id identifier rubyid_check'>check</span> <span class='id identifier rubyid_size'>size</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_type'>type</span>
<span class='id identifier rubyid_check_signedness'>check_signedness</span>(<span class='id identifier rubyid_type'>type</span>[<span class='comma'>,</span> <span class='id identifier rubyid_headers'>headers</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>]])<span class='op'>:</span> <span class='id identifier rubyid_check'>check</span> <span class='id identifier rubyid_signedness'>signedness</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_type'>type</span>
<span class='id identifier rubyid_convertible_int'>convertible_int</span>(<span class='id identifier rubyid_type'>type</span>[<span class='comma'>,</span> <span class='id identifier rubyid_headers'>headers</span>[<span class='comma'>,</span> <span class='id identifier rubyid_opts'>opts</span>]])<span class='op'>:</span> <span class='id identifier rubyid_find'>find</span> <span class='id identifier rubyid_convertible'>convertible</span> <span class='id identifier rubyid_integer'>integer</span> <span class='id identifier rubyid_type'>type</span>
<span class='id identifier rubyid_find_executable'>find_executable</span>(<span class='id identifier rubyid_bin'>bin</span>[<span class='comma'>,</span> <span class='id identifier rubyid_path'>path</span>])<span class='op'>:</span> <span class='id identifier rubyid_find'>find</span> <span class='id identifier rubyid_executable'>executable</span> <span class='id identifier rubyid_file'>file</span> <span class='id identifier rubyid_path'>path</span>
<span class='id identifier rubyid_create_header'>create_header</span>(<span class='id identifier rubyid_header'>header</span>)<span class='op'>:</span> <span class='id identifier rubyid_generate'>generate</span> <span class='id identifier rubyid_configured'>configured</span> <span class='id identifier rubyid_header'>header</span>
<span class='id identifier rubyid_create_makefile'>create_makefile</span>(<span class='id identifier rubyid_target'>target</span>[<span class='comma'>,</span> <span class='id identifier rubyid_target_prefix'>target_prefix</span>])<span class='op'>:</span> <span class='id identifier rubyid_generate'>generate</span> <span class='const'>Makefile</span></code></pre>

<p>See MakeMakefile for full documentation of these functions.</p>

<p>The value of the variables below will affect the Makefile.</p>

<pre class="code ruby"><code class="ruby"><span class='gvar'>$CFLAGS</span><span class='op'>:</span> <span class='id identifier rubyid_included'>included</span> <span class='kw'>in</span> <span class='const'>CFLAGS</span> <span class='id identifier rubyid_make'>make</span> <span class='id identifier rubyid_variable'>variable</span> (<span class='id identifier rubyid_such'>such</span> <span class='id identifier rubyid_as'>as</span> <span class='op'>-</span><span class='const'>O</span>)
<span class='gvar'>$CPPFLAGS</span><span class='op'>:</span> <span class='id identifier rubyid_included'>included</span> <span class='kw'>in</span> <span class='const'>CPPFLAGS</span> <span class='id identifier rubyid_make'>make</span> <span class='id identifier rubyid_variable'>variable</span> (<span class='id identifier rubyid_such'>such</span> <span class='id identifier rubyid_as'>as</span> <span class='op'>-</span><span class='const'>I</span><span class='comma'>,</span> <span class='op'>-</span><span class='const'>D</span>)
<span class='gvar'>$LDFLAGS</span><span class='op'>:</span> <span class='id identifier rubyid_included'>included</span> <span class='kw'>in</span> <span class='const'>LDFLAGS</span> <span class='id identifier rubyid_make'>make</span> <span class='id identifier rubyid_variable'>variable</span> (<span class='id identifier rubyid_such'>such</span> <span class='id identifier rubyid_as'>as</span> <span class='op'>-</span><span class='const'>L</span>)
<span class='gvar'>$objs</span><span class='op'>:</span> <span class='id identifier rubyid_list'>list</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_object'>object</span> <span class='id identifier rubyid_file'>file</span> <span class='id identifier rubyid_names'>names</span></code></pre>

<p>Compiler/linker flags are not portable usually, you should use <code>append_cppflags</code>, <code>append_cpflags</code> and <code>append_ldflags</code> respectively instead of appending the above variables directly.</p>

<p>Normally, the object files list is automatically generated by searching source files, but you must define them explicitly if any sources will be generated while building.</p>

<p>If a compilation condition is not fulfilled, you should not call “create_makefile”.  The Makefile will not be generated, compilation will not be done.</p>

<h3 id="label-Prepare+Depend+-28Optional-29">Prepare Depend (Optional)</h3>

<p>If the file named depend exists, Makefile will include that file to check dependencies.  You can make this file by invoking</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>% </span><span class='tstring_content'>gcc</span><span class='tstring_end'> </span></span><span class='op'>-</span><span class='const'>MM</span> <span class='op'>*</span>.<span class='id identifier rubyid_c'>c</span> <span class='op'>&gt;</span> <span class='id identifier rubyid_depend'>depend</span></code></pre>

<p>It’s harmless.  Prepare it.</p>

<h3 id="label-Generate+Makefile">Generate Makefile</h3>

<p>Try generating the Makefile by:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ruby'>ruby</span> <span class='id identifier rubyid_extconf'>extconf</span>.<span class='id identifier rubyid_rb'>rb</span></code></pre>

<p>If the library should be installed under vendor_ruby directory instead of site_ruby directory, use –vendor option as follows.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ruby'>ruby</span> <span class='id identifier rubyid_extconf'>extconf</span>.<span class='id identifier rubyid_rb'>rb</span> <span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_vendor'>vendor</span></code></pre>

<p>You don’t need this step if you put the extension library under the ext directory of the ruby source tree.  In that case, compilation of the interpreter will do this step for you.</p>

<h3 id="label-Run+make">Run make</h3>

<p>Type</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_make'>make</span></code></pre>

<p>to compile your extension.  You don’t need this step either if you have put the extension library under the ext directory of the ruby source tree.</p>

<h3 id="label-Debug">Debug</h3>

<p>You may need to rb_debug the extension.  Extensions can be linked statically by adding the directory name in the ext/Setup file so that you can inspect the extension with the debugger.</p>

<h3 id="label-Done-21+Now+You+Have+the+Extension+Library">Done! Now You Have the Extension Library</h3>

<p>You can do anything you want with your library.  The author of Ruby will not claim any restrictions on your code depending on the Ruby API. Feel free to use, modify, distribute or sell your program.</p>

<h2 id="label-Appendix+A.+Ruby+Header+and+Source+Files+Overview">Appendix A. Ruby Header and Source Files Overview</h2>

<h3 id="label-Ruby+Header+Files">Ruby Header Files</h3>

<p>Everything under <code>$repo_root/include/ruby</code> is installed with <code>make install</code>. It should be included per <code>#include &lt;ruby.h&gt;</code> from C extensions. All symbols are public API with the exception of symbols prefixed with <code>rbimpl_</code> or <code>RBIMPL_</code>. They are implementation details and shouldn’t be used by C extensions.</p>

<p>Only <code>$repo_root/include/ruby/*.h</code> whose corresponding macros are defined in the <code>$repo_root/include/ruby.h</code> header are allowed to be <code>#include</code>-d by C extensions.</p>

<p>Header files under <code>$repo_root/internal/</code> or directly under the root <code>$repo_root/*.h</code> are not make-installed. They are internal headers with only internal APIs.</p>

<h3 id="label-Ruby+Language+Core">Ruby Language Core</h3>
<dl class="rdoc-list note-list"><dt>class.c    
<dd>
<p>classes and modules</p>
</dd><dt>error.c    
<dd>
<p>exception classes and exception mechanism</p>
</dd><dt>gc.c       
<dd>
<p>memory management</p>
</dd><dt>load.c     
<dd>
<p>library loading</p>
</dd><dt>object.c   
<dd>
<p>objects</p>
</dd><dt>variable.c 
<dd>
<p>variables and constants</p>
</dd></dl>

<h3 id="label-Ruby+Syntax+Parser">Ruby Syntax Parser</h3>
<dl class="rdoc-list note-list"><dt>parse.y       
<dd>
<p>grammar definition</p>
</dd><dt>parse.c       
<dd>
<p>automatically generated from parse.y</p>
</dd><dt>defs/keywords 
<dd>
<p>reserved keywords</p>
</dd><dt>lex.c         
<dd>
<p>automatically generated from keywords</p>
</dd></dl>

<h3 id="label-Ruby+Evaluator+-28a.k.a.+YARV-29">Ruby Evaluator (a.k.a. YARV)</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_compile'>compile</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_eval'>eval</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_eval_error'>eval_error</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_eval_jump'>eval_jump</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_eval_safe'>eval_safe</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_insns'>insns</span>.<span class='id identifier rubyid_def'>def</span>           <span class='op'>:</span> <span class='id identifier rubyid_definition'>definition</span> <span class='id identifier rubyid_of'>of</span> <span class='const'>VM</span> <span class='id identifier rubyid_instructions'>instructions</span>
<span class='id identifier rubyid_iseq'>iseq</span>.<span class='id identifier rubyid_c'>c</span>              <span class='op'>:</span> <span class='id identifier rubyid_implementation'>implementation</span> <span class='id identifier rubyid_of'>of</span> <span class='const'>VM</span><span class='op'>::</span><span class='const'>ISeq</span>
<span class='id identifier rubyid_thread'>thread</span>.<span class='id identifier rubyid_c'>c</span>            <span class='op'>:</span> <span class='id identifier rubyid_thread'>thread</span> <span class='id identifier rubyid_management'>management</span> <span class='kw'>and</span> <span class='id identifier rubyid_context'>context</span> <span class='id identifier rubyid_switching'>switching</span>
<span class='id identifier rubyid_thread_win32'>thread_win32</span>.<span class='id identifier rubyid_c'>c</span>      <span class='op'>:</span> <span class='id identifier rubyid_thread'>thread</span> <span class='id identifier rubyid_implementation'>implementation</span>
<span class='id identifier rubyid_thread_pthread'>thread_pthread</span>.<span class='id identifier rubyid_c'>c</span>    <span class='op'>:</span> <span class='id identifier rubyid_ditto'>ditto</span>
<span class='id identifier rubyid_vm'>vm</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_vm_dump'>vm_dump</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_vm_eval'>vm_eval</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_vm_exec'>vm_exec</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_vm_insnhelper'>vm_insnhelper</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_vm_method'>vm_method</span>.<span class='id identifier rubyid_c'>c</span>

<span class='id identifier rubyid_defs'>defs</span><span class='op'>/</span><span class='id identifier rubyid_opt_insns_unif'>opt_insns_unif</span>.<span class='id identifier rubyid_def'>def</span>  <span class='op'>:</span> <span class='id identifier rubyid_instruction'>instruction</span> <span class='id identifier rubyid_unification'>unification</span>
<span class='id identifier rubyid_defs'>defs</span><span class='op'>/</span><span class='id identifier rubyid_opt_operand'>opt_operand</span>.<span class='id identifier rubyid_def'>def</span>     <span class='op'>:</span> <span class='id identifier rubyid_definitions'>definitions</span> <span class='kw'>for</span> <span class='id identifier rubyid_optimization'>optimization</span>

  <span class='comment'>#=&gt; insn*.inc           : automatically generated
</span>  <span class='comment'>#=&gt; opt*.inc            : automatically generated
</span>  <span class='comment'>#=&gt; vm.inc              : automatically generated</span></code></pre>

<h3 id="label-Regular+Expression+Engine+-28Onigumo-29">Regular Expression Engine (Onigumo)</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_regcomp'>regcomp</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_regenc'>regenc</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_regerror'>regerror</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_regexec'>regexec</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_regparse'>regparse</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_regsyntax'>regsyntax</span>.<span class='id identifier rubyid_c'>c</span></code></pre>

<h3 id="label-Utility+Functions">Utility Functions</h3>
<dl class="rdoc-list note-list"><dt>debug.c    
<dd>
<p>debug symbols for C debugger</p>
</dd><dt>dln.c      
<dd>
<p>dynamic loading</p>
</dd><dt>st.c       
<dd>
<p>general purpose hash table</p>
</dd><dt>strftime.c 
<dd>
<p>formatting times</p>
</dd><dt>util.c     
<dd>
<p>misc utilities</p>
</dd></dl>

<h3 id="label-Ruby+Interpreter+Implementation">Ruby Interpreter Implementation</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_dmyext'>dmyext</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_dmydln'>dmydln</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_dmyencoding'>dmyencoding</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_id'>id</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_inits'>inits</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_main'>main</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_ruby'>ruby</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_version'>version</span>.<span class='id identifier rubyid_c'>c</span>

<span class='id identifier rubyid_gem_prelude'>gem_prelude</span>.<span class='id identifier rubyid_rb'>rb</span>
<span class='id identifier rubyid_prelude'>prelude</span>.<span class='id identifier rubyid_rb'>rb</span></code></pre>

<h3 id="label-Class+Library">Class Library</h3>
<dl class="rdoc-list note-list"><dt>array.c      
<dd>
<p>Array</p>
</dd><dt>bignum.c     
<dd>
<p>Bignum</p>
</dd><dt>compar.c     
<dd>
<p>Comparable</p>
</dd><dt>complex.c    
<dd>
<p>Complex</p>
</dd><dt>cont.c       
<dd>
<p>Fiber, Continuation</p>
</dd><dt>dir.c        
<dd>
<p>Dir</p>
</dd><dt>enum.c       
<dd>
<p>Enumerable</p>
</dd><dt>enumerator.c 
<dd>
<p>Enumerator</p>
</dd><dt>file.c       
<dd>
<p>File</p>
</dd><dt>hash.c       
<dd>
<p>Hash</p>
</dd><dt>io.c         
<dd>
<p>IO</p>
</dd><dt>marshal.c    
<dd>
<p>Marshal</p>
</dd><dt>math.c       
<dd>
<p>Math</p>
</dd><dt>numeric.c    
<dd>
<p>Numeric, Integer, Fixnum, Float</p>
</dd><dt>pack.c       
<dd>
<p>Array#pack, String#unpack</p>
</dd><dt>proc.c       
<dd>
<p>Binding, Proc</p>
</dd><dt>process.c    
<dd>
<p>Process</p>
</dd><dt>random.c     
<dd>
<p>random number</p>
</dd><dt>range.c      
<dd>
<p>Range</p>
</dd><dt>rational.c   
<dd>
<p>Rational</p>
</dd><dt>re.c         
<dd>
<p>Regexp, MatchData</p>
</dd><dt>signal.c     
<dd>
<p>Signal</p>
</dd><dt>sprintf.c    
<dd>
<p>String#sprintf</p>
</dd><dt>string.c     
<dd>
<p>String</p>
</dd><dt>struct.c     
<dd>
<p>Struct</p>
</dd><dt>time.c       
<dd>
<p>Time</p>
</dd><dt>defs/known_errors.def 
<dd>
<p>Errno::* exception classes</p>
</dd><dt>-&gt; known_errors.inc   
<dd>
<p>automatically generated</p>
</dd></dl>

<h3 id="label-Multilingualization">Multilingualization</h3>
<dl class="rdoc-list note-list"><dt>encoding.c  
<dd>
<p>Encoding</p>
</dd><dt>transcode.c 
<dd>
<p>Encoding::Converter</p>
</dd><dt>enc/*.c     
<dd>
<p>encoding classes</p>
</dd><dt>enc/trans/* 
<dd>
<p>codepoint mapping tables</p>
</dd></dl>

<h3 id="label-goruby+Interpreter+Implementation">goruby Interpreter Implementation</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_goruby'>goruby</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_golf_prelude'>golf_prelude</span>.<span class='id identifier rubyid_rb'>rb</span>     <span class='op'>:</span> <span class='id identifier rubyid_goruby'>goruby</span> <span class='id identifier rubyid_specific'>specific</span> <span class='id identifier rubyid_libraries'>libraries</span>.
  <span class='comment'>#=&gt; golf_prelude.c : automatically generated</span></code></pre>

<h2 id="label-Appendix+B.+Ruby+Extension+API+Reference">Appendix B. Ruby Extension API Reference</h2>

<h3 id="label-Types">Types</h3>
<dl class="rdoc-list note-list"><dt>VALUE 
<dd>
<p>The type for the Ruby object.  Actual structures are defined in ruby.h, such as struct RString, etc.  To refer the values in structures, use casting macros like RSTRING(obj).</p>
</dd></dl>

<h3 id="label-Variables+and+Constants">Variables and Constants</h3>
<dl class="rdoc-list note-list"><dt>Qnil 
<dd>
<p>nil object</p>
</dd><dt>Qtrue 
<dd>
<p>true object (default true value)</p>
</dd><dt>Qfalse 
<dd>
<p>false object</p>
</dd></dl>

<h3 id="label-C+Pointer+Wrapping">C Pointer Wrapping</h3>
<dl class="rdoc-list note-list"><dt>Data_Wrap_Struct(VALUE klass, void (*mark)(), void (*free)(), void *sval) 
<dd>
<p>Wrap a C pointer into a Ruby object.  If object has references to other Ruby objects, they should be marked by using the mark function during the GC process.  Otherwise, mark should be 0.  When this object is no longer referred by anywhere, the pointer will be discarded by free function.</p>
</dd><dt>Data_Make_Struct(klass, type, mark, free, sval) 
<dd>
<p>This macro allocates memory using malloc(), assigns it to the variable sval, and returns the DATA encapsulating the pointer to memory region.</p>
</dd><dt>Data_Get_Struct(data, type, sval) 
<dd>
<p>This macro retrieves the pointer value from DATA, and assigns it to the variable sval.</p>
</dd></dl>

<h3 id="label-Checking+Data+Types">Checking Data Types</h3>
<dl class="rdoc-list note-list"><dt>RB_TYPE_P(value, type) 
<dd>
<p>Is <code>value</code> an internal type (T_NIL, T_FIXNUM, etc.)?</p>
</dd><dt>TYPE(value) 
<dd>
<p>Internal type (T_NIL, T_FIXNUM, etc.)</p>
</dd><dt>FIXNUM_P(value) 
<dd>
<p>Is <code>value</code> a Fixnum?</p>
</dd><dt>NIL_P(value) 
<dd>
<p>Is <code>value</code> nil?</p>
</dd><dt>RB_INTEGER_TYPE_P(value) 
<dd>
<p>Is <code>value</code> an Integer?</p>
</dd><dt>RB_FLOAT_TYPE_P(value) 
<dd>
<p>Is <code>value</code> a Float?</p>
</dd><dt>void Check_Type(VALUE value, int type) 
<dd>
<p>Ensures <code>value</code> is of the given internal <code>type</code> or raises a TypeError</p>
</dd></dl>

<h3 id="label-Data+Type+Conversion">Data Type Conversion</h3>
<dl class="rdoc-list note-list"><dt>FIX2INT(value), INT2FIX(i) 
<dd>
<p>Fixnum &lt;-&gt; integer</p>
</dd><dt>FIX2LONG(value), LONG2FIX(l) 
<dd>
<p>Fixnum &lt;-&gt; long</p>
</dd><dt>NUM2INT(value), INT2NUM(i) 
<dd>
<p>Numeric &lt;-&gt; integer</p>
</dd><dt>NUM2UINT(value), UINT2NUM(ui) 
<dd>
<p>Numeric &lt;-&gt; unsigned integer</p>
</dd><dt>NUM2LONG(value), LONG2NUM(l) 
<dd>
<p>Numeric &lt;-&gt; long</p>
</dd><dt>NUM2ULONG(value), ULONG2NUM(ul) 
<dd>
<p>Numeric &lt;-&gt; unsigned long</p>
</dd><dt>NUM2LL(value), LL2NUM(ll) 
<dd>
<p>Numeric &lt;-&gt; long long</p>
</dd><dt>NUM2ULL(value), ULL2NUM(ull) 
<dd>
<p>Numeric &lt;-&gt; unsigned long long</p>
</dd><dt>NUM2OFFT(value), OFFT2NUM(off) 
<dd>
<p>Numeric &lt;-&gt; off_t</p>
</dd><dt>NUM2SIZET(value), SIZET2NUM(size) 
<dd>
<p>Numeric &lt;-&gt; size_t</p>
</dd><dt>NUM2SSIZET(value), SSIZET2NUM(ssize) 
<dd>
<p>Numeric &lt;-&gt; ssize_t</p>
</dd><dt>rb_integer_pack(value, words, numwords, wordsize, nails, flags), rb_integer_unpack(words, numwords, wordsize, nails, flags) 
<dd>
<p>Numeric &lt;-&gt; Arbitrary size integer buffer</p>
</dd><dt>NUM2DBL(value) 
<dd>
<p>Numeric -&gt; double</p>
</dd><dt>rb_float_new(f) 
<dd>
<p>double -&gt; Float</p>
</dd><dt>RSTRING_LEN(str) 
<dd>
<p>String -&gt; length of String data in bytes</p>
</dd><dt>RSTRING_PTR(str) 
<dd>
<p>String -&gt; pointer to String data Note that the result pointer may not be NUL-terminated</p>
</dd><dt>StringValue(value) 
<dd>
<p>Object with #to_str -&gt; String</p>
</dd><dt>StringValuePtr(value) 
<dd>
<p>Object with #to_str -&gt; pointer to String data</p>
</dd><dt>StringValueCStr(value) 
<dd>
<p>Object with #to_str -&gt; pointer to String data without NUL bytes It is guaranteed that the result data is NUL-terminated</p>
</dd><dt>rb_str_new2(s) 
<dd>
<p>char * -&gt; String</p>
</dd></dl>

<h3 id="label-Defining+Classes+and+Modules">Defining Classes and Modules</h3>
<dl class="rdoc-list note-list"><dt>VALUE rb_define_class(const char *name, VALUE super) 
<dd>
<p>Defines a new Ruby class as a subclass of super.</p>
</dd><dt>VALUE rb_define_class_under(VALUE module, const char *name, VALUE super) 
<dd>
<p>Creates a new Ruby class as a subclass of super, under the module’s namespace.</p>
</dd><dt>VALUE rb_define_module(const char *name) 
<dd>
<p>Defines a new Ruby module.</p>
</dd><dt>VALUE rb_define_module_under(VALUE module, const char *name) 
<dd>
<p>Defines a new Ruby module under the module’s namespace.</p>
</dd><dt>void rb_include_module(VALUE klass, VALUE module) 
<dd>
<p>Includes module into class.  If class already includes it, just ignored.</p>
</dd><dt>void rb_extend_object(VALUE object, VALUE module) 
<dd>
<p>Extend the object with the module’s attributes.</p>
</dd></dl>

<h3 id="label-Defining+Global+Variables">Defining Global Variables</h3>
<dl class="rdoc-list note-list"><dt>void rb_define_variable(const char *name, VALUE *var) 
<dd>
<p>Defines a global variable which is shared between C and Ruby.  If name contains a character which is not allowed to be part of the symbol, it can’t be seen from Ruby programs.</p>
</dd><dt>void rb_define_readonly_variable(const char *name, VALUE *var) 
<dd>
<p>Defines a read-only global variable.  Works just like rb_define_variable(), except the defined variable is read-only.</p>
</dd><dt>void rb_define_virtual_variable(const char *name, VALUE (*getter)(), void (*setter)()) 
<dd>
<p>Defines a virtual variable, whose behavior is defined by a pair of C functions.  The getter function is called when the variable is referenced.  The setter function is called when the variable is set to a value.  The prototype for getter/setter functions are:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_getter'>getter</span>(<span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span>)
<span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_setter'>setter</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_val'>val</span><span class='comma'>,</span> <span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span>)</code></pre>

<p>The getter function must return the value for the access.</p>
</dd><dt>void rb_define_hooked_variable(const char *name, VALUE *var, VALUE (*getter)(), void (*setter)()) 
<dd>
<p>Defines hooked variable.  It’s a virtual variable with a C variable. The getter is called as</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_getter'>getter</span>(<span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_var'>var</span>)</code></pre>

<p>returning a new value.  The setter is called as</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_setter'>setter</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_val'>val</span><span class='comma'>,</span> <span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_var'>var</span>)</code></pre>
</dd><dt>void rb_global_variable(VALUE *var) 
<dd>
<p>Tells GC to protect C global variable, which holds Ruby value to be marked.</p>
</dd><dt>void rb_gc_register_mark_object(VALUE object) 
<dd>
<p>Tells GC to protect the <code>object</code>, which may not be referenced anywhere.</p>
</dd></dl>

<h3 id="label-Constant+Definition">Constant Definition</h3>
<dl class="rdoc-list note-list"><dt>void rb_define_const(VALUE klass, const char *name, VALUE val) 
<dd>
<p>Defines a new constant under the class/module.</p>
</dd><dt>void rb_define_global_const(const char *name, VALUE val) 
<dd>
<p>Defines a global constant.  This is just the same as</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_rb_define_const'>rb_define_const</span>(<span class='id identifier rubyid_rb_cObject'>rb_cObject</span><span class='comma'>,</span> <span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_val'>val</span>)</code></pre>
</dd></dl>

<h3 id="label-Method+Definition">Method Definition</h3>
<dl class="rdoc-list note-list"><dt>rb_define_method(VALUE klass, const char *name, VALUE (*func)(ANYARGS), int argc) 
<dd>
<p>Defines a method for the class.  func is the function pointer.  argc is the number of arguments.  if argc is -1, the function will receive 3 arguments: argc, argv, and self.  if argc is -2, the function will receive 2 arguments, self and args, where args is a Ruby array of the method arguments.</p>
</dd><dt>rb_define_private_method(VALUE klass, const char *name, VALUE (*func)(ANYARGS), int argc) 
<dd>
<p>Defines a private method for the class.  Arguments are same as rb_define_method().</p>
</dd><dt>rb_define_singleton_method(VALUE klass, const char *name, VALUE (*func)(ANYARGS), int argc) 
<dd>
<p>Defines a singleton method.  Arguments are same as rb_define_method().</p>
</dd><dt>rb_check_arity(int argc, int min, int max) 
<dd>
<p>Check the number of arguments, argc is in the range of min..max.  If max is UNLIMITED_ARGUMENTS, upper bound is not checked.  If argc is out of bounds, an ArgumentError will be raised.</p>
</dd><dt>rb_scan_args(int argc, VALUE *argv, const char *fmt, …) 
<dd>
<p>Retrieve argument from argc and argv to given VALUE references according to the format string.  The format can be described in ABNF as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_scan'>scan</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span>  <span class='symbeg'>:</span><span class='op'>=</span> <span class='id identifier rubyid_param'>param</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span> [<span class='id identifier rubyid_keyword'>keyword</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span>] [<span class='id identifier rubyid_block'>block</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span>]

<span class='id identifier rubyid_param'>param</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span> <span class='symbeg'>:</span><span class='op'>=</span> <span class='id identifier rubyid_pre'>pre</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span> [<span class='id identifier rubyid_post'>post</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span>] <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'> post-arg-spec </span><span class='regexp_end'>/</span></span>
                  <span class='id identifier rubyid_pre'>pre</span><span class='op'>-</span><span class='id identifier rubyid_opt'>opt</span><span class='op'>-</span><span class='id identifier rubyid_post'>post</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span>
<span class='id identifier rubyid_pre'>pre</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span>   <span class='symbeg'>:</span><span class='op'>=</span> <span class='id identifier rubyid_num'>num</span><span class='op'>-</span><span class='id identifier rubyid_of'>of</span><span class='op'>-</span><span class='id identifier rubyid_leading'>leading</span><span class='op'>-</span><span class='id identifier rubyid_mandatory'>mandatory</span><span class='op'>-</span><span class='id identifier rubyid_args'>args</span> [<span class='id identifier rubyid_num'>num</span><span class='op'>-</span><span class='id identifier rubyid_of'>of</span><span class='op'>-</span><span class='id identifier rubyid_optional'>optional</span><span class='op'>-</span><span class='id identifier rubyid_args'>args</span>]
<span class='id identifier rubyid_post'>post</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span>  <span class='symbeg'>:</span><span class='op'>=</span> <span class='id identifier rubyid_sym'>sym</span><span class='op'>-</span><span class='kw'>for</span><span class='op'>-</span><span class='id identifier rubyid_variable'>variable</span><span class='op'>-</span><span class='id identifier rubyid_length'>length</span><span class='op'>-</span><span class='id identifier rubyid_args'>args</span>
                  [<span class='id identifier rubyid_num'>num</span><span class='op'>-</span><span class='id identifier rubyid_of'>of</span><span class='op'>-</span><span class='id identifier rubyid_trailing'>trailing</span><span class='op'>-</span><span class='id identifier rubyid_mandatory'>mandatory</span><span class='op'>-</span><span class='id identifier rubyid_args'>args</span>]
<span class='id identifier rubyid_pre'>pre</span><span class='op'>-</span><span class='id identifier rubyid_opt'>opt</span><span class='op'>-</span><span class='id identifier rubyid_post'>post</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span> <span class='symbeg'>:</span><span class='op'>=</span> <span class='id identifier rubyid_num'>num</span><span class='op'>-</span><span class='id identifier rubyid_of'>of</span><span class='op'>-</span><span class='id identifier rubyid_leading'>leading</span><span class='op'>-</span><span class='id identifier rubyid_mandatory'>mandatory</span><span class='op'>-</span><span class='id identifier rubyid_args'>args</span> <span class='id identifier rubyid_num'>num</span><span class='op'>-</span><span class='id identifier rubyid_of'>of</span><span class='op'>-</span><span class='id identifier rubyid_optional'>optional</span><span class='op'>-</span><span class='id identifier rubyid_args'>args</span>
                         <span class='id identifier rubyid_num'>num</span><span class='op'>-</span><span class='id identifier rubyid_of'>of</span><span class='op'>-</span><span class='id identifier rubyid_trailing'>trailing</span><span class='op'>-</span><span class='id identifier rubyid_mandatory'>mandatory</span><span class='op'>-</span><span class='id identifier rubyid_args'>args</span>
<span class='id identifier rubyid_keyword'>keyword</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span> <span class='symbeg'>:</span><span class='op'>=</span> <span class='id identifier rubyid_sym'>sym</span><span class='op'>-</span><span class='kw'>for</span><span class='op'>-</span><span class='id identifier rubyid_keyword'>keyword</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span>
<span class='id identifier rubyid_block'>block</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span><span class='op'>-</span><span class='id identifier rubyid_spec'>spec</span> <span class='symbeg'>:</span><span class='op'>=</span> <span class='id identifier rubyid_sym'>sym</span><span class='op'>-</span><span class='kw'>for</span><span class='op'>-</span><span class='id identifier rubyid_block'>block</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span>

<span class='id identifier rubyid_num'>num</span><span class='op'>-</span><span class='id identifier rubyid_of'>of</span><span class='op'>-</span><span class='id identifier rubyid_leading'>leading</span><span class='op'>-</span><span class='id identifier rubyid_mandatory'>mandatory</span><span class='op'>-</span><span class='id identifier rubyid_args'>args</span>  <span class='symbeg'>:</span><span class='op'>=</span> <span class='const'>DIGIT</span> <span class='semicolon'>;</span> <span class='const'>The</span> <span class='id identifier rubyid_number'>number</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_leading'>leading</span>
                                        <span class='semicolon'>;</span> <span class='id identifier rubyid_mandatory'>mandatory</span> <span class='id identifier rubyid_arguments'>arguments</span>
<span class='id identifier rubyid_num'>num</span><span class='op'>-</span><span class='id identifier rubyid_of'>of</span><span class='op'>-</span><span class='id identifier rubyid_optional'>optional</span><span class='op'>-</span><span class='id identifier rubyid_args'>args</span>           <span class='symbeg'>:</span><span class='op'>=</span> <span class='const'>DIGIT</span> <span class='semicolon'>;</span> <span class='const'>The</span> <span class='id identifier rubyid_number'>number</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_optional'>optional</span>
                                        <span class='semicolon'>;</span> <span class='id identifier rubyid_arguments'>arguments</span>
<span class='id identifier rubyid_sym'>sym</span><span class='op'>-</span><span class='kw'>for</span><span class='op'>-</span><span class='id identifier rubyid_variable'>variable</span><span class='op'>-</span><span class='id identifier rubyid_length'>length</span><span class='op'>-</span><span class='id identifier rubyid_args'>args</span>   <span class='symbeg'>:</span><span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>*</span><span class='tstring_end'>&quot;</span></span>   <span class='semicolon'>;</span> <span class='const'>Indicates</span> <span class='id identifier rubyid_that'>that</span> <span class='id identifier rubyid_variable'>variable</span>
                                        <span class='semicolon'>;</span> <span class='id identifier rubyid_length'>length</span> <span class='id identifier rubyid_arguments'>arguments</span> <span class='id identifier rubyid_are'>are</span>
                                        <span class='semicolon'>;</span> <span class='id identifier rubyid_captured'>captured</span> <span class='id identifier rubyid_as'>as</span> <span class='id identifier rubyid_a'>a</span> <span class='id identifier rubyid_ruby'>ruby</span> <span class='id identifier rubyid_array'>array</span>
<span class='id identifier rubyid_num'>num</span><span class='op'>-</span><span class='id identifier rubyid_of'>of</span><span class='op'>-</span><span class='id identifier rubyid_trailing'>trailing</span><span class='op'>-</span><span class='id identifier rubyid_mandatory'>mandatory</span><span class='op'>-</span><span class='id identifier rubyid_args'>args</span> <span class='symbeg'>:</span><span class='op'>=</span> <span class='const'>DIGIT</span> <span class='semicolon'>;</span> <span class='const'>The</span> <span class='id identifier rubyid_number'>number</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_trailing'>trailing</span>
                                        <span class='semicolon'>;</span> <span class='id identifier rubyid_mandatory'>mandatory</span> <span class='id identifier rubyid_arguments'>arguments</span>
<span class='id identifier rubyid_sym'>sym</span><span class='op'>-</span><span class='kw'>for</span><span class='op'>-</span><span class='id identifier rubyid_keyword'>keyword</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span>            <span class='symbeg'>:</span><span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>:</span><span class='tstring_end'>&quot;</span></span>   <span class='semicolon'>;</span> <span class='const'>Indicates</span> <span class='id identifier rubyid_that'>that</span> <span class='id identifier rubyid_keyword'>keyword</span>
                                        <span class='semicolon'>;</span> <span class='id identifier rubyid_argument'>argument</span> <span class='id identifier rubyid_captured'>captured</span> <span class='id identifier rubyid_as'>as</span> <span class='id identifier rubyid_a'>a</span> <span class='id identifier rubyid_hash'>hash</span>.
                                        <span class='semicolon'>;</span> <span class='const'>If</span> <span class='id identifier rubyid_keyword'>keyword</span> <span class='id identifier rubyid_arguments'>arguments</span> <span class='id identifier rubyid_are'>are</span> <span class='kw'>not</span>
                                        <span class='semicolon'>;</span> <span class='id identifier rubyid_provided'>provided</span><span class='comma'>,</span> <span class='id identifier rubyid_returns'>returns</span> <span class='kw'>nil</span>.
<span class='id identifier rubyid_sym'>sym</span><span class='op'>-</span><span class='kw'>for</span><span class='op'>-</span><span class='id identifier rubyid_block'>block</span><span class='op'>-</span><span class='id identifier rubyid_arg'>arg</span>              <span class='symbeg'>:</span><span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>&amp;</span><span class='tstring_end'>&quot;</span></span>   <span class='semicolon'>;</span> <span class='const'>Indicates</span> <span class='id identifier rubyid_that'>that</span> <span class='id identifier rubyid_an'>an</span> <span class='id identifier rubyid_iterator'>iterator</span>
                                        <span class='semicolon'>;</span> <span class='id identifier rubyid_block'>block</span> <span class='id identifier rubyid_should'>should</span> <span class='id identifier rubyid_be'>be</span> <span class='id identifier rubyid_captured'>captured</span> <span class='kw'>if</span>
                                        <span class='semicolon'>;</span> <span class='id identifier rubyid_given'>given</span></code></pre>

<p>For example, “12” means that the method requires at least one argument, and at most receives three (1+2) arguments.  So, the format string must be followed by three variable references, which are to be assigned to captured arguments.  For omitted arguments, variables are set to Qnil.  NULL can be put in place of a variable reference, which means the corresponding captured argument(s) should be just dropped.</p>

<p>The number of given arguments, excluding an option hash or iterator block, is returned.</p>
</dd><dt>rb_scan_args_kw(int kw_splat, int argc, VALUE *argv, const char *fmt, …) 
<dd>
<p>The same as <code>rb_scan_args</code>, except the <code>kw_splat</code> argument specifies whether keyword arguments are provided (instead of being determined by the call from Ruby to the C function). <code>kw_splat</code> should be one of the following values:</p>
<dl class="rdoc-list note-list"><dt>RB_SCAN_ARGS_PASS_CALLED_KEYWORDS 
<dd>
<p>Same behavior as <code>rb_scan_args</code>.</p>
</dd><dt>RB_SCAN_ARGS_KEYWORDS 
<dd>
<p>The final argument should be a hash treated as keywords.</p>
</dd><dt>RB_SCAN_ARGS_LAST_HASH_KEYWORDS 
<dd>
<p>Treat a final argument as keywords if it is a hash, and not as keywords otherwise.</p>
</dd></dl>
</dd><dt>int rb_get_kwargs(VALUE keyword_hash, const ID *table, int required, int optional, VALUE *values) 
<dd>
<p>Retrieves argument VALUEs bound to keywords, which directed by <code>table</code> into <code>values</code>, deleting retrieved entries from <code>keyword_hash</code> along the way.  First <code>required</code> number of IDs referred by <code>table</code> are mandatory, and succeeding <code>optional</code> (- <code>optional</code> - 1 if <code>optional</code> is negative) number of IDs are optional.  If a mandatory key is not contained in <code>keyword_hash</code>, raises “missing keyword” <code>ArgumentError</code>.  If an optional key is not present in <code>keyword_hash</code>, the corresponding element in <code>values</code> is set to <code>Qundef</code>. If <code>optional</code> is negative, rest of <code>keyword_hash</code> are ignored, otherwise raises “unknown keyword” <code>ArgumentError</code>.</p>

<p>Be warned, handling keyword arguments in the C API is less efficient than handling them in Ruby.  Consider using a Ruby wrapper method around a non-keyword C function. ref: <a href="https://bugs.ruby-lang.org/issues/11339">bugs.ruby-lang.org/issues/11339</a></p>
</dd><dt>VALUE rb_extract_keywords(VALUE *original_hash) 
<dd>
<p>Extracts pairs whose key is a symbol into a new hash from a hash object referred by <code>original_hash</code>.  If the original hash contains non-symbol keys, then they are copied to another hash and the new hash is stored through <code>original_hash</code>, else 0 is stored.</p>
</dd></dl>

<h3 id="label-Invoking+Ruby+method">Invoking Ruby method</h3>
<dl class="rdoc-list note-list"><dt>VALUE rb_funcall(VALUE recv, ID mid, int narg, …) 
<dd>
<p>Invokes a method.  To retrieve mid from a method name, use rb_intern(). Able to call even private/protected methods.</p>
</dd><dt>VALUE rb_funcall2(VALUE recv, ID mid, int argc, VALUE *argv) 
<dt>VALUE rb_funcallv(VALUE recv, ID mid, int argc, VALUE *argv) 
<dd>
<p>Invokes a method, passing arguments as an array of values. Able to call even private/protected methods.</p>
</dd><dt>VALUE rb_funcallv_kw(VALUE recv, ID mid, int argc, VALUE *argv, int kw_splat) 
<dd>
<p>Same as rb_funcallv, using <code>kw_splat</code> to determine whether keyword arguments are passed.</p>
</dd><dt>VALUE rb_funcallv_public(VALUE recv, ID mid, int argc, VALUE *argv) 
<dd>
<p>Invokes a method, passing arguments as an array of values. Able to call only public methods.</p>
</dd><dt>VALUE rb_funcallv_public_kw(VALUE recv, ID mid, int argc, VALUE *argv, int kw_splat) 
<dd>
<p>Same as rb_funcallv_public, using <code>kw_splat</code> to determine whether keyword arguments are passed.</p>
</dd><dt>VALUE rb_funcall_passing_block(VALUE recv, ID mid, int argc, const VALUE* argv) 
<dd>
<p>Same as rb_funcallv_public, except is passes the currently active block as the block when calling the method.</p>
</dd><dt>VALUE rb_funcall_passing_block_kw(VALUE recv, ID mid, int argc, const VALUE* argv, int kw_splat) 
<dd>
<p>Same as rb_funcall_passing_block, using <code>kw_splat</code> to determine whether keyword arguments are passed.</p>
</dd><dt>VALUE rb_funcall_with_block(VALUE recv, ID mid, int argc, const VALUE *argv, VALUE passed_procval) 
<dd>
<p>Same as rb_funcallv_public, except <code>passed_procval</code> specifies the block to pass to the method.</p>
</dd><dt>VALUE rb_funcall_with_block_kw(VALUE recv, ID mid, int argc, const VALUE *argv, VALUE passed_procval, int kw_splat) 
<dd>
<p>Same as rb_funcall_with_block, using <code>kw_splat</code> to determine whether keyword arguments are passed.</p>
</dd><dt>VALUE rb_eval_string(const char *str) 
<dd>
<p>Compiles and executes the string as a Ruby program.</p>
</dd><dt>ID rb_intern(const char *name) 
<dd>
<p>Returns ID corresponding to the name.</p>
</dd><dt>char *rb_id2name(ID id) 
<dd>
<p>Returns the name corresponding ID.</p>
</dd><dt>char *rb_class2name(VALUE klass) 
<dd>
<p>Returns the name of the class.</p>
</dd><dt>int rb_respond_to(VALUE obj, ID id) 
<dd>
<p>Returns true if the object responds to the message specified by id.</p>
</dd></dl>

<h3 id="label-Instance+Variables">Instance Variables</h3>
<dl class="rdoc-list note-list"><dt>VALUE rb_iv_get(VALUE obj, const char *name) 
<dd>
<p>Retrieve the value of the instance variable.  If the name is not prefixed by ‘@’, that variable shall be inaccessible from Ruby.</p>
</dd><dt>VALUE rb_iv_set(VALUE obj, const char *name, VALUE val) 
<dd>
<p>Sets the value of the instance variable.</p>
</dd></dl>

<h3 id="label-Control+Structure">Control Structure</h3>
<dl class="rdoc-list note-list"><dt>VALUE rb_block_call(VALUE recv, ID mid, int argc, VALUE * argv, VALUE (*func) (ANYARGS), VALUE data2) 
<dd>
<p>Calls a method on the recv, with the method name specified by the symbol mid, with argc arguments in argv, supplying func as the block. When func is called as the block, it will receive the value from yield as the first argument, and data2 as the second argument. When yielded with multiple values (in C, rb_yield_values(), rb_yield_values2() and rb_yield_splat()), data2 is packed as an Array, whereas yielded values can be gotten via argc/argv of the third/fourth arguments.</p>
</dd><dt>VALUE rb_block_call_kw(VALUE recv, ID mid, int argc, VALUE * argv, VALUE (*func) (ANYARGS), VALUE data2, int kw_splat) 
<dd>
<p>Same as rb_funcall_with_block, using <code>kw_splat</code> to determine whether keyword arguments are passed.</p>
</dd><dt>[OBSOLETE] VALUE rb_iterate(VALUE (*func1)(), VALUE arg1, VALUE (*func2)(), VALUE arg2) 
<dd>
<p>Calls the function func1, supplying func2 as the block.  func1 will be called with the argument arg1.  func2 receives the value from yield as the first argument, arg2 as the second argument.</p>

<p>When rb_iterate is used in 1.9, func1 has to call some Ruby-level method. This function is obsolete since 1.9; use rb_block_call instead.</p>
</dd><dt>VALUE rb_yield(VALUE val) 
<dd>
<p>Yields val as a single argument to the block.</p>
</dd><dt>VALUE rb_yield_values(int n, …) 
<dd>
<p>Yields <code>n</code> number of arguments to the block, using one C argument per Ruby argument.</p>
</dd><dt>VALUE rb_yield_values2(int n, VALUE *argv) 
<dd>
<p>Yields <code>n</code> number of arguments to the block, with all Ruby arguments in the C argv array.</p>
</dd><dt>VALUE rb_yield_values_kw(int n, VALUE *argv, int kw_splat) 
<dd>
<p>Same as rb_yield_values2, using <code>kw_splat</code> to determine whether keyword arguments are passed.</p>
</dd><dt>VALUE rb_yield_splat(VALUE args) 
<dd>
<p>Same as rb_yield_values2, except arguments are specified by the Ruby array <code>args</code>.</p>
</dd><dt>VALUE rb_yield_splat_kw(VALUE args, int kw_splat) 
<dd>
<p>Same as rb_yield_splat, using <code>kw_splat</code> to determine whether keyword arguments are passed.</p>
</dd><dt>VALUE rb_rescue(VALUE (*func1)(ANYARGS), VALUE arg1, VALUE (*func2)(ANYARGS), VALUE arg2) 
<dd>
<p>Calls the function func1, with arg1 as the argument.  If an exception occurs during func1, it calls func2 with arg2 as the first argument and the exception object as the second argument.  The return value of rb_rescue() is the return value from func1 if no exception occurs, from func2 otherwise.</p>
</dd><dt>VALUE rb_ensure(VALUE (*func1)(ANYARGS), VALUE arg1, VALUE (*func2)(ANYARGS), VALUE arg2) 
<dd>
<p>Calls the function func1 with arg1 as the argument, then calls func2 with arg2 if execution terminated.  The return value from rb_ensure() is that of func1 when no exception occurred.</p>
</dd><dt>VALUE rb_protect(VALUE (*func) (VALUE), VALUE arg, int *state) 
<dd>
<p>Calls the function func with arg as the argument.  If no exception occurred during func, it returns the result of func and *state is zero. Otherwise, it returns Qnil and sets *state to nonzero.  If state is NULL, it is not set in both cases. You have to clear the error info with rb_set_errinfo(Qnil) when ignoring the caught exception.</p>
</dd><dt>void rb_jump_tag(int state) 
<dd>
<p>Continues the exception caught by rb_protect() and rb_eval_string_protect(). state must be the returned value from those functions.  This function never return to the caller.</p>
</dd><dt>void rb_iter_break() 
<dd>
<p>Exits from the current innermost block.  This function never return to the caller.</p>
</dd><dt>void rb_iter_break_value(VALUE value) 
<dd>
<p>Exits from the current innermost block with the value.  The block will return the given argument value.  This function never return to the caller.</p>
</dd></dl>

<h3 id="label-Exceptions+and+Errors">Exceptions and Errors</h3>
<dl class="rdoc-list note-list"><dt>void rb_warn(const char *fmt, …) 
<dd>
<p>Prints a warning message according to a printf-like format.</p>
</dd><dt>void rb_warning(const char *fmt, …) 
<dd>
<p>Prints a warning message according to a printf-like format, if $VERBOSE is true.</p>
</dd><dt>void rb_raise(rb_eRuntimeError, const char *fmt, …) 
<dd>
<p>Raises RuntimeError.  The fmt is a format string just like printf().</p>
</dd><dt>void rb_raise(VALUE exception, const char *fmt, …) 
<dd>
<p>Raises a class exception.  The fmt is a format string just like printf().</p>
</dd><dt>void rb_fatal(const char *fmt, …) 
<dd>
<p>Raises a fatal error, terminates the interpreter.  No exception handling will be done for fatal errors, but ensure blocks will be executed.</p>
</dd><dt>void rb_bug(const char *fmt, …) 
<dd>
<p>Terminates the interpreter immediately.  This function should be called under the situation caused by the bug in the interpreter.  No exception handling nor ensure execution will be done.</p>
</dd></dl>

<p>Note: In the format string, “%”PRIsVALUE can be used for Object#to_s (or Object#inspect if ‘+’ flag is set) output (and related argument must be a VALUE).  Since it conflicts with “%i”, for integers in format strings, use “%d”.</p>

<h3 id="label-Threading">Threading</h3>

<p>As of Ruby 1.9, Ruby supports native 1:1 threading with one kernel thread per Ruby Thread object.  Currently, there is a GVL (Global VM Lock) which prevents simultaneous execution of Ruby code which may be released by the rb_thread_call_without_gvl and rb_thread_call_without_gvl2 functions. These functions are tricky-to-use and documented in thread.c; do not use them before reading comments in thread.c.</p>
<dl class="rdoc-list note-list"><dt>void rb_thread_schedule(void) 
<dd>
<p>Give the scheduler a hint to pass execution to another thread.</p>
</dd></dl>

<h3 id="label-Input-2FOutput+-28IO-29+on+a+single+file+descriptor">Input/Output (IO) on a single file descriptor</h3>
<dl class="rdoc-list note-list"><dt>int rb_io_wait_readable(int fd) 
<dd>
<p>Wait indefinitely for the given FD to become readable, allowing other threads to be scheduled.  Returns a true value if a read may be performed, false if there is an unrecoverable error.</p>
</dd><dt>int rb_io_wait_writable(int fd) 
<dd>
<p>Like rb_io_wait_readable, but for writability.</p>
</dd><dt>int rb_wait_for_single_fd(int fd, int events, struct timeval *timeout) 
<dd>
<p>Allows waiting on a single FD for one or multiple events with a specified timeout.</p>

<p><code>events</code> is a mask of any combination of the following values:</p>
<ul><li>
<p>RB_WAITFD_IN - wait for readability of normal data</p>
</li><li>
<p>RB_WAITFD_OUT - wait for writability</p>
</li><li>
<p>RB_WAITFD_PRI - wait for readability of urgent data</p>
</li></ul>

<p>Use a NULL <code>timeout</code> to wait indefinitely.</p>
</dd></dl>

<h3 id="label-I-2FO+Multiplexing">I/O Multiplexing</h3>

<p>Ruby supports I/O multiplexing based on the select(2) system call. The Linux select_tut(2) manpage &lt;<a href="http://man7.org/linux/man-pages/man2/select_tut.2.html">man7.org/linux/man-pages/man2/select_tut.2.html</a>&gt; provides a good overview on how to use select(2), and the Ruby API has analogous functions and data structures to the well-known select API. Understanding of select(2) is required to understand this section.</p>
<dl class="rdoc-list note-list"><dt>typedef struct rb_fdset_t 
<dd>
<p>The data structure which wraps the fd_set bitmap used by select(2). This allows Ruby to use FD sets larger than that allowed by historic limitations on modern platforms.</p>
</dd><dt>void rb_fd_init(rb_fdset_t *) 
<dd>
<p>Initializes the rb_fdset_t, it must be initialized before other rb_fd_* operations.  Analogous to calling malloc(3) to allocate an fd_set.</p>
</dd><dt>void rb_fd_term(rb_fdset_t *) 
<dd>
<p>Destroys the rb_fdset_t, releasing any memory and resources it used. It must be reinitialized using rb_fd_init before future use. Analogous to calling free(3) to release memory for an fd_set.</p>
</dd><dt>void rb_fd_zero(rb_fdset_t *) 
<dd>
<p>Clears all FDs from the rb_fdset_t, analogous to FD_ZERO(3).</p>
</dd><dt>void rb_fd_set(int fd, rb_fdset_t *) 
<dd>
<p>Adds a given FD in the rb_fdset_t, analogous to FD_SET(3).</p>
</dd><dt>void rb_fd_clr(int fd, rb_fdset_t *) 
<dd>
<p>Removes a given FD from the rb_fdset_t, analogous to FD_CLR(3).</p>
</dd><dt>int rb_fd_isset(int fd, const rb_fdset_t *) 
<dd>
<p>Returns true if a given FD is set in the rb_fdset_t, false if not. Analogous to FD_ISSET(3).</p>
</dd><dt>int rb_thread_fd_select(int nfds, rb_fdset_t *readfds, rb_fdset_t *writefds, rb_fdset_t *exceptfds, struct timeval *timeout) 
<dd>
<p>Analogous to the select(2) system call, but allows other Ruby threads to be scheduled while waiting.</p>

<p>When only waiting on a single FD, favor rb_io_wait_readable, rb_io_wait_writable, or rb_wait_for_single_fd functions since they can be optimized for specific platforms (currently, only Linux).</p>
</dd></dl>

<h3 id="label-Initialize+and+Start+the+Interpreter">Initialize and Start the Interpreter</h3>

<p>The embedding API functions are below (not needed for extension libraries):</p>
<dl class="rdoc-list note-list"><dt>void ruby_init() 
<dd>
<p>Initializes the interpreter.</p>
</dd><dt>void *ruby_options(int argc, char **argv) 
<dd>
<p>Process command line arguments for the interpreter. And compiles the Ruby source to execute. It returns an opaque pointer to the compiled source or an internal special value.</p>
</dd><dt>int ruby_run_node(void *n) 
<dd>
<p>Runs the given compiled source and exits this process. It returns EXIT_SUCCESS if successfully runs the source. Otherwise, it returns other value.</p>
</dd><dt>void ruby_script(char *name) 
<dd>
<p>Specifies the name of the script ($0).</p>
</dd></dl>

<h3 id="label-Hooks+for+the+Interpreter+Events">Hooks for the Interpreter Events</h3>
<dl class="rdoc-list note-list"><dt>void rb_add_event_hook(rb_event_hook_func_t func, rb_event_flag_t events, VALUE data) 
<dd>
<p>Adds a hook function for the specified interpreter events. events should be OR’ed value of:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>RUBY_EVENT_LINE</span>
<span class='const'>RUBY_EVENT_CLASS</span>
<span class='const'>RUBY_EVENT_END</span>
<span class='const'>RUBY_EVENT_CALL</span>
<span class='const'>RUBY_EVENT_RETURN</span>
<span class='const'>RUBY_EVENT_C_CALL</span>
<span class='const'>RUBY_EVENT_C_RETURN</span>
<span class='const'>RUBY_EVENT_RAISE</span>
<span class='const'>RUBY_EVENT_ALL</span></code></pre>

<p>The definition of rb_event_hook_func_t is below:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_typedef'>typedef</span> <span class='id identifier rubyid_void'>void</span> (<span class='op'>*</span><span class='id identifier rubyid_rb_event_hook_func_t'>rb_event_hook_func_t</span>)(<span class='id identifier rubyid_rb_event_t'>rb_event_t</span> <span class='id identifier rubyid_event'>event</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='id identifier rubyid_data'>data</span><span class='comma'>,</span>
                                     <span class='const'>VALUE</span> <span class='kw'>self</span><span class='comma'>,</span> <span class='const'>ID</span> <span class='id identifier rubyid_id'>id</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='id identifier rubyid_klass'>klass</span>)</code></pre>

<p>The third argument ‘data’ to rb_add_event_hook() is passed to the hook function as the second argument, which was the pointer to the current NODE in 1.8.  See RB_EVENT_HOOKS_HAVE_CALLBACK_DATA below.</p>
</dd><dt>int rb_remove_event_hook(rb_event_hook_func_t func) 
<dd>
<p>Removes the specified hook function.</p>
</dd></dl>

<h3 id="label-Memory+usage">Memory usage</h3>
<dl class="rdoc-list note-list"><dt>void rb_gc_adjust_memory_usage(ssize_t diff) 
<dd>
<p>Adjusts the amount of registered external memory.  You can tell GC how much memory is used by an external library by this function.  Calling this function with positive diff means the memory usage is increased; new memory block is allocated or a block is reallocated as larger size.  Calling this function with negative diff means the memory usage is decreased; a memory block is freed or a block is reallocated as smaller size.  This function may trigger the GC.</p>
</dd></dl>

<h3 id="label-Macros+for+Compatibility">Macros for Compatibility</h3>

<p>Some macros to check API compatibilities are available by default.</p>
<dl class="rdoc-list note-list"><dt>NORETURN_STYLE_NEW 
<dd>
<p>Means that NORETURN macro is functional style instead of prefix.</p>
</dd><dt>HAVE_RB_DEFINE_ALLOC_FUNC 
<dd>
<p>Means that function rb_define_alloc_func() is provided, that means the allocation framework is used.  This is the same as the result of have_func(“rb_define_alloc_func”, “ruby.h”).</p>
</dd><dt>HAVE_RB_REG_NEW_STR 
<dd>
<p>Means that function rb_reg_new_str() is provided, that creates Regexp object from String object.  This is the same as the result of have_func(“rb_reg_new_str”, “ruby.h”).</p>
</dd><dt>HAVE_RB_IO_T 
<dd>
<p>Means that type rb_io_t is provided.</p>
</dd><dt>USE_SYMBOL_AS_METHOD_NAME 
<dd>
<p>Means that Symbols will be returned as method names, e.g., Module#methods, #singleton_methods and so on.</p>
</dd><dt>HAVE_RUBY_*_H 
<dd>
<p>Defined in ruby.h and means corresponding header is available.  For instance, when HAVE_RUBY_ST_H is defined you should use ruby/st.h not mere st.h.</p>

<p>Header files corresponding to these macros may be <code>#include</code> directly from extension libraries.</p>
</dd><dt>RB_EVENT_HOOKS_HAVE_CALLBACK_DATA 
<dd>
<p>Means that rb_add_event_hook() takes the third argument ‘data’, to be passed to the given event hook function.</p>
</dd></dl>

<h3 id="label-Defining+backward+compatible+macros+for+keyword+argument+functions">Defining backward compatible macros for keyword argument functions</h3>

<p>Most ruby C extensions are designed to support multiple Ruby versions. In order to correctly support Ruby 2.7+ in regards to keyword argument separation, C extensions need to use <code>*_kw</code> functions.  However, these functions do not exist in Ruby 2.6 and below, so in those cases macros should be defined to allow you to use the same code on multiple Ruby versions.  Here are example macros you can use in extensions that support Ruby 2.6 (or below) when using the <code>*_kw</code> functions introduced in Ruby 2.7.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'>#ifndef RB_PASS_KEYWORDS
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* Only define macros on Ruby &lt;2.7 *</span><span class='regexp_end'>/</span></span>
<span class='comment'>#define rb_funcallv_kw(o, m, c, v, kw) rb_funcallv(o, m, c, v)
</span><span class='comment'>#define rb_funcallv_public_kw(o, m, c, v, kw) rb_funcallv_public(o, m, c, v)
</span><span class='comment'>#define rb_funcall_passing_block_kw(o, m, c, v, kw) rb_funcall_passing_block(o, m, c, v)
</span><span class='comment'>#define rb_funcall_with_block_kw(o, m, c, v, b, kw) rb_funcall_with_block(o, m, c, v, b)
</span><span class='comment'>#define rb_scan_args_kw(kw, c, v, s, ...) rb_scan_args(c, v, s, __VA_ARGS__)
</span><span class='comment'>#define rb_call_super_kw(c, v, kw) rb_call_super(c, v)
</span><span class='comment'>#define rb_yield_values_kw(c, v, kw) rb_yield_values2(c, v)
</span><span class='comment'>#define rb_yield_splat_kw(a, kw) rb_yield_splat(a)
</span><span class='comment'>#define rb_block_call_kw(o, m, c, v, f, p, kw) rb_block_call(o, m, c, v, f, p)
</span><span class='comment'>#define rb_fiber_resume_kw(o, c, v, kw) rb_fiber_resume(o, c, v)
</span><span class='comment'>#define rb_fiber_yield_kw(c, v, kw) rb_fiber_yield(c, v)
</span><span class='comment'>#define rb_enumeratorize_with_size_kw(o, m, c, v, f, kw) rb_enumeratorize_with_size(o, m, c, v, f)
</span><span class='comment'>#define SIZED_ENUMERATOR_KW(obj, argc, argv, size_fn, kw_splat) \
</span>    <span class='id identifier rubyid_rb_enumeratorize_with_size'>rb_enumeratorize_with_size</span>((<span class='id identifier rubyid_obj'>obj</span>)<span class='comma'>,</span> <span class='const'>ID2SYM</span>(<span class='id identifier rubyid_rb_frame_this_func'>rb_frame_this_func</span>())<span class='comma'>,</span> \
                               (<span class='id identifier rubyid_argc'>argc</span>)<span class='comma'>,</span> (<span class='id identifier rubyid_argv'>argv</span>)<span class='comma'>,</span> (<span class='id identifier rubyid_size_fn'>size_fn</span>))
<span class='comment'>#define RETURN_SIZED_ENUMERATOR_KW(obj, argc, argv, size_fn, kw_splat) do { \
</span>        <span class='kw'>if</span> (<span class='op'>!</span><span class='id identifier rubyid_rb_block_given_p'>rb_block_given_p</span>())                                            \
            <span class='kw'>return</span> <span class='const'>SIZED_ENUMERATOR</span>(<span class='id identifier rubyid_obj'>obj</span><span class='comma'>,</span> <span class='id identifier rubyid_argc'>argc</span><span class='comma'>,</span> <span class='id identifier rubyid_argv'>argv</span><span class='comma'>,</span> <span class='id identifier rubyid_size_fn'>size_fn</span>)<span class='semicolon'>;</span>              \
    <span class='embexpr_end'>}</span> <span class='kw'>while</span> (<span class='int'>0</span>)
<span class='comment'>#define RETURN_ENUMERATOR_KW(obj, argc, argv, kw_splat) RETURN_SIZED_ENUMERATOR(obj, argc, argv, 0)
</span><span class='comment'>#define rb_check_funcall_kw(o, m, c, v, kw) rb_check_funcall(o, m, c, v)
</span><span class='comment'>#define rb_obj_call_init_kw(o, c, v, kw) rb_obj_call_init(o, c, v)
</span><span class='comment'>#define rb_class_new_instance_kw(c, v, k, kw) rb_class_new_instance(c, v, k)
</span><span class='comment'>#define rb_proc_call_kw(p, a, kw) rb_proc_call(p, a)
</span><span class='comment'>#define rb_proc_call_with_block_kw(p, c, v, b, kw) rb_proc_call_with_block(p, c, v, b)
</span><span class='comment'>#define rb_method_call_kw(c, v, m, kw) rb_method_call(c, v, m)
</span><span class='comment'>#define rb_method_call_with_block_kw(c, v, m, b, kw) rb_method_call_with_block(c, v, m, b)
</span><span class='comment'>#define rb_eval_cmd_kwd(c, a, kw) rb_eval_cmd(c, a, 0)
</span><span class='comment'>#endif</span></code></pre>

<h2 id="label-Appendix+C.+Functions+available+for+use+in+extconf.rb">Appendix C. Functions available for use in extconf.rb</h2>

<p>See documentation for <a href="file.MakeMakefile.html">mkmf</a>.</p>

<h2 id="label-Appendix+D.+Generational+GC">Appendix D. Generational GC</h2>

<p>Ruby 2.1 introduced a generational garbage collector (called RGenGC). RGenGC (mostly) keeps compatibility.</p>

<p>Generally, the use of the technique called write barriers is required in extension libraries for generational GC (<a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29">en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29</a>). RGenGC works fine without write barriers in extension libraries.</p>

<p>If your library adheres to the following tips, performance can be further improved. Especially, the “Don’t touch pointers directly” section is important.</p>

<h3 id="label-Incompatibility">Incompatibility</h3>

<p>You can’t write RBASIC(obj)-&gt;klass field directly because it is const value now.</p>

<p>Basically you should not write this field because MRI expects it to be an immutable field, but if you want to do it in your extension you can use the following functions:</p>
<dl class="rdoc-list note-list"><dt>VALUE rb_obj_hide(VALUE obj) 
<dd>
<p>Clear RBasic::klass field. The object will be an internal object. ObjectSpace::each_object can’t find this object.</p>
</dd><dt>VALUE rb_obj_reveal(VALUE obj, VALUE klass) 
<dd>
<p>Reset RBasic::klass to be klass. We expect the ‘klass’ is hidden class by rb_obj_hide().</p>
</dd></dl>

<h3 id="label-Write+barriers">Write barriers</h3>

<p>RGenGC doesn’t require write barriers to support generational GC. However, caring about write barrier can improve the performance of RGenGC. Please check the following tips.</p>

<h4 id="label-Don-27t+touch+pointers+directly">Don’t touch pointers directly</h4>

<p>In MRI (include/ruby/ruby.h), some macros to acquire pointers to the internal data structures are supported such as RARRAY_PTR(), RSTRUCT_PTR() and so on.</p>

<p>DO NOT USE THESE MACROS and instead use the corresponding C-APIs such as rb_ary_aref(), rb_ary_store() and so on.</p>

<h4 id="label-Consider+whether+to+insert+write+barriers">Consider whether to insert write barriers</h4>

<p>You don’t need to care about write barriers if you only use built-in types.</p>

<p>If you support T_DATA objects, you may consider using write barriers.</p>

<p>Inserting write barriers into T_DATA objects only works with the following type objects: (a) long-lived objects, (b) when a huge number of objects are generated and (c) container-type objects that have references to other objects. If your extension provides such a type of T_DATA objects, consider inserting write barriers.</p>

<p>(a): short-lived objects don’t become old generation objects. (b): only a few oldgen objects don’t have performance impact. (c): only a few references don’t have performance impact.</p>

<p>Inserting write barriers is a very difficult hack, it is easy to introduce critical bugs. And inserting write barriers has several areas of overhead. Basically we don’t recommend you insert write barriers. Please carefully consider the risks.</p>

<h4 id="label-Combine+with+built-in+types">Combine with built-in types</h4>

<p>Please consider utilizing built-in types. Most built-in types support write barrier, so you can use them to avoid manually inserting write barriers.</p>

<p>For example, if your T_DATA has references to other objects, then you can move these references to Array. A T_DATA object only has a reference to an array object. Or you can also use a Struct object to gather a T_DATA object (without any references) and an that Array contains references.</p>

<p>With use of such techniques, you don’t need to insert write barriers anymore.</p>

<h4 id="label-Insert+write+barriers">Insert write barriers</h4>

<p>[AGAIN] Inserting write barriers is a very difficult hack, and it is easy to introduce critical bugs. And inserting write barriers has several areas of overhead. Basically we don’t recommend you insert write barriers. Please carefully consider the risks.</p>

<p>Before inserting write barriers, you need to know about RGenGC algorithm (gc.c will help you). Macros and functions to insert write barriers are available in include/ruby/ruby.h. An example is available in iseq.c.</p>

<p>For a complete guide for RGenGC and write barriers, please refer to &lt;<a href="https://bugs.ruby-lang.org/projects/ruby-master/wiki/RGenGC">bugs.ruby-lang.org/projects/ruby-master/wiki/RGenGC</a>&gt;.</p>

<h2 id="label-Appendix+E.+RB_GC_GUARD+to+protect+from+premature+GC">Appendix E. RB_GC_GUARD to protect from premature GC</h2>

<p>C Ruby currently uses conservative garbage collection, thus VALUE variables must remain visible on the stack or registers to ensure any associated data remains usable.  Optimizing C compilers are not designed with conservative garbage collection in mind, so they may optimize away the original VALUE even if the code depends on data associated with that VALUE.</p>

<p>The following example illustrates the use of RB_GC_GUARD to ensure the contents of sptr remain valid while the second invocation of rb_str_new_cstr is running.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_s'>s</span><span class='comma'>,</span> <span class='id identifier rubyid_w'>w</span><span class='semicolon'>;</span>
<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_sptr'>sptr</span><span class='semicolon'>;</span>

<span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='id identifier rubyid_rb_str_new_cstr'>rb_str_new_cstr</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hello world!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><span class='tstring_end'>&quot;</span></span>)<span class='semicolon'>;</span>
<span class='id identifier rubyid_sptr'>sptr</span> <span class='op'>=</span> <span class='const'>RSTRING_PTR</span>(<span class='id identifier rubyid_s'>s</span>)<span class='semicolon'>;</span>
<span class='id identifier rubyid_w'>w</span> <span class='op'>=</span> <span class='id identifier rubyid_rb_str_new_cstr'>rb_str_new_cstr</span>(<span class='id identifier rubyid_sptr'>sptr</span> <span class='op'>+</span> <span class='int'>6</span>)<span class='semicolon'>;</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* Possible GC invocation *</span><span class='regexp_end'>/</span></span>

<span class='const'>RB_GC_GUARD</span>(<span class='id identifier rubyid_s'>s</span>)<span class='semicolon'>;</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>* ensure s (and thus sptr) do not get GC-ed *</span><span class='regexp_end'>/</span></span></code></pre>

<p>In the above example, RB_GC_GUARD must be placed <em>after</em> the last use of sptr.  Placing RB_GC_GUARD before dereferencing sptr would be of no use. RB_GC_GUARD is only effective on the VALUE data type, not converted C data types.</p>

<p>RB_GC_GUARD would not be necessary at all in the above example if non-inlined function calls are made on the ‘s’ VALUE after sptr is dereferenced.  Thus, in the above example, calling any un-inlined function on ‘s’ such as:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_rb_str_modify'>rb_str_modify</span>(<span class='id identifier rubyid_s'>s</span>)<span class='semicolon'>;</span></code></pre>

<p>Will ensure ‘s’ stays on the stack or register to prevent a GC invocation from prematurely freeing it.</p>

<p>Using the RB_GC_GUARD macro is preferable to using the “volatile” keyword in C.  RB_GC_GUARD has the following advantages:</p>
<ol><li>
<p>the intent of the macro use is clear</p>
</li><li>
<p>RB_GC_GUARD only affects its call site, “volatile” generates some extra code every time the variable is used, hurting optimization.</p>
</li><li>
<p>“volatile” implementations may be buggy/inconsistent in some compilers and architectures. RB_GC_GUARD is customizable for broken systems/compilers without negatively affecting other systems.</p>
</li></ol>

<h2 id="label-Appendix+F.+Ractor+support">Appendix F. Ractor support</h2>

<p>Ractor(s) are the parallel execution mechanism introduced in Ruby 3.0. All ractors can run in parallel on a different OS thread (using an underlying system provided thread), so the C extension should be thread-safe. A C extension that can run in multiple ractors is called “Ractor-safe”.</p>

<p>Ractor safety around C extensions has the following properties:</p>
<ol><li>
<p>By default, all C extensions are recognized as Ractor-unsafe.</p>
</li><li>
<p>Ractor-unsafe C-methods may only be called from the main Ractor.  If invoked by a non-main Ractor, then a Ractor::UnsafeError is raised.</p>
</li><li>
<p>If an extension desires to be marked as Ractor-safe the extension should call rb_ext_ractor_safe(true) at the Init_ function for the extension, and all defined methods will be marked as Ractor-safe.</p>
</li></ol>

<p>To make a “Ractor-safe” C extension, we need to check the following points:</p>

<p>(1) Do not share unshareable objects between ractors</p>

<p>For example, C’s global variable can lead sharing an unshareable objects between ractors.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_g_var'>g_var</span><span class='semicolon'>;</span>
<span class='const'>VALUE</span> <span class='id identifier rubyid_set'>set</span>(<span class='const'>VALUE</span> <span class='kw'>self</span><span class='comma'>,</span> <span class='const'>VALUE</span> <span class='id identifier rubyid_v'>v</span>){ <span class='kw'>return</span> <span class='id identifier rubyid_g_var'>g_var</span> <span class='op'>=</span> <span class='id identifier rubyid_v'>v</span><span class='semicolon'>;</span> }
<span class='const'>VALUE</span> <span class='id identifier rubyid_get'>get</span>(<span class='const'>VALUE</span> <span class='kw'>self</span>){ <span class='kw'>return</span> <span class='id identifier rubyid_g_var'>g_var</span><span class='semicolon'>;</span> }</code></pre>

<p>set() and get() pair can share an unshareable objects using g_var, and it is Ractor-unsafe.</p>

<p>Not only using global variables directly, some indirect data structure such as global st_table can share the objects, so please take care.</p>

<p>Note that class and module objects are shareable objects, so you can keep the code “cFoo = rb_define_class(…)” with C’s global variables.</p>

<p>(2) Check the thread-safety of the extension</p>

<p>An extension should be thread-safe. For example, the following code is not thread-safe:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_bool'>bool</span> <span class='id identifier rubyid_g_called'>g_called</span> <span class='op'>=</span> <span class='kw'>false</span><span class='semicolon'>;</span>
<span class='const'>VALUE</span> <span class='id identifier rubyid_call'>call</span>(<span class='const'>VALUE</span> <span class='kw'>self</span>) {
  <span class='kw'>if</span> (<span class='id identifier rubyid_g_called'>g_called</span>) <span class='id identifier rubyid_rb_raise'>rb_raise</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>recursive call is not allowed.</span><span class='tstring_end'>&quot;</span></span>)<span class='semicolon'>;</span>
  <span class='id identifier rubyid_g_called'>g_called</span> <span class='op'>=</span> <span class='kw'>true</span><span class='semicolon'>;</span>
  <span class='const'>VALUE</span> <span class='id identifier rubyid_ret'>ret</span> <span class='op'>=</span> <span class='id identifier rubyid_do_something'>do_something</span>()<span class='semicolon'>;</span>
  <span class='id identifier rubyid_g_called'>g_called</span> <span class='op'>=</span> <span class='kw'>false</span><span class='semicolon'>;</span>
  <span class='kw'>return</span> <span class='id identifier rubyid_ret'>ret</span><span class='semicolon'>;</span>
}</code></pre>

<p>because g_called global variable should be synchronized by other ractor’s threads. To avoid such data-race, some synchronization should be used. Check include/ruby/thread_native.h and include/ruby/atomic.h.</p>

<p>With Ractors, all objects given as method parameters and the receiver (self) are guaranteed to be from the current Ractor or to be shareable. As a consequence, it is easier to make code ractor-safe than to make code generally thread-safe. For example, we don’t need to lock an array object to access the element of it.</p>

<p>(3) Check the thread-safety of any used library</p>

<p>If the extension relies on an external library, such as a function foo() from a library libfoo, the function libfoo foo() should be thread safe.</p>

<p>(4) Make an object shareable</p>

<p>This is not required to make an extension Ractor-safe.</p>

<p>If an extension provides special objects defined by rb_data_type_t, consider these objects can become shareable or not.</p>

<p>RUBY_TYPED_FROZEN_SHAREABLE flag indicates that these objects can be shareable objects if the object is frozen. This means that if the object is frozen, the mutation of wrapped data is not allowed.</p>

<p>(5) Others</p>

<p>There are possibly other points or requirements which must be considered in the making of a Ractor-safe extension.  This document will be extended as they are discovered.</p>

<p>:enddoc: Local variables: :enddoc: fill-column: 70 :enddoc: end:</p>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>