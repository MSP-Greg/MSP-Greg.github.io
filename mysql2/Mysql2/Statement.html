<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: Mysql2::Statement &mdash; Mysql2 master</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Mysql2::Statement",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../'>Mysql2 master</a> &raquo; 
      <a href='../_index.html#alpha_S'>Index (S)</a> &raquo; 
        <a href="../Mysql2.html" title="Mysql2 (module)">Mysql2</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>Statement&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: Mysql2::Statement</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr>
      <td id='t2_inherits' class='box_2'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'><a href="../Object.html" title="Object (class)">Object</a></span>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2 o'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/brianmario/mysql2/blob/master/lib/mysql2/statement.rb#L2'>lib/mysql2/statement.rb</a><span class='defines'>,<br /><a class='repo' href='https://github.com/brianmario/mysql2/blob/master/ext/mysql2/statement.c#L640'>ext/mysql2/statement.c</a></span>
      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 class='h2_sum' id='instance_attribute_summary'>Instance Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature ro'>
      <a href="#closed%3F-instance_method" title="#closed? (instance method)">#<strong>closed?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns wheter or not the statement have been closed.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- instance_attribute_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#_execute-instance_method" title="#execute (instance method)">#<strong>execute</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Executes the current prepared statement, returns <code>result</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#affected_rows-instance_method" title="#affected_rows (instance method)">#<strong>affected_rows</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the number of rows changed, deleted, or inserted.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#close-instance_method" title="#close (instance method)">#<strong>close</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Explicitly closing this will free up server resources immediately rather than waiting for the garbage collector.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#execute-instance_method" title="#execute (instance method)">#<strong>execute</strong>(*args, **kwargs)  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#field_count-instance_method" title="#field_count (instance method)">#<strong>field_count</strong>(#)  &#x21d2; Numeric </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the number of fields the prepared statement returns.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#fields-instance_method" title="#fields (instance method)">#<strong>fields</strong>(#)  &#x21d2; Array </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns a list of fields that will be returned by this statement.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#last_id-instance_method" title="#last_id (instance method)">#<strong>last_id</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the AUTO_INCREMENT value from the executed INSERT or UPDATE.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#param_count-instance_method" title="#param_count (instance method)">#<strong>param_count</strong>(#)  &#x21d2; Numeric </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the number of parameters the prepared statement expects.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- instance_method_summary -->
<h2 class='y_details'>Instance Attribute Details</h2>
<section class='method_details first' id="closed?-instance_method">
  <h3 class='signature ro first'>
    #<strong>closed?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns wheter or not the statement have been closed.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/brianmario/mysql2/blob/master/ext/mysql2/statement.c#L624-L628'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='624' data-end='628'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/mysql2/statement.c', line 624</span></pre>
<pre class='code cpp'>

static VALUE rb_mysql_stmt_closed_p(VALUE self) {
  RAW_GET_STATEMENT(self);

  return stmt_wrapper-&gt;closed ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="_execute-instance_method">
  <h3 class='signature  first'>
    #<strong>execute</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Executes the current prepared statement, returns <code>result</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/brianmario/mysql2/blob/master/ext/mysql2/statement.c#L289-L519'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='289' data-end='519'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/mysql2/statement.c', line 289</span></pre>
<pre class='code cpp'>

static VALUE rb_mysql_stmt_execute(int argc, VALUE *argv, VALUE self) {
  MYSQL_BIND *bind_buffers = NULL;
  unsigned long *length_buffers = NULL;
  unsigned long bind_count;
  unsigned long i;
  MYSQL_STMT *stmt;
  MYSQL_RES *metadata;
  VALUE opts;
  VALUE current;
  VALUE resultObj;
  VALUE *params_enc = NULL;
  int is_streaming;
  rb_encoding *conn_enc;

  GET_STATEMENT(self);
  GET_CLIENT(stmt_wrapper-&gt;client);

  conn_enc = rb_to_encoding(wrapper-&gt;encoding);

  stmt = stmt_wrapper-&gt;stmt;
  bind_count = mysql_stmt_param_count(stmt);

  // Get count of ordinary arguments, and extract hash opts/keyword arguments
  // Use a local scope to avoid leaking the temporary count variable
  {
    int c = rb_scan_args(argc, argv, &quot;*:&quot;, NULL, &amp;opts);
    if (c != (long)bind_count) {
      rb_raise(cMysql2Error, &quot;Bind parameter count (%ld) doesn&#39;t match number of arguments (%d)&quot;, bind_count, c);
    }
  }

  // setup any bind variables in the query
  if (bind_count &gt; 0) {
    // Scratch space for string encoding exports, allocate on the stack
    params_enc = alloca(sizeof(VALUE) * bind_count);
    bind_buffers = xcalloc(bind_count, sizeof(MYSQL_BIND));
    length_buffers = xcalloc(bind_count, sizeof(unsigned long));

    for (i = 0; i &lt; bind_count; i++) {
      bind_buffers[i].buffer = NULL;
      params_enc[i] = Qnil;

      switch (TYPE(argv[i])) {
        case T_NIL:
          bind_buffers[i].buffer_type = MYSQL_TYPE_NULL;
          break;
        case T_FIXNUM:
#if SIZEOF_INT &lt; SIZEOF_LONG
          bind_buffers[i].buffer_type = MYSQL_TYPE_LONGLONG;
          bind_buffers[i].buffer = xmalloc(sizeof(long long int));
          *(long*)(bind_buffers[i].buffer) = FIX2LONG(argv[i]);
#else
          bind_buffers[i].buffer_type = MYSQL_TYPE_LONG;
          bind_buffers[i].buffer = xmalloc(sizeof(int));
          *(long*)(bind_buffers[i].buffer) = FIX2INT(argv[i]);
#endif
          break;
        case T_BIGNUM:
          {
            LONG_LONG num;
            if (my_big2ll(argv[i], &amp;num) == 0) {
              bind_buffers[i].buffer_type = MYSQL_TYPE_LONGLONG;
              bind_buffers[i].buffer = xmalloc(sizeof(long long int));
              *(LONG_LONG*)(bind_buffers[i].buffer) = num;
            } else {
              /* The bignum was larger than we can fit in LONG_LONG, send it as a string */
              bind_buffers[i].buffer_type = MYSQL_TYPE_NEWDECIMAL;
              params_enc[i] = rb_str_export_to_enc(rb_big2str(argv[i], 10), conn_enc);
              set_buffer_for_string(&amp;bind_buffers[i], &amp;length_buffers[i], params_enc[i]);
            }
          }
          break;
        case T_FLOAT:
          bind_buffers[i].buffer_type = MYSQL_TYPE_DOUBLE;
          bind_buffers[i].buffer = xmalloc(sizeof(double));
          *(double*)(bind_buffers[i].buffer) = NUM2DBL(argv[i]);
          break;
        case T_STRING:
          bind_buffers[i].buffer_type = MYSQL_TYPE_STRING;

          params_enc[i] = argv[i];
          params_enc[i] = rb_str_export_to_enc(params_enc[i], conn_enc);
          set_buffer_for_string(&amp;bind_buffers[i], &amp;length_buffers[i], params_enc[i]);
          break;
        case T_TRUE:
          bind_buffers[i].buffer_type = MYSQL_TYPE_TINY;
          bind_buffers[i].buffer = xmalloc(sizeof(signed char));
          *(signed char*)(bind_buffers[i].buffer) = 1;
          break;
        case T_FALSE:
          bind_buffers[i].buffer_type = MYSQL_TYPE_TINY;
          bind_buffers[i].buffer = xmalloc(sizeof(signed char));
          *(signed char*)(bind_buffers[i].buffer) = 0;
          break;
        default:
          // TODO: what Ruby type should support MYSQL_TYPE_TIME
          if (CLASS_OF(argv[i]) == rb_cTime || CLASS_OF(argv[i]) == cDateTime) {
            MYSQL_TIME t;
            VALUE rb_time = argv[i];

            bind_buffers[i].buffer_type = MYSQL_TYPE_DATETIME;
            bind_buffers[i].buffer = xmalloc(sizeof(MYSQL_TIME));

            memset(&amp;t, 0, sizeof(MYSQL_TIME));
            t.neg = 0;

            if (CLASS_OF(argv[i]) == rb_cTime) {
              t.second_part = FIX2INT(rb_funcall(rb_time, intern_usec, 0));
            } else if (CLASS_OF(argv[i]) == cDateTime) {
              t.second_part = NUM2DBL(rb_funcall(rb_time, intern_sec_fraction, 0)) * 1000000;
            }

            t.second = FIX2INT(rb_funcall(rb_time, intern_sec, 0));
            t.minute = FIX2INT(rb_funcall(rb_time, intern_min, 0));
            t.hour = FIX2INT(rb_funcall(rb_time, intern_hour, 0));
            t.day = FIX2INT(rb_funcall(rb_time, intern_day, 0));
            t.month = FIX2INT(rb_funcall(rb_time, intern_month, 0));
            t.year = FIX2INT(rb_funcall(rb_time, intern_year, 0));

            *(MYSQL_TIME*)(bind_buffers[i].buffer) = t;
          } else if (CLASS_OF(argv[i]) == cDate) {
            MYSQL_TIME t;
            VALUE rb_time = argv[i];

            bind_buffers[i].buffer_type = MYSQL_TYPE_DATE;
            bind_buffers[i].buffer = xmalloc(sizeof(MYSQL_TIME));

            memset(&amp;t, 0, sizeof(MYSQL_TIME));
            t.second_part = 0;
            t.neg = 0;
            t.day = FIX2INT(rb_funcall(rb_time, intern_day, 0));
            t.month = FIX2INT(rb_funcall(rb_time, intern_month, 0));
            t.year = FIX2INT(rb_funcall(rb_time, intern_year, 0));

            *(MYSQL_TIME*)(bind_buffers[i].buffer) = t;
          } else if (CLASS_OF(argv[i]) == cBigDecimal) {
            bind_buffers[i].buffer_type = MYSQL_TYPE_NEWDECIMAL;

            // DECIMAL are represented with the &quot;string representation of the
            // original server-side value&quot;, see
            // https://dev.mysql.com/doc/refman/5.7/en/c-api-prepared-statement-type-conversions.html
            // This should be independent of the locale used both on the server
            // and the client side.
            VALUE rb_val_as_string = rb_funcall(argv[i], intern_to_s, 0);

            params_enc[i] = rb_val_as_string;
            params_enc[i] = rb_str_export_to_enc(params_enc[i], conn_enc);
            set_buffer_for_string(&amp;bind_buffers[i], &amp;length_buffers[i], params_enc[i]);
          }
          break;
      }
    }

    // copies bind_buffers into internal storage
    if (mysql_stmt_bind_param(stmt, bind_buffers)) {
      FREE_BINDS;
      rb_raise_mysql2_stmt_error(stmt_wrapper);
    }
  }

  // Duplicate the options hash, merge! extra opts, put the copy into the Result object
  current = rb_hash_dup(rb_ivar_get(stmt_wrapper-&gt;client, intern_query_options));
  (void)RB_GC_GUARD(current);
  Check_Type(current, T_HASH);

  // Merge in hash opts/keyword arguments
  if (!NIL_P(opts)) {
    rb_funcall(current, intern_merge_bang, 1, opts);
  }

  is_streaming = (Qtrue == rb_hash_aref(current, sym_stream));

  // From stmt_execute to mysql_stmt_result_metadata to stmt_store_result, no
  // Ruby API calls are allowed so that GC is not invoked. If the connection is
  // in results-streaming-mode for Statement A, and in the middle Statement B
  // gets garbage collected, a message will be sent to the server notifying it
  // to release Statement B, resulting in the following error:
  //   Commands out of sync; you can&#39;t run this command now
  //
  // In streaming mode, statement execute must return a cursor because we
  // cannot prevent other Statement objects from being garbage collected
  // between fetches of each row of the result set. The following error
  // occurs if cursor mode is not set:
  //   Row retrieval was canceled by mysql_stmt_close

  if (is_streaming) {
    unsigned long type = CURSOR_TYPE_READ_ONLY;
    if (mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, &amp;type)) {
      FREE_BINDS;
      rb_raise(cMysql2Error, &quot;Unable to stream prepared statement, could not set CURSOR_TYPE_READ_ONLY&quot;);
    }
  }

  if ((VALUE)rb_thread_call_without_gvl(nogvl_stmt_execute, stmt, RUBY_UBF_IO, 0) == Qfalse) {
    FREE_BINDS;
    rb_raise_mysql2_stmt_error(stmt_wrapper);
  }

  FREE_BINDS;

  metadata = mysql_stmt_result_metadata(stmt);
  if (metadata == NULL) {
    if (mysql_stmt_errno(stmt) != 0) {
      // either CR_OUT_OF_MEMORY or CR_UNKNOWN_ERROR. both fatal.
      wrapper-&gt;active_fiber = Qnil;
      rb_raise_mysql2_stmt_error(stmt_wrapper);
    }
    // no data and no error, so query was not a SELECT
    return Qnil;
  }

  if (!is_streaming) {
    // receive the whole result set from the server
    if (mysql_stmt_store_result(stmt)) {
      mysql_free_result(metadata);
      rb_raise_mysql2_stmt_error(stmt_wrapper);
    }
    wrapper-&gt;active_fiber = Qnil;
  }

  resultObj = rb_mysql_result_to_obj(stmt_wrapper-&gt;client, wrapper-&gt;encoding, current, metadata, self);

  rb_mysql_set_server_query_flags(wrapper-&gt;client, resultObj);

  if (!is_streaming) {
    // cache all result
    rb_funcall(resultObj, intern_each, 0);
  }

  return resultObj;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="affected_rows-instance_method">
  <h3 class='signature '>
    #<strong>affected_rows</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the number of rows changed, deleted, or inserted.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/brianmario/mysql2/blob/master/ext/mysql2/statement.c#L589-L599'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='589' data-end='599'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/mysql2/statement.c', line 589</span></pre>
<pre class='code cpp'>

static VALUE rb_mysql_stmt_affected_rows(VALUE self) {
  my_ulonglong affected;
  GET_STATEMENT(self);

  affected = mysql_stmt_affected_rows(stmt_wrapper-&gt;stmt);
  if (affected == (my_ulonglong)-1) {
    rb_raise_mysql2_stmt_error(stmt_wrapper);
  }

  return ULL2NUM(affected);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="close-instance_method">
  <h3 class='signature '>
    #<strong>close</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Explicitly closing this will free up server resources immediately rather than waiting for the garbage collector. Useful if you’re managing your own prepared statement cache.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/brianmario/mysql2/blob/master/ext/mysql2/statement.c#L608-L617'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='608' data-end='617'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/mysql2/statement.c', line 608</span></pre>
<pre class='code cpp'>

static VALUE rb_mysql_stmt_close(VALUE self) {
  RAW_GET_STATEMENT(self);

  if (!stmt_wrapper-&gt;closed) {
      stmt_wrapper-&gt;closed = 1;
      rb_thread_call_without_gvl(nogvl_stmt_close, stmt_wrapper, RUBY_UBF_IO, 0);
  }

  return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="execute-instance_method">
  <h3 class='signature '>
    #<strong>execute</strong>(*args, **kwargs)  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/brianmario/mysql2/blob/master/lib/mysql2/statement.rb#L3-L7'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3' data-end='7'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/mysql2/statement.rb', line 3</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_execute'>execute</span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_kwargs'>kwargs</span>)
  <span class='const'>Thread</span>.<span class='id identifier rubyid_handle_interrupt'>handle_interrupt</span>(<span class='op'>::</span><span class='const'><a href="../Mysql2.html" title="Mysql2 (module)">Mysql2</a></span><span class='op'>::</span><span class='const'><a href="Util.html" title="Mysql2::Util (module)">Util</a></span><span class='op'>::</span><span class='const'><a href="Util.html#TIMEOUT_ERROR_NEVER-constant" title="Mysql2::Util::TIMEOUT_ERROR_NEVER (constant)">TIMEOUT_ERROR_NEVER</a></span>) <span class='kw'>do</span>
    <span class='id identifier rubyid__execute'><a href="#_execute-instance_method" title="Mysql2::Statement#_execute (method)">_execute</a></span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_kwargs'>kwargs</span>)
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="field_count-instance_method">
  <h3 class='signature '>
    #<strong>field_count</strong>(#)  &#x21d2; <code>Numeric</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the number of fields the prepared statement returns.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/brianmario/mysql2/blob/master/ext/mysql2/statement.c#L198-L202'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='198' data-end='202'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/mysql2/statement.c', line 198</span></pre>
<pre class='code cpp'>

static VALUE rb_mysql_stmt_field_count(VALUE self) {
  GET_STATEMENT(self);

  return UINT2NUM(mysql_stmt_field_count(stmt_wrapper-&gt;stmt));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="fields-instance_method">
  <h3 class='signature '>
    #<strong>fields</strong>(#)  &#x21d2; <code>Array</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns a list of fields that will be returned by this statement.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/brianmario/mysql2/blob/master/ext/mysql2/statement.c#L525-L572'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='525' data-end='572'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/mysql2/statement.c', line 525</span></pre>
<pre class='code cpp'>

static VALUE rb_mysql_stmt_fields(VALUE self) {
  MYSQL_FIELD *fields;
  MYSQL_RES *metadata;
  unsigned int field_count;
  unsigned int i;
  VALUE field_list;
  MYSQL_STMT* stmt;
  rb_encoding *default_internal_enc, *conn_enc;
  GET_STATEMENT(self);
  GET_CLIENT(stmt_wrapper-&gt;client);
  stmt = stmt_wrapper-&gt;stmt;

  default_internal_enc = rb_default_internal_encoding();
  {
    GET_CLIENT(stmt_wrapper-&gt;client);
    conn_enc = rb_to_encoding(wrapper-&gt;encoding);
  }

  metadata = mysql_stmt_result_metadata(stmt);
  if (metadata == NULL) {
    if (mysql_stmt_errno(stmt) != 0) {
      // either CR_OUT_OF_MEMORY or CR_UNKNOWN_ERROR. both fatal.
      wrapper-&gt;active_fiber = Qnil;
      rb_raise_mysql2_stmt_error(stmt_wrapper);
    }
    // no data and no error, so query was not a SELECT
    return Qnil;
  }

  fields      = mysql_fetch_fields(metadata);
  field_count = mysql_stmt_field_count(stmt);
  field_list  = rb_ary_new2((long)field_count);

  for (i = 0; i &lt; field_count; i++) {
    VALUE rb_field;

    rb_field = rb_str_new(fields[i].name, fields[i].name_length);
    rb_enc_associate(rb_field, conn_enc);
    if (default_internal_enc) {
     rb_field = rb_str_export_to_enc(rb_field, default_internal_enc);
   }

    rb_ary_store(field_list, (long)i, rb_field);
  }

  mysql_free_result(metadata);
  return field_list;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="last_id-instance_method">
  <h3 class='signature '>
    #<strong>last_id</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the AUTO_INCREMENT value from the executed INSERT or UPDATE.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/brianmario/mysql2/blob/master/ext/mysql2/statement.c#L579-L582'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='579' data-end='582'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/mysql2/statement.c', line 579</span></pre>
<pre class='code cpp'>

static VALUE rb_mysql_stmt_last_id(VALUE self) {
  GET_STATEMENT(self);
  return ULL2NUM(mysql_stmt_insert_id(stmt_wrapper-&gt;stmt));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="param_count-instance_method">
  <h3 class='signature '>
    #<strong>param_count</strong>(#)  &#x21d2; <code>Numeric</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the number of parameters the prepared statement expects.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/brianmario/mysql2/blob/master/ext/mysql2/statement.c#L188-L192'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='188' data-end='192'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/mysql2/statement.c', line 188</span></pre>
<pre class='code cpp'>

static VALUE rb_mysql_stmt_param_count(VALUE self) {
  GET_STATEMENT(self);

  return ULL2NUM(mysql_stmt_param_count(stmt_wrapper-&gt;stmt));
}
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>