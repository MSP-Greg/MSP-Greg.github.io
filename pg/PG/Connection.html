<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: PG::Connection &mdash; PG master</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "PG::Connection",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../'>PG master</a> &raquo; 
      <a href='../_index.html#alpha_C'>Index (C)</a> &raquo; 
        <a href="../PG.html" title="PG (module)">PG</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>Connection&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: PG::Connection</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Super Chains via Extension / Inclusion / Inheritance</td></tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Instance Chain:</div>
        <div class='box_22'>
          self,
          <a href="Constants.html" title="PG::Constants (module)"><code>Constants</code></a>
        </div>
      </td>
    </tr>
    <tr>
      <td id='t2_inherits' class='box_2'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'><a href="../Object.html" title="Object (class)">Object</a></span>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2 o'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L30'>lib/pg/connection.rb</a><span class='defines'>,<br /><a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4473'>ext/pg_connection.c</a></span>
      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p>The PostgreSQL connection class. The interface for this class is based on <a href="http://www.postgresql.org/docs/current/libpq.html" target="_parent" title="libpq">libpq</a>, the C application programmer’s interface to PostgreSQL. Some familiarity with libpq is recommended, but not necessary.</p>

<p>For example, to send query to the database on the localhost:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>pg</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_conn'>conn</span> <span class='op'>=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'>Connection</span>.<span class='id identifier rubyid_open'><a href="#open-class_method" title="PG::Connection.open (method)">open</a></span>(<span class='symbeg'>:</span><span class='id identifier rubyid_dbname'>dbname</span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_res'>res</span> <span class='op'>=</span> <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_exec_params'><a href="#exec_params-instance_method" title="PG::Connection#exec_params (method)">exec_params</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>SELECT $1 AS a, $2 AS b, $3 AS c</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='kw'>nil</span>])
<span class='comment'># Equivalent to:
</span><span class='comment'>#  res  = conn.exec(&#39;SELECT 1 AS a, 2 AS b, NULL AS c&#39;)</span></code></pre>

<p>See the <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> class for information on working with the results of a query.</p>

<p>Many methods of this class have three variants kind of:</p>
<ol><li>
<p><a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a> - the base method which is an alias to <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> . This is the method that should be used in general.</p>
</li><li>
<p><a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> - the async aware version of the method, implemented by libpq’s async API.</p>
</li><li>
<p><a href="#sync_exec-instance_method" title="PG::Connection#sync_exec (method)">#sync_exec</a> - the method version that is implemented by blocking function(s) of libpq.</p>
</li></ol>

<p>Sync and async version of the method can be switched by <a href="#async_api=-class_method" title="PG::Connection.async_api= (method)">.async_api=</a> , however it is not recommended to change the default.</p>

  </div>
</div>
</div>
<h2 id='t2_cnst' class='h2_sum'>Constant Summary</h2>
<div>
<ul class='constants summary full'>
  <li>
    <span id='BinarySignature-constant' class='summary_signature priv'>BinarySignature =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L120-L120'># File 'lib/pg/connection.rb', line 120</a>    <pre class='code ruby'><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>PGCOPY\n\377\r\n\0</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_b'>b</span></pre>
  </li>
  <li>
    <span id='CONNECT_ARGUMENT_ORDER-constant' class='summary_signature priv'>CONNECT_ARGUMENT_ORDER =</span>
    <span class='note title private'>private</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>The order the options are passed to the <a href="#connect-class_method" title="PG::Connection.connect (method)">.connect</a> method.</p>

  </div>
</div>
    <a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L33-L33'># File 'lib/pg/connection.rb', line 33</a>    <pre class='code ruby'><span class='qwords'><span class='qwords_beg'>%w[</span><span class='tstring_content'>host</span><span class='words_sep'> </span><span class='tstring_content'>port</span><span class='words_sep'> </span><span class='tstring_content'>options</span><span class='words_sep'> </span><span class='tstring_content'>tty</span><span class='words_sep'> </span><span class='tstring_content'>dbname</span><span class='words_sep'> </span><span class='tstring_content'>user</span><span class='words_sep'> </span><span class='tstring_content'>password</span><span class='tstring_end'>]</span></span>.<span class='id identifier rubyid_freeze'>freeze</span></pre>
  </li>
  <li>
    <span id='PROGRAM_NAME-constant' class='summary_signature priv'>PROGRAM_NAME =</span>
    <span class='note title private'>private</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>Shareable program name for Ractor</p>

  </div>
</div>
    <a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L49-L49'># File 'lib/pg/connection.rb', line 49</a>    <pre class='code ruby'><span class='gvar'>$PROGRAM_NAME</span>.<span class='id identifier rubyid_dup'>dup</span>.<span class='id identifier rubyid_freeze'>freeze</span></pre>
  </li>
  <li>
    <span id='REDIRECT_CLASS_METHODS-constant' class='summary_signature priv'>REDIRECT_CLASS_METHODS =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L878-L885'># File 'lib/pg/connection.rb', line 878</a>    <pre class='code ruby'><span class='const'><a href="../PG.html" title="PG (module)">PG</a></span>.<span class='id identifier rubyid_make_shareable'><a href="../PG.html#make_shareable-class_method" title="PG.make_shareable (method)">make_shareable</a></span>({
	<span class='symbeg'>:</span><span class='id identifier rubyid_new'><a href="#new-class_method" title="PG::Connection.new (method)">new</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_connect'><a href="#async_connect-class_method" title="PG::Connection.async_connect (method)">async_connect</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_connect'><a href="#sync_connect-class_method" title="PG::Connection.sync_connect (method)">sync_connect</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_connect'><a href="#connect-class_method" title="PG::Connection.connect (method)">connect</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_connect'><a href="#async_connect-class_method" title="PG::Connection.async_connect (method)">async_connect</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_connect'><a href="#sync_connect-class_method" title="PG::Connection.sync_connect (method)">sync_connect</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_open'><a href="#open-class_method" title="PG::Connection.open (method)">open</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_connect'><a href="#async_connect-class_method" title="PG::Connection.async_connect (method)">async_connect</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_connect'><a href="#sync_connect-class_method" title="PG::Connection.sync_connect (method)">sync_connect</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_setdb'><a href="#setdb-class_method" title="PG::Connection.setdb (method)">setdb</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_connect'><a href="#async_connect-class_method" title="PG::Connection.async_connect (method)">async_connect</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_connect'><a href="#sync_connect-class_method" title="PG::Connection.sync_connect (method)">sync_connect</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_setdblogin'><a href="#setdblogin-class_method" title="PG::Connection.setdblogin (method)">setdblogin</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_connect'><a href="#async_connect-class_method" title="PG::Connection.async_connect (method)">async_connect</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_connect'><a href="#sync_connect-class_method" title="PG::Connection.sync_connect (method)">sync_connect</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_ping'><a href="#ping-class_method" title="PG::Connection.ping (method)">ping</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_ping'><a href="#async_ping-class_method" title="PG::Connection.async_ping (method)">async_ping</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_ping'><a href="#sync_ping-class_method" title="PG::Connection.sync_ping (method)">sync_ping</a></span>]<span class='comma'>,</span>
})</pre>
  </li>
  <li>
    <span id='REDIRECT_METHODS-constant' class='summary_signature priv'>REDIRECT_METHODS =</span>
    <span class='note title private'>private</span>
    <br/>
    <a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L897-L913'># File 'lib/pg/connection.rb', line 897</a>    <pre class='code ruby'>{
	<span class='symbeg'>:</span><span class='id identifier rubyid_exec'><a href="#exec-instance_method" title="PG::Connection#exec (method)">exec</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_exec'><a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">async_exec</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_exec'><a href="#sync_exec-instance_method" title="PG::Connection#sync_exec (method)">sync_exec</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_query'>query</span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_exec'><a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">async_exec</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_exec'><a href="#sync_exec-instance_method" title="PG::Connection#sync_exec (method)">sync_exec</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_exec_params'><a href="#exec_params-instance_method" title="PG::Connection#exec_params (method)">exec_params</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_exec_params'><a href="#async_exec_params-instance_method" title="PG::Connection#async_exec_params (method)">async_exec_params</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_exec_params'><a href="#sync_exec_params-instance_method" title="PG::Connection#sync_exec_params (method)">sync_exec_params</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_prepare'><a href="#prepare-instance_method" title="PG::Connection#prepare (method)">prepare</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_prepare'><a href="#async_prepare-instance_method" title="PG::Connection#async_prepare (method)">async_prepare</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_prepare'><a href="#sync_prepare-instance_method" title="PG::Connection#sync_prepare (method)">sync_prepare</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_exec_prepared'><a href="#exec_prepared-instance_method" title="PG::Connection#exec_prepared (method)">exec_prepared</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_exec_prepared'><a href="#async_exec_prepared-instance_method" title="PG::Connection#async_exec_prepared (method)">async_exec_prepared</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_exec_prepared'><a href="#sync_exec_prepared-instance_method" title="PG::Connection#sync_exec_prepared (method)">sync_exec_prepared</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_describe_portal'><a href="#describe_portal-instance_method" title="PG::Connection#describe_portal (method)">describe_portal</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_describe_portal'><a href="#async_describe_portal-instance_method" title="PG::Connection#async_describe_portal (method)">async_describe_portal</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_describe_portal'><a href="#sync_describe_portal-instance_method" title="PG::Connection#sync_describe_portal (method)">sync_describe_portal</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_describe_prepared'><a href="#describe_prepared-instance_method" title="PG::Connection#describe_prepared (method)">describe_prepared</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_describe_prepared'><a href="#async_describe_prepared-instance_method" title="PG::Connection#async_describe_prepared (method)">async_describe_prepared</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_describe_prepared'><a href="#sync_describe_prepared-instance_method" title="PG::Connection#sync_describe_prepared (method)">sync_describe_prepared</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_setnonblocking'><a href="#setnonblocking-instance_method" title="PG::Connection#setnonblocking (method)">setnonblocking</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_setnonblocking'><a href="#async_setnonblocking-instance_method" title="PG::Connection#async_setnonblocking (method)">async_setnonblocking</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_setnonblocking'><a href="#sync_setnonblocking-instance_method" title="PG::Connection#sync_setnonblocking (method)">sync_setnonblocking</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_get_result'><a href="#get_result-instance_method" title="PG::Connection#get_result (method)">get_result</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_get_result'><a href="#async_get_result-instance_method" title="PG::Connection#async_get_result (method)">async_get_result</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_get_result'><a href="#sync_get_result-instance_method" title="PG::Connection#sync_get_result (method)">sync_get_result</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_get_last_result'><a href="#get_last_result-instance_method" title="PG::Connection#get_last_result (method)">get_last_result</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_get_last_result'><a href="#async_get_last_result-instance_method" title="PG::Connection#async_get_last_result (method)">async_get_last_result</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_get_last_result'><a href="#sync_get_last_result-instance_method" title="PG::Connection#sync_get_last_result (method)">sync_get_last_result</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_get_copy_data'><a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">get_copy_data</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_get_copy_data'><a href="#async_get_copy_data-instance_method" title="PG::Connection#async_get_copy_data (method)">async_get_copy_data</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_get_copy_data'><a href="#sync_get_copy_data-instance_method" title="PG::Connection#sync_get_copy_data (method)">sync_get_copy_data</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_reset'><a href="#reset-instance_method" title="PG::Connection#reset (method)">reset</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_reset'><a href="#async_reset-instance_method" title="PG::Connection#async_reset (method)">async_reset</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_reset'><a href="#sync_reset-instance_method" title="PG::Connection#sync_reset (method)">sync_reset</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_set_client_encoding'><a href="#set_client_encoding-instance_method" title="PG::Connection#set_client_encoding (method)">set_client_encoding</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_set_client_encoding'><a href="#async_set_client_encoding-instance_method" title="PG::Connection#async_set_client_encoding (method)">async_set_client_encoding</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_set_client_encoding'><a href="#sync_set_client_encoding-instance_method" title="PG::Connection#sync_set_client_encoding (method)">sync_set_client_encoding</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_client_encoding='><a href="#client_encoding=-instance_method" title="PG::Connection#client_encoding= (method)">client_encoding=</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_set_client_encoding'><a href="#async_set_client_encoding-instance_method" title="PG::Connection#async_set_client_encoding (method)">async_set_client_encoding</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_set_client_encoding'><a href="#sync_set_client_encoding-instance_method" title="PG::Connection#sync_set_client_encoding (method)">sync_set_client_encoding</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_cancel'><a href="#cancel-instance_method" title="PG::Connection#cancel (method)">cancel</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_cancel'><a href="#async_cancel-instance_method" title="PG::Connection#async_cancel (method)">async_cancel</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_cancel'><a href="#sync_cancel-instance_method" title="PG::Connection#sync_cancel (method)">sync_cancel</a></span>]<span class='comma'>,</span>
}</pre>
  </li>
  <li>
    <span id='REDIRECT_SEND_METHODS-constant' class='summary_signature priv'>REDIRECT_SEND_METHODS =</span>
    <span class='note title private'>private</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>These methods are affected by PQsetnonblocking</p>

  </div>
</div>
    <a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L889-L895'># File 'lib/pg/connection.rb', line 889</a>    <pre class='code ruby'><span class='const'><a href="../PG.html" title="PG (module)">PG</a></span>.<span class='id identifier rubyid_make_shareable'><a href="../PG.html#make_shareable-class_method" title="PG.make_shareable (method)">make_shareable</a></span>({
	<span class='symbeg'>:</span><span class='id identifier rubyid_isnonblocking'><a href="#isnonblocking-instance_method" title="PG::Connection#isnonblocking (method)">isnonblocking</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_isnonblocking'><a href="#async_isnonblocking-instance_method" title="PG::Connection#async_isnonblocking (method)">async_isnonblocking</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_isnonblocking'><a href="#sync_isnonblocking-instance_method" title="PG::Connection#sync_isnonblocking (method)">sync_isnonblocking</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_nonblocking?'><a href="#nonblocking%3F-instance_method" title="PG::Connection#nonblocking? (method)">nonblocking?</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_isnonblocking'><a href="#async_isnonblocking-instance_method" title="PG::Connection#async_isnonblocking (method)">async_isnonblocking</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_isnonblocking'><a href="#sync_isnonblocking-instance_method" title="PG::Connection#sync_isnonblocking (method)">sync_isnonblocking</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_put_copy_data'><a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">put_copy_data</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_put_copy_data'><a href="#async_put_copy_data-instance_method" title="PG::Connection#async_put_copy_data (method)">async_put_copy_data</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_put_copy_data'><a href="#sync_put_copy_data-instance_method" title="PG::Connection#sync_put_copy_data (method)">sync_put_copy_data</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_put_copy_end'><a href="#put_copy_end-instance_method" title="PG::Connection#put_copy_end (method)">put_copy_end</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_put_copy_end'><a href="#async_put_copy_end-instance_method" title="PG::Connection#async_put_copy_end (method)">async_put_copy_end</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_put_copy_end'><a href="#sync_put_copy_end-instance_method" title="PG::Connection#sync_put_copy_end (method)">sync_put_copy_end</a></span>]<span class='comma'>,</span>
	<span class='symbeg'>:</span><span class='id identifier rubyid_flush'><a href="#flush-instance_method" title="PG::Connection#flush (method)">flush</a></span> <span class='op'>=&gt;</span> [<span class='symbeg'>:</span><span class='id identifier rubyid_async_flush'><a href="#async_flush-instance_method" title="PG::Connection#async_flush (method)">async_flush</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_sync_flush'><a href="#sync_flush-instance_method" title="PG::Connection#sync_flush (method)">sync_flush</a></span>]<span class='comma'>,</span>
})</pre>
  </li>
</ul>
  <h3 class='inherited'><a href="Constants.html" title="PG::Constants (module)"><code>Constants</code></a> - Included</h3>
  <p  class='inherited'>
    <a href="Constants.html#CONNECTION_AUTH_OK-constant" title="PG::Constants::CONNECTION_AUTH_OK (constant)">CONNECTION_AUTH_OK</a>, 
    <a href="Constants.html#CONNECTION_AWAITING_RESPONSE-constant" title="PG::Constants::CONNECTION_AWAITING_RESPONSE (constant)">CONNECTION_AWAITING_RESPONSE</a>, 
    <a href="Constants.html#CONNECTION_BAD-constant" title="PG::Constants::CONNECTION_BAD (constant)">CONNECTION_BAD</a>, 
    <a href="Constants.html#CONNECTION_CHECK_STANDBY-constant" title="PG::Constants::CONNECTION_CHECK_STANDBY (constant)">CONNECTION_CHECK_STANDBY</a>, 
    <a href="Constants.html#CONNECTION_CHECK_TARGET-constant" title="PG::Constants::CONNECTION_CHECK_TARGET (constant)">CONNECTION_CHECK_TARGET</a>, 
    <a href="Constants.html#CONNECTION_CHECK_WRITABLE-constant" title="PG::Constants::CONNECTION_CHECK_WRITABLE (constant)">CONNECTION_CHECK_WRITABLE</a>, 
    <a href="Constants.html#CONNECTION_CONSUME-constant" title="PG::Constants::CONNECTION_CONSUME (constant)">CONNECTION_CONSUME</a>, 
    <a href="Constants.html#CONNECTION_GSS_STARTUP-constant" title="PG::Constants::CONNECTION_GSS_STARTUP (constant)">CONNECTION_GSS_STARTUP</a>, 
    <a href="Constants.html#CONNECTION_MADE-constant" title="PG::Constants::CONNECTION_MADE (constant)">CONNECTION_MADE</a>, 
    <a href="Constants.html#CONNECTION_NEEDED-constant" title="PG::Constants::CONNECTION_NEEDED (constant)">CONNECTION_NEEDED</a>, 
    <a href="Constants.html#CONNECTION_OK-constant" title="PG::Constants::CONNECTION_OK (constant)">CONNECTION_OK</a>, 
    <a href="Constants.html#CONNECTION_SETENV-constant" title="PG::Constants::CONNECTION_SETENV (constant)">CONNECTION_SETENV</a>, 
    <a href="Constants.html#CONNECTION_SSL_STARTUP-constant" title="PG::Constants::CONNECTION_SSL_STARTUP (constant)">CONNECTION_SSL_STARTUP</a>, 
    <a href="Constants.html#CONNECTION_STARTED-constant" title="PG::Constants::CONNECTION_STARTED (constant)">CONNECTION_STARTED</a>, 
    <a href="Constants.html#DEF_PGPORT-constant" title="PG::Constants::DEF_PGPORT (constant)">DEF_PGPORT</a>, 
    <a href="Constants.html#INVALID_OID-constant" title="PG::Constants::INVALID_OID (constant)">INVALID_OID</a>, 
    <a href="Constants.html#INV_READ-constant" title="PG::Constants::INV_READ (constant)">INV_READ</a>, 
    <a href="Constants.html#INV_WRITE-constant" title="PG::Constants::INV_WRITE (constant)">INV_WRITE</a>, 
    <a href="Constants.html#InvalidOid-constant" title="PG::Constants::InvalidOid (constant)">InvalidOid</a>, 
    <a href="Constants.html#PGRES_BAD_RESPONSE-constant" title="PG::Constants::PGRES_BAD_RESPONSE (constant)">PGRES_BAD_RESPONSE</a>, 
    <a href="Constants.html#PGRES_COMMAND_OK-constant" title="PG::Constants::PGRES_COMMAND_OK (constant)">PGRES_COMMAND_OK</a>, 
    <a href="Constants.html#PGRES_COPY_BOTH-constant" title="PG::Constants::PGRES_COPY_BOTH (constant)">PGRES_COPY_BOTH</a>, 
    <a href="Constants.html#PGRES_COPY_IN-constant" title="PG::Constants::PGRES_COPY_IN (constant)">PGRES_COPY_IN</a>, 
    <a href="Constants.html#PGRES_COPY_OUT-constant" title="PG::Constants::PGRES_COPY_OUT (constant)">PGRES_COPY_OUT</a>, 
    <a href="Constants.html#PGRES_EMPTY_QUERY-constant" title="PG::Constants::PGRES_EMPTY_QUERY (constant)">PGRES_EMPTY_QUERY</a>, 
    <a href="Constants.html#PGRES_FATAL_ERROR-constant" title="PG::Constants::PGRES_FATAL_ERROR (constant)">PGRES_FATAL_ERROR</a>, 
    <a href="Constants.html#PGRES_NONFATAL_ERROR-constant" title="PG::Constants::PGRES_NONFATAL_ERROR (constant)">PGRES_NONFATAL_ERROR</a>, 
    <a href="Constants.html#PGRES_PIPELINE_ABORTED-constant" title="PG::Constants::PGRES_PIPELINE_ABORTED (constant)">PGRES_PIPELINE_ABORTED</a>, 
    <a href="Constants.html#PGRES_PIPELINE_SYNC-constant" title="PG::Constants::PGRES_PIPELINE_SYNC (constant)">PGRES_PIPELINE_SYNC</a>, 
    <a href="Constants.html#PGRES_POLLING_FAILED-constant" title="PG::Constants::PGRES_POLLING_FAILED (constant)">PGRES_POLLING_FAILED</a>, 
    <a href="Constants.html#PGRES_POLLING_OK-constant" title="PG::Constants::PGRES_POLLING_OK (constant)">PGRES_POLLING_OK</a>, 
    <a href="Constants.html#PGRES_POLLING_READING-constant" title="PG::Constants::PGRES_POLLING_READING (constant)">PGRES_POLLING_READING</a>, 
    <a href="Constants.html#PGRES_POLLING_WRITING-constant" title="PG::Constants::PGRES_POLLING_WRITING (constant)">PGRES_POLLING_WRITING</a>, 
    <a href="Constants.html#PGRES_SINGLE_TUPLE-constant" title="PG::Constants::PGRES_SINGLE_TUPLE (constant)">PGRES_SINGLE_TUPLE</a>, 
    <a href="Constants.html#PGRES_TUPLES_OK-constant" title="PG::Constants::PGRES_TUPLES_OK (constant)">PGRES_TUPLES_OK</a>, 
    <a href="Constants.html#PG_DIAG_COLUMN_NAME-constant" title="PG::Constants::PG_DIAG_COLUMN_NAME (constant)">PG_DIAG_COLUMN_NAME</a>, 
    <a href="Constants.html#PG_DIAG_CONSTRAINT_NAME-constant" title="PG::Constants::PG_DIAG_CONSTRAINT_NAME (constant)">PG_DIAG_CONSTRAINT_NAME</a>, 
    <a href="Constants.html#PG_DIAG_CONTEXT-constant" title="PG::Constants::PG_DIAG_CONTEXT (constant)">PG_DIAG_CONTEXT</a>, 
    <a href="Constants.html#PG_DIAG_DATATYPE_NAME-constant" title="PG::Constants::PG_DIAG_DATATYPE_NAME (constant)">PG_DIAG_DATATYPE_NAME</a>, 
    <a href="Constants.html#PG_DIAG_INTERNAL_POSITION-constant" title="PG::Constants::PG_DIAG_INTERNAL_POSITION (constant)">PG_DIAG_INTERNAL_POSITION</a>, 
    <a href="Constants.html#PG_DIAG_INTERNAL_QUERY-constant" title="PG::Constants::PG_DIAG_INTERNAL_QUERY (constant)">PG_DIAG_INTERNAL_QUERY</a>, 
    <a href="Constants.html#PG_DIAG_MESSAGE_DETAIL-constant" title="PG::Constants::PG_DIAG_MESSAGE_DETAIL (constant)">PG_DIAG_MESSAGE_DETAIL</a>, 
    <a href="Constants.html#PG_DIAG_MESSAGE_HINT-constant" title="PG::Constants::PG_DIAG_MESSAGE_HINT (constant)">PG_DIAG_MESSAGE_HINT</a>, 
    <a href="Constants.html#PG_DIAG_MESSAGE_PRIMARY-constant" title="PG::Constants::PG_DIAG_MESSAGE_PRIMARY (constant)">PG_DIAG_MESSAGE_PRIMARY</a>, 
    <a href="Constants.html#PG_DIAG_SCHEMA_NAME-constant" title="PG::Constants::PG_DIAG_SCHEMA_NAME (constant)">PG_DIAG_SCHEMA_NAME</a>, 
    <a href="Constants.html#PG_DIAG_SEVERITY-constant" title="PG::Constants::PG_DIAG_SEVERITY (constant)">PG_DIAG_SEVERITY</a>, 
    <a href="Constants.html#PG_DIAG_SEVERITY_NONLOCALIZED-constant" title="PG::Constants::PG_DIAG_SEVERITY_NONLOCALIZED (constant)">PG_DIAG_SEVERITY_NONLOCALIZED</a>, 
    <a href="Constants.html#PG_DIAG_SOURCE_FILE-constant" title="PG::Constants::PG_DIAG_SOURCE_FILE (constant)">PG_DIAG_SOURCE_FILE</a>, 
    <a href="Constants.html#PG_DIAG_SOURCE_FUNCTION-constant" title="PG::Constants::PG_DIAG_SOURCE_FUNCTION (constant)">PG_DIAG_SOURCE_FUNCTION</a>, 
    <a href="Constants.html#PG_DIAG_SOURCE_LINE-constant" title="PG::Constants::PG_DIAG_SOURCE_LINE (constant)">PG_DIAG_SOURCE_LINE</a>, 
    <a href="Constants.html#PG_DIAG_SQLSTATE-constant" title="PG::Constants::PG_DIAG_SQLSTATE (constant)">PG_DIAG_SQLSTATE</a>, 
    <a href="Constants.html#PG_DIAG_STATEMENT_POSITION-constant" title="PG::Constants::PG_DIAG_STATEMENT_POSITION (constant)">PG_DIAG_STATEMENT_POSITION</a>, 
    <a href="Constants.html#PG_DIAG_TABLE_NAME-constant" title="PG::Constants::PG_DIAG_TABLE_NAME (constant)">PG_DIAG_TABLE_NAME</a>, 
    <a href="Constants.html#PQERRORS_DEFAULT-constant" title="PG::Constants::PQERRORS_DEFAULT (constant)">PQERRORS_DEFAULT</a>, 
    <a href="Constants.html#PQERRORS_SQLSTATE-constant" title="PG::Constants::PQERRORS_SQLSTATE (constant)">PQERRORS_SQLSTATE</a>, 
    <a href="Constants.html#PQERRORS_TERSE-constant" title="PG::Constants::PQERRORS_TERSE (constant)">PQERRORS_TERSE</a>, 
    <a href="Constants.html#PQERRORS_VERBOSE-constant" title="PG::Constants::PQERRORS_VERBOSE (constant)">PQERRORS_VERBOSE</a>, 
    <a href="Constants.html#PQPING_NO_ATTEMPT-constant" title="PG::Constants::PQPING_NO_ATTEMPT (constant)">PQPING_NO_ATTEMPT</a>, 
    <a href="Constants.html#PQPING_NO_RESPONSE-constant" title="PG::Constants::PQPING_NO_RESPONSE (constant)">PQPING_NO_RESPONSE</a>, 
    <a href="Constants.html#PQPING_OK-constant" title="PG::Constants::PQPING_OK (constant)">PQPING_OK</a>, 
    <a href="Constants.html#PQPING_REJECT-constant" title="PG::Constants::PQPING_REJECT (constant)">PQPING_REJECT</a>, 
    <a href="Constants.html#PQSHOW_CONTEXT_ALWAYS-constant" title="PG::Constants::PQSHOW_CONTEXT_ALWAYS (constant)">PQSHOW_CONTEXT_ALWAYS</a>, 
    <a href="Constants.html#PQSHOW_CONTEXT_ERRORS-constant" title="PG::Constants::PQSHOW_CONTEXT_ERRORS (constant)">PQSHOW_CONTEXT_ERRORS</a>, 
    <a href="Constants.html#PQSHOW_CONTEXT_NEVER-constant" title="PG::Constants::PQSHOW_CONTEXT_NEVER (constant)">PQSHOW_CONTEXT_NEVER</a>, 
    <a href="Constants.html#PQTRANS_ACTIVE-constant" title="PG::Constants::PQTRANS_ACTIVE (constant)">PQTRANS_ACTIVE</a>, 
    <a href="Constants.html#PQTRANS_IDLE-constant" title="PG::Constants::PQTRANS_IDLE (constant)">PQTRANS_IDLE</a>, 
    <a href="Constants.html#PQTRANS_INERROR-constant" title="PG::Constants::PQTRANS_INERROR (constant)">PQTRANS_INERROR</a>, 
    <a href="Constants.html#PQTRANS_INTRANS-constant" title="PG::Constants::PQTRANS_INTRANS (constant)">PQTRANS_INTRANS</a>, 
    <a href="Constants.html#PQTRANS_UNKNOWN-constant" title="PG::Constants::PQTRANS_UNKNOWN (constant)">PQTRANS_UNKNOWN</a>, 
    <a href="Constants.html#PQ_PIPELINE_ABORTED-constant" title="PG::Constants::PQ_PIPELINE_ABORTED (constant)">PQ_PIPELINE_ABORTED</a>, 
    <a href="Constants.html#PQ_PIPELINE_OFF-constant" title="PG::Constants::PQ_PIPELINE_OFF (constant)">PQ_PIPELINE_OFF</a>, 
    <a href="Constants.html#PQ_PIPELINE_ON-constant" title="PG::Constants::PQ_PIPELINE_ON (constant)">PQ_PIPELINE_ON</a>, 
    <a href="Constants.html#SEEK_CUR-constant" title="PG::Constants::SEEK_CUR (constant)">SEEK_CUR</a>, 
    <a href="Constants.html#SEEK_END-constant" title="PG::Constants::SEEK_END (constant)">SEEK_END</a>, 
    <a href="Constants.html#SEEK_SET-constant" title="PG::Constants::SEEK_SET (constant)">SEEK_SET</a>
  </p>
</div>

<h2 class='h2_sum' id='class_attribute_summary'>Class Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature wo'>
      <a href="#async_api=-class_method" title=".async_api= (class method)">.<strong>async_api=</strong>(enable)  </a>
    </span>
    <span class='note title writeonly'>writeonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Switch between sync and async libpq API.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature wo'>
      <a href="#async_send_api=-class_method" title=".async_send_api= (class method)">.<strong>async_send_api=</strong>(enable)  </a>
    </span>
    <span class='note title writeonly'>writeonly</span>
  </li>
</ul>
</div>  <!-- class_attribute_summary -->

<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#async_connect-class_method" title=".async_connect (class method)">.<strong>async_connect</strong>(*args)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#new-class_method" title="PG::Connection.new (method)">.new</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_ping-class_method" title=".async_ping (class method)">.<strong>async_ping</strong>(*args)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#ping-class_method" title="PG::Connection.ping (method)">.ping</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#conndefaults-class_method" title="conndefaults (class method)">.<strong>conndefaults</strong>  &#x21d2; Array </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns an array of hashes.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#conndefaults_hash-class_method" title=".conndefaults_hash (class method)">.<strong>conndefaults_hash</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Return the Postgres connection defaults structure as a Hash keyed by option keyword (as a Symbol).</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#connect-class_method" title=".connect (class method)">.<strong>connect</strong>(*args)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#new-class_method" title="PG::Connection.new (method)">.new</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#connect_hash_to_string-class_method" title=".connect_hash_to_string (class method)">.<strong>connect_hash_to_string</strong>(hash)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Convert Hash options to connection String.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#connect_start-class_method" title="connect_start (class method)">.<strong>connect_start</strong>(connection_hash)  &#x21d2; conn </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This is an asynchronous version of <a href="#new-class_method" title="PG::Connection.new (method)">.new</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#connect_to_hosts-class_method" title=".connect_to_hosts (class method)">.<strong>connect_to_hosts</strong>(*args)  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#conninfo_parse-class_method" title="conninfo_parse (class method)">.<strong>conninfo_parse</strong>(conninfo_string)  &#x21d2; Array </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns parsed connection options from the provided connection string as an array of hashes.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#encrypt_password-class_method" title="encrypt_password (class method)">.<strong>encrypt_password</strong>(password, username)  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This is an older, deprecated version of <a href="#encrypt_password-instance_method" title="PG::Connection#encrypt_password (method)">#encrypt_password</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#escape-class_method" title="escape (class method)">.<strong>escape</strong>(str)  &#x21d2; String </a>
      (also: .escape_string, #escape_string)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns a SQL-safe version of the String <em>str</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#escape_bytea-instance_method" title="#escape_bytea (instance method)">#<strong>escape_bytea</strong>(string)  &#x21d2; String </a>
      (also: #escape_bytea)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Escapes binary data for use within an SQL command with the type <code>bytea</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#escape_string-class_method" title="escape_string (class method)">.<strong>escape_string</strong>(str)  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#escape-class_method" title="PG::Connection.escape (method)">.escape</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#host_is_named_pipe%3F-class_method" title=".host_is_named_pipe? (class method)">.<strong>host_is_named_pipe?</strong>(host_string)  &#x21d2; Boolean </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#new-class_method" title="new (class method)">.<strong>new</strong>  &#x21d2; conn </a>
      (also: .async_connect, .connect, .open, .setdb, .setdblogin)
    </span>
    <span class='note title constructor'>constructor</span>
    <div class='summary_desc'>
      <div class='inline'><p>Create a connection to the specified server.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#open-class_method" title=".open (class method)">.<strong>open</strong>(*args)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#new-class_method" title="PG::Connection.new (method)">.new</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#parse_connect_args-class_method" title=".parse_connect_args (class method)">.<strong>parse_connect_args</strong>(*args)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Parse the connection <code>args</code> into a connection-parameter string.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#ping-class_method" title="ping (class method)">.<strong>ping</strong>(connection_hash)  &#x21d2; Integer </a>
      (also: .async_ping)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>PQpingParams reports the status of the server.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#quote_connstr-class_method" title=".quote_connstr (class method)">.<strong>quote_connstr</strong>(value)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Quote a single <code>value</code> for use in a connection-parameter string.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#quote_ident-class_method" title="#quote_ident (class method)">.<strong>quote_ident</strong>(str)  &#x21d2; String </a>
      (also: #quote_ident)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns a string that is safe for inclusion in a SQL query as an identifier.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#resolve_hosts-class_method" title=".resolve_hosts (class method)">.<strong>resolve_hosts</strong>(iopts)  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#setdb-class_method" title=".setdb (class method)">.<strong>setdb</strong>(*args)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#new-class_method" title="PG::Connection.new (method)">.new</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#setdblogin-class_method" title=".setdblogin (class method)">.<strong>setdblogin</strong>(*args)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#new-class_method" title="PG::Connection.new (method)">.new</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_connect-class_method" title=".sync_connect (class method)">.<strong>sync_connect</strong>(*args)  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_ping-class_method" title=".sync_ping (class method)">.<strong>sync_ping</strong>(*args)  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#unescape_bytea-instance_method" title="#unescape_bytea (instance method)">#<strong>unescape_bytea</strong>(string)  </a>
      (also: #unescape_bytea)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Converts an escaped string representation of binary data into binary data — the reverse of <a href="#escape_bytea-instance_method" title="PG::Connection#escape_bytea (method)">#escape_bytea</a>.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_attribute_summary'>Instance Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature rw'>
      <a href="#decoder_for_get_copy_data-instance_method" title="#decoder_for_get_copy_data (instance method)">#<strong>decoder_for_get_copy_data</strong>  &#x21d2; PG::Coder </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the default coder object that is currently set for type casting of received data by <a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">#get_copy_data</a> .</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#decoder_for_get_copy_data=-instance_method" title="#decoder_for_get_copy_data= (instance method)">#<strong>decoder_for_get_copy_data=</strong>(decoder)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Set the default coder that is used for type casting of received data by <a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">#get_copy_data</a> .</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#encoder_for_put_copy_data-instance_method" title="#encoder_for_put_copy_data (instance method)">#<strong>encoder_for_put_copy_data</strong>  &#x21d2; PG::Coder </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the default coder object that is currently set for type casting of parameters to <a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">#put_copy_data</a> .</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#encoder_for_put_copy_data=-instance_method" title="#encoder_for_put_copy_data= (instance method)">#<strong>encoder_for_put_copy_data=</strong>(encoder)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Set the default coder that is used for type casting of parameters to <a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">#put_copy_data</a> .</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#field_name_type-instance_method" title="#field_name_type (instance method)">#<strong>field_name_type</strong>  &#x21d2; Symbol </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Get type of field names.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#field_name_type=-instance_method" title="#field_name_type= (instance method)">#<strong>field_name_type=</strong>(Symbol)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Set default type of field names of results retrieved by this connection.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#finished%3F-instance_method" title="#finished? (instance method)">#<strong>finished?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns <code>true</code> if the backend connection has been closed.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#internal_encoding-instance_method" title="#internal_encoding (instance method)">#<strong>internal_encoding</strong>  &#x21d2; Encoding </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>defined in Ruby 1.9 or later.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#internal_encoding=-instance_method" title="#internal_encoding= (instance method)">#<strong>internal_encoding=</strong>(value)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>A wrapper of <a href="#set_client_encoding-instance_method" title="PG::Connection#set_client_encoding (method)">#set_client_encoding</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#nonblocking%3F-instance_method" title="#nonblocking? (instance method)">#<strong>nonblocking?</strong>  </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#isnonblocking-instance_method" title="PG::Connection#isnonblocking (method)">#isnonblocking</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#ssl_in_use%3F-instance_method" title="#ssl_in_use? (instance method)">#<strong>ssl_in_use?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns <code>true</code> if the connection uses SSL/TLS, <code>false</code> if not.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#type_map_for_queries-instance_method" title="#type_map_for_queries (instance method)">#<strong>type_map_for_queries</strong>  &#x21d2; TypeMap </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the default <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> that is currently set for type casts of query bind parameters.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#type_map_for_queries=-instance_method" title="#type_map_for_queries= (instance method)">#<strong>type_map_for_queries=</strong>(typemap)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Set the default <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> that is used for type casts of query bind parameters.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#type_map_for_results-instance_method" title="#type_map_for_results (instance method)">#<strong>type_map_for_results</strong>  &#x21d2; TypeMap </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the default <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> that is currently set for type casts of result values.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#type_map_for_results=-instance_method" title="#type_map_for_results= (instance method)">#<strong>type_map_for_results=</strong>(typemap)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Set the default <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> that is used for type casts of result values.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature wo priv'>
      <a href="#flush_data=-instance_method" title="#flush_data= (instance method)">#<strong>flush_data=</strong>(enabled)  </a>
    </span>
    <span class='note title writeonly'>writeonly</span>
    <span class='note title private'>private</span>
  </li>
</ul>
</div>  <!-- instance_attribute_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#async_cancel-instance_method" title="#async_cancel (instance method)">#<strong>async_cancel</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#cancel-instance_method" title="PG::Connection#cancel (method)">#cancel</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_describe_portal-instance_method" title="#async_describe_portal (instance method)">#<strong>async_describe_portal</strong>(portal_name)  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#describe_portal-instance_method" title="PG::Connection#describe_portal (method)">#describe_portal</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_describe_prepared-instance_method" title="#async_describe_prepared (instance method)">#<strong>async_describe_prepared</strong>(statement_name)  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#describe_prepared-instance_method" title="PG::Connection#describe_prepared (method)">#describe_prepared</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_encrypt_password-instance_method" title="#async_encrypt_password (instance method)">#<strong>async_encrypt_password</strong>(password, username, algorithm = nil)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#encrypt_password-instance_method" title="PG::Connection#encrypt_password (method)">#encrypt_password</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_exec-instance_method" title="#exec (instance method)">#<strong>exec</strong>(sql)  &#x21d2; PG::Result </a>
      (also: #async_query)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_exec_params-instance_method" title="#exec_params (instance method)">#<strong>exec_params</strong>(sql, params [, result_format [, type_map ]] )  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#exec_params-instance_method" title="PG::Connection#exec_params (method)">#exec_params</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_exec_prepared-instance_method" title="#exec_prepared (instance method)">#<strong>exec_prepared</strong>(statement_name [, params, result_format[, type_map]] )  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#exec_prepared-instance_method" title="PG::Connection#exec_prepared (method)">#exec_prepared</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_flush-instance_method" title="#async_flush (instance method)">#<strong>async_flush</strong>  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#flush-instance_method" title="PG::Connection#flush (method)">#flush</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_get_copy_data-instance_method" title="#async_get_copy_data (instance method)">#<strong>async_get_copy_data</strong>(async = false, decoder = nil)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">#get_copy_data</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_get_last_result-instance_method" title="#async_get_last_result (instance method)">#<strong>async_get_last_result</strong>()  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#get_last_result-instance_method" title="PG::Connection#get_last_result (method)">#get_last_result</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_get_result-instance_method" title="#async_get_result (instance method)">#<strong>async_get_result</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#get_result-instance_method" title="PG::Connection#get_result (method)">#get_result</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_isnonblocking-instance_method" title="#async_isnonblocking (instance method)">#<strong>async_isnonblocking</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#isnonblocking-instance_method" title="PG::Connection#isnonblocking (method)">#isnonblocking</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_prepare-instance_method" title="#async_prepare (instance method)">#<strong>async_prepare</strong>(stmt_name, sql [, param_types ] )  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#prepare-instance_method" title="PG::Connection#prepare (method)">#prepare</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_put_copy_data-instance_method" title="#async_put_copy_data (instance method)">#<strong>async_put_copy_data</strong>(buffer, encoder = nil)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">#put_copy_data</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_put_copy_end-instance_method" title="#async_put_copy_end (instance method)">#<strong>async_put_copy_end</strong>(*args)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#put_copy_end-instance_method" title="PG::Connection#put_copy_end (method)">#put_copy_end</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_query-instance_method" title="#exec (instance method)">#<strong>exec</strong>(sql)  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_reset-instance_method" title="#async_reset (instance method)">#<strong>async_reset</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#reset-instance_method" title="PG::Connection#reset (method)">#reset</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_set_client_encoding-instance_method" title="#async_set_client_encoding (instance method)">#<strong>async_set_client_encoding</strong>(encoding)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#client_encoding=-instance_method" title="PG::Connection#client_encoding= (method)">#client_encoding=</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_setnonblocking-instance_method" title="#async_setnonblocking (instance method)">#<strong>async_setnonblocking</strong>(enabled)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#setnonblocking-instance_method" title="PG::Connection#setnonblocking (method)">#setnonblocking</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#backend_key-instance_method" title="#backend_key (instance method)">#<strong>backend_key</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>key of backend — needed for cancels.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#backend_pid-instance_method" title="#backend_pid (instance method)">#<strong>backend_pid</strong>  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the process ID of the backend server process for this connection.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#block-instance_method" title="#block (instance method)">#<strong>block</strong>([ timeout ])  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Blocks until the server is no longer busy, or until the optional <em>timeout</em> is reached, whichever comes first.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#cancel-instance_method" title="#cancel (instance method)">#<strong>cancel</strong>  &#x21d2; String </a>
      (also: #async_cancel)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Requests cancellation of the command currently being processed.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#check_socket-instance_method" title="#check_socket (instance method)">#<strong>check_socket</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Read all pending socket input to internal memory and raise an exception in case of errors.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#client_encoding=-instance_method" title="#client_encoding= (instance method)">#<strong>client_encoding=</strong>(encoding)  </a>
      (also: #set_client_encoding, #async_set_client_encoding)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Sets the client encoding to the <em>encoding</em> String.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#close-instance_method" title="#close (instance method)">#<strong>close</strong>  </a>
      (also: #finish)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Closes the backend connection.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#conndefaults-instance_method" title="#conndefaults (instance method)">#<strong>conndefaults</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns an array of Hashes with connection defaults.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#conndefaults_hash-instance_method" title="#conndefaults_hash (instance method)">#<strong>conndefaults_hash</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns a Hash with connection defaults.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#connect_poll-instance_method" title="#connect_poll (instance method)">#<strong>connect_poll</strong>  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns one of: [<code>PGRES_POLLING_READING</code>].</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#connection_needs_password-instance_method" title="#connection_needs_password (instance method)">#<strong>connection_needs_password</strong>  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns <code>true</code> if the authentication method required a password, but none was available.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#connection_used_password-instance_method" title="#connection_used_password (instance method)">#<strong>connection_used_password</strong>  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns <code>true</code> if the authentication method used a caller-supplied password, <code>false</code> otherwise.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#conninfo-instance_method" title="#conninfo (instance method)">#<strong>conninfo</strong>  &#x21d2; Hash </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the connection options used by a live connection.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#conninfo_hash-instance_method" title="#conninfo_hash (instance method)">#<strong>conninfo_hash</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Return the Postgres connection info structure as a Hash keyed by option keyword (as a Symbol).</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#consume_input-instance_method" title="#consume_input (instance method)">#<strong>consume_input</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>If input is available from the server, consume it.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#copy_data-instance_method" title="#copy_data (instance method)">#<strong>copy_data</strong>(sql [, coder] ) {|sql_result| ... } &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Execute a copy process for transferring data to or from the server.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#db-instance_method" title="#db (instance method)">#<strong>db</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the connected database name.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_describe_portal-instance_method" title="#describe_portal (instance method)">#<strong>describe_portal</strong>(portal_name)  &#x21d2; PG::Result </a>
      (also: #async_describe_portal)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Retrieve information about the portal <em>portal_name</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_describe_prepared-instance_method" title="#describe_prepared (instance method)">#<strong>describe_prepared</strong>(statement_name)  &#x21d2; PG::Result </a>
      (also: #async_describe_prepared)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Retrieve information about the prepared statement <em>statement_name</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#discard_results-instance_method" title="#discard_results (instance method)">#<strong>discard_results</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Silently discard any prior query result that application didn’t eat.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#encrypt_password-instance_method" title="#encrypt_password (instance method)">#<strong>encrypt_password</strong>(password, username, algorithm = nil)  &#x21d2; String </a>
      (also: #async_encrypt_password)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This function is intended to be used by client applications that wish to send commands like <code>ALTER USER joe PASSWORD &#39;pwd&#39;</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#enter_pipeline_mode-instance_method" title="#enter_pipeline_mode (instance method)">#<strong>enter_pipeline_mode</strong>  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Causes a connection to enter pipeline mode if it is currently idle or already in pipeline mode.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#error_message-instance_method" title="#error_message (instance method)">#<strong>error_message</strong>  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the error message most recently generated by an operation on the connection.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#escape_bytea-instance_method" title="#escape_bytea (instance method)">#<strong>escape_bytea</strong>(string)  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#escape_bytea-class_method" title="PG::Connection.escape_bytea (method)">.escape_bytea</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#escape_identifier-instance_method" title="#escape_identifier (instance method)">#<strong>escape_identifier</strong>(str)  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Escape an arbitrary String <code>str</code> as an identifier.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#escape_literal-instance_method" title="#escape_literal (instance method)">#<strong>escape_literal</strong>(str)  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Escape an arbitrary String <code>str</code> as a literal.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#escape_string-instance_method" title="#escape_string (instance method)">#<strong>escape_string</strong>(str)  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#escape-class_method" title="PG::Connection.escape (method)">.escape</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#exec-instance_method" title="#exec (instance method)">#<strong>exec</strong>(sql)  &#x21d2; PG::Result </a>
      (also: #async_exec)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Sends SQL query request specified by <em>sql</em> to PostgreSQL.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#exec_params-instance_method" title="#exec_params (instance method)">#<strong>exec_params</strong>(sql, params [, result_format [, type_map ]] )  &#x21d2; nil </a>
      (also: #async_exec_params)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Sends SQL query request specified by <code>sql</code> to PostgreSQL using placeholders for parameters.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#exec_prepared-instance_method" title="#exec_prepared (instance method)">#<strong>exec_prepared</strong>(statement_name [, params, result_format[, type_map]] )  &#x21d2; PG::Result </a>
      (also: #async_exec_prepared)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Execute prepared named statement specified by <em>statement_name</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#exit_pipeline_mode-instance_method" title="#exit_pipeline_mode (instance method)">#<strong>exit_pipeline_mode</strong>  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Causes a connection to exit pipeline mode if it is currently in pipeline mode with an empty queue and no pending results.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#external_encoding-instance_method" title="#external_encoding (instance method)">#<strong>external_encoding</strong>  &#x21d2; Encoding </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Return the <code>server_encoding</code> of the connected database as a Ruby Encoding object.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#finish-instance_method" title="#finish (instance method)">#<strong>finish</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#close-instance_method" title="PG::Connection#close (method)">#close</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_flush-instance_method" title="#flush (instance method)">#<strong>flush</strong>  &#x21d2; Boolean </a>
      (also: #async_flush)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Attempts to flush any queued output data to the server.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#get_client_encoding-instance_method" title="#get_client_encoding (instance method)">#<strong>get_client_encoding</strong>  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the client encoding as a String.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#get_copy_data-instance_method" title="#get_copy_data (instance method)">#<strong>get_copy_data</strong>([ nonblock = false [, decoder = nil ]] )  &#x21d2; Object </a>
      (also: #async_get_copy_data)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Return one row of data, <code>nil</code> if the copy is done, or <code>false</code> if the call would block (only possible if <em>nonblock</em> is true).</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_get_last_result-instance_method" title="#get_last_result (instance method)">#<strong>get_last_result</strong>()  &#x21d2; PG::Result </a>
      (also: #async_get_last_result)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This function retrieves all available results on the current connection (from previously issued asynchronous commands like <tt>send_query()</tt>) and returns the last non-NULL result, or <code>nil</code> if no results are available.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#get_result-instance_method" title="#get_result (instance method)">#<strong>get_result</strong>  &#x21d2; PG::Result </a>
      (also: #async_get_result)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Blocks waiting for the next result from a call to <a href="#send_query-instance_method" title="PG::Connection#send_query (method)">#send_query</a> (or another asynchronous command), and returns it.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#host-instance_method" title="#host (instance method)">#<strong>host</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the server host name of the active connection.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#hostaddr-instance_method" title="#hostaddr (instance method)">#<strong>hostaddr</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the server IP address of the active connection.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#inspect-instance_method" title="#inspect (instance method)">#<strong>inspect</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Return a String representation of the object suitable for debugging.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#is_busy-instance_method" title="#is_busy (instance method)">#<strong>is_busy</strong>  &#x21d2; Boolean </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns <code>true</code> if a command is busy, that is, if <a href="#get_result-instance_method" title="PG::Connection#get_result (method)">#get_result</a> would block.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#isnonblocking-instance_method" title="#isnonblocking (instance method)">#<strong>isnonblocking</strong>  &#x21d2; Boolean </a>
      (also: #async_isnonblocking, #nonblocking?)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the blocking status of the database connection.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_close-instance_method" title="#lo_close (instance method)">#<strong>lo_close</strong>(lo_desc)  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#loclose-instance_method" title="PG::Connection#loclose (method)">#loclose</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_creat-instance_method" title="#lo_creat (instance method)">#<strong>lo_creat</strong>([mode])  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#locreat-instance_method" title="PG::Connection#locreat (method)">#locreat</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_create-instance_method" title="#lo_create (instance method)">#<strong>lo_create</strong>(oid)  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#locreate-instance_method" title="PG::Connection#locreate (method)">#locreate</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_export-instance_method" title="#lo_export (instance method)">#<strong>lo_export</strong>(oid, file)  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#loexport-instance_method" title="PG::Connection#loexport (method)">#loexport</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_import-instance_method" title="#lo_import (instance method)">#<strong>lo_import</strong>(file)  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#loimport-instance_method" title="PG::Connection#loimport (method)">#loimport</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_lseek-instance_method" title="#lo_lseek (instance method)">#<strong>lo_lseek</strong>(lo_desc, offset, whence)  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#loseek-instance_method" title="PG::Connection#loseek (method)">#loseek</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_open-instance_method" title="#lo_open (instance method)">#<strong>lo_open</strong>(oid, [mode])  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#loopen-instance_method" title="PG::Connection#loopen (method)">#loopen</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_read-instance_method" title="#lo_read (instance method)">#<strong>lo_read</strong>(lo_desc, len)  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#loread-instance_method" title="PG::Connection#loread (method)">#loread</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_seek-instance_method" title="#lo_seek (instance method)">#<strong>lo_seek</strong>(lo_desc, offset, whence)  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#loseek-instance_method" title="PG::Connection#loseek (method)">#loseek</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_tell-instance_method" title="#lo_tell (instance method)">#<strong>lo_tell</strong>(lo_desc)  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#lotell-instance_method" title="PG::Connection#lotell (method)">#lotell</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_truncate-instance_method" title="#lo_truncate (instance method)">#<strong>lo_truncate</strong>(lo_desc, len)  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#lotruncate-instance_method" title="PG::Connection#lotruncate (method)">#lotruncate</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_unlink-instance_method" title="#lo_unlink (instance method)">#<strong>lo_unlink</strong>(oid)  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#lounlink-instance_method" title="PG::Connection#lounlink (method)">#lounlink</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lo_write-instance_method" title="#lo_write (instance method)">#<strong>lo_write</strong>(lo_desc, buffer)  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#lowrite-instance_method" title="PG::Connection#lowrite (method)">#lowrite</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#loclose-instance_method" title="#loclose (instance method)">#<strong>loclose</strong>(lo_desc)  &#x21d2; nil </a>
      (also: #lo_close)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Closes the postgres large object of <em>lo_desc</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#locreat-instance_method" title="#locreat (instance method)">#<strong>locreat</strong>([mode])  &#x21d2; Integer </a>
      (also: #lo_creat)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Creates a large object with mode <em>mode</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#locreate-instance_method" title="#locreate (instance method)">#<strong>locreate</strong>(oid)  &#x21d2; Integer </a>
      (also: #lo_create)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Creates a large object with oid <em>oid</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#loexport-instance_method" title="#loexport (instance method)">#<strong>loexport</strong>(oid, file)  &#x21d2; nil </a>
      (also: #lo_export)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Saves a large object of <em>oid</em> to a <em>file</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#loimport-instance_method" title="#loimport (instance method)">#<strong>loimport</strong>(file)  &#x21d2; Integer </a>
      (also: #lo_import)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Import a file to a large object.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lolseek-instance_method" title="#lolseek (instance method)">#<strong>lolseek</strong>(lo_desc, offset, whence)  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#loseek-instance_method" title="PG::Connection#loseek (method)">#loseek</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#loopen-instance_method" title="#loopen (instance method)">#<strong>loopen</strong>(oid, [mode])  &#x21d2; Integer </a>
      (also: #lo_open)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Open a large object of <em>oid</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#loread-instance_method" title="#loread (instance method)">#<strong>loread</strong>(lo_desc, len)  &#x21d2; String </a>
      (also: #lo_read)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Attempts to read <em>len</em> bytes from large object <em>lo_desc</em>, returns resulting data.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#loseek-instance_method" title="#loseek (instance method)">#<strong>loseek</strong>(lo_desc, offset, whence)  &#x21d2; Integer </a>
      (also: #lo_lseek, #lolseek, #lo_seek)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Move the large object pointer <em>lo_desc</em> to offset <em>offset</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lotell-instance_method" title="#lotell (instance method)">#<strong>lotell</strong>(lo_desc)  &#x21d2; Integer </a>
      (also: #lo_tell)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the current position of the large object <em>lo_desc</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lotruncate-instance_method" title="#lotruncate (instance method)">#<strong>lotruncate</strong>(lo_desc, len)  &#x21d2; nil </a>
      (also: #lo_truncate)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Truncates the large object <em>lo_desc</em> to size <em>len</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lounlink-instance_method" title="#lounlink (instance method)">#<strong>lounlink</strong>(oid)  &#x21d2; nil </a>
      (also: #lo_unlink)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Unlinks (deletes) the postgres large object of <em>oid</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#lowrite-instance_method" title="#lowrite (instance method)">#<strong>lowrite</strong>(lo_desc, buffer)  &#x21d2; Integer </a>
      (also: #lo_write)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Writes the string <em>buffer</em> to the large object <em>lo_desc</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#make_empty_pgresult-instance_method" title="#make_empty_pgresult (instance method)">#<strong>make_empty_pgresult</strong>(status)  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Constructs and empty <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> with status <em>status</em>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#notifies-instance_method" title="#notifies (instance method)">#<strong>notifies</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns a hash of the unprocessed notifications.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#notifies_wait-instance_method" title="#notifies_wait (instance method)">#<strong>notifies_wait</strong>([ timeout ]) {|event, pid, payload| ... } &#x21d2; String </a>
      (also: #wait_for_notify)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Blocks while waiting for notification(s), or until the optional <em>timeout</em> is reached, whichever comes first.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#options-instance_method" title="#options (instance method)">#<strong>options</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns backend option string.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#parameter_status-instance_method" title="#parameter_status (instance method)">#<strong>parameter_status</strong>(param_name)  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the setting of parameter <em>param_name</em>, where <em>param_name</em> is one of * <a href="#server_version-instance_method" title="PG::Connection#server_version (method)">#server_version</a> * <code>server_encoding</code> * <code>client_encoding</code> * <code>is_superuser</code> * <code>session_authorization</code> * <code>DateStyle</code> * <code>TimeZone</code> * <code>integer_datetimes</code> * <code>standard_conforming_strings</code></p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#pass-instance_method" title="#pass (instance method)">#<strong>pass</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the authenticated password.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#pipeline_status-instance_method" title="#pipeline_status (instance method)">#<strong>pipeline_status</strong>  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the current pipeline mode status of the libpq connection.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#pipeline_sync-instance_method" title="#pipeline_sync (instance method)">#<strong>pipeline_sync</strong>  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Marks a synchronization point in a pipeline by sending a sync message and flushing the send buffer.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#port-instance_method" title="#port (instance method)">#<strong>port</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the connected server port number.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#async_prepare-instance_method" title="#prepare (instance method)">#<strong>prepare</strong>(stmt_name, sql [, param_types ] )  &#x21d2; PG::Result </a>
      (also: #async_prepare)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Prepares statement <em>sql</em> with name <em>name</em> to be executed later.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#protocol_version-instance_method" title="#protocol_version (instance method)">#<strong>protocol_version</strong>  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>The 3.0 protocol will normally be used when communicating with PostgreSQL 7.4 or later servers; pre-7.4 servers support only protocol 2.0.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#put_copy_data-instance_method" title="#put_copy_data (instance method)">#<strong>put_copy_data</strong>(buffer [, encoder] )  &#x21d2; Boolean </a>
      (also: #async_put_copy_data)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Transmits <em>buffer</em> as copy data to the server.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#put_copy_end-instance_method" title="#put_copy_end (instance method)">#<strong>put_copy_end</strong>([ error_message ])  &#x21d2; Boolean </a>
      (also: #async_put_copy_end)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Sends end-of-data indication to the server.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#quote_ident-instance_method" title="#quote_ident (instance method)">#<strong>quote_ident</strong>(str)  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#quote_ident-class_method" title="PG::Connection.quote_ident (method)">.quote_ident</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#reset-instance_method" title="#reset (instance method)">#<strong>reset</strong>  </a>
      (also: #async_reset)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Resets the backend connection.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#reset_poll-instance_method" title="#reset_poll (instance method)">#<strong>reset_poll</strong>  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Checks the status of a connection reset operation.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#reset_start-instance_method" title="#reset_start (instance method)">#<strong>reset_start</strong>  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Initiate a connection reset in a nonblocking manner.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#send_describe_portal-instance_method" title="#send_describe_portal (instance method)">#<strong>send_describe_portal</strong>(portal_name)  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Asynchronously send <em>command</em> to the server.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#send_describe_prepared-instance_method" title="#send_describe_prepared (instance method)">#<strong>send_describe_prepared</strong>(statement_name)  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Asynchronously send <em>command</em> to the server.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#send_flush_request-instance_method" title="#pipeline_sync (instance method)">#<strong>pipeline_sync</strong>  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Sends a request for the server to flush its output buffer.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#send_prepare-instance_method" title="#send_prepare (instance method)">#<strong>send_prepare</strong>(stmt_name, sql [, param_types ] )  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Prepares statement <em>sql</em> with name <em>name</em> to be executed later.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#send_query-instance_method" title="#send_query (instance method)">#<strong>send_query</strong>(sql)  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Sends SQL query request specified by <em>sql</em> to PostgreSQL for asynchronous processing, and immediately returns.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#send_query_params-instance_method" title="#send_query_params (instance method)">#<strong>send_query_params</strong>(sql, params [, result_format [, type_map ]] )  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Sends SQL query request specified by <em>sql</em> to PostgreSQL for asynchronous processing, and immediately returns.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#send_query_prepared-instance_method" title="#send_query_prepared (instance method)">#<strong>send_query_prepared</strong>(statement_name [, params, result_format[, type_map ]] )  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Execute prepared named statement specified by <em>statement_name</em> asynchronously, and returns immediately.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#server_version-instance_method" title="#server_version (instance method)">#<strong>server_version</strong>  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>The number is formed by converting the major, minor, and revision numbers into two-decimal-digit numbers and appending them together.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#set_client_encoding-instance_method" title="#set_client_encoding (instance method)">#<strong>set_client_encoding</strong>(encoding)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#client_encoding=-instance_method" title="PG::Connection#client_encoding= (method)">#client_encoding=</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#set_default_encoding-instance_method" title="#set_default_encoding (instance method)">#<strong>set_default_encoding</strong>  &#x21d2; Encoding </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>If Ruby has its <code>Encoding.default_internal</code> set, set PostgreSQL’s client_encoding to match.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#set_error_context_visibility-instance_method" title="#set_error_context_visibility (instance method)">#<strong>set_error_context_visibility</strong>(context_visibility)  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Sets connection’s context display mode to <em>context_visibility</em> and returns the previous setting.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#set_error_verbosity-instance_method" title="#set_error_verbosity (instance method)">#<strong>set_error_verbosity</strong>(verbosity)  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Sets connection’s verbosity to <em>verbosity</em> and returns the previous setting.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#set_notice_processor-instance_method" title="#set_notice_processor (instance method)">#<strong>set_notice_processor</strong> {|message| ... } &#x21d2; Proc </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>See <a href="#set_notice_receiver-instance_method" title="PG::Connection#set_notice_receiver (method)">#set_notice_receiver</a> for the description of what this and the notice_processor methods do.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#set_notice_receiver-instance_method" title="#set_notice_receiver (instance method)">#<strong>set_notice_receiver</strong> {|result| ... } &#x21d2; Proc </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Notice and warning messages generated by the server are not returned by the query execution functions, since they do not imply failure of the query.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#set_single_row_mode-instance_method" title="#set_single_row_mode (instance method)">#<strong>set_single_row_mode</strong>  &#x21d2; self </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>To enter single-row mode, call this method immediately after a successful call of send_query (or a sibling function).</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#setnonblocking-instance_method" title="#setnonblocking (instance method)">#<strong>setnonblocking</strong>(Boolean)  &#x21d2; nil </a>
      (also: #async_setnonblocking)
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Sets the nonblocking status of the connection.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#socket-instance_method" title="#socket (instance method)">#<strong>socket</strong>  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This method is deprecated.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#socket_io-instance_method" title="#socket_io (instance method)">#<strong>socket_io</strong>  &#x21d2; IO </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Fetch an IO object created from the Connection’s underlying socket.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#ssl_attribute-instance_method" title="#ssl_attribute (instance method)">#<strong>ssl_attribute</strong>(attribute_name)  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns SSL-related information about the connection.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#ssl_attribute_names-instance_method" title="#ssl_attribute_names (instance method)">#<strong>ssl_attribute_names</strong>  &#x21d2; Array&lt;String&gt; </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Return an array of SSL attribute names available.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#ssl_attributes-instance_method" title="#ssl_attributes (instance method)">#<strong>ssl_attributes</strong>  &#x21d2; Hash&lt;String, String&gt; </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns SSL-related information about the connection as key/value pairs.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#status-instance_method" title="#status (instance method)">#<strong>status</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the status of the connection, which is one:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_cancel-instance_method" title="#sync_cancel (instance method)">#<strong>sync_cancel</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p><code>Connection</code> INSTANCE METHODS: Cancelling Queries in Progress.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_describe_portal-instance_method" title="#sync_describe_portal (instance method)">#<strong>sync_describe_portal</strong>(portal_name)  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This function has the same behavior as <a href="#async_describe_portal-instance_method" title="PG::Connection#async_describe_portal (method)">#async_describe_portal</a>, but is implemented using the synchronous command processing API of libpq.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_describe_prepared-instance_method" title="#sync_describe_prepared (instance method)">#<strong>sync_describe_prepared</strong>(statement_name)  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This function has the same behavior as <a href="#async_describe_prepared-instance_method" title="PG::Connection#async_describe_prepared (method)">#async_describe_prepared</a>, but is implemented using the synchronous command processing API of libpq.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_encrypt_password-instance_method" title="#sync_encrypt_password (instance method)">#<strong>sync_encrypt_password</strong>(*args)  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_exec-instance_method" title="#sync_exec (instance method)">#<strong>sync_exec</strong>(sql)  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This function has the same behavior as <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a>, but is implemented using the synchronous command processing API of libpq.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_exec_params-instance_method" title="#sync_exec_params (instance method)">#<strong>sync_exec_params</strong>(sql, params[, result_format[, type_map]] )  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This function has the same behavior as <a href="#async_exec_params-instance_method" title="PG::Connection#async_exec_params (method)">#async_exec_params</a>, but is implemented using the synchronous command processing API of libpq.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_exec_prepared-instance_method" title="#sync_exec_prepared (instance method)">#<strong>sync_exec_prepared</strong>(statement_name [, params, result_format[, type_map]] )  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This function has the same behavior as <a href="#async_exec_prepared-instance_method" title="PG::Connection#async_exec_prepared (method)">#async_exec_prepared</a>, but is implemented using the synchronous command processing API of libpq.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_flush-instance_method" title="#sync_flush (instance method)">#<strong>sync_flush</strong>  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_get_copy_data-instance_method" title="#sync_get_copy_data (instance method)">#<strong>sync_get_copy_data</strong>(*args)  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_get_last_result-instance_method" title="#sync_get_last_result (instance method)">#<strong>sync_get_last_result</strong>()  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This function has the same behavior as <a href="#async_get_last_result-instance_method" title="PG::Connection#async_get_last_result (method)">#async_get_last_result</a>, but is implemented using the synchronous command processing API of libpq.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_get_result-instance_method" title="#sync_get_result (instance method)">#<strong>sync_get_result</strong>  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_isnonblocking-instance_method" title="#sync_isnonblocking (instance method)">#<strong>sync_isnonblocking</strong>  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_prepare-instance_method" title="#sync_prepare (instance method)">#<strong>sync_prepare</strong>(stmt_name, sql [, param_types ] )  &#x21d2; PG::Result </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This function has the same behavior as <a href="#async_prepare-instance_method" title="PG::Connection#async_prepare (method)">#async_prepare</a>, but is implemented using the synchronous command processing API of libpq.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_put_copy_data-instance_method" title="#sync_put_copy_data (instance method)">#<strong>sync_put_copy_data</strong>(*args)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p><code>Connection</code> INSTANCE METHODS: COPY.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_put_copy_end-instance_method" title="#sync_put_copy_end (instance method)">#<strong>sync_put_copy_end</strong>(*args)  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_reset-instance_method" title="#sync_reset (instance method)">#<strong>sync_reset</strong>  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_set_client_encoding-instance_method" title="#sync_set_client_encoding (instance method)">#<strong>sync_set_client_encoding</strong>(encoding)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>This function has the same behavior as <a href="#async_set_client_encoding-instance_method" title="PG::Connection#async_set_client_encoding (method)">#async_set_client_encoding</a>, but is implemented using the synchronous command processing API of libpq.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#sync_setnonblocking-instance_method" title="#sync_setnonblocking (instance method)">#<strong>sync_setnonblocking</strong>(state)  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#trace-instance_method" title="#trace (instance method)">#<strong>trace</strong>(stream)  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Enables tracing message passing between backend.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#transaction-instance_method" title="#transaction (instance method)">#<strong>transaction</strong> {|conn| ... } &#x21d2; result of the block </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Executes a <code>BEGIN</code> at the start of the block, and a <code>COMMIT</code> at the end of the block, or <code>ROLLBACK</code> if any exception occurs.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#transaction_status-instance_method" title="#transaction_status (instance method)">#<strong>transaction_status</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>returns one of the following statuses:</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#tty-instance_method" title="#tty (instance method)">#<strong>tty</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Obsolete function.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#unescape_bytea-instance_method" title="#unescape_bytea (instance method)">#<strong>unescape_bytea</strong>(string)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#unescape_bytea-class_method" title="PG::Connection.unescape_bytea (method)">.unescape_bytea</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#untrace-instance_method" title="#untrace (instance method)">#<strong>untrace</strong>  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Disables the message tracing.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#user-instance_method" title="#user (instance method)">#<strong>user</strong>  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the authenticated user name.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#wait_for_notify-instance_method" title="#wait_for_notify (instance method)">#<strong>wait_for_notify</strong>([ timeout ]) {|event, pid, payload| ... } &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#notifies_wait-instance_method" title="PG::Connection#notifies_wait (method)">#notifies_wait</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#async_connect_or_reset-instance_method" title="#async_connect_or_reset (instance method)">#<strong>async_connect_or_reset</strong>(poll_meth)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
  <li>
    <span class='summary_signature priv'>
      <a href="#reset_start2-instance_method" title="#reset_start2 (instance method)">#<strong>reset_start2</strong>(conninfo)  </a>
    </span>
    <span class='note title private'>private</span>
  </li>
</ul>
</div>  <!-- instance_method_summary -->
<h2 id='Constructor_Details' class='y_details'>Constructor Details</h2>

  <section class='method_details first' id="new-class_method">
  <h3 class='signature  first'>
    <div class='inline-block'>
      <span class='overload'>.<strong>new</strong>  &#x21d2; <code>conn</code> </span>
      <span class='overload'>.<strong>new</strong>(connection_hash)  &#x21d2; <code>conn</code> </span>
      <span class='overload'>.<strong>new</strong>(connection_string)  &#x21d2; <code>conn</code> </span>
      <span class='overload'>.<strong>new</strong>(host, port, options, tty, dbname, user, password)  &#x21d2; <code>conn</code> </span>
    </div>
    <span class='aliases'>Also known as: <span class='names'>.async_connect, .connect, .open, .setdb, .setdblogin</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Create a connection to the specified server.</p>

<p><code>connection_hash</code> must be a ruby Hash with connection parameters. See the <a href="https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS" target="_parent" title="list of valid parameters">list of valid parameters</a> in the PostgreSQL documentation.</p>

<p>There are two accepted formats for <code>connection_string</code>: plain <code>keyword = value</code> strings and URIs. See the documentation of <a href="https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING" target="_parent" title="connection strings">connection strings</a>.</p>

<p>The positional parameter form has the same functionality except that the missing parameters will always take on default values. The parameters are:</p>
<dl class="rdoc-list label-list"><dt><code>host</code>
<dd>
<p>server hostname</p>
</dd><dt><code>port</code>
<dd>
<p>server port number</p>
</dd><dt><code>options</code>
<dd>
<p>backend options</p>
</dd><dt><code>tty</code>
<dd>
<p>(ignored in all versions of PostgreSQL)</p>
</dd><dt><code>dbname</code>
<dd>
<p>connecting database name</p>
</dd><dt><code>user</code>
<dd>
<p>login user name</p>
</dd><dt><code>password</code>
<dd>
<p>login password</p>
</dd></dl>

<p>Examples:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Connect using all defaults
</span><span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'>Connection</span>.<span class='id identifier rubyid_new'>new</span>

<span class='comment'># As a Hash
</span><span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'>Connection</span>.<span class='id identifier rubyid_new'>new</span>( <span class='label'>dbname:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>port:</span> <span class='int'>5432</span> )

<span class='comment'># As a String
</span><span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'>Connection</span>.<span class='id identifier rubyid_new'>new</span>( <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dbname=test port=5432</span><span class='tstring_end'>&quot;</span></span> )

<span class='comment'># As an Array
</span><span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'>Connection</span>.<span class='id identifier rubyid_new'>new</span>( <span class='kw'>nil</span><span class='comma'>,</span> <span class='int'>5432</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='kw'>nil</span> )

<span class='comment'># As an URI
</span><span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'>Connection</span>.<span class='id identifier rubyid_new'>new</span>( <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>postgresql://user:pass@pgsql.example.com:5432/testdb?sslmode=require</span><span class='tstring_end'>&quot;</span></span> )</code></pre>

<p>If the Ruby default internal encoding is set (i.e., <code>Encoding.default_internal != nil</code>), the connection will have its <code>client_encoding</code> set accordingly.</p>

<p>Raises a <a href="Error.html" title="PG::Error (class)"><code>Error</code></a> if the connection fails.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L763-L774'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='763' data-end='774'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 763</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_new'>new</span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>)
	<span class='id identifier rubyid_conn'>conn</span> <span class='op'>=</span> <span class='id identifier rubyid_connect_to_hosts'><a href="#connect_to_hosts-class_method" title="PG::Connection.connect_to_hosts (method)">connect_to_hosts</a></span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>)

	<span class='kw'>if</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
		<span class='kw'>begin</span>
			<span class='kw'>return</span> <span class='kw'>yield</span> <span class='id identifier rubyid_conn'>conn</span>
		<span class='kw'>ensure</span>
			<span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_finish'><a href="#finish-instance_method" title="PG::Connection#finish (method)">finish</a></span>
		<span class='kw'>end</span>
	<span class='kw'>end</span>
	<span class='id identifier rubyid_conn'>conn</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Class Attribute Details</h2>
<section class='method_details first' id="async_api=-class_method">
  <h3 class='signature wo first'>
    .<strong>async_api=</strong>(enable)   <span class="extras">(<span class='writeonly'>writeonly</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Switch between sync and async libpq API.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'>Connection</span>.<span class='id identifier rubyid_async_api'>async_api</span> <span class='op'>=</span> <span class='kw'>true</span></code></pre>

<p>this is the default. It sets an alias from <a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a> to <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a>, <a href="#reset-instance_method" title="PG::Connection#reset (method)">#reset</a> to <a href="#async_reset-instance_method" title="PG::Connection#async_reset (method)">#async_reset</a> and so on.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'>Connection</span>.<span class='id identifier rubyid_async_api'>async_api</span> <span class='op'>=</span> <span class='kw'>false</span></code></pre>

<p>sets an alias from <a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a> to <a href="#sync_exec-instance_method" title="PG::Connection#sync_exec (method)">#sync_exec</a>, <a href="#reset-instance_method" title="PG::Connection#reset (method)">#reset</a> to <a href="#sync_reset-instance_method" title="PG::Connection#sync_reset (method)">#sync_reset</a> and so on.</p>

<p>pg-1.1.0+ defaults to libpq’s async API for query related blocking methods. pg-1.3.0+ defaults to libpq’s async API for all possibly blocking methods.</p>

<p><em>PLEASE</em> <em>NOTE</em>: This method is not part of the public API and is for debug and development use only. Do not use this method in production code. Any issues with the default setting of <code>async_api=true</code> should be reported to the maintainers instead.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L946-L956'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='946' data-end='956'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 946</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_async_api='>async_api=</span>(<span class='id identifier rubyid_enable'>enable</span>)
	<span class='kw'>self</span>.<span class='id identifier rubyid_async_send_api'>async_send_api</span> <span class='op'>=</span> <span class='id identifier rubyid_enable'>enable</span>
	<span class='const'><a href="#REDIRECT_METHODS-constant" title="PG::Connection::REDIRECT_METHODS (constant)">REDIRECT_METHODS</a></span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ali'>ali</span><span class='comma'>,</span> (<span class='id identifier rubyid_async'>async</span><span class='comma'>,</span> <span class='id identifier rubyid_sync'>sync</span>)<span class='op'>|</span>
		<span class='id identifier rubyid_remove_method'>remove_method</span>(<span class='id identifier rubyid_ali'>ali</span>) <span class='kw'>if</span> <span class='id identifier rubyid_method_defined?'>method_defined?</span>(<span class='id identifier rubyid_ali'>ali</span>)
		<span class='id identifier rubyid_alias_method'>alias_method</span>( <span class='id identifier rubyid_ali'>ali</span><span class='comma'>,</span> <span class='id identifier rubyid_enable'>enable</span> <span class='op'>?</span> <span class='id identifier rubyid_async'>async</span> <span class='op'>:</span> <span class='id identifier rubyid_sync'>sync</span> )
	<span class='kw'>end</span>
	<span class='const'><a href="#REDIRECT_CLASS_METHODS-constant" title="PG::Connection::REDIRECT_CLASS_METHODS (constant)">REDIRECT_CLASS_METHODS</a></span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ali'>ali</span><span class='comma'>,</span> (<span class='id identifier rubyid_async'>async</span><span class='comma'>,</span> <span class='id identifier rubyid_sync'>sync</span>)<span class='op'>|</span>
		<span class='id identifier rubyid_singleton_class'>singleton_class</span>.<span class='id identifier rubyid_remove_method'>remove_method</span>(<span class='id identifier rubyid_ali'>ali</span>) <span class='kw'>if</span> <span class='id identifier rubyid_method_defined?'>method_defined?</span>(<span class='id identifier rubyid_ali'>ali</span>)
		<span class='id identifier rubyid_singleton_class'>singleton_class</span>.<span class='id identifier rubyid_alias_method'>alias_method</span>(<span class='id identifier rubyid_ali'>ali</span><span class='comma'>,</span> <span class='id identifier rubyid_enable'>enable</span> <span class='op'>?</span> <span class='id identifier rubyid_async'>async</span> <span class='op'>:</span> <span class='id identifier rubyid_sync'>sync</span> )
	<span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="async_send_api=-class_method">
  <h3 class='signature wo'>
    .<strong>async_send_api=</strong>(enable)   <span class="extras">(<span class='writeonly'>writeonly</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L923-L928'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='923' data-end='928'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 923</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_async_send_api='>async_send_api=</span>(<span class='id identifier rubyid_enable'>enable</span>)
	<span class='const'><a href="#REDIRECT_SEND_METHODS-constant" title="PG::Connection::REDIRECT_SEND_METHODS (constant)">REDIRECT_SEND_METHODS</a></span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_ali'>ali</span><span class='comma'>,</span> (<span class='id identifier rubyid_async'>async</span><span class='comma'>,</span> <span class='id identifier rubyid_sync'>sync</span>)<span class='op'>|</span>
		<span class='id identifier rubyid_undef_method'>undef_method</span>(<span class='id identifier rubyid_ali'>ali</span>) <span class='kw'>if</span> <span class='id identifier rubyid_method_defined?'>method_defined?</span>(<span class='id identifier rubyid_ali'>ali</span>)
		<span class='id identifier rubyid_alias_method'>alias_method</span>( <span class='id identifier rubyid_ali'>ali</span><span class='comma'>,</span> <span class='id identifier rubyid_enable'>enable</span> <span class='op'>?</span> <span class='id identifier rubyid_async'>async</span> <span class='op'>:</span> <span class='id identifier rubyid_sync'>sync</span> )
	<span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Class Method Details</h2>
<section class='method_details first' id="async_connect-class_method">
  <h3 class='signature  first'>
    .<strong>async_connect</strong>(*args)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#new-class_method" title="PG::Connection.new (method)">.new</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L775-L775'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='775' data-end='775'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 775</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_async_connect'>async_connect</span> <span class='id identifier rubyid_new'><a href="#new-class_method" title="PG::Connection.new (method)">new</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="async_ping-class_method">
  <h3 class='signature '>
    .<strong>async_ping</strong>(*args)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#ping-class_method" title="PG::Connection.ping (method)">.ping</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L876-L876'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='876' data-end='876'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 876</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_async_ping'>async_ping</span> <span class='id identifier rubyid_ping'><a href="#ping-class_method" title="PG::Connection.ping (method)">ping</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="conndefaults-class_method">
  <h3 class='signature '>
    .<strong>conndefaults</strong>  &#x21d2; <code>Array</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns an array of hashes. Each hash has the keys:</p>
<dl class="rdoc-list label-list"><dt><code>:keyword</code>
<dd>
<p>the name of the option</p>
</dd><dt><code>:envvar</code>
<dd>
<p>the environment variable to fall back to</p>
</dd><dt><code>:compiled</code>
<dd>
<p>the compiled in option as a secondary fallback</p>
</dd><dt><code>:val</code>
<dd>
<p>the option’s current value, or <code>nil</code> if not known</p>
</dd><dt><code>:label</code>
<dd>
<p>the label for the field</p>
</dd><dt><code>:dispchar</code>
<dd>
<p>“” for normal, “D” for debug, and “*” for password</p>
</dd><dt><code>:dispsize</code>
<dd>
<p>field size</p>
</dd></dl>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L377-L388'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='377' data-end='388'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 377</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_s_conndefaults(VALUE self)
{
	PQconninfoOption *options = PQconndefaults();
	VALUE array = pgconn_make_conninfo_array( options );

	PQconninfoFree(options);

	UNUSED( self );

	return array;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="conndefaults_hash-class_method">
  <h3 class='signature '>
    .<strong>conndefaults_hash</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Return the Postgres connection defaults structure as a Hash keyed by option keyword (as a Symbol).</p>

<p>See also <a href="#conndefaults-instance_method" title="PG::Connection#conndefaults (method)">#conndefaults</a></p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L329-L333'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='329' data-end='333'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 329</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_conndefaults_hash'>conndefaults_hash</span>
	<span class='kw'>return</span> <span class='kw'>self</span>.<span class='id identifier rubyid_conndefaults'><a href="#conndefaults-class_method" title="PG::Connection.conndefaults (method)">conndefaults</a></span>.<span class='id identifier rubyid_each_with_object'>each_with_object</span>({}) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_info'>info</span><span class='comma'>,</span> <span class='id identifier rubyid_hash'>hash</span><span class='op'>|</span>
		<span class='id identifier rubyid_hash'>hash</span>[ <span class='id identifier rubyid_info'>info</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_keyword'>keyword</span>].<span class='id identifier rubyid_to_sym'>to_sym</span> ] <span class='op'>=</span> <span class='id identifier rubyid_info'>info</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_val'>val</span>]
	<span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="connect-class_method">
  <h3 class='signature '>
    .<strong>connect</strong>(*args)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#new-class_method" title="PG::Connection.new (method)">.new</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L776-L776'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='776' data-end='776'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 776</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_connect'>connect</span> <span class='id identifier rubyid_new'><a href="#new-class_method" title="PG::Connection.new (method)">new</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="connect_hash_to_string-class_method">
  <h3 class='signature '>
    .<strong>connect_hash_to_string</strong>(hash)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Convert Hash options to connection String</p>

<p>Values are properly quoted and escaped.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L44-L46'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='44' data-end='46'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 44</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_connect_hash_to_string'>connect_hash_to_string</span>( <span class='id identifier rubyid_hash'>hash</span> )
	<span class='id identifier rubyid_hash'>hash</span>.<span class='id identifier rubyid_map'>map</span> { <span class='op'>|</span><span class='id identifier rubyid_k'>k</span><span class='comma'>,</span><span class='id identifier rubyid_v'>v</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_k'>k</span><span class='embexpr_end'>}</span><span class='tstring_content'>=</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_quote_connstr'><a href="#quote_connstr-class_method" title="PG::Connection.quote_connstr (method)">quote_connstr</a></span>(<span class='id identifier rubyid_v'>v</span>)<span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> }.<span class='id identifier rubyid_join'>join</span>( <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'> </span><span class='tstring_end'>&#39;</span></span> )
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="connect_start-class_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>.<strong>connect_start</strong>(connection_hash)  &#x21d2; <code>conn</code> </span>
      <span class='overload'>.<strong>connect_start</strong>(connection_string)  &#x21d2; <code>conn</code> </span>
      <span class='overload'>.<strong>connect_start</strong>(host, port, options, tty, dbname, login, password)  &#x21d2; <code>conn</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This is an asynchronous version of <a href="#new-class_method" title="PG::Connection.new (method)">.new</a>.</p>

<p>Use <a href="#connect_poll-instance_method" title="PG::Connection#connect_poll (method)">#connect_poll</a> to poll the status of the connection.</p>

<p>NOTE: this does <strong>not</strong> set the connection’s <code>client_encoding</code> for you if <code>Encoding.default_internal</code> is set. To set it after the connection is established, call <a href="#internal_encoding=-instance_method" title="PG::Connection#internal_encoding= (method)">#internal_encoding=</a>. You can also set it automatically by setting <code>ENV[&#39;PGCLIENTENCODING&#39;]</code>, or include the ‘options’ connection parameter.</p>

<p>See also the ‘sample’ directory of this gem and the corresponding <a href="https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS" target="_parent" title="libpq functions">libpq functions</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L314-L340'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='314' data-end='340'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 314</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_s_connect_start( int argc, VALUE *argv, VALUE klass )
{
	VALUE rb_conn;
	VALUE conninfo;
	t_pg_connection *this;

	/*
	 * PG::Connection.connect_start must act as both alloc() and initialize()
	 * because it is not invoked by calling new().
	 */
	rb_conn  = pgconn_s_allocate( klass );
	this = pg_get_connection( rb_conn );
	conninfo = rb_funcall2( klass, rb_intern(&quot;parse_connect_args&quot;), argc, argv );
	this-&gt;pgconn = gvl_PQconnectStart( StringValueCStr(conninfo) );

	if( this-&gt;pgconn == NULL )
		rb_raise(rb_ePGerror, &quot;PQconnectStart() unable to allocate PGconn structure&quot;);

	if ( PQstatus(this-&gt;pgconn) == CONNECTION_BAD )
		pg_raise_conn_error( rb_eConnectionBad, rb_conn, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));

	if ( rb_block_given_p() ) {
		return rb_ensure( rb_yield, rb_conn, pgconn_finish, rb_conn );
	}
	return rb_conn;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="connect_to_hosts-class_method">
  <h3 class='signature '>
    .<strong>connect_to_hosts</strong>(*args)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<a href="ConnectionBad.html" title="PG::ConnectionBad (class)">PG::ConnectionBad</a>)</span>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L815-L835'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='815' data-end='835'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 815</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_private'>private</span> <span class='kw'>def</span> <span class='id identifier rubyid_connect_to_hosts'>connect_to_hosts</span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>)
	<span class='id identifier rubyid_option_string'>option_string</span> <span class='op'>=</span> <span class='id identifier rubyid_parse_connect_args'><a href="#parse_connect_args-class_method" title="PG::Connection.parse_connect_args (method)">parse_connect_args</a></span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>)
	<span class='id identifier rubyid_iopts'>iopts</span> <span class='op'>=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'>Connection</span>.<span class='id identifier rubyid_conninfo_parse'><a href="#conninfo_parse-class_method" title="PG::Connection.conninfo_parse (method)">conninfo_parse</a></span>(<span class='id identifier rubyid_option_string'>option_string</span>).<span class='id identifier rubyid_each_with_object'>each_with_object</span>({}){<span class='op'>|</span><span class='id identifier rubyid_h'>h</span><span class='comma'>,</span> <span class='id identifier rubyid_o'>o</span><span class='op'>|</span> <span class='id identifier rubyid_o'>o</span>[<span class='id identifier rubyid_h'>h</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_keyword'>keyword</span>].<span class='id identifier rubyid_to_sym'>to_sym</span>] <span class='op'>=</span> <span class='id identifier rubyid_h'>h</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_val'>val</span>] <span class='kw'>if</span> <span class='id identifier rubyid_h'>h</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_val'>val</span>] }
	<span class='id identifier rubyid_iopts'>iopts</span> <span class='op'>=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'>Connection</span>.<span class='id identifier rubyid_conndefaults'><a href="#conndefaults-class_method" title="PG::Connection.conndefaults (method)">conndefaults</a></span>.<span class='id identifier rubyid_each_with_object'>each_with_object</span>({}){<span class='op'>|</span><span class='id identifier rubyid_h'>h</span><span class='comma'>,</span> <span class='id identifier rubyid_o'>o</span><span class='op'>|</span> <span class='id identifier rubyid_o'>o</span>[<span class='id identifier rubyid_h'>h</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_keyword'>keyword</span>].<span class='id identifier rubyid_to_sym'>to_sym</span>] <span class='op'>=</span> <span class='id identifier rubyid_h'>h</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_val'>val</span>] <span class='kw'>if</span> <span class='id identifier rubyid_h'>h</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_val'>val</span>] }.<span class='id identifier rubyid_merge'>merge</span>(<span class='id identifier rubyid_iopts'>iopts</span>)

	<span class='kw'>if</span> <span class='id identifier rubyid_iopts'>iopts</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_hostaddr'><a href="#hostaddr-instance_method" title="PG::Connection#hostaddr (method)">hostaddr</a></span>]
		<span class='comment'># hostaddr is provided -&gt; no need to resolve hostnames
</span>
	<span class='kw'>elsif</span> <span class='id identifier rubyid_iopts'>iopts</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_host'><a href="#host-instance_method" title="PG::Connection#host (method)">host</a></span>] <span class='op'>&amp;&amp;</span> <span class='op'>!</span><span class='id identifier rubyid_iopts'>iopts</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_host'><a href="#host-instance_method" title="PG::Connection#host (method)">host</a></span>].<span class='id identifier rubyid_empty?'>empty?</span> <span class='op'>&amp;&amp;</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span>.<span class='id identifier rubyid_library_version'><a href="../PG.html#library_version-class_method" title="PG.library_version (method)">library_version</a></span> <span class='op'>&gt;=</span> <span class='int'>100000</span>
		<span class='id identifier rubyid_iopts'>iopts</span> <span class='op'>=</span> <span class='id identifier rubyid_resolve_hosts'><a href="#resolve_hosts-class_method" title="PG::Connection.resolve_hosts (method)">resolve_hosts</a></span>(<span class='id identifier rubyid_iopts'>iopts</span>)
	<span class='kw'>else</span>
		<span class='comment'># No host given
</span>	<span class='kw'>end</span>
	<span class='id identifier rubyid_conn'>conn</span> <span class='op'>=</span> <span class='kw'>self</span>.<span class='id identifier rubyid_connect_start'><a href="#connect_start-class_method" title="PG::Connection.connect_start (method)">connect_start</a></span>(<span class='id identifier rubyid_iopts'>iopts</span>) <span class='kw'>or</span>
								<span class='id identifier rubyid_raise'>raise</span>(<span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Error.html" title="PG::Error (class)">Error</a></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Unable to create a new connection</span><span class='tstring_end'>&quot;</span></span>)

	<span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="ConnectionBad.html" title="PG::ConnectionBad (class)">ConnectionBad</a></span><span class='comma'>,</span> <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_error_message'><a href="#error_message-instance_method" title="PG::Connection#error_message (method)">error_message</a></span> <span class='kw'>if</span> <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_status'><a href="#status-instance_method" title="PG::Connection#status (method)">status</a></span> <span class='op'>==</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#CONNECTION_BAD-constant" title="PG::Constants::CONNECTION_BAD (constant)">CONNECTION_BAD</a></span>

	<span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_send'>send</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_async_connect_or_reset'><a href="#async_connect_or_reset-instance_method" title="PG::Connection#async_connect_or_reset (method)">async_connect_or_reset</a></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_connect_poll'><a href="#connect_poll-instance_method" title="PG::Connection#connect_poll (method)">connect_poll</a></span>)
	<span class='id identifier rubyid_conn'>conn</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="conninfo_parse-class_method">
  <h3 class='signature '>
    .<strong>conninfo_parse</strong>(conninfo_string)  &#x21d2; <code>Array</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns parsed connection options from the provided connection string as an array of hashes. Each hash has the same keys as <code>Connection</code>.conndefaults() . The values from the <code>conninfo_string</code> are stored in the <code>:val</code> key.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L400-L418'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='400' data-end='418'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 400</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_s_conninfo_parse(VALUE self, VALUE conninfo)
{
	VALUE array;
	char *errmsg = NULL;
	PQconninfoOption *options = PQconninfoParse(StringValueCStr(conninfo), &amp;errmsg);
	if(errmsg){
		VALUE error = rb_str_new_cstr(errmsg);
		PQfreemem(errmsg);
		rb_raise(rb_ePGerror, &quot;%&quot;PRIsVALUE, error);
	}
	array = pgconn_make_conninfo_array( options );

	PQconninfoFree(options);

	UNUSED( self );

	return array;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="encrypt_password-class_method">
  <h3 class='signature '>
    .<strong>encrypt_password</strong>(password, username)  &#x21d2; <code>String</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This is an older, deprecated version of <a href="#encrypt_password-instance_method" title="PG::Connection#encrypt_password (method)">#encrypt_password</a>. The difference is that this function always uses <code>md5</code> as the encryption algorithm.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L456-L472'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='456' data-end='472'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 456</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_s_encrypt_password(VALUE self, VALUE password, VALUE username)
{
	char *encrypted = NULL;
	VALUE rval = Qnil;

	UNUSED( self );

	Check_Type(password, T_STRING);
	Check_Type(username, T_STRING);

	encrypted = PQencryptPassword(StringValueCStr(password), StringValueCStr(username));
	rval = rb_str_new2( encrypted );
	PQfreemem( encrypted );

	return rval;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="escape-class_method">
  <h3 class='signature '>
    .<strong>escape</strong>(str)  &#x21d2; <code>String</code>     <span class='aliases'>Also known as: <span class='names'>.escape_string, #escape_string</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns a SQL-safe version of the String <em>str</em>. This is the preferred way to make strings safe for inclusion in SQL queries.</p>

<p>Consider using exec_params, which avoids the need for passing values inside of SQL commands.</p>

<p>Character encoding of escaped string will be equal to client encoding of connection.</p>

<p>NOTE: This class version of this method can only be used safely in client programs that use a single PostgreSQL connection at a time (in this case it can find out what it needs to know “behind the scenes”). It might give the wrong results if used in programs that use multiple database connections; use the same method on the connection object in such cases.</p>

<p>See also convenience functions <a href="#escape_literal-instance_method" title="PG::Connection#escape_literal (method)">#escape_literal</a> and <a href="#escape_identifier-instance_method" title="PG::Connection#escape_identifier (method)">#escape_identifier</a> which also add proper quotes around the string.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1627-L1656'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1627' data-end='1656'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1627</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_s_escape(VALUE self, VALUE string)
{
	size_t size;
	int error;
	VALUE result;
	int enc_idx;
	int singleton = !rb_obj_is_kind_of(self, rb_cPGconn);

	StringValueCStr(string);
	enc_idx = singleton ? ENCODING_GET(string) : pg_get_connection(self)-&gt;enc_idx;
	if( ENCODING_GET(string) != enc_idx ){
		string = rb_str_export_to_enc(string, rb_enc_from_index(enc_idx));
	}

	result = rb_str_new(NULL, RSTRING_LEN(string) * 2 + 1);
	PG_ENCODING_SET_NOCHECK(result, enc_idx);
	if( !singleton ) {
		size = PQescapeStringConn(pg_get_pgconn(self), RSTRING_PTR(result),
			RSTRING_PTR(string), RSTRING_LEN(string), &amp;error);
		if(error)
			pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(pg_get_pgconn(self)));

	} else {
		size = PQescapeString(RSTRING_PTR(result), RSTRING_PTR(string), RSTRING_LEN(string));
	}
	rb_str_set_len(result, size);

	return result;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="escape_bytea-class_method">
  <h3 class='signature '>
    #<strong>escape_bytea</strong>(string)  &#x21d2; <code>String</code>     <span class='aliases'>Also known as: <span class='names'>#escape_bytea</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Escapes binary data for use within an SQL command with the type <code>bytea</code>.</p>

<p>Certain byte values must be escaped (but all byte values may be escaped) when used as part of a <code>bytea</code> literal in an SQL statement. In general, to escape a byte, it is converted into the three digit octal number equal to the octet value, and preceded by two backslashes. The single quote (‘) and backslash () characters have special alternative escape sequences. <a href="#escape_bytea-instance_method" title="PG::Connection#escape_bytea (method)">#escape_bytea</a> performs this operation, escaping only the minimally required bytes.</p>

<p>Consider using exec_params, which avoids the need for passing values inside of SQL commands.</p>

<p>NOTE: This class version of this method can only be used safely in client programs that use a single PostgreSQL connection at a time (in this case it can find out what it needs to know “behind the scenes”). It might give the wrong results if used in programs that use multiple database connections; use the same method on the connection object in such cases.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1681-L1701'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1681' data-end='1701'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1681</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_s_escape_bytea(VALUE self, VALUE str)
{
	unsigned char *from, *to;
	size_t from_len, to_len;
	VALUE ret;

	Check_Type(str, T_STRING);
	from      = (unsigned char*)RSTRING_PTR(str);
	from_len  = RSTRING_LEN(str);

	if ( rb_obj_is_kind_of(self, rb_cPGconn) ) {
		to = PQescapeByteaConn(pg_get_pgconn(self), from, from_len, &amp;to_len);
	} else {
		to = PQescapeBytea( from, from_len, &amp;to_len);
	}

	ret = rb_str_new((char*)to, to_len - 1);
	PQfreemem(to);
	return ret;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="escape_string-class_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>escape</strong>(str)  &#x21d2; <code>String</code> </span>
      <span class='overload'>.<strong>escape_string</strong>(str)  &#x21d2; <code>String</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#escape-class_method" title="PG::Connection.escape (method)">.escape</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="host_is_named_pipe?-class_method">
  <h3 class='signature '>
    .<strong>host_is_named_pipe?</strong>(host_string)  &#x21d2; <code>Boolean</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L837-L842'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='837' data-end='842'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 837</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_private'>private</span> <span class='kw'>def</span> <span class='id identifier rubyid_host_is_named_pipe?'>host_is_named_pipe?</span>(<span class='id identifier rubyid_host_string'>host_string</span>)
	<span class='id identifier rubyid_host_string'>host_string</span>.<span class='id identifier rubyid_empty?'>empty?</span> <span class='op'>||</span> <span class='id identifier rubyid_host_string'>host_string</span>.<span class='id identifier rubyid_start_with?'>start_with?</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>/</span><span class='tstring_end'>&quot;</span></span>) <span class='op'>||</span>  <span class='comment'># it&#39;s UnixSocket?
</span>					<span class='id identifier rubyid_host_string'>host_string</span>.<span class='id identifier rubyid_start_with?'>start_with?</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>@</span><span class='tstring_end'>&quot;</span></span>) <span class='op'>||</span>  <span class='comment'># it&#39;s UnixSocket in the abstract namespace?
</span>					<span class='comment'># it&#39;s a path on Windows?
</span>					(<span class='const'>RUBY_PLATFORM</span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>mingw|mswin</span><span class='regexp_end'>/</span></span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_host_string'>host_string</span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A([\/\\]|\w:[\/\\])</span><span class='regexp_end'>/</span></span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="open-class_method">
  <h3 class='signature '>
    .<strong>open</strong>(*args)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#new-class_method" title="PG::Connection.new (method)">.new</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L777-L777'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='777' data-end='777'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 777</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_open'>open</span> <span class='id identifier rubyid_new'><a href="#new-class_method" title="PG::Connection.new (method)">new</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="parse_connect_args-class_method">
  <h3 class='signature '>
    .<strong>parse_connect_args</strong>(*args)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Parse the connection <code>args</code> into a connection-parameter string. See <a href="#new-class_method" title="PG::Connection.new (method)">.new</a> for valid arguments.</p>

<p>It accepts:</p>
<ul><li>
<p>an option String kind of “host=name port=5432”</p>
</li><li>
<p>an option Hash kind of <code>“name”, port: 5432</code></p>
</li><li>
<p>URI string</p>
</li><li>
<p>URI object</p>
</li><li>
<p>positional arguments</p>
</li></ul>

<p>The method adds the option “fallback_application_name” if it isn’t already set. It returns a connection string with “key=value” pairs.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L64-L97'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='64' data-end='97'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 64</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_parse_connect_args'>parse_connect_args</span>( <span class='op'>*</span><span class='id identifier rubyid_args'>args</span> )
	<span class='id identifier rubyid_hash_arg'>hash_arg</span> <span class='op'>=</span> <span class='id identifier rubyid_args'>args</span>.<span class='id identifier rubyid_last'>last</span>.<span class='id identifier rubyid_is_a?'>is_a?</span>( <span class='const'>Hash</span> ) <span class='op'>?</span> <span class='id identifier rubyid_args'>args</span>.<span class='id identifier rubyid_pop'>pop</span>.<span class='id identifier rubyid_transform_keys'>transform_keys</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_to_sym'>to_sym</span>) <span class='op'>:</span> {}
	<span class='id identifier rubyid_iopts'>iopts</span> <span class='op'>=</span> {}

	<span class='kw'>if</span> <span class='id identifier rubyid_args'>args</span>.<span class='id identifier rubyid_length'>length</span> <span class='op'>==</span> <span class='int'>1</span>
		<span class='kw'>case</span> <span class='id identifier rubyid_args'>args</span>.<span class='id identifier rubyid_first'>first</span>.<span class='id identifier rubyid_to_s'>to_s</span>
		<span class='kw'>when</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>=</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>:\/\/</span><span class='regexp_end'>/</span></span>
			<span class='comment'># Option or URL string style
</span>			<span class='id identifier rubyid_conn_string'>conn_string</span> <span class='op'>=</span> <span class='id identifier rubyid_args'>args</span>.<span class='id identifier rubyid_first'>first</span>.<span class='id identifier rubyid_to_s'>to_s</span>
			<span class='id identifier rubyid_iopts'>iopts</span> <span class='op'>=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'>Connection</span>.<span class='id identifier rubyid_conninfo_parse'><a href="#conninfo_parse-class_method" title="PG::Connection.conninfo_parse (method)">conninfo_parse</a></span>(<span class='id identifier rubyid_conn_string'>conn_string</span>).<span class='id identifier rubyid_each_with_object'>each_with_object</span>({}){<span class='op'>|</span><span class='id identifier rubyid_h'>h</span><span class='comma'>,</span> <span class='id identifier rubyid_o'>o</span><span class='op'>|</span> <span class='id identifier rubyid_o'>o</span>[<span class='id identifier rubyid_h'>h</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_keyword'>keyword</span>].<span class='id identifier rubyid_to_sym'>to_sym</span>] <span class='op'>=</span> <span class='id identifier rubyid_h'>h</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_val'>val</span>] <span class='kw'>if</span> <span class='id identifier rubyid_h'>h</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_val'>val</span>] }
		<span class='kw'>else</span>
			<span class='comment'># Positional parameters (only host given)
</span>			<span class='id identifier rubyid_iopts'>iopts</span>[<span class='const'><a href="#CONNECT_ARGUMENT_ORDER-constant" title="PG::Connection::CONNECT_ARGUMENT_ORDER (constant)">CONNECT_ARGUMENT_ORDER</a></span>.<span class='id identifier rubyid_first'>first</span>.<span class='id identifier rubyid_to_sym'>to_sym</span>] <span class='op'>=</span> <span class='id identifier rubyid_args'>args</span>.<span class='id identifier rubyid_first'>first</span>
		<span class='kw'>end</span>
	<span class='kw'>else</span>
		<span class='comment'># Positional parameters with host and more
</span>		<span class='id identifier rubyid_max'>max</span> <span class='op'>=</span> <span class='const'><a href="#CONNECT_ARGUMENT_ORDER-constant" title="PG::Connection::CONNECT_ARGUMENT_ORDER (constant)">CONNECT_ARGUMENT_ORDER</a></span>.<span class='id identifier rubyid_length'>length</span>
		<span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span>
				<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Extra positional parameter %d: %p</span><span class='tstring_end'>&quot;</span></span> <span class='op'>%</span> [ <span class='id identifier rubyid_max'>max</span> <span class='op'>+</span> <span class='int'>1</span><span class='comma'>,</span> <span class='id identifier rubyid_args'>args</span>[<span class='id identifier rubyid_max'>max</span>] ] <span class='kw'>if</span> <span class='id identifier rubyid_args'>args</span>.<span class='id identifier rubyid_length'>length</span> <span class='op'>&gt;</span> <span class='id identifier rubyid_max'>max</span>

		<span class='const'><a href="#CONNECT_ARGUMENT_ORDER-constant" title="PG::Connection::CONNECT_ARGUMENT_ORDER (constant)">CONNECT_ARGUMENT_ORDER</a></span>.<span class='id identifier rubyid_zip'>zip</span>( <span class='id identifier rubyid_args'>args</span> ) <span class='kw'>do</span> <span class='op'>|</span>(<span class='id identifier rubyid_k'>k</span><span class='comma'>,</span><span class='id identifier rubyid_v'>v</span>)<span class='op'>|</span>
			<span class='id identifier rubyid_iopts'>iopts</span>[ <span class='id identifier rubyid_k'>k</span>.<span class='id identifier rubyid_to_sym'>to_sym</span> ] <span class='op'>=</span> <span class='id identifier rubyid_v'>v</span> <span class='kw'>if</span> <span class='id identifier rubyid_v'>v</span>
		<span class='kw'>end</span>
		<span class='id identifier rubyid_iopts'>iopts</span>.<span class='id identifier rubyid_delete'>delete</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_tty'><a href="#tty-instance_method" title="PG::Connection#tty (method)">tty</a></span>) <span class='comment'># ignore obsolete tty parameter
</span>	<span class='kw'>end</span>

	<span class='id identifier rubyid_iopts'>iopts</span>.<span class='id identifier rubyid_merge!'>merge!</span>( <span class='id identifier rubyid_hash_arg'>hash_arg</span> )

	<span class='kw'>if</span> <span class='op'>!</span><span class='id identifier rubyid_iopts'>iopts</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_fallback_application_name'>fallback_application_name</span>]
		<span class='id identifier rubyid_iopts'>iopts</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_fallback_application_name'>fallback_application_name</span>] <span class='op'>=</span> <span class='const'><a href="#PROGRAM_NAME-constant" title="PG::Connection::PROGRAM_NAME (constant)">PROGRAM_NAME</a></span>.<span class='id identifier rubyid_sub'>sub</span>( <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^(.{30}).{4,}(.{30})$</span><span class='regexp_end'>/</span></span> ){ <span class='backref'>$1</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>...</span><span class='tstring_end'>&quot;</span></span><span class='backref'>$2</span> }
	<span class='kw'>end</span>

	<span class='kw'>return</span> <span class='id identifier rubyid_connect_hash_to_string'><a href="#connect_hash_to_string-class_method" title="PG::Connection.connect_hash_to_string (method)">connect_hash_to_string</a></span>(<span class='id identifier rubyid_iopts'>iopts</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="ping-class_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>.<strong>ping</strong>(connection_hash)  &#x21d2; <code>Integer</code> </span>
      <span class='overload'>.<strong>ping</strong>(connection_string)  &#x21d2; <code>Integer</code> </span>
      <span class='overload'>.<strong>ping</strong>(host, port, options, tty, dbname, login, password)  &#x21d2; <code>Integer</code> </span>
    </div>
    <span class='aliases'>Also known as: <span class='names'>.async_ping</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>PQpingParams reports the status of the server.</p>

<p>It accepts connection parameters identical to those of <code>PQ::Connection.new</code> . It is not necessary to supply correct user name, password, or database name values to obtain the server status; however, if incorrect values are provided, the server will log a failed connection attempt.</p>

<p>See <a href="#new-class_method" title="PG::Connection.new (method)">.new</a> for a description of the parameters.</p>

<p>Returns one of:</p>
<dl class="rdoc-list label-list"><dt><code>PQPING_OK</code>
<dd>
<p>server is accepting connections</p>
</dd><dt><code>PQPING_REJECT</code>
<dd>
<p>server is alive but rejecting connections</p>
</dd><dt><code>PQPING_NO_RESPONSE</code>
<dd>
<p>could not establish connection</p>
</dd><dt><code>PQPING_NO_ATTEMPT</code>
<dd>
<p>connection not attempted (bad params)</p>
</dd></dl>

<p>See also check_socket for a way to check the connection without doing any server communication.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L867-L875'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='867' data-end='875'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 867</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_ping'>ping</span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>)
	<span class='kw'>if</span> <span class='const'>Fiber</span>.<span class='id identifier rubyid_respond_to?'>respond_to?</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_scheduler'>scheduler</span>) <span class='op'>&amp;&amp;</span> <span class='const'>Fiber</span>.<span class='id identifier rubyid_scheduler'>scheduler</span>
		<span class='comment'># Run PQping in a second thread to avoid blocking of the scheduler.
</span>		<span class='comment'># Unfortunately there&#39;s no nonblocking way to run ping.
</span>		<span class='const'>Thread</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="PG::Connection.new (method)">new</a></span> { <span class='id identifier rubyid_sync_ping'><a href="#sync_ping-class_method" title="PG::Connection.sync_ping (method)">sync_ping</a></span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>) }.<span class='id identifier rubyid_value'>value</span>
	<span class='kw'>else</span>
		<span class='id identifier rubyid_sync_ping'><a href="#sync_ping-class_method" title="PG::Connection.sync_ping (method)">sync_ping</a></span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>)
	<span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="quote_connstr-class_method">
  <h3 class='signature '>
    .<strong>quote_connstr</strong>(value)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Quote a single <code>value</code> for use in a connection-parameter string.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L37-L39'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='37' data-end='39'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 37</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_quote_connstr'>quote_connstr</span>( <span class='id identifier rubyid_value'>value</span> )
	<span class='kw'>return</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>&#39;</span><span class='tstring_end'>&quot;</span></span> <span class='op'>+</span> <span class='id identifier rubyid_value'>value</span>.<span class='id identifier rubyid_to_s'>to_s</span>.<span class='id identifier rubyid_gsub'>gsub</span>( <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[\\&#39;]</span><span class='regexp_end'>/</span></span> ) {<span class='op'>|</span><span class='id identifier rubyid_m'>m</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>\\</span><span class='tstring_end'>&#39;</span></span> <span class='op'>+</span> <span class='id identifier rubyid_m'>m</span> } <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>&#39;</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="quote_ident-class_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>quote_ident</strong>(str)  &#x21d2; <code>String</code> </span>
      <span class='overload'>#<strong>quote_ident</strong>(array)  &#x21d2; <code>String</code> </span>
      <span class='overload'>#<strong>quote_ident</strong>(str)  &#x21d2; <code>String</code> </span>
      <span class='overload'>#<strong>quote_ident</strong>(array)  &#x21d2; <code>String</code> </span>
    </div>
    <span class='aliases'>Also known as: <span class='names'>#quote_ident</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns a string that is safe for inclusion in a SQL query as an identifier. Note: this is not a quote function for values, but for identifiers.</p>

<p>For example, in a typical SQL query: <code>SELECT FOO FROM MYTABLE</code> The identifier <code>FOO</code> is folded to lower case, so it actually means <code>foo</code>. If you really want to access the case-sensitive field name <code>FOO</code>, use this function like <code>conn.quote_ident(&#39;FOO&#39;)</code>, which will return <code>&quot;FOO&quot;</code> (with double-quotes). PostgreSQL will see the double-quotes, and it will not fold to lower case.</p>

<p>Similarly, this function also protects against special characters, and other things that might allow SQL injection if the identifier comes from an untrusted source.</p>

<p>If the parameter is an Array, then all it’s values are separately quoted and then joined by a “.” character. This can be used for identifiers in the form “schema”.“table”.“column” .</p>

<p>This method is functional identical to the encoder <a href="TextEncoder/Identifier.html" title="PG::TextEncoder::Identifier (class)"><code>TextEncoder::Identifier</code></a> .</p>

<p>If the instance method form is used and the input string character encoding is different to the connection encoding, then the string is converted to this encoding, so that the returned string is always encoded as <a href="#internal_encoding-instance_method" title="PG::Connection#internal_encoding (method)">#internal_encoding</a> .</p>

<p>In the singleton form (PG::Connection.quote_ident) the character encoding of the result string is set to the character encoding of the input string.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3013-L3027'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3013' data-end='3027'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3013</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_s_quote_ident(VALUE self, VALUE str_or_array)
{
	VALUE ret;
	int enc_idx;

	if( rb_obj_is_kind_of(self, rb_cPGconn) ){
		enc_idx = pg_get_connection(self)-&gt;enc_idx;
	}else{
		enc_idx = RB_TYPE_P(str_or_array, T_STRING) ? ENCODING_GET( str_or_array ) : rb_ascii8bit_encindex();
	}
	pg_text_enc_identifier(NULL, str_or_array, NULL, &amp;ret, enc_idx);

	return ret;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="resolve_hosts-class_method">
  <h3 class='signature '>
    .<strong>resolve_hosts</strong>(iopts)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<a href="ConnectionBad.html" title="PG::ConnectionBad (class)">PG::ConnectionBad</a>)</span>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L784-L813'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='784' data-end='813'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 784</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_private'>private</span> <span class='kw'>def</span> <span class='id identifier rubyid_resolve_hosts'>resolve_hosts</span>(<span class='id identifier rubyid_iopts'>iopts</span>)
	<span class='id identifier rubyid_ihosts'>ihosts</span> <span class='op'>=</span> <span class='id identifier rubyid_iopts'>iopts</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_host'><a href="#host-instance_method" title="PG::Connection#host (method)">host</a></span>].<span class='id identifier rubyid_split'>split</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>,</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='op'>-</span><span class='int'>1</span>)
	<span class='id identifier rubyid_iports'>iports</span> <span class='op'>=</span> <span class='id identifier rubyid_iopts'>iopts</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_port'><a href="#port-instance_method" title="PG::Connection#port (method)">port</a></span>].<span class='id identifier rubyid_split'>split</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>,</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='op'>-</span><span class='int'>1</span>)
	<span class='id identifier rubyid_iports'>iports</span> <span class='op'>=</span> [<span class='kw'>nil</span>] <span class='kw'>if</span> <span class='id identifier rubyid_iports'>iports</span>.<span class='id identifier rubyid_size'>size</span> <span class='op'>==</span> <span class='int'>0</span>
	<span class='id identifier rubyid_iports'>iports</span> <span class='op'>=</span> <span class='id identifier rubyid_iports'>iports</span> <span class='op'>*</span> <span class='id identifier rubyid_ihosts'>ihosts</span>.<span class='id identifier rubyid_size'>size</span> <span class='kw'>if</span> <span class='id identifier rubyid_iports'>iports</span>.<span class='id identifier rubyid_size'>size</span> <span class='op'>==</span> <span class='int'>1</span>
	<span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="ConnectionBad.html" title="PG::ConnectionBad (class)">ConnectionBad</a></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>could not match </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_iports'>iports</span>.<span class='id identifier rubyid_size'>size</span><span class='embexpr_end'>}</span><span class='tstring_content'> port numbers to </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_ihosts'>ihosts</span>.<span class='id identifier rubyid_size'>size</span><span class='embexpr_end'>}</span><span class='tstring_content'> hosts</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_iports'>iports</span>.<span class='id identifier rubyid_size'>size</span> <span class='op'>!=</span> <span class='id identifier rubyid_ihosts'>ihosts</span>.<span class='id identifier rubyid_size'>size</span>

	<span class='id identifier rubyid_dests'>dests</span> <span class='op'>=</span> <span class='id identifier rubyid_ihosts'>ihosts</span>.<span class='id identifier rubyid_each_with_index'>each_with_index</span>.<span class='id identifier rubyid_flat_map'>flat_map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_mhost'>mhost</span><span class='comma'>,</span> <span class='id identifier rubyid_idx'>idx</span><span class='op'>|</span>
		<span class='kw'>unless</span> <span class='id identifier rubyid_host_is_named_pipe?'><a href="#host_is_named_pipe%3F-class_method" title="PG::Connection.host_is_named_pipe? (method)">host_is_named_pipe?</a></span>(<span class='id identifier rubyid_mhost'>mhost</span>)
			<span class='kw'>if</span> <span class='const'>Fiber</span>.<span class='id identifier rubyid_respond_to?'>respond_to?</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_scheduler'>scheduler</span>) <span class='op'>&amp;&amp;</span>
						<span class='const'>Fiber</span>.<span class='id identifier rubyid_scheduler'>scheduler</span> <span class='op'>&amp;&amp;</span>
						<span class='const'>RUBY_VERSION</span> <span class='op'>&lt;</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>3.1.</span><span class='tstring_end'>&#39;</span></span>

				<span class='comment'># Use a second thread to avoid blocking of the scheduler.
</span>				<span class='comment'># `TCPSocket.gethostbyname` isn&#39;t fiber aware before ruby-3.1.
</span>				<span class='id identifier rubyid_hostaddrs'>hostaddrs</span> <span class='op'>=</span> <span class='const'>Thread</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="PG::Connection.new (method)">new</a></span>{ <span class='const'>Addrinfo</span>.<span class='id identifier rubyid_getaddrinfo'>getaddrinfo</span>(<span class='id identifier rubyid_mhost'>mhost</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='const'>STREAM</span>).<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_ip_address'>ip_address</span>) <span class='kw'>rescue</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span>] }.<span class='id identifier rubyid_value'>value</span>
			<span class='kw'>else</span>
				<span class='id identifier rubyid_hostaddrs'>hostaddrs</span> <span class='op'>=</span> <span class='const'>Addrinfo</span>.<span class='id identifier rubyid_getaddrinfo'>getaddrinfo</span>(<span class='id identifier rubyid_mhost'>mhost</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='const'>STREAM</span>).<span class='id identifier rubyid_map'>map</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_ip_address'>ip_address</span>) <span class='kw'>rescue</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span>]
			<span class='kw'>end</span>
		<span class='kw'>else</span>
			<span class='comment'># No hostname to resolve (UnixSocket)
</span>			<span class='id identifier rubyid_hostaddrs'>hostaddrs</span> <span class='op'>=</span> [<span class='kw'>nil</span>]
		<span class='kw'>end</span>
		<span class='id identifier rubyid_hostaddrs'>hostaddrs</span>.<span class='id identifier rubyid_map'>map</span> { <span class='op'>|</span><span class='id identifier rubyid_hostaddr'><a href="#hostaddr-instance_method" title="PG::Connection#hostaddr (method)">hostaddr</a></span><span class='op'>|</span> [<span class='id identifier rubyid_hostaddr'><a href="#hostaddr-instance_method" title="PG::Connection#hostaddr (method)">hostaddr</a></span><span class='comma'>,</span> <span class='id identifier rubyid_mhost'>mhost</span><span class='comma'>,</span> <span class='id identifier rubyid_iports'>iports</span>[<span class='id identifier rubyid_idx'>idx</span>]] }
	<span class='kw'>end</span>
	<span class='id identifier rubyid_iopts'>iopts</span>.<span class='id identifier rubyid_merge'>merge</span>(
		<span class='label'>hostaddr:</span> <span class='id identifier rubyid_dests'>dests</span>.<span class='id identifier rubyid_map'>map</span>{<span class='op'>|</span><span class='id identifier rubyid_d'>d</span><span class='op'>|</span> <span class='id identifier rubyid_d'>d</span>[<span class='int'>0</span>] }.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>,</span><span class='tstring_end'>&quot;</span></span>)<span class='comma'>,</span>
		<span class='label'>host:</span> <span class='id identifier rubyid_dests'>dests</span>.<span class='id identifier rubyid_map'>map</span>{<span class='op'>|</span><span class='id identifier rubyid_d'>d</span><span class='op'>|</span> <span class='id identifier rubyid_d'>d</span>[<span class='int'>1</span>] }.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>,</span><span class='tstring_end'>&quot;</span></span>)<span class='comma'>,</span>
		<span class='label'>port:</span> <span class='id identifier rubyid_dests'>dests</span>.<span class='id identifier rubyid_map'>map</span>{<span class='op'>|</span><span class='id identifier rubyid_d'>d</span><span class='op'>|</span> <span class='id identifier rubyid_d'>d</span>[<span class='int'>2</span>] }.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>,</span><span class='tstring_end'>&quot;</span></span>))
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="setdb-class_method">
  <h3 class='signature '>
    .<strong>setdb</strong>(*args)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#new-class_method" title="PG::Connection.new (method)">.new</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L778-L778'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='778' data-end='778'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 778</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_setdb'>setdb</span> <span class='id identifier rubyid_new'><a href="#new-class_method" title="PG::Connection.new (method)">new</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="setdblogin-class_method">
  <h3 class='signature '>
    .<strong>setdblogin</strong>(*args)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#new-class_method" title="PG::Connection.new (method)">.new</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L779-L779'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='779' data-end='779'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 779</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_setdblogin'>setdblogin</span> <span class='id identifier rubyid_new'><a href="#new-class_method" title="PG::Connection.new (method)">new</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_connect-class_method">
  <h3 class='signature '>
    .<strong>sync_connect</strong>(*args)  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L271-L294'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='271' data-end='294'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 271</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_s_sync_connect(int argc, VALUE *argv, VALUE klass)
{
	t_pg_connection *this;
	VALUE conninfo;
	VALUE self = pgconn_s_allocate( klass );

	this = pg_get_connection( self );
	conninfo = rb_funcall2( rb_cPGconn, rb_intern(&quot;parse_connect_args&quot;), argc, argv );
	this-&gt;pgconn = gvl_PQconnectdb(StringValueCStr(conninfo));

	if(this-&gt;pgconn == NULL)
		rb_raise(rb_ePGerror, &quot;PQconnectdb() unable to allocate PGconn structure&quot;);

	if (PQstatus(this-&gt;pgconn) == CONNECTION_BAD)
		pg_raise_conn_error( rb_eConnectionBad, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));

	pgconn_set_default_encoding( self );

	if (rb_block_given_p()) {
		return rb_ensure(rb_yield, self, pgconn_finish, self);
	}
	return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_ping-class_method">
  <h3 class='signature '>
    .<strong>sync_ping</strong>(*args)  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L342-L352'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='342' data-end='352'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 342</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_s_sync_ping( int argc, VALUE *argv, VALUE klass )
{
	PGPing ping;
	VALUE conninfo;

	conninfo = rb_funcall2( klass, rb_intern(&quot;parse_connect_args&quot;), argc, argv );
	ping     = gvl_PQping( StringValueCStr(conninfo) );

	return INT2FIX((int)ping);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="unescape_bytea-class_method">
  <h3 class='signature '>
    #<strong>unescape_bytea</strong>(string)      <span class='aliases'>Also known as: <span class='names'>#unescape_bytea</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Converts an escaped string representation of binary data into binary data — the reverse of <a href="#escape_bytea-instance_method" title="PG::Connection#escape_bytea (method)">#escape_bytea</a>. This is needed when retrieving <code>bytea</code> data in text format, but not when retrieving it in binary format.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1713-L1730'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1713' data-end='1730'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1713</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_s_unescape_bytea(VALUE self, VALUE str)
{
	unsigned char *from, *to;
	size_t to_len;
	VALUE ret;

	UNUSED( self );

	Check_Type(str, T_STRING);
	from = (unsigned char*)StringValueCStr(str);

	to = PQunescapeBytea(from, &amp;to_len);

	ret = rb_str_new((char*)to, to_len);
	PQfreemem(to);
	return ret;
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Attribute Details</h2>
<section class='method_details first' id="decoder_for_get_copy_data-instance_method">
  <h3 class='signature rw first'>
    #<strong>decoder_for_get_copy_data</strong>  &#x21d2; <a href="Coder.html" title="PG::Coder (class)">PG::Coder</a>  <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the default coder object that is currently set for type casting of received data by <a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">#get_copy_data</a> .</p>

<p>Returns either:</p>
<ul><li>
<p>a kind of <a href="Coder.html" title="PG::Coder (class)"><code>Coder</code></a></p>
</li><li>
<p><code>nil</code> - type encoding is disabled, returned data will be a String.</p>
</li></ul>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4396-L4402'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4396' data-end='4402'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4396</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_decoder_for_get_copy_data_get(VALUE self)
{
	t_pg_connection *this = pg_get_connection( self );

	return this-&gt;decoder_for_get_copy_data;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="decoder_for_get_copy_data=-instance_method">
  <h3 class='signature rw'>
    #<strong>decoder_for_get_copy_data=</strong>(decoder)   <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Set the default coder that is used for type casting of received data by <a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">#get_copy_data</a> .</p>

<p><code>decoder</code> can be:</p>
<ul><li>
<p>a kind of <a href="Coder.html" title="PG::Coder (class)"><code>Coder</code></a></p>
</li><li>
<p><code>nil</code> - disable type decoding, returned data will be a String.</p>
</li></ul>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4367-L4382'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4367' data-end='4382'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4367</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_decoder_for_get_copy_data_set(VALUE self, VALUE decoder)
{
	t_pg_connection *this = pg_get_connection( self );

	rb_check_frozen(self);
	if( decoder != Qnil ){
		t_pg_coder *co;
		UNUSED(co);
		/* Check argument type */
		TypedData_Get_Struct(decoder, t_pg_coder, &amp;pg_coder_type, co);
	}
	RB_OBJ_WRITE(self, &amp;this-&gt;decoder_for_get_copy_data, decoder);

	return decoder;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="encoder_for_put_copy_data-instance_method">
  <h3 class='signature rw'>
    #<strong>encoder_for_put_copy_data</strong>  &#x21d2; <a href="Coder.html" title="PG::Coder (class)">PG::Coder</a>  <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the default coder object that is currently set for type casting of parameters to <a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">#put_copy_data</a> .</p>

<p>Returns either:</p>
<ul><li>
<p>a kind of <a href="Coder.html" title="PG::Coder (class)"><code>Coder</code></a></p>
</li><li>
<p><code>nil</code> - type encoding is disabled, data must be a String.</p>
</li></ul>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4347-L4353'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4347' data-end='4353'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4347</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_encoder_for_put_copy_data_get(VALUE self)
{
	t_pg_connection *this = pg_get_connection( self );

	return this-&gt;encoder_for_put_copy_data;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="encoder_for_put_copy_data=-instance_method">
  <h3 class='signature rw'>
    #<strong>encoder_for_put_copy_data=</strong>(encoder)   <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Set the default coder that is used for type casting of parameters to <a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">#put_copy_data</a> .</p>

<p><code>encoder</code> can be:</p>
<ul><li>
<p>a kind of <a href="Coder.html" title="PG::Coder (class)"><code>Coder</code></a></p>
</li><li>
<p><code>nil</code> - disable type encoding, data must be a String.</p>
</li></ul>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4318-L4333'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4318' data-end='4333'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4318</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_encoder_for_put_copy_data_set(VALUE self, VALUE encoder)
{
	t_pg_connection *this = pg_get_connection( self );

	rb_check_frozen(self);
	if( encoder != Qnil ){
		t_pg_coder *co;
		UNUSED(co);
		/* Check argument type */
		TypedData_Get_Struct(encoder, t_pg_coder, &amp;pg_coder_type, co);
	}
	RB_OBJ_WRITE(self, &amp;this-&gt;encoder_for_put_copy_data, encoder);

	return encoder;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="field_name_type-instance_method">
  <h3 class='signature rw'>
    #<strong>field_name_type</strong>  &#x21d2; <code>Symbol</code>  <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Get type of field names.</p>

<p>See description at <a href="#field_name_type=-instance_method" title="PG::Connection#field_name_type= (method)">#field_name_type=</a></p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4443-L4455'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4443' data-end='4455'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4443</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_field_name_type_get(VALUE self)
{
	t_pg_connection *this = pg_get_connection( self );

	if( this-&gt;flags &amp; PG_RESULT_FIELD_NAMES_SYMBOL ){
		return sym_symbol;
	} else if( this-&gt;flags &amp; PG_RESULT_FIELD_NAMES_STATIC_SYMBOL ){
		return sym_static_symbol;
	} else {
		return sym_string;
	}
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="field_name_type=-instance_method">
  <h3 class='signature rw'>
    #<strong>field_name_type=</strong>(Symbol)   <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Set default type of field names of results retrieved by this connection. It can be set to one of:</p>
<ul><li>
<p><code>:string</code> to use String based field names</p>
</li><li>
<p><code>:symbol</code> to use Symbol based field names</p>
</li></ul>

<p>The default is <code>:string</code> .</p>

<p>Settings the type of field names affects only future results.</p>

<p>See further description at <a href="Result.html#field_name_type=-instance_method" title="PG::Result#field_name_type= (method)">Result#field_name_type=</a></p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4420-L4433'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4420' data-end='4433'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4420</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_field_name_type_set(VALUE self, VALUE sym)
{
	t_pg_connection *this = pg_get_connection( self );

	rb_check_frozen(self);
	this-&gt;flags &amp;= ~PG_RESULT_FIELD_NAMES_MASK;
	if( sym == sym_symbol ) this-&gt;flags |= PG_RESULT_FIELD_NAMES_SYMBOL;
	else if ( sym == sym_static_symbol ) this-&gt;flags |= PG_RESULT_FIELD_NAMES_STATIC_SYMBOL;
	else if ( sym == sym_string );
	else rb_raise(rb_eArgError, &quot;invalid argument %+&quot;PRIsVALUE, sym);

	return sym;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="finished?-instance_method">
  <h3 class='signature ro'>
    #<strong>finished?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns <code>true</code> if the backend connection has been closed.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L549-L555'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='549' data-end='555'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 549</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_finished_p( VALUE self )
{
	t_pg_connection *this = pg_get_connection( self );
	if ( this-&gt;pgconn ) return Qfalse;
	return Qtrue;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="flush_data=-instance_method">
  <h3 class='signature wo priv'>
    #<strong>flush_data=</strong>(enabled)   <span class="extras">(<span class='writeonly'>writeonly</span>, <span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2495-L2501'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2495' data-end='2501'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2495</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_flush_data_set( VALUE self, VALUE enabled ){
	t_pg_connection *conn = pg_get_connection(self);
	rb_check_frozen(self);
	conn-&gt;flush_data = RTEST(enabled);
	return enabled;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="internal_encoding-instance_method">
  <h3 class='signature rw'>
    #<strong>internal_encoding</strong>  &#x21d2; <code>Encoding</code>  <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>defined in Ruby 1.9 or later.</p>

<p>Returns:</p>
<ul><li>
<p>an Encoding - client_encoding of the connection as a Ruby Encoding object.</p>
</li><li>
<p>nil - the client_encoding is ‘SQL_ASCII’</p>
</li></ul>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4067-L4078'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4067' data-end='4078'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4067</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_internal_encoding(VALUE self)
{
	PGconn *conn = pg_get_pgconn( self );
	rb_encoding *enc = pg_conn_enc_get( conn );

	if ( enc ) {
		return rb_enc_from_encoding( enc );
	} else {
		return Qnil;
	}
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="internal_encoding=-instance_method">
  <h3 class='signature rw'>
    #<strong>internal_encoding=</strong>(value)   <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>A wrapper of <a href="#set_client_encoding-instance_method" title="PG::Connection#set_client_encoding (method)">#set_client_encoding</a>. defined in Ruby 1.9 or later.</p>

<p><code>value</code> can be one of:</p>
<ul><li>
<p>an Encoding</p>
</li><li>
<p>a String - a name of Encoding</p>
</li><li>
<p><code>nil</code> - sets the client_encoding to SQL_ASCII.</p>
</li></ul>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4094-L4118'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4094' data-end='4118'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4094</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_internal_encoding_set(VALUE self, VALUE enc)
{
	rb_check_frozen(self);
	if (NIL_P(enc)) {
		pgconn_sync_set_client_encoding( self, rb_usascii_str_new_cstr(&quot;SQL_ASCII&quot;) );
		return enc;
	}
	else if ( TYPE(enc) == T_STRING &amp;&amp; strcasecmp(&quot;JOHAB&quot;, StringValueCStr(enc)) == 0 ) {
		pgconn_sync_set_client_encoding(self, rb_usascii_str_new_cstr(&quot;JOHAB&quot;));
		return enc;
	}
	else {
		rb_encoding *rbenc = rb_to_encoding( enc );
		const char *name = pg_get_rb_encoding_as_pg_encoding( rbenc );

		if ( gvl_PQsetClientEncoding(pg_get_pgconn( self ), name) == -1 ) {
			VALUE server_encoding = pgconn_external_encoding( self );
			rb_raise( rb_eEncCompatError, &quot;incompatible character encodings: %s and %s&quot;,
					  rb_enc_name(rb_to_encoding(server_encoding)), name );
		}
		pgconn_set_internal_encoding_index( self );
		return enc;
	}
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="nonblocking?-instance_method">
  <h3 class='signature ro'>
    #<strong>nonblocking?</strong>   <span class="extras">(<span class='readonly'>readonly</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#isnonblocking-instance_method" title="PG::Connection#isnonblocking (method)">#isnonblocking</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L475-L475'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='475' data-end='475'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 475</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_nonblocking?'>nonblocking?</span> <span class='id identifier rubyid_isnonblocking'><a href="#isnonblocking-instance_method" title="PG::Connection#isnonblocking (method)">isnonblocking</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="ssl_in_use?-instance_method">
  <h3 class='signature ro'>
    #<strong>ssl_in_use?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns <code>true</code> if the connection uses SSL/TLS, <code>false</code> if not.</p>

<p>Available since PostgreSQL-9.5</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3517-L3521'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3517' data-end='3521'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3517</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_ssl_in_use(VALUE self)
{
	return PQsslInUse(pg_get_pgconn(self)) ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="type_map_for_queries-instance_method">
  <h3 class='signature rw'>
    #<strong>type_map_for_queries</strong>  &#x21d2; <a href="TypeMap.html" title="PG::TypeMap (class)">TypeMap</a>  <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the default <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> that is currently set for type casts of query bind parameters.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4259-L4265'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4259' data-end='4265'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4259</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_type_map_for_queries_get(VALUE self)
{
	t_pg_connection *this = pg_get_connection( self );

	return this-&gt;type_map_for_queries;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="type_map_for_queries=-instance_method">
  <h3 class='signature rw'>
    #<strong>type_map_for_queries=</strong>(typemap)   <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Set the default <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> that is used for type casts of query bind parameters.</p>

<p><code>typemap</code> must be a kind of <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> .</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4235-L4249'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4235' data-end='4249'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4235</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_type_map_for_queries_set(VALUE self, VALUE typemap)
{
	t_pg_connection *this = pg_get_connection( self );
	t_typemap *tm;
	UNUSED(tm);

	rb_check_frozen(self);
	/* Check type of method param */
	TypedData_Get_Struct(typemap, t_typemap, &amp;pg_typemap_type, tm);

	RB_OBJ_WRITE(self, &amp;this-&gt;type_map_for_queries, typemap);

	return typemap;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="type_map_for_results-instance_method">
  <h3 class='signature rw'>
    #<strong>type_map_for_results</strong>  &#x21d2; <a href="TypeMap.html" title="PG::TypeMap (class)">TypeMap</a>  <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the default <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> that is currently set for type casts of result values.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4297-L4303'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4297' data-end='4303'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4297</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_type_map_for_results_get(VALUE self)
{
	t_pg_connection *this = pg_get_connection( self );

	return this-&gt;type_map_for_results;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="type_map_for_results=-instance_method">
  <h3 class='signature rw'>
    #<strong>type_map_for_results=</strong>(typemap)   <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Set the default <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> that is used for type casts of result values.</p>

<p><code>typemap</code> must be a kind of <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> .</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4276-L4288'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4276' data-end='4288'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4276</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_type_map_for_results_set(VALUE self, VALUE typemap)
{
	t_pg_connection *this = pg_get_connection( self );
	t_typemap *tm;
	UNUSED(tm);

	rb_check_frozen(self);
	TypedData_Get_Struct(typemap, t_typemap, &amp;pg_typemap_type, tm);
	RB_OBJ_WRITE(self, &amp;this-&gt;type_map_for_results, typemap);

	return typemap;
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="async_cancel-instance_method">
  <h3 class='signature  first'>
    #<strong>async_cancel</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#cancel-instance_method" title="PG::Connection#cancel (method)">#cancel</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L640-L640'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='640' data-end='640'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 640</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_async_cancel'>async_cancel</span> <span class='id identifier rubyid_cancel'><a href="#cancel-instance_method" title="PG::Connection#cancel (method)">cancel</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="async_connect_or_reset-instance_method">
  <h3 class='signature priv'>
    #<strong>async_connect_or_reset</strong>(poll_meth)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L642-L709'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='642' data-end='709'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 642</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_private'>private</span> <span class='kw'>def</span> <span class='id identifier rubyid_async_connect_or_reset'>async_connect_or_reset</span>(<span class='id identifier rubyid_poll_meth'>poll_meth</span>)
	<span class='comment'># Track the progress of the connection, waiting for the socket to become readable/writable before polling it
</span>
	<span class='kw'>if</span> (<span class='id identifier rubyid_timeo'>timeo</span> <span class='op'>=</span> <span class='id identifier rubyid_conninfo_hash'><a href="#conninfo_hash-instance_method" title="PG::Connection#conninfo_hash (method)">conninfo_hash</a></span>[<span class='symbeg'>:</span><span class='id identifier rubyid_connect_timeout'>connect_timeout</span>].<span class='id identifier rubyid_to_i'>to_i</span>) <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_timeo'>timeo</span> <span class='op'>&gt;</span> <span class='int'>0</span>
		<span class='comment'># Lowest timeout is 2 seconds - like in libpq
</span>		<span class='id identifier rubyid_timeo'>timeo</span> <span class='op'>=</span> [<span class='id identifier rubyid_timeo'>timeo</span><span class='comma'>,</span> <span class='int'>2</span>].<span class='id identifier rubyid_max'>max</span>
		<span class='id identifier rubyid_host_count'>host_count</span> <span class='op'>=</span> <span class='id identifier rubyid_conninfo_hash'><a href="#conninfo_hash-instance_method" title="PG::Connection#conninfo_hash (method)">conninfo_hash</a></span>[<span class='symbeg'>:</span><span class='id identifier rubyid_host'><a href="#host-instance_method" title="PG::Connection#host (method)">host</a></span>].<span class='id identifier rubyid_to_s'>to_s</span>.<span class='id identifier rubyid_count'>count</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>,</span><span class='tstring_end'>&quot;</span></span>) <span class='op'>+</span> <span class='int'>1</span>
		<span class='id identifier rubyid_stop_time'>stop_time</span> <span class='op'>=</span> <span class='id identifier rubyid_timeo'>timeo</span> <span class='op'>*</span> <span class='id identifier rubyid_host_count'>host_count</span> <span class='op'>+</span> <span class='const'>Process</span>.<span class='id identifier rubyid_clock_gettime'>clock_gettime</span>(<span class='const'>Process</span><span class='op'>::</span><span class='const'>CLOCK_MONOTONIC</span>)
	<span class='kw'>end</span>

	<span class='id identifier rubyid_poll_status'>poll_status</span> <span class='op'>=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#PGRES_POLLING_WRITING-constant" title="PG::Constants::PGRES_POLLING_WRITING (constant)">PGRES_POLLING_WRITING</a></span>
	<span class='kw'>until</span> <span class='id identifier rubyid_poll_status'>poll_status</span> <span class='op'>==</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#PGRES_POLLING_OK-constant" title="PG::Constants::PGRES_POLLING_OK (constant)">PGRES_POLLING_OK</a></span> <span class='op'>||</span>
			<span class='id identifier rubyid_poll_status'>poll_status</span> <span class='op'>==</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#PGRES_POLLING_FAILED-constant" title="PG::Constants::PGRES_POLLING_FAILED (constant)">PGRES_POLLING_FAILED</a></span>

		<span class='comment'># Set single timeout to parameter &quot;connect_timeout&quot; but
</span>		<span class='comment'># don&#39;t exceed total connection time of number-of-hosts * connect_timeout.
</span>		<span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>=</span> [<span class='id identifier rubyid_timeo'>timeo</span><span class='comma'>,</span> <span class='id identifier rubyid_stop_time'>stop_time</span> <span class='op'>-</span> <span class='const'>Process</span>.<span class='id identifier rubyid_clock_gettime'>clock_gettime</span>(<span class='const'>Process</span><span class='op'>::</span><span class='const'>CLOCK_MONOTONIC</span>)].<span class='id identifier rubyid_min'>min</span> <span class='kw'>if</span> <span class='id identifier rubyid_stop_time'>stop_time</span>
		<span class='id identifier rubyid_event'>event</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='op'>!</span><span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>||</span> <span class='id identifier rubyid_timeout'>timeout</span> <span class='op'>&gt;=</span> <span class='int'>0</span>
			<span class='comment'># If the socket needs to read, wait &#39;til it becomes readable to poll again
</span>			<span class='kw'>case</span> <span class='id identifier rubyid_poll_status'>poll_status</span>
			<span class='kw'>when</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#PGRES_POLLING_READING-constant" title="PG::Constants::PGRES_POLLING_READING (constant)">PGRES_POLLING_READING</a></span>
				<span class='kw'>if</span> <span class='kw'>defined?</span>(<span class='const'>IO</span><span class='op'>::</span><span class='const'>READABLE</span>) <span class='comment'># ruby-3.0+
</span>					<span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>.<span class='id identifier rubyid_wait'>wait</span>(<span class='const'>IO</span><span class='op'>::</span><span class='const'>READABLE</span> <span class='op'>|</span> <span class='const'>IO</span><span class='op'>::</span><span class='const'>PRIORITY</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span>)
				<span class='kw'>else</span>
					<span class='const'>IO</span>.<span class='id identifier rubyid_select'>select</span>([<span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>]<span class='comma'>,</span> <span class='kw'>nil</span><span class='comma'>,</span> [<span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>]<span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span>)
				<span class='kw'>end</span>

			<span class='comment'># ...and the same for when the socket needs to write
</span>			<span class='kw'>when</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#PGRES_POLLING_WRITING-constant" title="PG::Constants::PGRES_POLLING_WRITING (constant)">PGRES_POLLING_WRITING</a></span>
				<span class='kw'>if</span> <span class='kw'>defined?</span>(<span class='const'>IO</span><span class='op'>::</span><span class='const'>WRITABLE</span>) <span class='comment'># ruby-3.0+
</span>					<span class='comment'># Use wait instead of wait_readable, since connection errors are delivered as
</span>					<span class='comment'># exceptional/priority events on Windows.
</span>					<span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>.<span class='id identifier rubyid_wait'>wait</span>(<span class='const'>IO</span><span class='op'>::</span><span class='const'>WRITABLE</span> <span class='op'>|</span> <span class='const'>IO</span><span class='op'>::</span><span class='const'>PRIORITY</span><span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span>)
				<span class='kw'>else</span>
					<span class='comment'># io#wait on ruby-2.x doesn&#39;t wait for priority, so fallback to IO.select
</span>					<span class='const'>IO</span>.<span class='id identifier rubyid_select'>select</span>(<span class='kw'>nil</span><span class='comma'>,</span> [<span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>]<span class='comma'>,</span> [<span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>]<span class='comma'>,</span> <span class='id identifier rubyid_timeout'>timeout</span>)
				<span class='kw'>end</span>
			<span class='kw'>end</span>
		<span class='kw'>end</span>
		<span class='comment'># connection to server at &quot;localhost&quot; (127.0.0.1), port 5433 failed: timeout expired (PG::ConnectionBad)
</span>		<span class='comment'># connection to server on socket &quot;/var/run/postgresql/.s.PGSQL.5433&quot; failed: No such file or directory
</span>		<span class='kw'>unless</span> <span class='id identifier rubyid_event'>event</span>
			<span class='kw'>if</span> <span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span>.<span class='id identifier rubyid_send'>send</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_host_is_named_pipe?'><a href="#host_is_named_pipe%3F-class_method" title="PG::Connection.host_is_named_pipe? (method)">host_is_named_pipe?</a></span><span class='comma'>,</span> <span class='id identifier rubyid_host'><a href="#host-instance_method" title="PG::Connection#host (method)">host</a></span>)
				<span class='id identifier rubyid_connhost'>connhost</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>on socket \&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_host'><a href="#host-instance_method" title="PG::Connection#host (method)">host</a></span><span class='embexpr_end'>}</span><span class='tstring_content'>\&quot;</span><span class='tstring_end'>&quot;</span></span>
			<span class='kw'>elsif</span> <span class='id identifier rubyid_respond_to?'>respond_to?</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_hostaddr'><a href="#hostaddr-instance_method" title="PG::Connection#hostaddr (method)">hostaddr</a></span>)
				<span class='id identifier rubyid_connhost'>connhost</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>at \&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_host'><a href="#host-instance_method" title="PG::Connection#host (method)">host</a></span><span class='embexpr_end'>}</span><span class='tstring_content'>\&quot; (</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_hostaddr'><a href="#hostaddr-instance_method" title="PG::Connection#hostaddr (method)">hostaddr</a></span><span class='embexpr_end'>}</span><span class='tstring_content'>), port </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_port'><a href="#port-instance_method" title="PG::Connection#port (method)">port</a></span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
			<span class='kw'>else</span>
				<span class='id identifier rubyid_connhost'>connhost</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>at \&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_host'><a href="#host-instance_method" title="PG::Connection#host (method)">host</a></span><span class='embexpr_end'>}</span><span class='tstring_content'>\&quot;, port </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_port'><a href="#port-instance_method" title="PG::Connection#port (method)">port</a></span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
			<span class='kw'>end</span>
			<span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="ConnectionBad.html" title="PG::ConnectionBad (class)">ConnectionBad</a></span>.<span class='id identifier rubyid_new'><a href="Error.html#new-class_method" title="PG::Error.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>connection to server </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_connhost'>connhost</span><span class='embexpr_end'>}</span><span class='tstring_content'> failed: timeout expired</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>connection:</span> <span class='kw'>self</span>)
		<span class='kw'>end</span>

		<span class='comment'># Check to see if it&#39;s finished or failed yet
</span>		<span class='id identifier rubyid_poll_status'>poll_status</span> <span class='op'>=</span> <span class='id identifier rubyid_send'>send</span>( <span class='id identifier rubyid_poll_meth'>poll_meth</span> )
	<span class='kw'>end</span>

	<span class='kw'>unless</span> <span class='id identifier rubyid_status'><a href="#status-instance_method" title="PG::Connection#status (method)">status</a></span> <span class='op'>==</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#CONNECTION_OK-constant" title="PG::Constants::CONNECTION_OK (constant)">CONNECTION_OK</a></span>
		<span class='id identifier rubyid_msg'>msg</span> <span class='op'>=</span> <span class='id identifier rubyid_error_message'><a href="#error_message-instance_method" title="PG::Connection#error_message (method)">error_message</a></span>
		<span class='id identifier rubyid_finish'><a href="#finish-instance_method" title="PG::Connection#finish (method)">finish</a></span>
		<span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="ConnectionBad.html" title="PG::ConnectionBad (class)">ConnectionBad</a></span>.<span class='id identifier rubyid_new'><a href="Error.html#new-class_method" title="PG::Error.new (method)">new</a></span>(<span class='id identifier rubyid_msg'>msg</span><span class='comma'>,</span> <span class='label'>connection:</span> <span class='kw'>self</span>)
	<span class='kw'>end</span>

	<span class='comment'># Set connection to nonblocking to handle all blocking states in ruby.
</span>	<span class='comment'># That way a fiber scheduler is able to handle IO requests.
</span>	<span class='id identifier rubyid_sync_setnonblocking'><a href="#sync_setnonblocking-instance_method" title="PG::Connection#sync_setnonblocking (method)">sync_setnonblocking</a></span>(<span class='kw'>true</span>)
	<span class='kw'>self</span>.<span class='id identifier rubyid_flush_data'>flush_data</span> <span class='op'>=</span> <span class='kw'>true</span>
	<span class='id identifier rubyid_set_default_encoding'><a href="#set_default_encoding-instance_method" title="PG::Connection#set_default_encoding (method)">set_default_encoding</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="async_describe_portal-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>describe_portal</strong>(portal_name)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>async_describe_portal</strong>(portal_name)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#describe_portal-instance_method" title="PG::Connection#describe_portal (method)">#describe_portal</a>.</p>

  </div>
</div>

</section>

<section class='method_details' id="async_describe_prepared-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>describe_prepared</strong>(statement_name)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>async_describe_prepared</strong>(statement_name)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#describe_prepared-instance_method" title="PG::Connection#describe_prepared (method)">#describe_prepared</a>.</p>

  </div>
</div>

</section>

<section class='method_details' id="async_encrypt_password-instance_method">
  <h3 class='signature '>
    #<strong>async_encrypt_password</strong>(password, username, algorithm = nil)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#encrypt_password-instance_method" title="PG::Connection#encrypt_password (method)">#encrypt_password</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L559-L559'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='559' data-end='559'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 559</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_async_encrypt_password'>async_encrypt_password</span> <span class='id identifier rubyid_encrypt_password'><a href="#encrypt_password-class_method" title="PG::Connection.encrypt_password (method)">encrypt_password</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="async_exec-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>exec</strong>(sql)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>exec</strong>(sql) {|pg_result| ... } </span>
    </div>
    <span class='aliases'>Also known as: <span class='names'>#async_query</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a>.</p>

  </div>
</div>

</section>

<section class='method_details' id="async_exec_params-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>exec_params</strong>(sql, params [, result_format [, type_map ]] )  &#x21d2; <code>nil</code> </span>
      <span class='overload'>#<strong>exec_params</strong>(sql, params [, result_format [, type_map ]] ) {|pg_result| ... } </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#exec_params-instance_method" title="PG::Connection#exec_params (method)">#exec_params</a>.</p>

  </div>
</div>

</section>

<section class='method_details' id="async_exec_prepared-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>exec_prepared</strong>(statement_name [, params, result_format[, type_map]] )  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>exec_prepared</strong>(statement_name [, params, result_format[, type_map]] ) {|pg_result| ... } </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#exec_prepared-instance_method" title="PG::Connection#exec_prepared (method)">#exec_prepared</a>.</p>

  </div>
</div>

</section>

<section class='method_details' id="async_flush-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>flush</strong>  &#x21d2; <code>Boolean</code> </span>
      <span class='overload'>#<strong>async_flush</strong>  &#x21d2; <code>Boolean</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#flush-instance_method" title="PG::Connection#flush (method)">#flush</a>.</p>

  </div>
</div>

</section>

<section class='method_details' id="async_get_copy_data-instance_method">
  <h3 class='signature '>
    #<strong>async_get_copy_data</strong>(async = false, decoder = nil)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">#get_copy_data</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L434-L434'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='434' data-end='434'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 434</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_async_get_copy_data'>async_get_copy_data</span> <span class='id identifier rubyid_get_copy_data'><a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">get_copy_data</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="async_get_last_result-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>get_last_result</strong>()  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>async_get_last_result</strong>()  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#get_last_result-instance_method" title="PG::Connection#get_last_result (method)">#get_last_result</a>.</p>

  </div>
</div>

</section>

<section class='method_details' id="async_get_result-instance_method">
  <h3 class='signature '>
    #<strong>async_get_result</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#get_result-instance_method" title="PG::Connection#get_result (method)">#get_result</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L404-L404'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='404' data-end='404'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 404</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_async_get_result'>async_get_result</span> <span class='id identifier rubyid_get_result'><a href="#get_result-instance_method" title="PG::Connection#get_result (method)">get_result</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="async_isnonblocking-instance_method">
  <h3 class='signature '>
    #<strong>async_isnonblocking</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#isnonblocking-instance_method" title="PG::Connection#isnonblocking (method)">#isnonblocking</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L474-L474'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='474' data-end='474'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 474</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_async_isnonblocking'>async_isnonblocking</span> <span class='id identifier rubyid_isnonblocking'><a href="#isnonblocking-instance_method" title="PG::Connection#isnonblocking (method)">isnonblocking</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="async_prepare-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>prepare</strong>(stmt_name, sql [, param_types ] )  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>async_prepare</strong>(stmt_name, sql [, param_types ] )  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#prepare-instance_method" title="PG::Connection#prepare (method)">#prepare</a>.</p>

  </div>
</div>

</section>

<section class='method_details' id="async_put_copy_data-instance_method">
  <h3 class='signature '>
    #<strong>async_put_copy_data</strong>(buffer, encoder = nil)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">#put_copy_data</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L511-L511'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='511' data-end='511'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 511</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_async_put_copy_data'>async_put_copy_data</span> <span class='id identifier rubyid_put_copy_data'><a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">put_copy_data</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="async_put_copy_end-instance_method">
  <h3 class='signature '>
    #<strong>async_put_copy_end</strong>(*args)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#put_copy_end-instance_method" title="PG::Connection#put_copy_end (method)">#put_copy_end</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L532-L532'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='532' data-end='532'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 532</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_async_put_copy_end'>async_put_copy_end</span> <span class='id identifier rubyid_put_copy_end'><a href="#put_copy_end-instance_method" title="PG::Connection#put_copy_end (method)">put_copy_end</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="async_query-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>exec</strong>(sql)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>exec</strong>(sql) {|pg_result| ... } </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a>.</p>

  </div>
</div>

</section>

<section class='method_details' id="async_reset-instance_method">
  <h3 class='signature '>
    #<strong>async_reset</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#reset-instance_method" title="PG::Connection#reset (method)">#reset</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L577-L577'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='577' data-end='577'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 577</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_async_reset'>async_reset</span> <span class='id identifier rubyid_reset'><a href="#reset-instance_method" title="PG::Connection#reset (method)">reset</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="async_set_client_encoding-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>client_encoding=</strong>(encoding)  </span>
      <span class='overload'>#<strong>async_set_client_encoding</strong>(encoding)  </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#client_encoding=-instance_method" title="PG::Connection#client_encoding= (method)">#client_encoding=</a>.</p>

  </div>
</div>

</section>

<section class='method_details' id="async_setnonblocking-instance_method">
  <h3 class='signature '>
    #<strong>async_setnonblocking</strong>(enabled)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#setnonblocking-instance_method" title="PG::Connection#setnonblocking (method)">#setnonblocking</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L462-L462'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='462' data-end='462'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 462</span></pre>
<pre class='code ruby'>

<span class='kw'>alias</span> <span class='id identifier rubyid_async_setnonblocking'>async_setnonblocking</span> <span class='id identifier rubyid_setnonblocking'><a href="#setnonblocking-instance_method" title="PG::Connection#setnonblocking (method)">setnonblocking</a></span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="backend_key-instance_method">
  <h3 class='signature '>
    #<strong>backend_key</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>key of backend — needed for cancels</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1010-L1029'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1010' data-end='1029'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1010</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_backend_key(VALUE self)
{
	int be_key;
	struct pg_cancel *cancel;
	PGconn *conn = pg_get_pgconn(self);

	cancel = (struct pg_cancel*)PQgetCancel(conn);
	if(cancel == NULL)
		pg_raise_conn_error( rb_ePGerror, self, &quot;Invalid connection!&quot;);

	if( cancel-&gt;be_pid != PQbackendPID(conn) )
		rb_raise(rb_ePGerror,&quot;Unexpected binary struct layout - please file a bug report at ruby-pg!&quot;);

	be_key = cancel-&gt;be_key;

	PQfreeCancel(cancel);

	return INT2NUM(be_key);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="backend_pid-instance_method">
  <h3 class='signature '>
    #<strong>backend_pid</strong>  &#x21d2; <code>Integer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the process ID of the backend server process for this connection. Note that this is a PID on database server host.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L980-L984'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='980' data-end='984'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 980</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_backend_pid(VALUE self)
{
	return INT2NUM(PQbackendPID(pg_get_pgconn(self)));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="block-instance_method">
  <h3 class='signature '>
    #<strong>block</strong>([ timeout ])  &#x21d2; <code>Boolean</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Blocks until the server is no longer busy, or until the optional <em>timeout</em> is reached, whichever comes first. <em>timeout</em> is measured in seconds and can be fractional.</p>

<p>Returns <code>false</code> if <em>timeout</em> is reached, <code>true</code> otherwise.</p>

<p>If <code>true</code> is returned, <code>conn.is_busy</code> will return <code>false</code> and <code>conn.get_result</code> will not block.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3050-L3071'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3050' data-end='3071'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3050</span></pre>
<pre class='code cpp'>

VALUE
pgconn_block( int argc, VALUE *argv, VALUE self ) {
	struct timeval timeout;
	struct timeval *ptimeout = NULL;
	VALUE timeout_in;
	double timeout_sec;
	void *ret;

	if ( rb_scan_args(argc, argv, &quot;01&quot;, &amp;timeout_in) == 1 ) {
		timeout_sec = NUM2DBL( timeout_in );
		timeout.tv_sec = (time_t)timeout_sec;
		timeout.tv_usec = (suseconds_t)((timeout_sec - (long)timeout_sec) * 1e6);
		ptimeout = &amp;timeout;
	}

	ret = wait_socket_readable( self, ptimeout, get_result_readable);

	if( !ret )
		return Qfalse;

	return Qtrue;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="cancel-instance_method">
  <h3 class='signature '>
    #<strong>cancel</strong>  &#x21d2; <code>String</code>     <span class='aliases'>Also known as: <span class='names'>#async_cancel</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Requests cancellation of the command currently being processed.</p>

<p>Returns <code>nil</code> on success, or a string containing the error message if a failure occurs.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L587-L639'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='587' data-end='639'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 587</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_cancel'>cancel</span>
	<span class='id identifier rubyid_be_pid'>be_pid</span> <span class='op'>=</span> <span class='id identifier rubyid_backend_pid'><a href="#backend_pid-instance_method" title="PG::Connection#backend_pid (method)">backend_pid</a></span>
	<span class='id identifier rubyid_be_key'>be_key</span> <span class='op'>=</span> <span class='id identifier rubyid_backend_key'><a href="#backend_key-instance_method" title="PG::Connection#backend_key (method)">backend_key</a></span>
	<span class='id identifier rubyid_cancel_request'>cancel_request</span> <span class='op'>=</span> [<span class='int'>0x10</span><span class='comma'>,</span> <span class='int'>1234</span><span class='comma'>,</span> <span class='int'>5678</span><span class='comma'>,</span> <span class='id identifier rubyid_be_pid'>be_pid</span><span class='comma'>,</span> <span class='id identifier rubyid_be_key'>be_key</span>].<span class='id identifier rubyid_pack'>pack</span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>NnnNN</span><span class='tstring_end'>&quot;</span></span>)

	<span class='kw'>if</span> <span class='const'>Fiber</span>.<span class='id identifier rubyid_respond_to?'>respond_to?</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_scheduler'>scheduler</span>) <span class='op'>&amp;&amp;</span> <span class='const'>Fiber</span>.<span class='id identifier rubyid_scheduler'>scheduler</span> <span class='op'>&amp;&amp;</span> <span class='const'>RUBY_PLATFORM</span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>mingw|mswin</span><span class='regexp_end'>/</span></span>
		<span class='comment'># Ruby&#39;s nonblocking IO is not really supported on Windows.
</span>		<span class='comment'># We work around by using threads and explicit calls to wait_readable/wait_writable.
</span>		<span class='id identifier rubyid_cl'>cl</span> <span class='op'>=</span> <span class='const'>Thread</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="PG::Connection.new (method)">new</a></span>(<span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>.<span class='id identifier rubyid_remote_address'>remote_address</span>) { <span class='op'>|</span><span class='id identifier rubyid_ra'>ra</span><span class='op'>|</span> <span class='id identifier rubyid_ra'>ra</span>.<span class='id identifier rubyid_connect'><a href="#connect-class_method" title="PG::Connection.connect (method)">connect</a></span> }.<span class='id identifier rubyid_value'>value</span>
		<span class='kw'>begin</span>
			<span class='id identifier rubyid_cl'>cl</span>.<span class='id identifier rubyid_write_nonblock'>write_nonblock</span>(<span class='id identifier rubyid_cancel_request'>cancel_request</span>)
		<span class='kw'>rescue</span> <span class='const'>IO</span><span class='op'>::</span><span class='const'>WaitReadable</span><span class='comma'>,</span> <span class='const'>Errno</span><span class='op'>::</span><span class='const'>EINTR</span>
			<span class='id identifier rubyid_cl'>cl</span>.<span class='id identifier rubyid_wait_writable'>wait_writable</span>
			<span class='kw'>retry</span>
		<span class='kw'>end</span>
		<span class='kw'>begin</span>
			<span class='id identifier rubyid_cl'>cl</span>.<span class='id identifier rubyid_read_nonblock'>read_nonblock</span>(<span class='int'>1</span>)
		<span class='kw'>rescue</span> <span class='const'>IO</span><span class='op'>::</span><span class='const'>WaitReadable</span><span class='comma'>,</span> <span class='const'>Errno</span><span class='op'>::</span><span class='const'>EINTR</span>
			<span class='id identifier rubyid_cl'>cl</span>.<span class='id identifier rubyid_wait_readable'>wait_readable</span>
			<span class='kw'>retry</span>
		<span class='kw'>rescue</span> <span class='const'>EOFError</span>
		<span class='kw'>end</span>
	<span class='kw'>elsif</span> <span class='const'>RUBY_ENGINE</span> <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>truffleruby</span><span class='tstring_end'>&#39;</span></span>
		<span class='kw'>begin</span>
			<span class='id identifier rubyid_cl'>cl</span> <span class='op'>=</span> <span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>.<span class='id identifier rubyid_remote_address'>remote_address</span>.<span class='id identifier rubyid_connect'><a href="#connect-class_method" title="PG::Connection.connect (method)">connect</a></span>
		<span class='kw'>rescue</span> <span class='const'>NotImplementedError</span>
			<span class='comment'># Workaround for truffleruby &lt; 21.3.0
</span>			<span class='id identifier rubyid_cl2'>cl2</span> <span class='op'>=</span> <span class='const'>Socket</span>.<span class='id identifier rubyid_for_fd'>for_fd</span>(<span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>.<span class='id identifier rubyid_fileno'>fileno</span>)
			<span class='id identifier rubyid_cl2'>cl2</span>.<span class='id identifier rubyid_autoclose'>autoclose</span> <span class='op'>=</span> <span class='kw'>false</span>
			<span class='id identifier rubyid_adr'>adr</span> <span class='op'>=</span> <span class='id identifier rubyid_cl2'>cl2</span>.<span class='id identifier rubyid_remote_address'>remote_address</span>
			<span class='kw'>if</span> <span class='id identifier rubyid_adr'>adr</span>.<span class='id identifier rubyid_ip?'>ip?</span>
				<span class='id identifier rubyid_cl'>cl</span> <span class='op'>=</span> <span class='const'>TCPSocket</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="PG::Connection.new (method)">new</a></span>(<span class='id identifier rubyid_adr'>adr</span>.<span class='id identifier rubyid_ip_address'>ip_address</span><span class='comma'>,</span> <span class='id identifier rubyid_adr'>adr</span>.<span class='id identifier rubyid_ip_port'>ip_port</span>)
				<span class='id identifier rubyid_cl'>cl</span>.<span class='id identifier rubyid_autoclose'>autoclose</span> <span class='op'>=</span> <span class='kw'>false</span>
			<span class='kw'>else</span>
				<span class='id identifier rubyid_cl'>cl</span> <span class='op'>=</span> <span class='const'>UNIXSocket</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="PG::Connection.new (method)">new</a></span>(<span class='id identifier rubyid_adr'>adr</span>.<span class='id identifier rubyid_unix_path'>unix_path</span>)
				<span class='id identifier rubyid_cl'>cl</span>.<span class='id identifier rubyid_autoclose'>autoclose</span> <span class='op'>=</span> <span class='kw'>false</span>
			<span class='kw'>end</span>
		<span class='kw'>end</span>
		<span class='id identifier rubyid_cl'>cl</span>.<span class='id identifier rubyid_write'>write</span>(<span class='id identifier rubyid_cancel_request'>cancel_request</span>)
		<span class='id identifier rubyid_cl'>cl</span>.<span class='id identifier rubyid_read'>read</span>(<span class='int'>1</span>)
	<span class='kw'>else</span>
		<span class='id identifier rubyid_cl'>cl</span> <span class='op'>=</span> <span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>.<span class='id identifier rubyid_remote_address'>remote_address</span>.<span class='id identifier rubyid_connect'><a href="#connect-class_method" title="PG::Connection.connect (method)">connect</a></span>
		<span class='comment'># Send CANCEL_REQUEST_CODE and parameters
</span>		<span class='id identifier rubyid_cl'>cl</span>.<span class='id identifier rubyid_write'>write</span>(<span class='id identifier rubyid_cancel_request'>cancel_request</span>)
		<span class='comment'># Wait for the postmaster to close the connection, which indicates that it&#39;s processed the request.
</span>		<span class='id identifier rubyid_cl'>cl</span>.<span class='id identifier rubyid_read'>read</span>(<span class='int'>1</span>)
	<span class='kw'>end</span>

	<span class='id identifier rubyid_cl'>cl</span>.<span class='id identifier rubyid_close'><a href="#close-instance_method" title="PG::Connection#close (method)">close</a></span>
	<span class='kw'>nil</span>
<span class='kw'>rescue</span> <span class='const'>SystemCallError</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_err'>err</span>
	<span class='id identifier rubyid_err'>err</span>.<span class='id identifier rubyid_to_s'>to_s</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="check_socket-instance_method">
  <h3 class='signature '>
    #<strong>check_socket</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Read all pending socket input to internal memory and raise an exception in case of errors.</p>

<p>This verifies that the connection socket is in a usable state and not aborted in any way. No communication is done with the server. Only pending data is read from the socket - the method doesn’t wait for any outstanding server answers.</p>

<p>Raises a kind of <a href="Error.html" title="PG::Error (class)"><code>Error</code></a> if there was an error reading the data or if the socket is in a failure state.</p>

<p>The method doesn’t verify that the server is still responding. To verify that the communication to the server works, it is recommended to use something like <code>conn.exec(&#39;&#39;)</code> instead.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L379-L384'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='379' data-end='384'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 379</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_check_socket'>check_socket</span>
	<span class='kw'>while</span> <span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>.<span class='id identifier rubyid_wait_readable'>wait_readable</span>(<span class='int'>0</span>)
		<span class='id identifier rubyid_consume_input'><a href="#consume_input-instance_method" title="PG::Connection#consume_input (method)">consume_input</a></span>
	<span class='kw'>end</span>
	<span class='kw'>nil</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="client_encoding=-instance_method">
  <h3 class='signature '>
    #<strong>client_encoding=</strong>(encoding)      <span class='aliases'>Also known as: <span class='names'>#set_client_encoding, #async_set_client_encoding</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sets the client encoding to the <em>encoding</em> String.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4147-L4161'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4147' data-end='4161'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4147</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_async_set_client_encoding(VALUE self, VALUE encname)
{
	VALUE query_format, query;

	rb_check_frozen(self);
	Check_Type(encname, T_STRING);
	query_format = rb_str_new_cstr(&quot;set client_encoding to &#39;%s&#39;&quot;);
	query = rb_funcall(query_format, rb_intern(&quot;%&quot;), 1, encname);

	pgconn_async_exec(1, &amp;query, self);
	pgconn_set_internal_encoding_index( self );

	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="close-instance_method">
  <h3 class='signature '>
    #<strong>close</strong>      <span class='aliases'>Also known as: <span class='names'>#finish</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Closes the backend connection.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L531-L540'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='531' data-end='540'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 531</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_finish( VALUE self )
{
	t_pg_connection *this = pg_get_connection_safe( self );

	pgconn_close_socket_io( self );
	PQfinish( this-&gt;pgconn );
	this-&gt;pgconn = NULL;
	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="conndefaults-instance_method">
  <h3 class='signature '>
    #<strong>conndefaults</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns an array of Hashes with connection defaults. See <a href="#conndefaults-class_method" title="PG::Connection.conndefaults (method)">.conndefaults</a> for details.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L321-L323'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='321' data-end='323'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 321</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_conndefaults'>conndefaults</span>
	<span class='kw'>return</span> <span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span>.<span class='id identifier rubyid_conndefaults'>conndefaults</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="conndefaults_hash-instance_method">
  <h3 class='signature '>
    #<strong>conndefaults_hash</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns a Hash with connection defaults. See <a href="#conndefaults_hash-class_method" title="PG::Connection.conndefaults_hash (method)">.conndefaults_hash</a> for details.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L337-L339'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='337' data-end='339'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 337</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_conndefaults_hash'>conndefaults_hash</span>
	<span class='kw'>return</span> <span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span>.<span class='id identifier rubyid_conndefaults_hash'>conndefaults_hash</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="connect_poll-instance_method">
  <h3 class='signature '>
    #<strong>connect_poll</strong>  &#x21d2; <code>Integer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns one of:</p>
<dl class="rdoc-list label-list"><dt><code>PGRES_POLLING_READING</code>
<dd>
<p>wait until the socket is ready to read</p>
</dd><dt><code>PGRES_POLLING_WRITING</code>
<dd>
<p>wait until the socket is ready to write</p>
</dd><dt><code>PGRES_POLLING_FAILED</code>
<dd>
<p>the asynchronous connection has failed</p>
</dd><dt><code>PGRES_POLLING_OK</code>
<dd>
<p>the asynchronous connection is ready</p>
</dd></dl>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>io/wait</span><span class='tstring_end'>&quot;</span></span>

<span class='id identifier rubyid_conn'>conn</span> <span class='op'>=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'>Connection</span>.<span class='id identifier rubyid_connect_start'><a href="#connect_start-class_method" title="PG::Connection.connect_start (method)">connect_start</a></span>(<span class='label'>dbname:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>mydatabase</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_status'><a href="#status-instance_method" title="PG::Connection#status (method)">status</a></span> <span class='op'>=</span> <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_connect_poll'>connect_poll</span>
<span class='kw'>while</span>(<span class='id identifier rubyid_status'><a href="#status-instance_method" title="PG::Connection#status (method)">status</a></span> <span class='op'>!=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#PGRES_POLLING_OK-constant" title="PG::Constants::PGRES_POLLING_OK (constant)">PGRES_POLLING_OK</a></span>) <span class='kw'>do</span>
  <span class='comment'># do some work while waiting for the connection to complete
</span>  <span class='kw'>if</span>(<span class='id identifier rubyid_status'><a href="#status-instance_method" title="PG::Connection#status (method)">status</a></span> <span class='op'>==</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#PGRES_POLLING_READING-constant" title="PG::Constants::PGRES_POLLING_READING (constant)">PGRES_POLLING_READING</a></span>)
    <span class='kw'>unless</span> <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>.<span class='id identifier rubyid_wait_readable'>wait_readable</span>(<span class='float'>10.0</span>)
      <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Asynchronous connection timed out!</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>
  <span class='kw'>elsif</span>(<span class='id identifier rubyid_status'><a href="#status-instance_method" title="PG::Connection#status (method)">status</a></span> <span class='op'>==</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#PGRES_POLLING_WRITING-constant" title="PG::Constants::PGRES_POLLING_WRITING (constant)">PGRES_POLLING_WRITING</a></span>)
    <span class='kw'>unless</span> <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>.<span class='id identifier rubyid_wait_writable'>wait_writable</span>(<span class='float'>10.0</span>)
      <span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Asynchronous connection timed out!</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_status'><a href="#status-instance_method" title="PG::Connection#status (method)">status</a></span> <span class='op'>=</span> <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_connect_poll'>connect_poll</span>
<span class='kw'>end</span>
<span class='comment'># now conn.status == CONNECTION_OK, and connection
</span><span class='comment'># is ready.</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L514-L523'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='514' data-end='523'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 514</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_connect_poll(VALUE self)
{
	PostgresPollingStatusType status;

	pgconn_close_socket_io(self);
	status = gvl_PQconnectPoll(pg_get_pgconn(self));

	return INT2FIX((int)status);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="connection_needs_password-instance_method">
  <h3 class='signature '>
    #<strong>connection_needs_password</strong>  &#x21d2; <code>Boolean</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns <code>true</code> if the authentication method required a password, but none was available. <code>false</code> otherwise.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1038-L1042'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1038' data-end='1042'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1038</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_connection_needs_password(VALUE self)
{
	return PQconnectionNeedsPassword(pg_get_pgconn(self)) ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="connection_used_password-instance_method">
  <h3 class='signature '>
    #<strong>connection_used_password</strong>  &#x21d2; <code>Boolean</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns <code>true</code> if the authentication method used a caller-supplied password, <code>false</code> otherwise.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1051-L1055'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1051' data-end='1055'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1051</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_connection_used_password(VALUE self)
{
	return PQconnectionUsedPassword(pg_get_pgconn(self)) ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="conninfo-instance_method">
  <h3 class='signature '>
    #<strong>conninfo</strong>  &#x21d2; <code>Hash</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the connection options used by a live connection.</p>

<p>Available since PostgreSQL-9.3</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L764-L774'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='764' data-end='774'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 764</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_conninfo( VALUE self )
{
	PGconn *conn = pg_get_pgconn(self);
	PQconninfoOption *options = PQconninfo( conn );
	VALUE array = pgconn_make_conninfo_array( options );

	PQconninfoFree(options);

	return array;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="conninfo_hash-instance_method">
  <h3 class='signature '>
    #<strong>conninfo_hash</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Return the Postgres connection info structure as a Hash keyed by option keyword (as a Symbol).</p>

<p>See also <a href="#conninfo-instance_method" title="PG::Connection#conninfo (method)">#conninfo</a></p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L345-L349'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='345' data-end='349'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 345</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_conninfo_hash'>conninfo_hash</span>
	<span class='kw'>return</span> <span class='kw'>self</span>.<span class='id identifier rubyid_conninfo'><a href="#conninfo-instance_method" title="PG::Connection#conninfo (method)">conninfo</a></span>.<span class='id identifier rubyid_each_with_object'>each_with_object</span>({}) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_info'>info</span><span class='comma'>,</span> <span class='id identifier rubyid_hash'>hash</span><span class='op'>|</span>
		<span class='id identifier rubyid_hash'>hash</span>[ <span class='id identifier rubyid_info'>info</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_keyword'>keyword</span>].<span class='id identifier rubyid_to_sym'>to_sym</span> ] <span class='op'>=</span> <span class='id identifier rubyid_info'>info</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_val'>val</span>]
	<span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="consume_input-instance_method">
  <h3 class='signature '>
    #<strong>consume_input</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>If input is available from the server, consume it. After calling <code>consume_input</code>, you can check <a href="#is_busy-instance_method" title="PG::Connection#is_busy (method)">#is_busy</a> or <strong>notifies</strong> to see if the state has changed.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2143-L2154'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2143' data-end='2154'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2143</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_consume_input(VALUE self)
{
	PGconn *conn = pg_get_pgconn(self);
	/* returns 0 on error */
	if(PQconsumeInput(conn) == 0) {
		pgconn_close_socket_io(self);
		pg_raise_conn_error( rb_eConnectionBad, self, &quot;%s&quot;, PQerrorMessage(conn));
	}

	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="copy_data-instance_method">
  <h3 class='signature '>
    #<strong>copy_data</strong>(sql [, coder] ) {|sql_result| ... } &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Execute a copy process for transferring data to or from the server.</p>

<p>This issues the SQL COPY command via <a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a>. The response to this (if there is no error in the command) is a <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> object that is passed to the block, bearing a status code of PGRES_COPY_OUT or PGRES_COPY_IN (depending on the specified copy direction). The application should then use <a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">#put_copy_data</a> or <a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">#get_copy_data</a> to receive or transmit data rows and should return from the block when finished.</p>

<p><code>#copy_data</code> returns another <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> object when the data transfer is complete. An exception is raised if some problem was encountered, so it isn’t required to make use of any of them. At this point further SQL commands can be issued via <a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a>. (It is not possible to execute other SQL commands using the same connection while the COPY operation is in progress.)</p>

<p>This method ensures, that the copy process is properly terminated in case of client side or server side failures. Therefore, in case of blocking mode of operation, <code>#copy_data</code> is preferred to raw calls of <a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">#put_copy_data</a>, <a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">#get_copy_data</a> and <a href="#put_copy_end-instance_method" title="PG::Connection#put_copy_end (method)">#put_copy_end</a>.</p>

<p><em>coder</em> can be a <a href="Coder.html" title="PG::Coder (class)"><code>Coder</code></a> derivation (typically <a href="TextEncoder/CopyRow.html" title="PG::TextEncoder::CopyRow (class)"><code>TextEncoder::CopyRow</code></a> or <a href="TextDecoder/CopyRow.html" title="PG::TextDecoder::CopyRow (class)"><code>TextDecoder::CopyRow</code></a>). This enables encoding of data fields given to <a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">#put_copy_data</a> or decoding of fields received by <a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">#get_copy_data</a>.</p>

<p>Example with CSV input format:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_exec'><a href="#exec-instance_method" title="PG::Connection#exec (method)">exec</a></span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>create table my_table (a text,b text,c text,d text)</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_copy_data'>copy_data</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>COPY my_table FROM STDIN CSV</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_put_copy_data'><a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">put_copy_data</a></span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>some,data,to,copy\n</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_put_copy_data'><a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">put_copy_data</a></span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>more,data,to,copy\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span></code></pre>

<p>This creates <code>my_table</code> and inserts two CSV rows.</p>

<p>The same with text format encoder <a href="TextEncoder/CopyRow.html" title="PG::TextEncoder::CopyRow (class)"><code>TextEncoder::CopyRow</code></a> and Array input:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_enco'>enco</span> <span class='op'>=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="TextEncoder.html" title="PG::TextEncoder (module)">TextEncoder</a></span><span class='op'>::</span><span class='const'><a href="TextEncoder/CopyRow.html" title="PG::TextEncoder::CopyRow (class)">CopyRow</a></span>.<span class='id identifier rubyid_new'><a href="Coder.html#new-class_method" title="PG::Coder.new (method)">new</a></span>
<span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_copy_data'>copy_data</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>COPY my_table FROM STDIN</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_enco'>enco</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_put_copy_data'><a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">put_copy_data</a></span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>data</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>to</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>copy</span><span class='tstring_end'>&#39;</span></span>]
  <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_put_copy_data'><a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">put_copy_data</a></span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>more</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>data</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>to</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>copy</span><span class='tstring_end'>&#39;</span></span>]
<span class='kw'>end</span></code></pre>

<p>Also <a href="BinaryEncoder/CopyRow.html" title="PG::BinaryEncoder::CopyRow (class)"><code>BinaryEncoder::CopyRow</code></a> can be used to send data in binary format to the server. In this case copy_data generates the header and trailer data automatically:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_enco'>enco</span> <span class='op'>=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="BinaryEncoder.html" title="PG::BinaryEncoder (module)">BinaryEncoder</a></span><span class='op'>::</span><span class='const'><a href="BinaryEncoder/CopyRow.html" title="PG::BinaryEncoder::CopyRow (class)">CopyRow</a></span>.<span class='id identifier rubyid_new'><a href="Coder.html#new-class_method" title="PG::Coder.new (method)">new</a></span>
<span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_copy_data'>copy_data</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>COPY my_table FROM STDIN (FORMAT binary)</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_enco'>enco</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_put_copy_data'><a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">put_copy_data</a></span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>data</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>to</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>copy</span><span class='tstring_end'>&#39;</span></span>]
  <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_put_copy_data'><a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">put_copy_data</a></span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>more</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>data</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>to</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>copy</span><span class='tstring_end'>&#39;</span></span>]
<span class='kw'>end</span></code></pre>

<p>Example with CSV output format:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_copy_data'>copy_data</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>COPY my_table TO STDOUT CSV</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>do</span>
  <span class='kw'>while</span> <span class='id identifier rubyid_row'>row</span><span class='op'>=</span><span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_get_copy_data'><a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">get_copy_data</a></span>
    <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_row'>row</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>This prints all rows of <code>my_table</code> to stdout:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>some,data,to,copy\n</span><span class='tstring_end'>&quot;</span></span>
<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>more,data,to,copy\n</span><span class='tstring_end'>&quot;</span></span></code></pre>

<p>The same with text format decoder <a href="TextDecoder/CopyRow.html" title="PG::TextDecoder::CopyRow (class)"><code>TextDecoder::CopyRow</code></a> and Array output:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_deco'>deco</span> <span class='op'>=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="TextDecoder.html" title="PG::TextDecoder (module)">TextDecoder</a></span><span class='op'>::</span><span class='const'><a href="TextDecoder/CopyRow.html" title="PG::TextDecoder::CopyRow (class)">CopyRow</a></span>.<span class='id identifier rubyid_new'><a href="Coder.html#new-class_method" title="PG::Coder.new (method)">new</a></span>
<span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_copy_data'>copy_data</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>COPY my_table TO STDOUT</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_deco'>deco</span> <span class='kw'>do</span>
  <span class='kw'>while</span> <span class='id identifier rubyid_row'>row</span><span class='op'>=</span><span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_get_copy_data'><a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">get_copy_data</a></span>
    <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_row'>row</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>This receives all rows of <code>my_table</code> as ruby array:</p>

<pre class="code ruby"><code class="ruby">[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>some</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>data</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>to</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>copy</span><span class='tstring_end'>&quot;</span></span>]
[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>more</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>data</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>to</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>copy</span><span class='tstring_end'>&quot;</span></span>]</code></pre>

<p>Also <a href="BinaryDecoder/CopyRow.html" title="PG::BinaryDecoder::CopyRow (class)"><code>BinaryDecoder::CopyRow</code></a> can be used to retrieve data in binary format from the server. In this case the header and trailer data is processed by the decoder and the remaining <code>nil</code> from get_copy_data is processed by copy_data, so that binary data can be processed equally to text data:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_deco'>deco</span> <span class='op'>=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="BinaryDecoder.html" title="PG::BinaryDecoder (module)">BinaryDecoder</a></span><span class='op'>::</span><span class='const'><a href="BinaryDecoder/CopyRow.html" title="PG::BinaryDecoder::CopyRow (class)">CopyRow</a></span>.<span class='id identifier rubyid_new'><a href="Coder.html#new-class_method" title="PG::Coder.new (method)">new</a></span>
<span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_copy_data'>copy_data</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>COPY my_table TO STDOUT (FORMAT binary)</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_deco'>deco</span> <span class='kw'>do</span>
  <span class='kw'>while</span> <span class='id identifier rubyid_row'>row</span><span class='op'>=</span><span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_get_copy_data'><a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">get_copy_data</a></span>
    <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_row'>row</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>This receives all rows of <code>my_table</code> as ruby array:</p>

<pre class="code ruby"><code class="ruby">[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>some</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>data</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>to</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>copy</span><span class='tstring_end'>&quot;</span></span>]
[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>more</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>data</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>to</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>copy</span><span class='tstring_end'>&quot;</span></span>]</code></pre>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<a href="NotInBlockingMode.html" title="PG::NotInBlockingMode (class)">PG::NotInBlockingMode</a>)</span>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L211-L291'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='211' data-end='291'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 211</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_copy_data'>copy_data</span>( <span class='id identifier rubyid_sql'>sql</span><span class='comma'>,</span> <span class='id identifier rubyid_coder'>coder</span><span class='op'>=</span><span class='kw'>nil</span> )
	<span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="NotInBlockingMode.html" title="PG::NotInBlockingMode (class)">NotInBlockingMode</a></span>.<span class='id identifier rubyid_new'><a href="Error.html#new-class_method" title="PG::Error.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>copy_data can not be used in nonblocking mode</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>connection:</span> <span class='kw'>self</span>) <span class='kw'>if</span> <span class='id identifier rubyid_nonblocking?'><a href="#nonblocking%3F-instance_method" title="PG::Connection#nonblocking? (method)">nonblocking?</a></span>
	<span class='id identifier rubyid_res'>res</span> <span class='op'>=</span> <span class='id identifier rubyid_exec'><a href="#exec-instance_method" title="PG::Connection#exec (method)">exec</a></span>( <span class='id identifier rubyid_sql'>sql</span> )

	<span class='kw'>case</span> <span class='id identifier rubyid_res'>res</span>.<span class='id identifier rubyid_result_status'>result_status</span>
	<span class='kw'>when</span> <span class='const'><a href="Constants.html#PGRES_COPY_IN-constant" title="PG::Constants::PGRES_COPY_IN (constant)">PGRES_COPY_IN</a></span>
		<span class='kw'>begin</span>
			<span class='kw'>if</span> <span class='id identifier rubyid_coder'>coder</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_res'>res</span>.<span class='id identifier rubyid_binary_tuples'>binary_tuples</span> <span class='op'>==</span> <span class='int'>1</span>
				<span class='comment'># Binary file header (11 byte signature, 32 bit flags and 32 bit extension length)
</span>				<span class='id identifier rubyid_put_copy_data'><a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">put_copy_data</a></span>(<span class='const'><a href="#BinarySignature-constant" title="PG::Connection::BinarySignature (constant)">BinarySignature</a></span> <span class='op'>+</span> (<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\x00</span><span class='tstring_end'>&quot;</span></span> <span class='op'>*</span> <span class='int'>8</span>))
			<span class='kw'>end</span>

			<span class='kw'>if</span> <span class='id identifier rubyid_coder'>coder</span>
				<span class='id identifier rubyid_old_coder'>old_coder</span> <span class='op'>=</span> <span class='kw'>self</span>.<span class='id identifier rubyid_encoder_for_put_copy_data'><a href="#encoder_for_put_copy_data-instance_method" title="PG::Connection#encoder_for_put_copy_data (method)">encoder_for_put_copy_data</a></span>
				<span class='kw'>self</span>.<span class='id identifier rubyid_encoder_for_put_copy_data'><a href="#encoder_for_put_copy_data-instance_method" title="PG::Connection#encoder_for_put_copy_data (method)">encoder_for_put_copy_data</a></span> <span class='op'>=</span> <span class='id identifier rubyid_coder'>coder</span>
			<span class='kw'>end</span>

			<span class='kw'>yield</span> <span class='id identifier rubyid_res'>res</span>
		<span class='kw'>rescue</span> <span class='const'>Exception</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_err'>err</span>
			<span class='id identifier rubyid_errmsg'>errmsg</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>%s while copy data: %s</span><span class='tstring_end'>&quot;</span></span> <span class='op'>%</span> [ <span class='id identifier rubyid_err'>err</span>.<span class='id identifier rubyid_class'>class</span>.<span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_err'>err</span>.<span class='id identifier rubyid_message'>message</span> ]
			<span class='kw'>begin</span>
				<span class='id identifier rubyid_put_copy_end'><a href="#put_copy_end-instance_method" title="PG::Connection#put_copy_end (method)">put_copy_end</a></span>( <span class='id identifier rubyid_errmsg'>errmsg</span> )
			<span class='kw'>rescue</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Error.html" title="PG::Error (class)">Error</a></span>
				<span class='comment'># Ignore error in cleanup to avoid losing original exception
</span>			<span class='kw'>end</span>
			<span class='id identifier rubyid_discard_results'><a href="#discard_results-instance_method" title="PG::Connection#discard_results (method)">discard_results</a></span>
			<span class='id identifier rubyid_raise'>raise</span> <span class='id identifier rubyid_err'>err</span>
		<span class='kw'>else</span>
			<span class='kw'>begin</span>
				<span class='kw'>self</span>.<span class='id identifier rubyid_encoder_for_put_copy_data'><a href="#encoder_for_put_copy_data-instance_method" title="PG::Connection#encoder_for_put_copy_data (method)">encoder_for_put_copy_data</a></span> <span class='op'>=</span> <span class='id identifier rubyid_old_coder'>old_coder</span> <span class='kw'>if</span> <span class='id identifier rubyid_coder'>coder</span>

				<span class='kw'>if</span> <span class='id identifier rubyid_coder'>coder</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_res'>res</span>.<span class='id identifier rubyid_binary_tuples'>binary_tuples</span> <span class='op'>==</span> <span class='int'>1</span>
					<span class='id identifier rubyid_put_copy_data'><a href="#put_copy_data-instance_method" title="PG::Connection#put_copy_data (method)">put_copy_data</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xFF\xFF</span><span class='tstring_end'>&quot;</span></span>) <span class='comment'># Binary file trailer 16 bit &quot;-1&quot;
</span>				<span class='kw'>end</span>

				<span class='id identifier rubyid_put_copy_end'><a href="#put_copy_end-instance_method" title="PG::Connection#put_copy_end (method)">put_copy_end</a></span>
			<span class='kw'>rescue</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Error.html" title="PG::Error (class)">Error</a></span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_err'>err</span>
				<span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="LostCopyState.html" title="PG::LostCopyState (class)">LostCopyState</a></span>.<span class='id identifier rubyid_new'><a href="Error.html#new-class_method" title="PG::Error.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_err'>err</span><span class='embexpr_end'>}</span><span class='tstring_content'> (probably by executing another SQL query while running a COPY command)</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>connection:</span> <span class='kw'>self</span>)
			<span class='kw'>end</span>
			<span class='id identifier rubyid_get_last_result'><a href="#get_last_result-instance_method" title="PG::Connection#get_last_result (method)">get_last_result</a></span>
		<span class='kw'>ensure</span>
			<span class='kw'>self</span>.<span class='id identifier rubyid_encoder_for_put_copy_data'><a href="#encoder_for_put_copy_data-instance_method" title="PG::Connection#encoder_for_put_copy_data (method)">encoder_for_put_copy_data</a></span> <span class='op'>=</span> <span class='id identifier rubyid_old_coder'>old_coder</span> <span class='kw'>if</span> <span class='id identifier rubyid_coder'>coder</span>
		<span class='kw'>end</span>

	<span class='kw'>when</span> <span class='const'><a href="Constants.html#PGRES_COPY_OUT-constant" title="PG::Constants::PGRES_COPY_OUT (constant)">PGRES_COPY_OUT</a></span>
		<span class='kw'>begin</span>
			<span class='kw'>if</span> <span class='id identifier rubyid_coder'>coder</span>
				<span class='id identifier rubyid_old_coder'>old_coder</span> <span class='op'>=</span> <span class='kw'>self</span>.<span class='id identifier rubyid_decoder_for_get_copy_data'><a href="#decoder_for_get_copy_data-instance_method" title="PG::Connection#decoder_for_get_copy_data (method)">decoder_for_get_copy_data</a></span>
				<span class='kw'>self</span>.<span class='id identifier rubyid_decoder_for_get_copy_data'><a href="#decoder_for_get_copy_data-instance_method" title="PG::Connection#decoder_for_get_copy_data (method)">decoder_for_get_copy_data</a></span> <span class='op'>=</span> <span class='id identifier rubyid_coder'>coder</span>
			<span class='kw'>end</span>
			<span class='kw'>yield</span> <span class='id identifier rubyid_res'>res</span>
		<span class='kw'>rescue</span> <span class='const'>Exception</span>
			<span class='id identifier rubyid_cancel'><a href="#cancel-instance_method" title="PG::Connection#cancel (method)">cancel</a></span>
			<span class='id identifier rubyid_discard_results'><a href="#discard_results-instance_method" title="PG::Connection#discard_results (method)">discard_results</a></span>
			<span class='id identifier rubyid_raise'>raise</span>
		<span class='kw'>else</span>
			<span class='kw'>if</span> <span class='id identifier rubyid_coder'>coder</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_res'>res</span>.<span class='id identifier rubyid_binary_tuples'>binary_tuples</span> <span class='op'>==</span> <span class='int'>1</span>
				<span class='comment'># There are two end markers in binary mode: file trailer and the final nil.
</span>				<span class='comment'># The file trailer is expected to be processed by BinaryDecoder::CopyRow and already returns nil, so that the remaining NULL from PQgetCopyData is retrieved here:
</span>				<span class='kw'>if</span> <span class='id identifier rubyid_get_copy_data'><a href="#get_copy_data-instance_method" title="PG::Connection#get_copy_data (method)">get_copy_data</a></span>
					<span class='id identifier rubyid_discard_results'><a href="#discard_results-instance_method" title="PG::Connection#discard_results (method)">discard_results</a></span>
					<span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="NotAllCopyDataRetrieved.html" title="PG::NotAllCopyDataRetrieved (class)">NotAllCopyDataRetrieved</a></span>.<span class='id identifier rubyid_new'><a href="Error.html#new-class_method" title="PG::Error.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Not all binary COPY data retrieved</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>connection:</span> <span class='kw'>self</span>)
				<span class='kw'>end</span>
			<span class='kw'>end</span>
			<span class='id identifier rubyid_res'>res</span> <span class='op'>=</span> <span class='id identifier rubyid_get_last_result'><a href="#get_last_result-instance_method" title="PG::Connection#get_last_result (method)">get_last_result</a></span>
			<span class='kw'>if</span> <span class='op'>!</span><span class='id identifier rubyid_res'>res</span>
				<span class='id identifier rubyid_discard_results'><a href="#discard_results-instance_method" title="PG::Connection#discard_results (method)">discard_results</a></span>
				<span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="LostCopyState.html" title="PG::LostCopyState (class)">LostCopyState</a></span>.<span class='id identifier rubyid_new'><a href="Error.html#new-class_method" title="PG::Error.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Lost COPY state (probably by executing another SQL query while running a COPY command)</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>connection:</span> <span class='kw'>self</span>)
			<span class='kw'>elsif</span> <span class='id identifier rubyid_res'>res</span>.<span class='id identifier rubyid_result_status'>result_status</span> <span class='op'>!=</span> <span class='const'><a href="Constants.html#PGRES_COMMAND_OK-constant" title="PG::Constants::PGRES_COMMAND_OK (constant)">PGRES_COMMAND_OK</a></span>
				<span class='id identifier rubyid_discard_results'><a href="#discard_results-instance_method" title="PG::Connection#discard_results (method)">discard_results</a></span>
				<span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="NotAllCopyDataRetrieved.html" title="PG::NotAllCopyDataRetrieved (class)">NotAllCopyDataRetrieved</a></span>.<span class='id identifier rubyid_new'><a href="Error.html#new-class_method" title="PG::Error.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Not all COPY data retrieved</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>connection:</span> <span class='kw'>self</span>)
			<span class='kw'>end</span>
			<span class='id identifier rubyid_res'>res</span>
		<span class='kw'>ensure</span>
			<span class='kw'>self</span>.<span class='id identifier rubyid_decoder_for_get_copy_data'><a href="#decoder_for_get_copy_data-instance_method" title="PG::Connection#decoder_for_get_copy_data (method)">decoder_for_get_copy_data</a></span> <span class='op'>=</span> <span class='id identifier rubyid_old_coder'>old_coder</span> <span class='kw'>if</span> <span class='id identifier rubyid_coder'>coder</span>
		<span class='kw'>end</span>

	<span class='kw'>else</span>
		<span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>SQL command is no COPY statement: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_sql'>sql</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
	<span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="db-instance_method">
  <h3 class='signature '>
    #<strong>db</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the connected database name.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L632-L638'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='632' data-end='638'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 632</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_db(VALUE self)
{
	char *db = PQdb(pg_get_pgconn(self));
	if (!db) return Qnil;
	return rb_str_new2(db);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="describe_portal-instance_method">
  <h3 class='signature '>
    #<strong>describe_portal</strong>(portal_name)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a>     <span class='aliases'>Also known as: <span class='names'>#async_describe_portal</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Retrieve information about the portal <em>portal_name</em>.</p>

<p>See also corresponding <a href="https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQDESCRIBEPORTAL" target="_parent" title="libpq function">libpq function</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3468-L3481'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3468' data-end='3481'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3468</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_async_describe_portal(VALUE self, VALUE portal)
{
	VALUE rb_pgresult = Qnil;

	pgconn_discard_results( self );
	pgconn_send_describe_portal( self, portal );
	rb_pgresult = pgconn_async_get_last_result( self );

	if ( rb_block_given_p() ) {
		return rb_ensure( rb_yield, rb_pgresult, pg_result_clear, rb_pgresult );
	}
	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="describe_prepared-instance_method">
  <h3 class='signature '>
    #<strong>describe_prepared</strong>(statement_name)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a>     <span class='aliases'>Also known as: <span class='names'>#async_describe_prepared</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Retrieve information about the prepared statement <em>statement_name</em>.</p>

<p>See also corresponding <a href="https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQDESCRIBEPREPARED" target="_parent" title="libpq function">libpq function</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3492-L3505'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3492' data-end='3505'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3492</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_async_describe_prepared(VALUE self, VALUE stmt_name)
{
	VALUE rb_pgresult = Qnil;

	pgconn_discard_results( self );
	pgconn_send_describe_prepared( self, stmt_name );
	rb_pgresult = pgconn_async_get_last_result( self );

	if ( rb_block_given_p() ) {
		return rb_ensure( rb_yield, rb_pgresult, pg_result_clear, rb_pgresult );
	}
	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="discard_results-instance_method">
  <h3 class='signature '>
    #<strong>discard_results</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Silently discard any prior query result that application didn’t eat. This is internally used prior to <a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a> and sibling methods. It doesn’t raise an exception on connection errors, but returns <code>false</code> instead.</p>

<p>Returns:</p>
<ul><li>
<p><code>nil</code>  when the connection is already idle</p>
</li><li>
<p><code>true</code>  when some results have been discarded</p>
</li><li>
<p><code>false</code>  when a failure occurred and the connection was closed</p>
</li></ul>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3175-L3251'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3175' data-end='3251'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3175</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_discard_results(VALUE self)
{
	PGconn *conn = pg_get_pgconn(self);
	VALUE socket_io;

	switch( PQtransactionStatus(conn) ) {
		case PQTRANS_IDLE:
		case PQTRANS_INTRANS:
		case PQTRANS_INERROR:
			return Qnil;
		default:;
	}

	socket_io = pgconn_socket_io(self);

	for(;;) {
		PGresult *cur;
		int status;

		/* pgconn_block() raises an exception in case of errors.
		* To avoid this call pg_rb_io_wait() and PQconsumeInput() without rb_raise().
		*/
		while( gvl_PQisBusy(conn) ){
			int events;

			switch( PQflush(conn) ) {
				case 1:
					events = RB_NUM2INT(pg_rb_io_wait(socket_io, RB_INT2NUM(PG_RUBY_IO_READABLE | PG_RUBY_IO_WRITABLE), Qnil));
					if (events &amp; PG_RUBY_IO_READABLE){
						if ( PQconsumeInput(conn) == 0 ) goto error;
					}
					break;
				case 0:
					pg_rb_io_wait(socket_io, RB_INT2NUM(PG_RUBY_IO_READABLE), Qnil);
					if ( PQconsumeInput(conn) == 0 ) goto error;
					break;
				default:
					goto error;
			}
		}

		cur = gvl_PQgetResult(conn);
		if( cur == NULL) break;

		status = PQresultStatus(cur);
		PQclear(cur);
		if (status == PGRES_COPY_IN){
			while( gvl_PQputCopyEnd(conn, &quot;COPY terminated by new query or discard_results&quot;) == 0 ){
				pgconn_async_flush(self);
			}
		}
		if (status == PGRES_COPY_OUT){
			for(;;) {
				char *buffer = NULL;
				int st = gvl_PQgetCopyData(conn, &amp;buffer, 1);
				if( st == 0 ) {
					/* would block -&gt; wait for readable data */
					pg_rb_io_wait(socket_io, RB_INT2NUM(PG_RUBY_IO_READABLE), Qnil);
					if ( PQconsumeInput(conn) == 0 ) goto error;
				} else if( st &gt; 0 ) {
					/* some data retrieved -&gt; discard it */
					PQfreemem(buffer);
				} else {
					/* no more data */
					break;
				}
			}
		}
	}

	return Qtrue;

error:
	pgconn_close_socket_io(self);
	return Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="encrypt_password-instance_method">
  <h3 class='signature '>
    #<strong>encrypt_password</strong>(password, username, algorithm = nil)  &#x21d2; <code>String</code>     <span class='aliases'>Also known as: <span class='names'>#async_encrypt_password</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This function is intended to be used by client applications that wish to send commands like <code>ALTER USER joe PASSWORD &#39;pwd&#39;</code>. It is good practice not to send the original cleartext password in such a command, because it might be exposed in command logs, activity displays, and so on. Instead, use this function to convert the password to encrypted form before it is sent.</p>

<p>The <code>password</code> and <code>username</code> arguments are the cleartext password, and the SQL name of the user it is for. <code>algorithm</code> specifies the encryption algorithm to use to encrypt the password. Currently supported algorithms are <code>md5</code> and <code>scram-sha-256</code> (<code>on</code> and <code>off</code> are also accepted as aliases for <code>md5</code>, for compatibility with older server versions). Note that support for <code>scram-sha-256</code> was introduced in PostgreSQL version 10, and will not work correctly with older server versions. If algorithm is omitted or <code>nil</code>, this function will query the server for the current value of the <code>password_encryption</code> setting. That can block, and will fail if the current transaction is aborted, or if the connection is busy executing another query. If you wish to use the default algorithm for the server but want to avoid blocking, query <code>password_encryption</code> yourself before calling <code>#encrypt_password</code>, and pass that value as the algorithm.</p>

<p>Return value is the encrypted password. The caller can assume the string doesn’t contain any special characters that would require escaping.</p>

<p>Available since PostgreSQL-10. See also corresponding <a href="https://www.postgresql.org/docs/current/libpq-misc.html#LIBPQ-PQENCRYPTPASSWORDCONN" target="_parent" title="libpq function">libpq function</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L555-L558'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='555' data-end='558'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 555</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_encrypt_password'>encrypt_password</span>( <span class='id identifier rubyid_password'>password</span><span class='comma'>,</span> <span class='id identifier rubyid_username'>username</span><span class='comma'>,</span> <span class='id identifier rubyid_algorithm'>algorithm</span><span class='op'>=</span><span class='kw'>nil</span> )
	<span class='id identifier rubyid_algorithm'>algorithm</span> <span class='op'>||=</span> <span class='id identifier rubyid_exec'><a href="#exec-instance_method" title="PG::Connection#exec (method)">exec</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>SHOW password_encryption</span><span class='tstring_end'>&quot;</span></span>).<span class='id identifier rubyid_getvalue'>getvalue</span>(<span class='int'>0</span><span class='comma'>,</span><span class='int'>0</span>)
	<span class='id identifier rubyid_sync_encrypt_password'><a href="#sync_encrypt_password-instance_method" title="PG::Connection#sync_encrypt_password (method)">sync_encrypt_password</a></span>(<span class='id identifier rubyid_password'>password</span><span class='comma'>,</span> <span class='id identifier rubyid_username'>username</span><span class='comma'>,</span> <span class='id identifier rubyid_algorithm'>algorithm</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="enter_pipeline_mode-instance_method">
  <h3 class='signature '>
    #<strong>enter_pipeline_mode</strong>  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Causes a connection to enter pipeline mode if it is currently idle or already in pipeline mode.</p>

<p>Raises <a href="Error.html" title="PG::Error (class)"><code>Error</code></a> and has no effect if the connection is not currently idle, i.e., it has a result ready, or it is waiting for more input from the server, etc. This function does not actually send anything to the server, it just changes the libpq connection state.</p>

<p>Available since PostgreSQL-14</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3622-L3631'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3622' data-end='3631'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3622</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_enter_pipeline_mode(VALUE self)
{
	PGconn *conn = pg_get_pgconn(self);
	int res = PQenterPipelineMode(conn);
	if( res != 1 )
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(conn));

	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="error_message-instance_method">
  <h3 class='signature '>
    #<strong>error_message</strong>  &#x21d2; <code>String</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the error message most recently generated by an operation on the connection.</p>

<p>Nearly all libpq functions will set a message for conn.error_message if they fail. Note that by libpq convention, a nonempty error_message result can consist of multiple lines, and will include a trailing newline.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L885-L891'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='885' data-end='891'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 885</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_error_message(VALUE self)
{
	char *error = PQerrorMessage(pg_get_pgconn(self));
	if (!error) return Qnil;
	return rb_str_new2(error);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="escape_bytea-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>escape_bytea</strong>(string)  &#x21d2; <code>String</code> </span>
      <span class='overload'>#<strong>escape_bytea</strong>(string)  &#x21d2; <code>String</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#escape_bytea-class_method" title="PG::Connection.escape_bytea (method)">.escape_bytea</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="escape_identifier-instance_method">
  <h3 class='signature '>
    #<strong>escape_identifier</strong>(str)  &#x21d2; <code>String</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Escape an arbitrary String <code>str</code> as an identifier.</p>

<p>This method does the same as <a href="#quote_ident-instance_method" title="PG::Connection#quote_ident (method)">#quote_ident</a> with a String argument, but it doesn’t support an Array argument and it makes use of libpq to process the string.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1774-L1796'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1774' data-end='1796'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1774</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_escape_identifier(VALUE self, VALUE string)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	char *escaped = NULL;
	VALUE result = Qnil;
	int enc_idx = this-&gt;enc_idx;

	StringValueCStr(string);
	if( ENCODING_GET(string) != enc_idx ){
		string = rb_str_export_to_enc(string, rb_enc_from_index(enc_idx));
	}

	escaped = PQescapeIdentifier(this-&gt;pgconn, RSTRING_PTR(string), RSTRING_LEN(string));
	if (escaped == NULL)
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));

	result = rb_str_new2(escaped);
	PQfreemem(escaped);
	PG_ENCODING_SET_NOCHECK(result, enc_idx);

	return result;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="escape_literal-instance_method">
  <h3 class='signature '>
    #<strong>escape_literal</strong>(str)  &#x21d2; <code>String</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Escape an arbitrary String <code>str</code> as a literal.</p>

<p>See also <a href="TextEncoder/QuotedLiteral.html" title="PG::TextEncoder::QuotedLiteral (class)"><code>TextEncoder::QuotedLiteral</code></a> for a type cast integrated version of this function.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1740-L1762'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1740' data-end='1762'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1740</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_escape_literal(VALUE self, VALUE string)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	char *escaped = NULL;
	VALUE result = Qnil;
	int enc_idx = this-&gt;enc_idx;

	StringValueCStr(string);
	if( ENCODING_GET(string) != enc_idx ){
		string = rb_str_export_to_enc(string, rb_enc_from_index(enc_idx));
	}

	escaped = PQescapeLiteral(this-&gt;pgconn, RSTRING_PTR(string), RSTRING_LEN(string));
	if (escaped == NULL)
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));

	result = rb_str_new2(escaped);
	PQfreemem(escaped);
	PG_ENCODING_SET_NOCHECK(result, enc_idx);

	return result;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="escape_string-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>escape</strong>(str)  &#x21d2; <code>String</code> </span>
      <span class='overload'>#<strong>escape_string</strong>(str)  &#x21d2; <code>String</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#escape-class_method" title="PG::Connection.escape (method)">.escape</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="exec-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>exec</strong>(sql)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>exec</strong>(sql) {|pg_result| ... } </span>
    </div>
    <span class='aliases'>Also known as: <span class='names'>#async_exec</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sends SQL query request specified by <em>sql</em> to PostgreSQL. On success, it returns a <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> instance with all result rows and columns. On failure, it raises a <a href="Error.html" title="PG::Error (class)"><code>Error</code></a>.</p>

<p>For backward compatibility, if you pass more than one parameter to this method, it will call <a href="#exec_params-instance_method" title="PG::Connection#exec_params (method)">#exec_params</a> for you. New code should explicitly use <a href="#exec_params-instance_method" title="PG::Connection#exec_params (method)">#exec_params</a> if argument placeholders are used.</p>

<p>If the optional code block is given, it will be passed <em>result</em> as an argument, and the <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> object will  automatically be cleared when the block terminates. In this instance, <code>conn.exec</code> returns the value of the block.</p>

<p><code>#exec</code> is an alias for <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> which is almost identical to <a href="#sync_exec-instance_method" title="PG::Connection#sync_exec (method)">#sync_exec</a> . <a href="#sync_exec-instance_method" title="PG::Connection#sync_exec (method)">#sync_exec</a> is implemented on the simpler synchronous command processing API of libpq, whereas <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> is implemented on the asynchronous API and on ruby’s IO mechanisms. Only <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> is compatible to <code>Fiber.scheduler</code> based asynchronous IO processing introduced in ruby-3.0. Both methods ensure that other threads can process while waiting for the server to complete the request, but <a href="#sync_exec-instance_method" title="PG::Connection#sync_exec (method)">#sync_exec</a> blocks all signals to be processed until the query is finished. This is most notably visible by a delayed reaction to Control+C. It’s not recommended to use explicit sync or async variants but <code>#exec</code> instead, unless you have a good reason to do so.</p>

<p>See also corresponding <a href="https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQEXEC" target="_parent" title="libpq function">libpq function</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3281-L3294'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3281' data-end='3294'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3281</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_async_exec(int argc, VALUE *argv, VALUE self)
{
	VALUE rb_pgresult = Qnil;

	pgconn_discard_results( self );
	pgconn_send_query( argc, argv, self );
	rb_pgresult = pgconn_async_get_last_result( self );

	if ( rb_block_given_p() ) {
		return rb_ensure( rb_yield, rb_pgresult, pg_result_clear, rb_pgresult );
	}
	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="exec_params-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>exec_params</strong>(sql, params [, result_format [, type_map ]] )  &#x21d2; <code>nil</code> </span>
      <span class='overload'>#<strong>exec_params</strong>(sql, params [, result_format [, type_map ]] ) {|pg_result| ... } </span>
    </div>
    <span class='aliases'>Also known as: <span class='names'>#async_exec_params</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sends SQL query request specified by <code>sql</code> to PostgreSQL using placeholders for parameters.</p>

<p>Returns a <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> instance on success. On failure, it raises a <a href="Error.html" title="PG::Error (class)"><code>Error</code></a>.</p>

<p><code>params</code> is an array of the bind parameters for the SQL query. Each element of the <code>params</code> array may be either:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_a'>a</span> <span class='id identifier rubyid_hash'>hash</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_the'>the</span> <span class='label'>form:</span>
  {<span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span>  <span class='op'>=&gt;</span> <span class='const'>String</span> (<span class='id identifier rubyid_value'>value</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_bind'>bind</span> <span class='id identifier rubyid_parameter'>parameter</span>)
   <span class='symbeg'>:</span><span class='id identifier rubyid_type'>type</span>   <span class='op'>=&gt;</span> <span class='const'>Integer</span> (<span class='id identifier rubyid_oid'>oid</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_type'>type</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_bind'>bind</span> <span class='id identifier rubyid_parameter'>parameter</span>)
   <span class='symbeg'>:</span><span class='id identifier rubyid_format'>format</span> <span class='op'>=&gt;</span> <span class='const'>Integer</span> (<span class='int'>0</span> <span class='kw'>for</span> <span class='id identifier rubyid_text'>text</span><span class='comma'>,</span> <span class='int'>1</span> <span class='kw'>for</span> <span class='id identifier rubyid_binary'>binary</span>)
  }
<span class='kw'>or</span><span class='comma'>,</span> <span class='id identifier rubyid_it'>it</span> <span class='id identifier rubyid_may'>may</span> <span class='id identifier rubyid_be'>be</span> <span class='id identifier rubyid_a'>a</span> <span class='const'>String</span>. <span class='const'>If</span> <span class='id identifier rubyid_it'>it</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_a'>a</span> <span class='id identifier rubyid_string'>string</span><span class='comma'>,</span> <span class='id identifier rubyid_that'>that</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_equivalent'>equivalent</span> <span class='id identifier rubyid_to'>to</span> <span class='id identifier rubyid_the'>the</span> <span class='label'>hash:</span>
  { <span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span> <span class='op'>=&gt;</span> <span class='op'>&lt;</span><span class='id identifier rubyid_string'>string</span> <span class='id identifier rubyid_value'>value</span><span class='op'>&gt;</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_type'>type</span> <span class='op'>=&gt;</span> <span class='int'>0</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_format'>format</span> <span class='op'>=&gt;</span> <span class='int'>0</span> }</code></pre>

<p>PostgreSQL bind parameters are represented as $1, $2, $3, etc., inside the SQL query. The 0th element of the <code>params</code> array is bound to $1, the 1st element is bound to $2, etc. <code>nil</code> is treated as <code>NULL</code>.</p>

<p>If the types are not specified, they will be inferred by PostgreSQL. Instead of specifying type oids, it’s recommended to simply add explicit casts in the query to ensure that the right type is used.</p>

<p>For example: “SELECT $1::int”</p>

<p>The optional <code>result_format</code> should be 0 for text results, 1 for binary.</p>

<p><code>type_map</code> can be a <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> derivation (such as <a href="BasicTypeMapForQueries.html" title="PG::BasicTypeMapForQueries (class)"><code>BasicTypeMapForQueries</code></a>). This will type cast the params from various Ruby types before transmission based on the encoders defined by the type map. When a type encoder is used the format and oid of a given bind parameter are retrieved from the encoder instead out of the hash form described above.</p>

<p>If the optional code block is given, it will be passed <em>result</em> as an argument, and the <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> object will  automatically be cleared when the block terminates. In this instance, <code>conn.exec</code> returns the value of the block.</p>

<p>The primary advantage of <code>#exec_params</code> over <a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a> is that parameter values can be separated from the command string, thus avoiding the need for tedious and error-prone quoting and escaping. Unlike <a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a>, <code>#exec_params</code> allows at most one SQL command in the given string. (There can be semicolons in it, but not more than one nonempty command.) This is a limitation of the underlying protocol, but has some usefulness as an extra defense against SQL-injection attacks.</p>

<p>See also corresponding <a href="https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQEXECPARAMS" target="_parent" title="libpq function">libpq function</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3347-L3366'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3347' data-end='3366'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3347</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_async_exec_params(int argc, VALUE *argv, VALUE self)
{
	VALUE rb_pgresult = Qnil;

	pgconn_discard_results( self );
	/* If called with no or nil parameters, use PQsendQuery for compatibility */
	if ( argc == 1 || (argc &gt;= 2 &amp;&amp; argc &lt;= 4 &amp;&amp; NIL_P(argv[1]) )) {
		pg_deprecated(3, (&quot;forwarding async_exec_params to async_exec is deprecated&quot;));
		pgconn_send_query( argc, argv, self );
	} else {
		pgconn_send_query_params( argc, argv, self );
	}
	rb_pgresult = pgconn_async_get_last_result( self );

	if ( rb_block_given_p() ) {
		return rb_ensure( rb_yield, rb_pgresult, pg_result_clear, rb_pgresult );
	}
	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="exec_prepared-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>exec_prepared</strong>(statement_name [, params, result_format[, type_map]] )  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>exec_prepared</strong>(statement_name [, params, result_format[, type_map]] ) {|pg_result| ... } </span>
    </div>
    <span class='aliases'>Also known as: <span class='names'>#async_exec_prepared</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Execute prepared named statement specified by <em>statement_name</em>. Returns a <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> instance on success. On failure, it raises a <a href="Error.html" title="PG::Error (class)"><code>Error</code></a>.</p>

<p><code>params</code> is an array of the optional bind parameters for the SQL query. Each element of the <code>params</code> array may be either:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_a'>a</span> <span class='id identifier rubyid_hash'>hash</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_the'>the</span> <span class='label'>form:</span>
  {<span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span>  <span class='op'>=&gt;</span> <span class='const'>String</span> (<span class='id identifier rubyid_value'>value</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_bind'>bind</span> <span class='id identifier rubyid_parameter'>parameter</span>)
   <span class='symbeg'>:</span><span class='id identifier rubyid_format'>format</span> <span class='op'>=&gt;</span> <span class='const'>Integer</span> (<span class='int'>0</span> <span class='kw'>for</span> <span class='id identifier rubyid_text'>text</span><span class='comma'>,</span> <span class='int'>1</span> <span class='kw'>for</span> <span class='id identifier rubyid_binary'>binary</span>)
  }
<span class='kw'>or</span><span class='comma'>,</span> <span class='id identifier rubyid_it'>it</span> <span class='id identifier rubyid_may'>may</span> <span class='id identifier rubyid_be'>be</span> <span class='id identifier rubyid_a'>a</span> <span class='const'>String</span>. <span class='const'>If</span> <span class='id identifier rubyid_it'>it</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_a'>a</span> <span class='id identifier rubyid_string'>string</span><span class='comma'>,</span> <span class='id identifier rubyid_that'>that</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_equivalent'>equivalent</span> <span class='id identifier rubyid_to'>to</span> <span class='id identifier rubyid_the'>the</span> <span class='label'>hash:</span>
  { <span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span> <span class='op'>=&gt;</span> <span class='op'>&lt;</span><span class='id identifier rubyid_string'>string</span> <span class='id identifier rubyid_value'>value</span><span class='op'>&gt;</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_format'>format</span> <span class='op'>=&gt;</span> <span class='int'>0</span> }</code></pre>

<p>PostgreSQL bind parameters are represented as $1, $2, $3, etc., inside the SQL query. The 0th element of the <code>params</code> array is bound to $1, the 1st element is bound to $2, etc. <code>nil</code> is treated as <code>NULL</code>.</p>

<p>The optional <code>result_format</code> should be 0 for text results, 1 for binary.</p>

<p><code>type_map</code> can be a <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> derivation (such as <a href="BasicTypeMapForQueries.html" title="PG::BasicTypeMapForQueries (class)"><code>BasicTypeMapForQueries</code></a>). This will type cast the params from various Ruby types before transmission based on the encoders defined by the type map. When a type encoder is used the format and oid of a given bind parameter are retrieved from the encoder instead out of the hash form described above.</p>

<p>If the optional code block is given, it will be passed <em>result</em> as an argument, and the <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> object will  automatically be cleared when the block terminates. In this instance, <code>conn.exec_prepared</code> returns the value of the block.</p>

<p>See also corresponding <a href="https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQEXECPREPARED" target="_parent" title="libpq function">libpq function</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3444-L3457'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3444' data-end='3457'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3444</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_async_exec_prepared(int argc, VALUE *argv, VALUE self)
{
	VALUE rb_pgresult = Qnil;

	pgconn_discard_results( self );
	pgconn_send_query_prepared( argc, argv, self );
	rb_pgresult = pgconn_async_get_last_result( self );

	if ( rb_block_given_p() ) {
		return rb_ensure( rb_yield, rb_pgresult, pg_result_clear, rb_pgresult );
	}
	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="exit_pipeline_mode-instance_method">
  <h3 class='signature '>
    #<strong>exit_pipeline_mode</strong>  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Causes a connection to exit pipeline mode if it is currently in pipeline mode with an empty queue and no pending results.</p>

<p>Takes no action if not in pipeline mode. Raises <a href="Error.html" title="PG::Error (class)"><code>Error</code></a> if the current statement isn’t finished processing, or PQgetResult has not been called to collect results from all previously sent query.</p>

<p>Available since PostgreSQL-14</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3644-L3653'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3644' data-end='3653'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3644</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_exit_pipeline_mode(VALUE self)
{
	PGconn *conn = pg_get_pgconn(self);
	int res = PQexitPipelineMode(conn);
	if( res != 1 )
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(conn));

	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="external_encoding-instance_method">
  <h3 class='signature '>
    #<strong>external_encoding</strong>  &#x21d2; <code>Encoding</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Return the <code>server_encoding</code> of the connected database as a Ruby Encoding object. The <code>SQL_ASCII</code> encoding is mapped to to <code>ASCII_8BIT</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4129-L4139'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4129' data-end='4139'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4129</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_external_encoding(VALUE self)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	rb_encoding *enc = NULL;
	const char *pg_encname = NULL;

	pg_encname = PQparameterStatus( this-&gt;pgconn, &quot;server_encoding&quot; );
	enc = pg_get_pg_encname_as_rb_encoding( pg_encname );
	return rb_enc_from_encoding( enc );
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="finish-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>close</strong>  </span>
      <span class='overload'>#<strong>finish</strong>  </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#close-instance_method" title="PG::Connection#close (method)">#close</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="flush-instance_method">
  <h3 class='signature '>
    #<strong>flush</strong>  &#x21d2; <code>Boolean</code>     <span class='aliases'>Also known as: <span class='names'>#async_flush</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Attempts to flush any queued output data to the server. Returns <code>true</code> if data is successfully flushed, <code>false</code> if not. It can only return <code>false</code> if connection is in nonblocking mode. Raises <a href="Error.html" title="PG::Error (class)"><code>Error</code></a> if some other failure occurred.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2471-L2485'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2471' data-end='2485'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2471</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_async_flush(VALUE self)
{
	while( pgconn_sync_flush(self) == Qfalse ){
		/* wait for the socket to become read- or write-ready */
		int events;
		VALUE socket_io = pgconn_socket_io(self);
		events = RB_NUM2INT(pg_rb_io_wait(socket_io, RB_INT2NUM(PG_RUBY_IO_READABLE | PG_RUBY_IO_WRITABLE), Qnil));

		if (events &amp; PG_RUBY_IO_READABLE){
			pgconn_consume_input(self);
		}
	}
	return Qtrue;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="get_client_encoding-instance_method">
  <h3 class='signature '>
    #<strong>get_client_encoding</strong>  &#x21d2; <code>String</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the client encoding as a String.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2944-L2949'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2944' data-end='2949'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2944</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_get_client_encoding(VALUE self)
{
	char *encoding = (char *)pg_encoding_to_char(PQclientEncoding(pg_get_pgconn(self)));
	return rb_str_new2(encoding);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="get_copy_data-instance_method">
  <h3 class='signature '>
    #<strong>get_copy_data</strong>([ nonblock = false [, decoder = nil ]] )  &#x21d2; <a href="../Object.html" title="Object (class)">Object</a>     <span class='aliases'>Also known as: <span class='names'>#async_get_copy_data</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Return one row of data, <code>nil</code> if the copy is done, or <code>false</code> if the call would block (only possible if <em>nonblock</em> is true).</p>

<p>If <em>decoder</em> is not set or <code>nil</code>, data is returned as binary string.</p>

<p>If <em>decoder</em> is set to a <a href="Coder.html" title="PG::Coder (class)"><code>Coder</code></a> derivation, the return type depends on this decoder. <a href="TextDecoder/CopyRow.html" title="PG::TextDecoder::CopyRow (class)"><code>TextDecoder::CopyRow</code></a> decodes the received data fields from one row of PostgreSQL’s COPY text format to an Array of Strings. Optionally the decoder can type cast the single fields to various Ruby types in one step, if <code>PG::TextDecoder::CopyRow#type_map</code> is set accordingly.</p>

<p>See also <a href="#copy_data-instance_method" title="PG::Connection#copy_data (method)">#copy_data</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L423-L433'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='423' data-end='433'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 423</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_get_copy_data'>get_copy_data</span>(<span class='id identifier rubyid_async'>async</span><span class='op'>=</span><span class='kw'>false</span><span class='comma'>,</span> <span class='id identifier rubyid_decoder'>decoder</span><span class='op'>=</span><span class='kw'>nil</span>)
	<span class='kw'>if</span> <span class='id identifier rubyid_async'>async</span>
		<span class='kw'>return</span> <span class='id identifier rubyid_sync_get_copy_data'><a href="#sync_get_copy_data-instance_method" title="PG::Connection#sync_get_copy_data (method)">sync_get_copy_data</a></span>(<span class='id identifier rubyid_async'>async</span><span class='comma'>,</span> <span class='id identifier rubyid_decoder'>decoder</span>)
	<span class='kw'>else</span>
		<span class='kw'>while</span> (<span class='id identifier rubyid_res'>res</span><span class='op'>=</span><span class='id identifier rubyid_sync_get_copy_data'><a href="#sync_get_copy_data-instance_method" title="PG::Connection#sync_get_copy_data (method)">sync_get_copy_data</a></span>(<span class='kw'>true</span><span class='comma'>,</span> <span class='id identifier rubyid_decoder'>decoder</span>)) <span class='op'>==</span> <span class='kw'>false</span>
			<span class='id identifier rubyid_socket_io'><a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">socket_io</a></span>.<span class='id identifier rubyid_wait_readable'>wait_readable</span>
			<span class='id identifier rubyid_consume_input'><a href="#consume_input-instance_method" title="PG::Connection#consume_input (method)">consume_input</a></span>
		<span class='kw'>end</span>
		<span class='kw'>return</span> <span class='id identifier rubyid_res'>res</span>
	<span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="get_last_result-instance_method">
  <h3 class='signature '>
    #<strong>get_last_result</strong>()  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a>     <span class='aliases'>Also known as: <span class='names'>#async_get_last_result</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This function retrieves all available results on the current connection (from previously issued asynchronous commands like <tt>send_query()</tt>) and returns the last non-NULL result, or <code>nil</code> if no results are available.</p>

<p>If the last result contains a bad result_status, an appropriate exception is raised.</p>

<p>This function is similar to <a href="#get_result-instance_method" title="PG::Connection#get_result (method)">#get_result</a> except that it is designed to get one and only one result and that it checks the result state.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3127-L3159'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3127' data-end='3159'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3127</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_async_get_last_result(VALUE self)
{
	PGconn *conn = pg_get_pgconn(self);
	VALUE rb_pgresult = Qnil;
	PGresult *cur, *prev;

	cur = prev = NULL;
	for(;;) {
		int status;

		/* wait for input (without blocking) before reading each result */
		wait_socket_readable(self, NULL, get_result_readable);

		cur = gvl_PQgetResult(conn);
		if (cur == NULL)
			break;

		if (prev) PQclear(prev);
		prev = cur;

		status = PQresultStatus(cur);
		if (status == PGRES_COPY_OUT || status == PGRES_COPY_IN || status == PGRES_COPY_BOTH)
			break;
	}

	if (prev) {
		rb_pgresult = pg_new_result( prev, self );
		pg_result_check(rb_pgresult);
	}

	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="get_result-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>get_result</strong>  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>get_result</strong> {|pg_result| ... } </span>
    </div>
    <span class='aliases'>Also known as: <span class='names'>#async_get_result</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Blocks waiting for the next result from a call to <a href="#send_query-instance_method" title="PG::Connection#send_query (method)">#send_query</a> (or another asynchronous command), and returns it. Returns <code>nil</code> if no more results are available.</p>

<p>Note: call this function repeatedly until it returns <code>nil</code>, or else you will not be able to issue further commands.</p>

<p>If the optional code block is given, it will be passed <em>result</em> as an argument, and the <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> object will  automatically be cleared when the block terminates. In this instance, <code>conn.exec</code> returns the value of the block.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L400-L403'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='400' data-end='403'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 400</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_get_result'>get_result</span>
	<span class='id identifier rubyid_block'><a href="#block-instance_method" title="PG::Connection#block (method)">block</a></span>
	<span class='id identifier rubyid_sync_get_result'><a href="#sync_get_result-instance_method" title="PG::Connection#sync_get_result (method)">sync_get_result</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="host-instance_method">
  <h3 class='signature '>
    #<strong>host</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the server host name of the active connection. This can be a host name, an IP address, or a directory path if the connection is via Unix socket. (The path case can be distinguished because it will always be an absolute path, beginning with <code>/</code> .)</p>

<p>If the connection parameters specified both host and hostaddr, then <code>host</code> will return the host information. If only hostaddr was specified, then that is returned. If multiple hosts were specified in the connection parameters, <code>host</code> returns the host actually connected to.</p>

<p>If there is an error producing the host information (perhaps if the connection has not been fully established or there was an error), it returns an empty string.</p>

<p>If multiple hosts were specified in the connection parameters, it is not possible to rely on the result of <code>host</code> until the connection is established. The status of the connection can be checked using the function <a href="#status-instance_method" title="PG::Connection#status (method)">#status</a> .</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L685-L691'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='685' data-end='691'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 685</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_host(VALUE self)
{
	char *host = PQhost(pg_get_pgconn(self));
	if (!host) return Qnil;
	return rb_str_new2(host);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="hostaddr-instance_method">
  <h3 class='signature '>
    #<strong>hostaddr</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the server IP address of the active connection. This can be the address that a host name resolved to, or an IP address provided through the hostaddr parameter. If there is an error producing the host information (perhaps if the connection has not been fully established or there was an error), it returns an empty string.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L704-L710'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='704' data-end='710'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 704</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_hostaddr(VALUE self)
{
	char *host = PQhostaddr(pg_get_pgconn(self));
	if (!host) return Qnil;
	return rb_str_new2(host);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="inspect-instance_method">
  <h3 class='signature '>
    #<strong>inspect</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Return a String representation of the object suitable for debugging.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L100-L118'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='100' data-end='118'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 100</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_inspect'>inspect</span>
	<span class='id identifier rubyid_str'>str</span> <span class='op'>=</span> <span class='kw'>self</span>.<span class='id identifier rubyid_to_s'>to_s</span>
	<span class='id identifier rubyid_str'>str</span>[<span class='op'>-</span><span class='int'>1</span><span class='comma'>,</span><span class='int'>0</span>] <span class='op'>=</span> <span class='kw'>if</span> <span class='id identifier rubyid_finished?'><a href="#finished%3F-instance_method" title="PG::Connection#finished? (method)">finished?</a></span>
		<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> finished</span><span class='tstring_end'>&quot;</span></span>
	<span class='kw'>else</span>
		<span class='id identifier rubyid_stats'>stats</span> <span class='op'>=</span> []
		<span class='id identifier rubyid_stats'>stats</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> status=</span><span class='embexpr_beg'>#{</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span>.<span class='id identifier rubyid_constants'>constants</span>.<span class='id identifier rubyid_grep'>grep</span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>CONNECTION_</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_find'>find</span>{<span class='op'>|</span><span class='id identifier rubyid_c'>c</span><span class='op'>|</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span>.<span class='id identifier rubyid_const_get'>const_get</span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>==</span> <span class='id identifier rubyid_status'><a href="#status-instance_method" title="PG::Connection#status (method)">status</a></span>} <span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_status'><a href="#status-instance_method" title="PG::Connection#status (method)">status</a></span> <span class='op'>!=</span> <span class='const'><a href="Constants.html#CONNECTION_OK-constant" title="PG::Constants::CONNECTION_OK (constant)">CONNECTION_OK</a></span>
		<span class='id identifier rubyid_stats'>stats</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> transaction_status=</span><span class='embexpr_beg'>#{</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span>.<span class='id identifier rubyid_constants'>constants</span>.<span class='id identifier rubyid_grep'>grep</span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>PQTRANS_</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_find'>find</span>{<span class='op'>|</span><span class='id identifier rubyid_c'>c</span><span class='op'>|</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span>.<span class='id identifier rubyid_const_get'>const_get</span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>==</span> <span class='id identifier rubyid_transaction_status'><a href="#transaction_status-instance_method" title="PG::Connection#transaction_status (method)">transaction_status</a></span>} <span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_transaction_status'><a href="#transaction_status-instance_method" title="PG::Connection#transaction_status (method)">transaction_status</a></span> <span class='op'>!=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#PQTRANS_IDLE-constant" title="PG::Constants::PQTRANS_IDLE (constant)">PQTRANS_IDLE</a></span>
		<span class='id identifier rubyid_stats'>stats</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> nonblocking=</span><span class='embexpr_beg'>#{</span> <span class='id identifier rubyid_isnonblocking'><a href="#isnonblocking-instance_method" title="PG::Connection#isnonblocking (method)">isnonblocking</a></span> <span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_isnonblocking'><a href="#isnonblocking-instance_method" title="PG::Connection#isnonblocking (method)">isnonblocking</a></span>
		<span class='id identifier rubyid_stats'>stats</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> pipeline_status=</span><span class='embexpr_beg'>#{</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span>.<span class='id identifier rubyid_constants'>constants</span>.<span class='id identifier rubyid_grep'>grep</span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>PQ_PIPELINE_</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_find'>find</span>{<span class='op'>|</span><span class='id identifier rubyid_c'>c</span><span class='op'>|</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span>.<span class='id identifier rubyid_const_get'>const_get</span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>==</span> <span class='id identifier rubyid_pipeline_status'><a href="#pipeline_status-instance_method" title="PG::Connection#pipeline_status (method)">pipeline_status</a></span>} <span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_respond_to?'>respond_to?</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_pipeline_status'><a href="#pipeline_status-instance_method" title="PG::Connection#pipeline_status (method)">pipeline_status</a></span>) <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_pipeline_status'><a href="#pipeline_status-instance_method" title="PG::Connection#pipeline_status (method)">pipeline_status</a></span> <span class='op'>!=</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#PQ_PIPELINE_OFF-constant" title="PG::Constants::PQ_PIPELINE_OFF (constant)">PQ_PIPELINE_OFF</a></span>
		<span class='id identifier rubyid_stats'>stats</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> client_encoding=</span><span class='embexpr_beg'>#{</span> <span class='id identifier rubyid_get_client_encoding'><a href="#get_client_encoding-instance_method" title="PG::Connection#get_client_encoding (method)">get_client_encoding</a></span> <span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_get_client_encoding'><a href="#get_client_encoding-instance_method" title="PG::Connection#get_client_encoding (method)">get_client_encoding</a></span> <span class='op'>!=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>UTF8</span><span class='tstring_end'>&quot;</span></span>
		<span class='id identifier rubyid_stats'>stats</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> type_map_for_results=</span><span class='embexpr_beg'>#{</span> <span class='id identifier rubyid_type_map_for_results'><a href="#type_map_for_results-instance_method" title="PG::Connection#type_map_for_results (method)">type_map_for_results</a></span>.<span class='id identifier rubyid_to_s'>to_s</span> <span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_type_map_for_results'><a href="#type_map_for_results-instance_method" title="PG::Connection#type_map_for_results (method)">type_map_for_results</a></span>.<span class='id identifier rubyid_is_a?'>is_a?</span>(<span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="TypeMapAllStrings.html" title="PG::TypeMapAllStrings (class)">TypeMapAllStrings</a></span>)
		<span class='id identifier rubyid_stats'>stats</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> type_map_for_queries=</span><span class='embexpr_beg'>#{</span> <span class='id identifier rubyid_type_map_for_queries'><a href="#type_map_for_queries-instance_method" title="PG::Connection#type_map_for_queries (method)">type_map_for_queries</a></span>.<span class='id identifier rubyid_to_s'>to_s</span> <span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_type_map_for_queries'><a href="#type_map_for_queries-instance_method" title="PG::Connection#type_map_for_queries (method)">type_map_for_queries</a></span>.<span class='id identifier rubyid_is_a?'>is_a?</span>(<span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="TypeMapAllStrings.html" title="PG::TypeMapAllStrings (class)">TypeMapAllStrings</a></span>)
		<span class='id identifier rubyid_stats'>stats</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> encoder_for_put_copy_data=</span><span class='embexpr_beg'>#{</span> <span class='id identifier rubyid_encoder_for_put_copy_data'><a href="#encoder_for_put_copy_data-instance_method" title="PG::Connection#encoder_for_put_copy_data (method)">encoder_for_put_copy_data</a></span>.<span class='id identifier rubyid_to_s'>to_s</span> <span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_encoder_for_put_copy_data'><a href="#encoder_for_put_copy_data-instance_method" title="PG::Connection#encoder_for_put_copy_data (method)">encoder_for_put_copy_data</a></span>
		<span class='id identifier rubyid_stats'>stats</span> <span class='op'>&lt;&lt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> decoder_for_get_copy_data=</span><span class='embexpr_beg'>#{</span> <span class='id identifier rubyid_decoder_for_get_copy_data'><a href="#decoder_for_get_copy_data-instance_method" title="PG::Connection#decoder_for_get_copy_data (method)">decoder_for_get_copy_data</a></span>.<span class='id identifier rubyid_to_s'>to_s</span> <span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_decoder_for_get_copy_data'><a href="#decoder_for_get_copy_data-instance_method" title="PG::Connection#decoder_for_get_copy_data (method)">decoder_for_get_copy_data</a></span>
		<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> host=</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_host'><a href="#host-instance_method" title="PG::Connection#host (method)">host</a></span><span class='embexpr_end'>}</span><span class='tstring_content'> port=</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_port'><a href="#port-instance_method" title="PG::Connection#port (method)">port</a></span><span class='embexpr_end'>}</span><span class='tstring_content'> user=</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_user'><a href="#user-instance_method" title="PG::Connection#user (method)">user</a></span><span class='embexpr_end'>}</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_stats'>stats</span>.<span class='id identifier rubyid_join'>join</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
	<span class='kw'>end</span>
	<span class='kw'>return</span> <span class='id identifier rubyid_str'>str</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="is_busy-instance_method">
  <h3 class='signature '>
    #<strong>is_busy</strong>  &#x21d2; <code>Boolean</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns <code>true</code> if a command is busy, that is, if <a href="#get_result-instance_method" title="PG::Connection#get_result (method)">#get_result</a> would block. Otherwise returns <code>false</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2163-L2167'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2163' data-end='2167'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2163</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_is_busy(VALUE self)
{
	return gvl_PQisBusy(pg_get_pgconn(self)) ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="isnonblocking-instance_method">
  <h3 class='signature '>
    #<strong>isnonblocking</strong>  &#x21d2; <code>Boolean</code>     <span class='aliases'>Also known as: <span class='names'>#async_isnonblocking, #nonblocking?</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the blocking status of the database connection. Returns <code>true</code> if the connection is set to nonblocking mode and <code>false</code> if blocking.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L471-L473'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='471' data-end='473'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 471</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_isnonblocking'>isnonblocking</span>
	<span class='kw'>false</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="lo_close-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>loclose</strong>(lo_desc)  &#x21d2; <code>nil</code> </span>
      <span class='overload'>#<strong>lo_close</strong>(lo_desc)  &#x21d2; <code>nil</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#loclose-instance_method" title="PG::Connection#loclose (method)">#loclose</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="lo_creat-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>locreat</strong>([mode])  &#x21d2; <code>Integer</code> </span>
      <span class='overload'>#<strong>lo_creat</strong>([mode])  &#x21d2; <code>Integer</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#locreat-instance_method" title="PG::Connection#locreat (method)">#locreat</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="lo_create-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>locreate</strong>(oid)  &#x21d2; <code>Integer</code> </span>
      <span class='overload'>#<strong>lo_create</strong>(oid)  &#x21d2; <code>Integer</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#locreate-instance_method" title="PG::Connection#locreate (method)">#locreate</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="lo_export-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>loexport</strong>(oid, file)  &#x21d2; <code>nil</code> </span>
      <span class='overload'>#<strong>lo_export</strong>(oid, file)  &#x21d2; <code>nil</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#loexport-instance_method" title="PG::Connection#loexport (method)">#loexport</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="lo_import-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>loimport</strong>(file)  &#x21d2; <code>Integer</code> </span>
      <span class='overload'>#<strong>lo_import</strong>(file)  &#x21d2; <code>Integer</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#loimport-instance_method" title="PG::Connection#loimport (method)">#loimport</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="lo_lseek-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>loseek</strong>(lo_desc, offset, whence)  &#x21d2; <code>Integer</code> </span>
      <span class='overload'>#<strong>lo_lseek</strong>(lo_desc, offset, whence)  &#x21d2; <code>Integer</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#loseek-instance_method" title="PG::Connection#loseek (method)">#loseek</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="lo_open-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>loopen</strong>(oid, [mode])  &#x21d2; <code>Integer</code> </span>
      <span class='overload'>#<strong>lo_open</strong>(oid, [mode])  &#x21d2; <code>Integer</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#loopen-instance_method" title="PG::Connection#loopen (method)">#loopen</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="lo_read-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>loread</strong>(lo_desc, len)  &#x21d2; <code>String</code> </span>
      <span class='overload'>#<strong>lo_read</strong>(lo_desc, len)  &#x21d2; <code>String</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#loread-instance_method" title="PG::Connection#loread (method)">#loread</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="lo_seek-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>loseek</strong>(lo_desc, offset, whence)  &#x21d2; <code>Integer</code> </span>
      <span class='overload'>#<strong>lo_seek</strong>(lo_desc, offset, whence)  &#x21d2; <code>Integer</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#loseek-instance_method" title="PG::Connection#loseek (method)">#loseek</a>.</p>

  </div>
</div>

</section>

<section class='method_details' id="lo_tell-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>lotell</strong>(lo_desc)  &#x21d2; <code>Integer</code> </span>
      <span class='overload'>#<strong>lo_tell</strong>(lo_desc)  &#x21d2; <code>Integer</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#lotell-instance_method" title="PG::Connection#lotell (method)">#lotell</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="lo_truncate-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>lotruncate</strong>(lo_desc, len)  &#x21d2; <code>nil</code> </span>
      <span class='overload'>#<strong>lo_truncate</strong>(lo_desc, len)  &#x21d2; <code>nil</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#lotruncate-instance_method" title="PG::Connection#lotruncate (method)">#lotruncate</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="lo_unlink-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>lounlink</strong>(oid)  &#x21d2; <code>nil</code> </span>
      <span class='overload'>#<strong>lo_unlink</strong>(oid)  &#x21d2; <code>nil</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#lounlink-instance_method" title="PG::Connection#lounlink (method)">#lounlink</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="lo_write-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>lowrite</strong>(lo_desc, buffer)  &#x21d2; <code>Integer</code> </span>
      <span class='overload'>#<strong>lo_write</strong>(lo_desc, buffer)  &#x21d2; <code>Integer</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#lowrite-instance_method" title="PG::Connection#lowrite (method)">#lowrite</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="loclose-instance_method">
  <h3 class='signature '>
    #<strong>loclose</strong>(lo_desc)  &#x21d2; <code>nil</code>     <span class='aliases'>Also known as: <span class='names'>#lo_close</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Closes the postgres large object of <em>lo_desc</em>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4005-L4020'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4005' data-end='4020'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4005</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_loclose(VALUE self, VALUE in_lo_desc)
{
	PGconn *conn = pg_get_pgconn(self);
	int lo_desc = NUM2INT(in_lo_desc);
	int ret;

	BLOCKING_BEGIN(conn)
		ret = lo_close(conn,lo_desc);
	BLOCKING_END(conn)

	if(ret &lt; 0)
		pg_raise_conn_error( rb_ePGerror, self, &quot;lo_close failed&quot;);

	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="locreat-instance_method">
  <h3 class='signature '>
    #<strong>locreat</strong>([mode])  &#x21d2; <code>Integer</code>     <span class='aliases'>Also known as: <span class='names'>#lo_creat</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Creates a large object with mode <em>mode</em>. Returns a large object Oid. On failure, it raises <a href="Error.html" title="PG::Error (class)"><code>Error</code></a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3722-L3743'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3722' data-end='3743'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3722</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_locreat(int argc, VALUE *argv, VALUE self)
{
	Oid lo_oid;
	int mode;
	VALUE nmode;
	PGconn *conn = pg_get_pgconn(self);

	if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;nmode) == 0)
		mode = INV_READ;
	else
		mode = NUM2INT(nmode);

	BLOCKING_BEGIN(conn)
		lo_oid = lo_creat(conn, mode);
	BLOCKING_END(conn)

	if (lo_oid == 0)
		pg_raise_conn_error( rb_ePGerror, self, &quot;lo_creat failed&quot;);

	return UINT2NUM(lo_oid);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="locreate-instance_method">
  <h3 class='signature '>
    #<strong>locreate</strong>(oid)  &#x21d2; <code>Integer</code>     <span class='aliases'>Also known as: <span class='names'>#lo_create</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Creates a large object with oid <em>oid</em>. Returns the large object Oid. On failure, it raises <a href="Error.html" title="PG::Error (class)"><code>Error</code></a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3752-L3764'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3752' data-end='3764'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3752</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_locreate(VALUE self, VALUE in_lo_oid)
{
	Oid ret, lo_oid;
	PGconn *conn = pg_get_pgconn(self);
	lo_oid = NUM2UINT(in_lo_oid);

	ret = lo_create(conn, lo_oid);
	if (ret == InvalidOid)
		pg_raise_conn_error( rb_ePGerror, self, &quot;lo_create failed&quot;);

	return UINT2NUM(ret);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="loexport-instance_method">
  <h3 class='signature '>
    #<strong>loexport</strong>(oid, file)  &#x21d2; <code>nil</code>     <span class='aliases'>Also known as: <span class='names'>#lo_export</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Saves a large object of <em>oid</em> to a <em>file</em>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3799-L3817'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3799' data-end='3817'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3799</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_loexport(VALUE self, VALUE lo_oid, VALUE filename)
{
	PGconn *conn = pg_get_pgconn(self);
	Oid oid;
	int ret;
	Check_Type(filename, T_STRING);

	oid = NUM2UINT(lo_oid);

	BLOCKING_BEGIN(conn)
		ret = lo_export(conn, oid, StringValueCStr(filename));
	BLOCKING_END(conn)

	if (ret &lt; 0) {
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(conn));
	}
	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="loimport-instance_method">
  <h3 class='signature '>
    #<strong>loimport</strong>(file)  &#x21d2; <code>Integer</code>     <span class='aliases'>Also known as: <span class='names'>#lo_import</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Import a file to a large object. Returns a large object Oid.</p>

<p>On failure, it raises a <a href="Error.html" title="PG::Error (class)"><code>Error</code></a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3774-L3791'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3774' data-end='3791'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3774</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_loimport(VALUE self, VALUE filename)
{
	Oid lo_oid;

	PGconn *conn = pg_get_pgconn(self);

	Check_Type(filename, T_STRING);

	BLOCKING_BEGIN(conn)
		lo_oid = lo_import(conn, StringValueCStr(filename));
	BLOCKING_END(conn)

	if (lo_oid == 0) {
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(conn));
	}
	return UINT2NUM(lo_oid);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="lolseek-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>loseek</strong>(lo_desc, offset, whence)  &#x21d2; <code>Integer</code> </span>
      <span class='overload'>#<strong>lolseek</strong>(lo_desc, offset, whence)  &#x21d2; <code>Integer</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#loseek-instance_method" title="PG::Connection#loseek (method)">#loseek</a>.</p>

  </div>
</div>

</section>

<section class='method_details' id="loopen-instance_method">
  <h3 class='signature '>
    #<strong>loopen</strong>(oid, [mode])  &#x21d2; <code>Integer</code>     <span class='aliases'>Also known as: <span class='names'>#lo_open</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Open a large object of <em>oid</em>. Returns a large object descriptor instance on success. The <em>mode</em> argument specifies the mode for the opened large object,which is either <code>INV_READ</code>, or <code>INV_WRITE</code>.</p>

<p>If <em>mode</em> is omitted, the default is <code>INV_READ</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3829-L3852'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3829' data-end='3852'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3829</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_loopen(int argc, VALUE *argv, VALUE self)
{
	Oid lo_oid;
	int fd, mode;
	VALUE nmode, selfid;
	PGconn *conn = pg_get_pgconn(self);

	rb_scan_args(argc, argv, &quot;11&quot;, &amp;selfid, &amp;nmode);
	lo_oid = NUM2UINT(selfid);
	if(NIL_P(nmode))
		mode = INV_READ;
	else
		mode = NUM2INT(nmode);

	BLOCKING_BEGIN(conn)
		fd = lo_open(conn, lo_oid, mode);
	BLOCKING_END(conn)

	if(fd &lt; 0) {
		pg_raise_conn_error( rb_ePGerror, self, &quot;can&#39;t open large object: %s&quot;, PQerrorMessage(conn));
	}
	return INT2FIX(fd);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="loread-instance_method">
  <h3 class='signature '>
    #<strong>loread</strong>(lo_desc, len)  &#x21d2; <code>String</code>     <span class='aliases'>Also known as: <span class='names'>#lo_read</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Attempts to read <em>len</em> bytes from large object <em>lo_desc</em>, returns resulting data.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3892-L3923'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3892' data-end='3923'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3892</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_loread(VALUE self, VALUE in_lo_desc, VALUE in_len)
{
	int ret;
  PGconn *conn = pg_get_pgconn(self);
	int len = NUM2INT(in_len);
	int lo_desc = NUM2INT(in_lo_desc);
	VALUE str;
	char *buffer;

	if (len &lt; 0)
		pg_raise_conn_error( rb_ePGerror, self, &quot;negative length %d given&quot;, len);

	buffer = ALLOC_N(char, len);

	BLOCKING_BEGIN(conn)
		ret = lo_read(conn, lo_desc, buffer, len);
	BLOCKING_END(conn)

	if(ret &lt; 0)
		pg_raise_conn_error( rb_ePGerror, self, &quot;lo_read failed&quot;);

	if(ret == 0) {
		xfree(buffer);
		return Qnil;
	}

	str = rb_str_new(buffer, ret);
	xfree(buffer);

	return str;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="loseek-instance_method">
  <h3 class='signature '>
    #<strong>loseek</strong>(lo_desc, offset, whence)  &#x21d2; <code>Integer</code>     <span class='aliases'>Also known as: <span class='names'>#lo_lseek, #lolseek, #lo_seek</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Move the large object pointer <em>lo_desc</em> to offset <em>offset</em>. Valid values for <em>whence</em> are <code>SEEK_SET</code>, <code>SEEK_CUR</code>, and <code>SEEK_END</code>. (Or 0, 1, or 2.)</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3934-L3950'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3934' data-end='3950'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3934</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_lolseek(VALUE self, VALUE in_lo_desc, VALUE offset, VALUE whence)
{
	PGconn *conn = pg_get_pgconn(self);
	int lo_desc = NUM2INT(in_lo_desc);
	int ret;

	BLOCKING_BEGIN(conn)
		ret = lo_lseek(conn, lo_desc, NUM2INT(offset), NUM2INT(whence));
	BLOCKING_END(conn)

	if(ret &lt; 0) {
		pg_raise_conn_error( rb_ePGerror, self, &quot;lo_lseek failed&quot;);
	}

	return INT2FIX(ret);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="lotell-instance_method">
  <h3 class='signature '>
    #<strong>lotell</strong>(lo_desc)  &#x21d2; <code>Integer</code>     <span class='aliases'>Also known as: <span class='names'>#lo_tell</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the current position of the large object <em>lo_desc</em>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3958-L3973'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3958' data-end='3973'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3958</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_lotell(VALUE self, VALUE in_lo_desc)
{
	int position;
	PGconn *conn = pg_get_pgconn(self);
	int lo_desc = NUM2INT(in_lo_desc);

	BLOCKING_BEGIN(conn)
		position = lo_tell(conn, lo_desc);
	BLOCKING_END(conn)

	if(position &lt; 0)
		pg_raise_conn_error( rb_ePGerror, self, &quot;lo_tell failed&quot;);

	return INT2FIX(position);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="lotruncate-instance_method">
  <h3 class='signature '>
    #<strong>lotruncate</strong>(lo_desc, len)  &#x21d2; <code>nil</code>     <span class='aliases'>Also known as: <span class='names'>#lo_truncate</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Truncates the large object <em>lo_desc</em> to size <em>len</em>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3981-L3997'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3981' data-end='3997'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3981</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_lotruncate(VALUE self, VALUE in_lo_desc, VALUE in_len)
{
	PGconn *conn = pg_get_pgconn(self);
	int lo_desc = NUM2INT(in_lo_desc);
	size_t len = NUM2INT(in_len);
	int ret;

	BLOCKING_BEGIN(conn)
		ret = lo_truncate(conn,lo_desc,len);
	BLOCKING_END(conn)

	if(ret &lt; 0)
		pg_raise_conn_error( rb_ePGerror, self, &quot;lo_truncate failed&quot;);

	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="lounlink-instance_method">
  <h3 class='signature '>
    #<strong>lounlink</strong>(oid)  &#x21d2; <code>nil</code>     <span class='aliases'>Also known as: <span class='names'>#lo_unlink</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Unlinks (deletes) the postgres large object of <em>oid</em>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4028-L4043'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4028' data-end='4043'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4028</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_lounlink(VALUE self, VALUE in_oid)
{
	PGconn *conn = pg_get_pgconn(self);
	Oid oid = NUM2UINT(in_oid);
	int ret;

	BLOCKING_BEGIN(conn)
		ret = lo_unlink(conn,oid);
	BLOCKING_END(conn)

	if(ret &lt; 0)
		pg_raise_conn_error( rb_ePGerror, self, &quot;lo_unlink failed&quot;);

	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="lowrite-instance_method">
  <h3 class='signature '>
    #<strong>lowrite</strong>(lo_desc, buffer)  &#x21d2; <code>Integer</code>     <span class='aliases'>Also known as: <span class='names'>#lo_write</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Writes the string <em>buffer</em> to the large object <em>lo_desc</em>. Returns the number of bytes written.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3861-L3883'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3861' data-end='3883'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3861</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_lowrite(VALUE self, VALUE in_lo_desc, VALUE buffer)
{
	int n;
	PGconn *conn = pg_get_pgconn(self);
	int fd = NUM2INT(in_lo_desc);

	Check_Type(buffer, T_STRING);

	if( RSTRING_LEN(buffer) &lt; 0) {
		pg_raise_conn_error( rb_ePGerror, self, &quot;write buffer zero string&quot;);
	}
	BLOCKING_BEGIN(conn)
		n = lo_write(conn, fd, StringValuePtr(buffer),
				RSTRING_LEN(buffer));
	BLOCKING_END(conn)

	if(n &lt; 0) {
		pg_raise_conn_error( rb_ePGerror, self, &quot;lo_write failed: %s&quot;, PQerrorMessage(conn));
	}

	return INT2FIX(n);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="make_empty_pgresult-instance_method">
  <h3 class='signature '>
    #<strong>make_empty_pgresult</strong>(status)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Constructs and empty <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> with status <em>status</em>. <em>status</em> may be one of:</p>
<ul><li>
<p><code>PGRES_EMPTY_QUERY</code></p>
</li><li>
<p><code>PGRES_COMMAND_OK</code></p>
</li><li>
<p><code>PGRES_TUPLES_OK</code></p>
</li><li>
<p><code>PGRES_COPY_OUT</code></p>
</li><li>
<p><code>PGRES_COPY_IN</code></p>
</li><li>
<p><code>PGRES_BAD_RESPONSE</code></p>
</li><li>
<p><code>PGRES_NONFATAL_ERROR</code></p>
</li><li>
<p><code>PGRES_FATAL_ERROR</code></p>
</li><li>
<p><code>PGRES_COPY_BOTH</code></p>
</li><li>
<p><code>PGRES_SINGLE_TUPLE</code></p>
</li><li>
<p><code>PGRES_PIPELINE_SYNC</code></p>
</li><li>
<p><code>PGRES_PIPELINE_ABORTED</code></p>
</li></ul>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1593-L1603'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1593' data-end='1603'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1593</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_make_empty_pgresult(VALUE self, VALUE status)
{
	PGresult *result;
	VALUE rb_pgresult;
	PGconn *conn = pg_get_pgconn(self);
	result = PQmakeEmptyPGresult(conn, NUM2INT(status));
	rb_pgresult = pg_new_result(result, self);
	pg_result_check(rb_pgresult);
	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="notifies-instance_method">
  <h3 class='signature '>
    #<strong>notifies</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns a hash of the unprocessed notifications. If there is no unprocessed notifier, it returns <code>nil</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2236-L2267'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2236' data-end='2267'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2236</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_notifies(VALUE self)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	PGnotify *notification;
	VALUE hash;
	VALUE sym_relname, sym_be_pid, sym_extra;
	VALUE relname, be_pid, extra;

	sym_relname = ID2SYM(rb_intern(&quot;relname&quot;));
	sym_be_pid = ID2SYM(rb_intern(&quot;be_pid&quot;));
	sym_extra = ID2SYM(rb_intern(&quot;extra&quot;));

	notification = gvl_PQnotifies(this-&gt;pgconn);
	if (notification == NULL) {
		return Qnil;
	}

	hash = rb_hash_new();
	relname = rb_str_new2(notification-&gt;relname);
	be_pid = INT2NUM(notification-&gt;be_pid);
	extra = rb_str_new2(notification-&gt;extra);
	PG_ENCODING_SET_NOCHECK( relname, this-&gt;enc_idx );
	PG_ENCODING_SET_NOCHECK( extra, this-&gt;enc_idx );

	rb_hash_aset(hash, sym_relname, relname);
	rb_hash_aset(hash, sym_be_pid, be_pid);
	rb_hash_aset(hash, sym_extra, extra);

	PQfreemem(notification);
	return hash;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="notifies_wait-instance_method">
  <h3 class='signature '>
    #<strong>notifies_wait</strong>([ timeout ]) {|event, pid, payload| ... } &#x21d2; <code>String</code>     <span class='aliases'>Also known as: <span class='names'>#wait_for_notify</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Blocks while waiting for notification(s), or until the optional <em>timeout</em> is reached, whichever comes first.  <em>timeout</em> is measured in seconds and can be fractional.</p>

<p>Returns <code>nil</code> if <em>timeout</em> is reached, the name of the NOTIFY event otherwise. If used in block form, passes the name of the NOTIFY <code>event</code>, the generating <code>pid</code> and the optional <code>payload</code> string into the block.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2521-L2558'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2521' data-end='2558'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2521</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_wait_for_notify(int argc, VALUE *argv, VALUE self)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	PGnotify *pnotification;
	struct timeval timeout;
	struct timeval *ptimeout = NULL;
	VALUE timeout_in = Qnil, relname = Qnil, be_pid = Qnil, extra = Qnil;
	double timeout_sec;

	rb_scan_args( argc, argv, &quot;01&quot;, &amp;timeout_in );

	if ( RTEST(timeout_in) ) {
		timeout_sec = NUM2DBL( timeout_in );
		timeout.tv_sec = (time_t)timeout_sec;
		timeout.tv_usec = (suseconds_t)( (timeout_sec - (long)timeout_sec) * 1e6 );
		ptimeout = &amp;timeout;
	}

	pnotification = (PGnotify*) wait_socket_readable( self, ptimeout, notify_readable);

	/* Return nil if the select timed out */
	if ( !pnotification ) return Qnil;

	relname = rb_str_new2( pnotification-&gt;relname );
	PG_ENCODING_SET_NOCHECK( relname, this-&gt;enc_idx );
	be_pid = INT2NUM( pnotification-&gt;be_pid );
	if ( *pnotification-&gt;extra ) {
		extra = rb_str_new2( pnotification-&gt;extra );
		PG_ENCODING_SET_NOCHECK( extra, this-&gt;enc_idx );
	}
	PQfreemem( pnotification );

	if ( rb_block_given_p() )
		rb_yield_values( 3, relname, be_pid, extra );

	return relname;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="options-instance_method">
  <h3 class='signature '>
    #<strong>options</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns backend option string.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L747-L753'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='747' data-end='753'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 747</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_options(VALUE self)
{
	char *options = PQoptions(pg_get_pgconn(self));
	if (!options) return Qnil;
	return rb_str_new2(options);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="parameter_status-instance_method">
  <h3 class='signature '>
    #<strong>parameter_status</strong>(param_name)  &#x21d2; <code>String</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the setting of parameter <em>param_name</em>, where <em>param_name</em> is one of</p>
<ul><li>
<p><a href="#server_version-instance_method" title="PG::Connection#server_version (method)">#server_version</a></p>
</li><li>
<p><code>server_encoding</code></p>
</li><li>
<p><code>client_encoding</code></p>
</li><li>
<p><code>is_superuser</code></p>
</li><li>
<p><code>session_authorization</code></p>
</li><li>
<p><code>DateStyle</code></p>
</li><li>
<p><code>TimeZone</code></p>
</li><li>
<p><code>integer_datetimes</code></p>
</li><li>
<p><code>standard_conforming_strings</code></p>
</li></ul>

<p>Returns nil if the value of the parameter is not known.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L835-L843'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='835' data-end='843'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 835</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_parameter_status(VALUE self, VALUE param_name)
{
	const char *ret = PQparameterStatus(pg_get_pgconn(self), StringValueCStr(param_name));
	if(ret == NULL)
		return Qnil;
	else
		return rb_str_new2(ret);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="pass-instance_method">
  <h3 class='signature '>
    #<strong>pass</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the authenticated password.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L660-L666'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='660' data-end='666'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 660</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_pass(VALUE self)
{
	char *user = PQpass(pg_get_pgconn(self));
	if (!user) return Qnil;
	return rb_str_new2(user);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="pipeline_status-instance_method">
  <h3 class='signature '>
    #<strong>pipeline_status</strong>  &#x21d2; <code>Integer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the current pipeline mode status of the libpq connection.</p>

<p>PQpipelineStatus can return one of the following values:</p>
<ul><li>
<p>PQ_PIPELINE_ON - The libpq connection is in pipeline mode.</p>
</li><li>
<p>PQ_PIPELINE_OFF - The libpq connection is not in pipeline mode.</p>
</li><li>
<p>PQ_PIPELINE_ABORTED - The libpq connection is in pipeline mode and an error occurred while processing the current pipeline. The aborted flag is cleared when PQgetResult returns a result of type PGRES_PIPELINE_SYNC.</p>
</li></ul>

<p>Available since PostgreSQL-14</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3603-L3608'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3603' data-end='3608'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3603</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_pipeline_status(VALUE self)
{
	int res = PQpipelineStatus(pg_get_pgconn(self));
	return INT2FIX(res);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="pipeline_sync-instance_method">
  <h3 class='signature '>
    #<strong>pipeline_sync</strong>  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Marks a synchronization point in a pipeline by sending a sync message and flushing the send buffer. This serves as the delimiter of an implicit transaction and an error recovery point; see Section 34.5.1.3 of the PostgreSQL documentation.</p>

<p>Raises <a href="Error.html" title="PG::Error (class)"><code>Error</code></a> if the connection is not in pipeline mode or sending a sync message failed.</p>

<p>Available since PostgreSQL-14</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3667-L3676'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3667' data-end='3676'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3667</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_pipeline_sync(VALUE self)
{
	PGconn *conn = pg_get_pgconn(self);
	int res = PQpipelineSync(conn);
	if( res != 1 )
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(conn));

	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="port-instance_method">
  <h3 class='signature '>
    #<strong>port</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the connected server port number.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L719-L727'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='719' data-end='727'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 719</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_port(VALUE self)
{
	char* port = PQport(pg_get_pgconn(self));
	if (!port || port[0] == &#39;\0&#39;)
		return INT2NUM(DEF_PGPORT);
	else
		return INT2NUM(atoi(port));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="prepare-instance_method">
  <h3 class='signature '>
    #<strong>prepare</strong>(stmt_name, sql [, param_types ] )  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a>     <span class='aliases'>Also known as: <span class='names'>#async_prepare</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Prepares statement <em>sql</em> with name <em>name</em> to be executed later. Returns a <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> instance on success. On failure, it raises a <a href="Error.html" title="PG::Error (class)"><code>Error</code></a>.</p>

<p><code>param_types</code> is an optional parameter to specify the Oids of the types of the parameters.</p>

<p>If the types are not specified, they will be inferred by PostgreSQL. Instead of specifying type oids, it’s recommended to simply add explicit casts in the query to ensure that the right type is used.</p>

<p>For example: “SELECT $1::int”</p>

<p>PostgreSQL bind parameters are represented as $1, $2, $3, etc., inside the SQL query.</p>

<p>See also corresponding <a href="https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQPREPARE" target="_parent" title="libpq function">libpq function</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3391-L3404'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3391' data-end='3404'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3391</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_async_prepare(int argc, VALUE *argv, VALUE self)
{
	VALUE rb_pgresult = Qnil;

	pgconn_discard_results( self );
	pgconn_send_prepare( argc, argv, self );
	rb_pgresult = pgconn_async_get_last_result( self );

	if ( rb_block_given_p() ) {
		return rb_ensure( rb_yield, rb_pgresult, pg_result_clear, rb_pgresult );
	}
	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="protocol_version-instance_method">
  <h3 class='signature '>
    #<strong>protocol_version</strong>  &#x21d2; <code>Integer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>The 3.0 protocol will normally be used when communicating with PostgreSQL 7.4 or later servers; pre-7.4 servers support only protocol 2.0. (Protocol 1.0 is obsolete and not supported by libpq.)</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L853-L857'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='853' data-end='857'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 853</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_protocol_version(VALUE self)
{
	return INT2NUM(PQprotocolVersion(pg_get_pgconn(self)));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="put_copy_data-instance_method">
  <h3 class='signature '>
    #<strong>put_copy_data</strong>(buffer [, encoder] )  &#x21d2; <code>Boolean</code>     <span class='aliases'>Also known as: <span class='names'>#async_put_copy_data</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Transmits <em>buffer</em> as copy data to the server. Returns true if the data was sent, false if it was not sent (false is only possible if the connection is in nonblocking mode, and this command would block).</p>

<p><em>encoder</em> can be a <a href="Coder.html" title="PG::Coder (class)"><code>Coder</code></a> derivation (typically <a href="TextEncoder/CopyRow.html" title="PG::TextEncoder::CopyRow (class)"><code>TextEncoder::CopyRow</code></a>). This encodes the data fields given as <em>buffer</em> from an Array of Strings to PostgreSQL’s COPY text format inclusive proper escaping. Optionally the encoder can type cast the fields from various Ruby types in one step, if <code>PG::TextEncoder::CopyRow#type_map</code> is set accordingly.</p>

<p>Raises an exception if an error occurs.</p>

<p>See also <a href="#copy_data-instance_method" title="PG::Connection#copy_data (method)">#copy_data</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L495-L510'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='495' data-end='510'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 495</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_put_copy_data'>put_copy_data</span>(<span class='id identifier rubyid_buffer'>buffer</span><span class='comma'>,</span> <span class='id identifier rubyid_encoder'>encoder</span><span class='op'>=</span><span class='kw'>nil</span>)
	<span class='comment'># sync_put_copy_data does a non-blocking attempt to flush data.
</span>	<span class='kw'>until</span> <span class='id identifier rubyid_res'>res</span><span class='op'>=</span><span class='id identifier rubyid_sync_put_copy_data'><a href="#sync_put_copy_data-instance_method" title="PG::Connection#sync_put_copy_data (method)">sync_put_copy_data</a></span>(<span class='id identifier rubyid_buffer'>buffer</span><span class='comma'>,</span> <span class='id identifier rubyid_encoder'>encoder</span>)
		<span class='comment'># It didn&#39;t flush immediately and allocation of more buffering memory failed.
</span>		<span class='comment'># Wait for all data sent by doing a blocking flush.
</span>		<span class='id identifier rubyid_res'>res</span> <span class='op'>=</span> <span class='id identifier rubyid_flush'><a href="#flush-instance_method" title="PG::Connection#flush (method)">flush</a></span>
	<span class='kw'>end</span>

	<span class='comment'># And do a blocking flush every 100 calls.
</span>	<span class='comment'># This is to avoid memory bloat, when sending the data is slower than calls to put_copy_data happen.
</span>	<span class='kw'>if</span> (<span class='ivar'>@calls_to_put_copy_data</span> <span class='op'>+=</span> <span class='int'>1</span>) <span class='op'>&gt;</span> <span class='int'>100</span>
		<span class='ivar'>@calls_to_put_copy_data</span> <span class='op'>=</span> <span class='int'>0</span>
		<span class='id identifier rubyid_res'>res</span> <span class='op'>=</span> <span class='id identifier rubyid_flush'><a href="#flush-instance_method" title="PG::Connection#flush (method)">flush</a></span>
	<span class='kw'>end</span>
	<span class='id identifier rubyid_res'>res</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="put_copy_end-instance_method">
  <h3 class='signature '>
    #<strong>put_copy_end</strong>([ error_message ])  &#x21d2; <code>Boolean</code>     <span class='aliases'>Also known as: <span class='names'>#async_put_copy_end</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sends end-of-data indication to the server.</p>

<p><em>error_message</em> is an optional parameter, and if set, forces the COPY command to fail with the string <em>error_message</em>.</p>

<p>Returns true if the end-of-data was sent, #false* if it was not sent (<strong>false</strong> is only possible if the connection is in nonblocking mode, and this command would block).</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L525-L531'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='525' data-end='531'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 525</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_put_copy_end'>put_copy_end</span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>)
	<span class='kw'>until</span> <span class='id identifier rubyid_sync_put_copy_end'><a href="#sync_put_copy_end-instance_method" title="PG::Connection#sync_put_copy_end (method)">sync_put_copy_end</a></span>(<span class='op'>*</span><span class='id identifier rubyid_args'>args</span>)
		<span class='id identifier rubyid_flush'><a href="#flush-instance_method" title="PG::Connection#flush (method)">flush</a></span>
	<span class='kw'>end</span>
	<span class='ivar'>@calls_to_put_copy_data</span> <span class='op'>=</span> <span class='int'>0</span>
	<span class='id identifier rubyid_flush'><a href="#flush-instance_method" title="PG::Connection#flush (method)">flush</a></span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="quote_ident-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>quote_ident</strong>(str)  &#x21d2; <code>String</code> </span>
      <span class='overload'>#<strong>quote_ident</strong>(array)  &#x21d2; <code>String</code> </span>
      <span class='overload'>#<strong>quote_ident</strong>(str)  &#x21d2; <code>String</code> </span>
      <span class='overload'>#<strong>quote_ident</strong>(array)  &#x21d2; <code>String</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#quote_ident-class_method" title="PG::Connection.quote_ident (method)">.quote_ident</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="reset-instance_method">
  <h3 class='signature '>
    #<strong>reset</strong>      <span class='aliases'>Also known as: <span class='names'>#async_reset</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Resets the backend connection. This method closes the backend connection and tries to re-connect.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L567-L576'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='567' data-end='576'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 567</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_reset'>reset</span>
	<span class='id identifier rubyid_iopts'>iopts</span> <span class='op'>=</span> <span class='id identifier rubyid_conninfo_hash'><a href="#conninfo_hash-instance_method" title="PG::Connection#conninfo_hash (method)">conninfo_hash</a></span>.<span class='id identifier rubyid_compact'>compact</span>
	<span class='kw'>if</span> <span class='id identifier rubyid_iopts'>iopts</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_host'><a href="#host-instance_method" title="PG::Connection#host (method)">host</a></span>] <span class='op'>&amp;&amp;</span> <span class='op'>!</span><span class='id identifier rubyid_iopts'>iopts</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_host'><a href="#host-instance_method" title="PG::Connection#host (method)">host</a></span>].<span class='id identifier rubyid_empty?'>empty?</span> <span class='op'>&amp;&amp;</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span>.<span class='id identifier rubyid_library_version'><a href="../PG.html#library_version-class_method" title="PG.library_version (method)">library_version</a></span> <span class='op'>&gt;=</span> <span class='int'>100000</span>
		<span class='id identifier rubyid_iopts'>iopts</span> <span class='op'>=</span> <span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span>.<span class='id identifier rubyid_send'>send</span>(<span class='symbeg'>:</span><span class='id identifier rubyid_resolve_hosts'><a href="#resolve_hosts-class_method" title="PG::Connection.resolve_hosts (method)">resolve_hosts</a></span><span class='comma'>,</span> <span class='id identifier rubyid_iopts'>iopts</span>)
	<span class='kw'>end</span>
	<span class='id identifier rubyid_conninfo'><a href="#conninfo-instance_method" title="PG::Connection#conninfo (method)">conninfo</a></span> <span class='op'>=</span> <span class='kw'>self</span>.<span class='id identifier rubyid_class'>class</span>.<span class='id identifier rubyid_parse_connect_args'><a href="#parse_connect_args-class_method" title="PG::Connection.parse_connect_args (method)">parse_connect_args</a></span>( <span class='id identifier rubyid_iopts'>iopts</span> )<span class='semicolon'>;</span>
	<span class='id identifier rubyid_reset_start2'><a href="#reset_start2-instance_method" title="PG::Connection#reset_start2 (method)">reset_start2</a></span>(<span class='id identifier rubyid_conninfo'><a href="#conninfo-instance_method" title="PG::Connection#conninfo (method)">conninfo</a></span>)
	<span class='id identifier rubyid_async_connect_or_reset'><a href="#async_connect_or_reset-instance_method" title="PG::Connection#async_connect_or_reset (method)">async_connect_or_reset</a></span>(<span class='symbeg'>:</span><span class='id identifier rubyid_reset_poll'><a href="#reset_poll-instance_method" title="PG::Connection#reset_poll (method)">reset_poll</a></span>)
	<span class='kw'>self</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="reset_poll-instance_method">
  <h3 class='signature '>
    #<strong>reset_poll</strong>  &#x21d2; <code>Integer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Checks the status of a connection reset operation. See <code>#connect_start</code> and <a href="#connect_poll-instance_method" title="PG::Connection#connect_poll (method)">#connect_poll</a> for usage information and return values.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L614-L623'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='614' data-end='623'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 614</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_reset_poll(VALUE self)
{
	PostgresPollingStatusType status;

	pgconn_close_socket_io(self);
	status = gvl_PQresetPoll(pg_get_pgconn(self));

	return INT2FIX((int)status);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="reset_start-instance_method">
  <h3 class='signature '>
    #<strong>reset_start</strong>  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Initiate a connection reset in a nonblocking manner. This will close the current connection and attempt to reconnect using the same connection parameters. Use <a href="#reset_poll-instance_method" title="PG::Connection#reset_poll (method)">#reset_poll</a> to check the status of the connection reset.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L597-L604'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='597' data-end='604'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 597</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_reset_start(VALUE self)
{
	pgconn_close_socket_io( self );
	if(gvl_PQresetStart(pg_get_pgconn(self)) == 0)
		pg_raise_conn_error( rb_eUnableToSend, self, &quot;reset has failed&quot;);
	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="reset_start2-instance_method">
  <h3 class='signature priv'>
    #<strong>reset_start2</strong>(conninfo)   <span class="extras">(<span class='priv'>private</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L566-L585'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='566' data-end='585'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 566</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_reset_start2( VALUE self, VALUE conninfo )
{
	t_pg_connection *this = pg_get_connection( self );

	/* Close old connection */
	pgconn_close_socket_io( self );
	PQfinish( this-&gt;pgconn );

	/* Start new connection */
	this-&gt;pgconn = gvl_PQconnectStart( StringValueCStr(conninfo) );

	if( this-&gt;pgconn == NULL )
		rb_raise(rb_ePGerror, &quot;PQconnectStart() unable to allocate PGconn structure&quot;);

	if ( PQstatus(this-&gt;pgconn) == CONNECTION_BAD )
		pg_raise_conn_error( rb_eConnectionBad, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));

	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="send_describe_portal-instance_method">
  <h3 class='signature '>
    #<strong>send_describe_portal</strong>(portal_name)  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Asynchronously send <em>command</em> to the server. Does not block. Use in combination with <code>conn.get_result</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2104-L2114'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2104' data-end='2114'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2104</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_send_describe_portal(VALUE self, VALUE portal)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	/* returns 0 on failure */
	if(gvl_PQsendDescribePortal(this-&gt;pgconn, pg_cstr_enc(portal, this-&gt;enc_idx)) == 0)
		pg_raise_conn_error( rb_eUnableToSend, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));

	pgconn_wait_for_flush( self );
	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="send_describe_prepared-instance_method">
  <h3 class='signature '>
    #<strong>send_describe_prepared</strong>(statement_name)  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Asynchronously send <em>command</em> to the server. Does not block. Use in combination with <code>conn.get_result</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2084-L2094'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2084' data-end='2094'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2084</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_send_describe_prepared(VALUE self, VALUE stmt_name)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	/* returns 0 on failure */
	if(gvl_PQsendDescribePrepared(this-&gt;pgconn, pg_cstr_enc(stmt_name, this-&gt;enc_idx)) == 0)
		pg_raise_conn_error( rb_eUnableToSend, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));

	pgconn_wait_for_flush( self );
	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="send_flush_request-instance_method">
  <h3 class='signature '>
    #<strong>pipeline_sync</strong>  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sends a request for the server to flush its output buffer.</p>

<p>The server flushes its output buffer automatically as a result of <a href="#pipeline_sync-instance_method" title="PG::Connection#pipeline_sync (method)">#pipeline_sync</a> being called, or on any request when not in pipeline mode. This function is useful to cause the server to flush its output buffer in pipeline mode without establishing a synchronization point. Note that the request is not itself flushed to the server automatically; use <a href="#flush-instance_method" title="PG::Connection#flush (method)">#flush</a> if necessary.</p>

<p>Available since PostgreSQL-14</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3690-L3699'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3690' data-end='3699'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3690</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_send_flush_request(VALUE self)
{
	PGconn *conn = pg_get_pgconn(self);
	int res = PQsendFlushRequest(conn);
	if( res != 1 )
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(conn));

	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="send_prepare-instance_method">
  <h3 class='signature '>
    #<strong>send_prepare</strong>(stmt_name, sql [, param_types ] )  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Prepares statement <em>sql</em> with name <em>name</em> to be executed later. Sends prepare command asynchronously, and returns immediately. On failure, it raises a <a href="Error.html" title="PG::Error (class)"><code>Error</code></a>.</p>

<p><code>param_types</code> is an optional parameter to specify the Oids of the types of the parameters.</p>

<p>If the types are not specified, they will be inferred by PostgreSQL. Instead of specifying type oids, it’s recommended to simply add explicit casts in the query to ensure that the right type is used.</p>

<p>For example: “SELECT $1::int”</p>

<p>PostgreSQL bind parameters are represented as $1, $2, $3, etc., inside the SQL query.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1970-L2009'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1970' data-end='2009'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1970</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_send_prepare(int argc, VALUE *argv, VALUE self)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	int result;
	VALUE name, command, in_paramtypes;
	VALUE param;
	int i = 0;
	int nParams = 0;
	Oid *paramTypes = NULL;
	const char *name_cstr;
	const char *command_cstr;
	int enc_idx = this-&gt;enc_idx;

	rb_scan_args(argc, argv, &quot;21&quot;, &amp;name, &amp;command, &amp;in_paramtypes);
	name_cstr = pg_cstr_enc(name, enc_idx);
	command_cstr = pg_cstr_enc(command, enc_idx);

	if(! NIL_P(in_paramtypes)) {
		Check_Type(in_paramtypes, T_ARRAY);
		nParams = (int)RARRAY_LEN(in_paramtypes);
		paramTypes = ALLOC_N(Oid, nParams);
		for(i = 0; i &lt; nParams; i++) {
			param = rb_ary_entry(in_paramtypes, i);
			if(param == Qnil)
				paramTypes[i] = 0;
			else
				paramTypes[i] = NUM2UINT(param);
		}
	}
	result = gvl_PQsendPrepare(this-&gt;pgconn, name_cstr, command_cstr, nParams, paramTypes);

	xfree(paramTypes);

	if(result == 0) {
		pg_raise_conn_error( rb_eUnableToSend, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));
	}
	pgconn_wait_for_flush( self );
	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="send_query-instance_method">
  <h3 class='signature '>
    #<strong>send_query</strong>(sql)  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sends SQL query request specified by <em>sql</em> to PostgreSQL for asynchronous processing, and immediately returns. On failure, it raises a <a href="Error.html" title="PG::Error (class)"><code>Error</code></a>.</p>

<p>For backward compatibility, if you pass more than one parameter to this method, it will call <a href="#send_query_params-instance_method" title="PG::Connection#send_query_params (method)">#send_query_params</a> for you. New code should explicitly use <a href="#send_query_params-instance_method" title="PG::Connection#send_query_params (method)">#send_query_params</a> if argument placeholders are used.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1861-L1881'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1861' data-end='1881'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1861</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_send_query(int argc, VALUE *argv, VALUE self)
{
	t_pg_connection *this = pg_get_connection_safe( self );

	/* If called with no or nil parameters, use PQexec for compatibility */
	if ( argc == 1 || (argc &gt;= 2 &amp;&amp; argc &lt;= 4 &amp;&amp; NIL_P(argv[1]) )) {
		if(gvl_PQsendQuery(this-&gt;pgconn, pg_cstr_enc(argv[0], this-&gt;enc_idx)) == 0)
			pg_raise_conn_error( rb_eUnableToSend, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));

		pgconn_wait_for_flush( self );
		return Qnil;
	}

	pg_deprecated(2, (&quot;forwarding async_exec to async_exec_params and send_query to send_query_params is deprecated&quot;));

	/* If called with parameters, and optionally result_format,
	 * use PQsendQueryParams
	 */
	return pgconn_send_query_params( argc, argv, self);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="send_query_params-instance_method">
  <h3 class='signature '>
    #<strong>send_query_params</strong>(sql, params [, result_format [, type_map ]] )  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sends SQL query request specified by <em>sql</em> to PostgreSQL for asynchronous processing, and immediately returns. On failure, it raises a <a href="Error.html" title="PG::Error (class)"><code>Error</code></a>.</p>

<p><code>params</code> is an array of the bind parameters for the SQL query. Each element of the <code>params</code> array may be either:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_a'>a</span> <span class='id identifier rubyid_hash'>hash</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_the'>the</span> <span class='label'>form:</span>
  {<span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span>  <span class='op'>=&gt;</span> <span class='const'>String</span> (<span class='id identifier rubyid_value'>value</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_bind'>bind</span> <span class='id identifier rubyid_parameter'>parameter</span>)
   <span class='symbeg'>:</span><span class='id identifier rubyid_type'>type</span>   <span class='op'>=&gt;</span> <span class='const'>Integer</span> (<span class='id identifier rubyid_oid'>oid</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_type'>type</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_bind'>bind</span> <span class='id identifier rubyid_parameter'>parameter</span>)
   <span class='symbeg'>:</span><span class='id identifier rubyid_format'>format</span> <span class='op'>=&gt;</span> <span class='const'>Integer</span> (<span class='int'>0</span> <span class='kw'>for</span> <span class='id identifier rubyid_text'>text</span><span class='comma'>,</span> <span class='int'>1</span> <span class='kw'>for</span> <span class='id identifier rubyid_binary'>binary</span>)
  }
<span class='kw'>or</span><span class='comma'>,</span> <span class='id identifier rubyid_it'>it</span> <span class='id identifier rubyid_may'>may</span> <span class='id identifier rubyid_be'>be</span> <span class='id identifier rubyid_a'>a</span> <span class='const'>String</span>. <span class='const'>If</span> <span class='id identifier rubyid_it'>it</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_a'>a</span> <span class='id identifier rubyid_string'>string</span><span class='comma'>,</span> <span class='id identifier rubyid_that'>that</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_equivalent'>equivalent</span> <span class='id identifier rubyid_to'>to</span> <span class='id identifier rubyid_the'>the</span> <span class='label'>hash:</span>
  { <span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span> <span class='op'>=&gt;</span> <span class='op'>&lt;</span><span class='id identifier rubyid_string'>string</span> <span class='id identifier rubyid_value'>value</span><span class='op'>&gt;</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_type'>type</span> <span class='op'>=&gt;</span> <span class='int'>0</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_format'>format</span> <span class='op'>=&gt;</span> <span class='int'>0</span> }</code></pre>

<p>PostgreSQL bind parameters are represented as $1, $2, $3, etc., inside the SQL query. The 0th element of the <code>params</code> array is bound to $1, the 1st element is bound to $2, etc. <code>nil</code> is treated as <code>NULL</code>.</p>

<p>If the types are not specified, they will be inferred by PostgreSQL. Instead of specifying type oids, it’s recommended to simply add explicit casts in the query to ensure that the right type is used.</p>

<p>For example: “SELECT $1::int”</p>

<p>The optional <code>result_format</code> should be 0 for text results, 1 for binary.</p>

<p><code>type_map</code> can be a <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> derivation (such as <a href="BasicTypeMapForQueries.html" title="PG::BasicTypeMapForQueries (class)"><code>BasicTypeMapForQueries</code></a>). This will type cast the params from various Ruby types before transmission based on the encoders defined by the type map. When a type encoder is used the format and oid of a given bind parameter are retrieved from the encoder instead out of the hash form described above.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1921-L1948'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1921' data-end='1948'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1921</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_send_query_params(int argc, VALUE *argv, VALUE self)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	int result;
	VALUE command, in_res_fmt;
	int nParams;
	int resultFormat;
	struct query_params_data paramsData = { this-&gt;enc_idx };

	rb_scan_args(argc, argv, &quot;22&quot;, &amp;command, &amp;paramsData.params, &amp;in_res_fmt, &amp;paramsData.typemap);
	paramsData.with_types = 1;

	pgconn_query_assign_typemap( self, &amp;paramsData );
	resultFormat = NIL_P(in_res_fmt) ? 0 : NUM2INT(in_res_fmt);
	nParams = alloc_query_params( &amp;paramsData );

	result = gvl_PQsendQueryParams(this-&gt;pgconn, pg_cstr_enc(command, paramsData.enc_idx), nParams, paramsData.types,
		(const char * const *)paramsData.values, paramsData.lengths, paramsData.formats, resultFormat);

	free_query_params( &amp;paramsData );

	if(result == 0)
		pg_raise_conn_error( rb_eUnableToSend, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));

	pgconn_wait_for_flush( self );
	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="send_query_prepared-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>send_query_prepared</strong>(statement_name [, params, result_format[, type_map ]] )  </span>
      <span class='overload'>#<strong>-</strong>  </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Execute prepared named statement specified by <em>statement_name</em> asynchronously, and returns immediately. On failure, it raises a <a href="Error.html" title="PG::Error (class)"><code>Error</code></a>.</p>

<p><code>params</code> is an array of the optional bind parameters for the SQL query. Each element of the <code>params</code> array may be either:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_a'>a</span> <span class='id identifier rubyid_hash'>hash</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_the'>the</span> <span class='label'>form:</span>
  {<span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span>  <span class='op'>=&gt;</span> <span class='const'>String</span> (<span class='id identifier rubyid_value'>value</span> <span class='id identifier rubyid_of'>of</span> <span class='id identifier rubyid_bind'>bind</span> <span class='id identifier rubyid_parameter'>parameter</span>)
   <span class='symbeg'>:</span><span class='id identifier rubyid_format'>format</span> <span class='op'>=&gt;</span> <span class='const'>Integer</span> (<span class='int'>0</span> <span class='kw'>for</span> <span class='id identifier rubyid_text'>text</span><span class='comma'>,</span> <span class='int'>1</span> <span class='kw'>for</span> <span class='id identifier rubyid_binary'>binary</span>)
  }
<span class='kw'>or</span><span class='comma'>,</span> <span class='id identifier rubyid_it'>it</span> <span class='id identifier rubyid_may'>may</span> <span class='id identifier rubyid_be'>be</span> <span class='id identifier rubyid_a'>a</span> <span class='const'>String</span>. <span class='const'>If</span> <span class='id identifier rubyid_it'>it</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_a'>a</span> <span class='id identifier rubyid_string'>string</span><span class='comma'>,</span> <span class='id identifier rubyid_that'>that</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_equivalent'>equivalent</span> <span class='id identifier rubyid_to'>to</span> <span class='id identifier rubyid_the'>the</span> <span class='label'>hash:</span>
  { <span class='symbeg'>:</span><span class='id identifier rubyid_value'>value</span> <span class='op'>=&gt;</span> <span class='op'>&lt;</span><span class='id identifier rubyid_string'>string</span> <span class='id identifier rubyid_value'>value</span><span class='op'>&gt;</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_format'>format</span> <span class='op'>=&gt;</span> <span class='int'>0</span> }</code></pre>

<p>PostgreSQL bind parameters are represented as $1, $2, $3, etc., inside the SQL query. The 0th element of the <code>params</code> array is bound to $1, the 1st element is bound to $2, etc. <code>nil</code> is treated as <code>NULL</code>.</p>

<p>The optional <code>result_format</code> should be 0 for text results, 1 for binary.</p>

<p><code>type_map</code> can be a <a href="TypeMap.html" title="PG::TypeMap (class)"><code>TypeMap</code></a> derivation (such as <a href="BasicTypeMapForQueries.html" title="PG::BasicTypeMapForQueries (class)"><code>BasicTypeMapForQueries</code></a>). This will type cast the params from various Ruby types before transmission based on the encoders defined by the type map. When a type encoder is used the format and oid of a given bind parameter are retrieved from the encoder instead out of the hash form described above.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2043-L2075'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2043' data-end='2075'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2043</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_send_query_prepared(int argc, VALUE *argv, VALUE self)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	int result;
	VALUE name, in_res_fmt;
	int nParams;
	int resultFormat;
	struct query_params_data paramsData = { this-&gt;enc_idx };

	rb_scan_args(argc, argv, &quot;13&quot;, &amp;name, &amp;paramsData.params, &amp;in_res_fmt, &amp;paramsData.typemap);
	paramsData.with_types = 0;

	if(NIL_P(paramsData.params)) {
		paramsData.params = rb_ary_new2(0);
	}
	pgconn_query_assign_typemap( self, &amp;paramsData );

	resultFormat = NIL_P(in_res_fmt) ? 0 : NUM2INT(in_res_fmt);
	nParams = alloc_query_params( &amp;paramsData );

	result = gvl_PQsendQueryPrepared(this-&gt;pgconn, pg_cstr_enc(name, paramsData.enc_idx), nParams,
		(const char * const *)paramsData.values, paramsData.lengths, paramsData.formats,
		resultFormat);

	free_query_params( &amp;paramsData );

	if(result == 0)
		pg_raise_conn_error( rb_eUnableToSend, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));

	pgconn_wait_for_flush( self );
	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="server_version-instance_method">
  <h3 class='signature '>
    #<strong>server_version</strong>  &#x21d2; <code>Integer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>The number is formed by converting the major, minor, and revision numbers into two-decimal-digit numbers and appending them together. For example, version 7.4.2 will be returned as 70402, and version 8.1 will be returned as 80100 (leading zeroes are not shown). Zero is returned if the connection is bad.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L870-L874'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='870' data-end='874'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 870</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_server_version(VALUE self)
{
	return INT2NUM(PQserverVersion(pg_get_pgconn(self)));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="set_client_encoding-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>client_encoding=</strong>(encoding)  </span>
      <span class='overload'>#<strong>set_client_encoding</strong>(encoding)  </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#client_encoding=-instance_method" title="PG::Connection#client_encoding= (method)">#client_encoding=</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="set_default_encoding-instance_method">
  <h3 class='signature '>
    #<strong>set_default_encoding</strong>  &#x21d2; <code>Encoding</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>If Ruby has its <code>Encoding.default_internal</code> set, set PostgreSQL’s client_encoding to match. Returns the new Encoding, or <code>nil</code> if the default internal encoding wasn’t set.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L4198-L4223'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='4198' data-end='4223'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 4198</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_set_default_encoding( VALUE self )
{
	PGconn *conn = pg_get_pgconn( self );
	rb_encoding *rb_enc;

	rb_check_frozen(self);
	if (( rb_enc = rb_default_internal_encoding() )) {
		rb_encoding * conn_encoding = pg_conn_enc_get( conn );

		/* Don&#39;t set the server encoding, if it&#39;s unnecessary.
		 * This is important for connection proxies, who disallow configuration settings.
		 */
		if ( conn_encoding != rb_enc ) {
			const char *encname = pg_get_rb_encoding_as_pg_encoding( rb_enc );
			if ( pgconn_set_client_encoding_async(self, rb_str_new_cstr(encname)) != 0 )
				rb_warning( &quot;Failed to set the default_internal encoding to %s: &#39;%s&#39;&quot;,
								encname, PQerrorMessage(conn) );
		}
		pgconn_set_internal_encoding_index( self );
		return rb_enc_from_encoding( rb_enc );
	} else {
		pgconn_set_internal_encoding_index( self );
		return Qnil;
	}
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="set_error_context_visibility-instance_method">
  <h3 class='signature '>
    #<strong>set_error_context_visibility</strong>(context_visibility)  &#x21d2; <code>Integer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sets connection’s context display mode to <em>context_visibility</em> and returns the previous setting. Available settings are:</p>
<ul><li>
<p>PQSHOW_CONTEXT_NEVER</p>
</li><li>
<p>PQSHOW_CONTEXT_ERRORS</p>
</li><li>
<p>PQSHOW_CONTEXT_ALWAYS</p>
</li></ul>

<p>This mode controls whether the CONTEXT field is included in messages (unless the verbosity setting is TERSE, in which case CONTEXT is never shown). The NEVER mode never includes CONTEXT, while ALWAYS always includes it if available. In ERRORS mode (the default), CONTEXT fields are included only for error messages, not for notices and warnings.</p>

<p>Changing this mode does not affect the messages available from already-existing <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> objects, only subsequently-created ones. (But see <a href="Result.html#verbose_error_message-instance_method" title="PG::Result#verbose_error_message (method)">Result#verbose_error_message</a> if you want to print a previous error with a different display mode.)</p>

<p>See also corresponding <a href="https://www.postgresql.org/docs/current/libpq-control.html#LIBPQ-PQSETERRORCONTEXTVISIBILITY" target="_parent" title="libpq function">libpq function</a>.</p>

<p>Available since PostgreSQL-9.6</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2726-L2732'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2726' data-end='2732'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2726</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_set_error_context_visibility(VALUE self, VALUE in_context_visibility)
{
	PGconn *conn = pg_get_pgconn(self);
	PGContextVisibility context_visibility = NUM2INT(in_context_visibility);
	return INT2FIX(PQsetErrorContextVisibility(conn, context_visibility));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="set_error_verbosity-instance_method">
  <h3 class='signature '>
    #<strong>set_error_verbosity</strong>(verbosity)  &#x21d2; <code>Integer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sets connection’s verbosity to <em>verbosity</em> and returns the previous setting. Available settings are:</p>
<ul><li>
<p>PQERRORS_TERSE</p>
</li><li>
<p>PQERRORS_DEFAULT</p>
</li><li>
<p>PQERRORS_VERBOSE</p>
</li><li>
<p>PQERRORS_SQLSTATE</p>
</li></ul>

<p>Changing the verbosity does not affect the messages available from already-existing <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> objects, only subsequently-created ones. (But see <a href="Result.html#verbose_error_message-instance_method" title="PG::Result#verbose_error_message (method)">Result#verbose_error_message</a> if you want to print a previous error with a different verbosity.)</p>

<p>See also corresponding <a href="https://www.postgresql.org/docs/current/libpq-control.html#LIBPQ-PQSETERRORVERBOSITY" target="_parent" title="libpq function">libpq function</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2696-L2702'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2696' data-end='2702'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2696</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_set_error_verbosity(VALUE self, VALUE in_verbosity)
{
	PGconn *conn = pg_get_pgconn(self);
	PGVerbosity verbosity = NUM2INT(in_verbosity);
	return INT2FIX(PQsetErrorVerbosity(conn, verbosity));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="set_notice_processor-instance_method">
  <h3 class='signature '>
    #<strong>set_notice_processor</strong> {|message| ... } &#x21d2; <code>Proc</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>See <a href="#set_notice_receiver-instance_method" title="PG::Connection#set_notice_receiver (method)">#set_notice_receiver</a> for the description of what this and the notice_processor methods do.</p>

<p>This function takes a new block to act as the notice processor and returns the Proc object previously set, or <code>nil</code> if it was previously the default. The block should accept a single String object.</p>

<p>If you pass no arguments, it will reset the handler to the default.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2908-L2935'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2908' data-end='2935'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2908</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_set_notice_processor(VALUE self)
{
	VALUE proc, old_proc;
	t_pg_connection *this = pg_get_connection_safe( self );

	rb_check_frozen(self);
	/* If default_notice_processor is unset, assume that the current
	 * notice processor is the default, and save it to a global variable.
	 * This should not be a problem because the default processor is
	 * always the same, so won&#39;t vary among connections.
	 */
	if(this-&gt;default_notice_processor == NULL)
		this-&gt;default_notice_processor = PQsetNoticeProcessor(this-&gt;pgconn, NULL, NULL);

	old_proc = this-&gt;notice_processor;
	if( rb_block_given_p() ) {
		proc = rb_block_proc();
		PQsetNoticeProcessor(this-&gt;pgconn, gvl_notice_processor_proxy, (void *)self);
	} else {
		/* if no block is given, set back to default */
		proc = Qnil;
		PQsetNoticeProcessor(this-&gt;pgconn, this-&gt;default_notice_processor, NULL);
	}

	RB_OBJ_WRITE(self, &amp;this-&gt;notice_processor, proc);
	return old_proc;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="set_notice_receiver-instance_method">
  <h3 class='signature '>
    #<strong>set_notice_receiver</strong> {|result| ... } &#x21d2; <code>Proc</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Notice and warning messages generated by the server are not returned by the query execution functions, since they do not imply failure of the query. Instead they are passed to a notice handling function, and execution continues normally after the handler returns. The default notice handling function prints the message on <code>stderr</code>, but the application can override this behavior by supplying its own handling function.</p>

<p>For historical reasons, there are two levels of notice handling, called the notice receiver and notice processor. The default behavior is for the notice receiver to format the notice and pass a string to the notice processor for printing. However, an application that chooses to provide its own notice receiver will typically ignore the notice processor layer and just do all the work in the notice receiver.</p>

<p>This function takes a new block to act as the handler, which should accept a single parameter that will be a <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> object, and returns the Proc object previously set, or <code>nil</code> if it was previously the default.</p>

<p>If you pass no arguments, it will reset the handler to the default.</p>

<p><strong>Note:</strong> The <code>result</code> passed to the block should not be used outside of the block, since the corresponding C object could be freed after the block finishes.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2847-L2874'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2847' data-end='2874'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2847</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_set_notice_receiver(VALUE self)
{
	VALUE proc, old_proc;
	t_pg_connection *this = pg_get_connection_safe( self );

	rb_check_frozen(self);
	/* If default_notice_receiver is unset, assume that the current
	 * notice receiver is the default, and save it to a global variable.
	 * This should not be a problem because the default receiver is
	 * always the same, so won&#39;t vary among connections.
	 */
	if(this-&gt;default_notice_receiver == NULL)
		this-&gt;default_notice_receiver = PQsetNoticeReceiver(this-&gt;pgconn, NULL, NULL);

	old_proc = this-&gt;notice_receiver;
	if( rb_block_given_p() ) {
		proc = rb_block_proc();
		PQsetNoticeReceiver(this-&gt;pgconn, gvl_notice_receiver_proxy, (void *)self);
	} else {
		/* if no block is given, set back to default */
		proc = Qnil;
		PQsetNoticeReceiver(this-&gt;pgconn, this-&gt;default_notice_receiver, NULL);
	}

	RB_OBJ_WRITE(self, &amp;this-&gt;notice_receiver, proc);
	return old_proc;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="set_single_row_mode-instance_method">
  <h3 class='signature '>
    #<strong>set_single_row_mode</strong>  &#x21d2; <code>self</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>To enter single-row mode, call this method immediately after a successful call of send_query (or a sibling function). This mode selection is effective only for the currently executing query. Then call <a href="#get_result-instance_method" title="PG::Connection#get_result (method)">#get_result</a> repeatedly, until it returns nil.</p>

<p>Each (but the last) received <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> has exactly one row and a <a href="Result.html#result_status-instance_method" title="PG::Result#result_status (method)">Result#result_status</a> of PGRES_SINGLE_TUPLE. The last <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> has zero rows and is used to indicate a successful execution of the query. All of these <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> objects will contain the same row description data (column names, types, etc) that an ordinary <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> object for the query would have.</p>

<p><strong>Caution:</strong> While processing a query, the server may return some rows and then encounter an error, causing the query to be aborted. Ordinarily, pg discards any such rows and reports only the error. But in single-row mode, those rows will have already been returned to the application. Hence, the application will see some <a href="Result.html" title="PG::Result (class)"><code>Result</code></a> objects followed by an <a href="Error.html" title="PG::Error (class)"><code>Error</code></a> raised in get_result. For proper transactional behavior, the application must be designed to discard or undo whatever has been done with the previously-processed rows, if the query ultimately fails.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_send_query'><a href="#send_query-instance_method" title="PG::Connection#send_query (method)">send_query</a></span>( <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>your SQL command</span><span class='tstring_end'>&quot;</span></span> )
<span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_set_single_row_mode'>set_single_row_mode</span>
<span class='id identifier rubyid_loop'>loop</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_res'>res</span> <span class='op'>=</span> <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_get_result'><a href="#get_result-instance_method" title="PG::Connection#get_result (method)">get_result</a></span> <span class='kw'>or</span> <span class='kw'>break</span>
  <span class='id identifier rubyid_res'>res</span>.<span class='id identifier rubyid_check'>check</span>
  <span class='id identifier rubyid_res'>res</span>.<span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_row'>row</span><span class='op'>|</span>
    <span class='comment'># do something with the received row
</span>  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1834-L1844'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1834' data-end='1844'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1834</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_set_single_row_mode(VALUE self)
{
	PGconn *conn = pg_get_pgconn(self);

	rb_check_frozen(self);
	if( PQsetSingleRowMode(conn) == 0 )
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(conn));

	return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="setnonblocking-instance_method">
  <h3 class='signature '>
    #<strong>setnonblocking</strong>(Boolean)  &#x21d2; <code>nil</code>     <span class='aliases'>Also known as: <span class='names'>#async_setnonblocking</span></span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sets the nonblocking status of the connection. In the blocking state, calls to <a href="#send_query-instance_method" title="PG::Connection#send_query (method)">#send_query</a> will block until the message is sent to the server, but will not wait for the query results. In the nonblocking state, calls to <a href="#send_query-instance_method" title="PG::Connection#send_query (method)">#send_query</a> will return an error if the socket is not ready for writing. Note: This function does not affect <a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a>, because that function doesn’t return until the server has processed the query and returned the results.</p>

<p>Returns <code>nil</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L457-L461'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='457' data-end='461'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 457</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_setnonblocking'>setnonblocking</span>(<span class='id identifier rubyid_enabled'>enabled</span>)
	<span class='id identifier rubyid_singleton_class'>singleton_class</span>.<span class='id identifier rubyid_async_send_api'>async_send_api</span> <span class='op'>=</span> <span class='op'>!</span><span class='id identifier rubyid_enabled'>enabled</span>
	<span class='kw'>self</span>.<span class='id identifier rubyid_flush_data'>flush_data</span> <span class='op'>=</span> <span class='op'>!</span><span class='id identifier rubyid_enabled'>enabled</span>
	<span class='id identifier rubyid_sync_setnonblocking'><a href="#sync_setnonblocking-instance_method" title="PG::Connection#sync_setnonblocking (method)">sync_setnonblocking</a></span>(<span class='kw'>true</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="socket-instance_method">
  <h3 class='signature '>
    #<strong>socket</strong>  &#x21d2; <code>Integer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This method is deprecated. Please use the more portable method <a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">#socket_io</a> .</p>

<p>Returns the socket’s file descriptor for this connection. <code>IO.for_fd()</code> can be used to build a proper IO object to the socket. If you do so, you will likely also want to set <code>autoclose=false</code> on it to prevent Ruby from closing the socket to PostgreSQL if it goes out of scope. Alternatively, you can use <a href="#socket_io-instance_method" title="PG::Connection#socket_io (method)">#socket_io</a>, which creates an IO that’s associated with the connection object itself, and so won’t go out of scope until the connection does.</p>

<p><strong>Note:</strong> On Windows the file descriptor is not usable, since it can not be used to build a Ruby IO object.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L910-L920'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='910' data-end='920'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 910</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_socket(VALUE self)
{
	int sd;
	pg_deprecated(4, (&quot;conn.socket is deprecated and should be replaced by conn.socket_io&quot;));

	if( (sd = PQsocket(pg_get_pgconn(self))) &lt; 0)
		pg_raise_conn_error( rb_eConnectionBad, self, &quot;PQsocket() can&#39;t get socket descriptor&quot;);

	return INT2NUM(sd);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="socket_io-instance_method">
  <h3 class='signature '>
    #<strong>socket_io</strong>  &#x21d2; <code>IO</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Fetch an IO object created from the Connection’s underlying socket. This object can be used per <code>socket_io.wait_readable</code>, <code>socket_io.wait_writable</code> or for <code>IO.select</code> to wait for events while running asynchronous API calls. <code>IO#wait_*able</code> is is <code>Fiber.scheduler</code> compatible in contrast to <code>IO.select</code>.</p>

<p>The IO object can change while the connection is established, but is memorized afterwards. So be sure not to cache the IO object, but repeat calling <code>conn.socket_io</code> instead.</p>

<p>Using this method also works on Windows in contrast to using <a href="#socket-instance_method" title="PG::Connection#socket (method)">#socket</a> . It also avoids the problem of the underlying connection being closed by Ruby when an IO created using <code>IO.for_fd(conn.socket)</code> goes out of scope.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L936-L970'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='936' data-end='970'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 936</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_socket_io(VALUE self)
{
	int sd;
	int ruby_sd;
	t_pg_connection *this = pg_get_connection_safe( self );
	VALUE cSocket;
	VALUE socket_io = this-&gt;socket_io;

	if ( !RTEST(socket_io) ) {
		if( (sd = PQsocket(this-&gt;pgconn)) &lt; 0){
			pg_raise_conn_error( rb_eConnectionBad, self, &quot;PQsocket() can&#39;t get socket descriptor&quot;);
		}

		#ifdef _WIN32
			ruby_sd = rb_w32_wrap_io_handle((HANDLE)(intptr_t)sd, O_RDWR|O_BINARY|O_NOINHERIT);
			if( ruby_sd == -1 )
				pg_raise_conn_error( rb_eConnectionBad, self, &quot;Could not wrap win32 socket handle&quot;);

			this-&gt;ruby_sd = ruby_sd;
		#else
			ruby_sd = sd;
		#endif

		cSocket = rb_const_get(rb_cObject, rb_intern(&quot;BasicSocket&quot;));
		socket_io = rb_funcall( cSocket, rb_intern(&quot;for_fd&quot;), 1, INT2NUM(ruby_sd));

		/* Disable autoclose feature */
		rb_funcall( socket_io, s_id_autoclose_set, 1, Qfalse );

		RB_OBJ_WRITE(self, &amp;this-&gt;socket_io, socket_io);
	}

	return socket_io;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="ssl_attribute-instance_method">
  <h3 class='signature '>
    #<strong>ssl_attribute</strong>(attribute_name)  &#x21d2; <code>String</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns SSL-related information about the connection.</p>

<p>The list of available attributes varies depending on the SSL library being used, and the type of connection. If an attribute is not available, returns nil.</p>

<p>The following attributes are commonly available:</p>
<dl class="rdoc-list label-list"><dt><code>library</code>
<dd>
<p>Name of the SSL implementation in use. (Currently, only “OpenSSL” is implemented)</p>
</dd><dt><code>protocol</code>
<dd>
<p>SSL/TLS version in use. Common values are “SSLv2”, “SSLv3”, “TLSv1”, “TLSv1.1” and “TLSv1.2”, but an implementation may return other strings if some other protocol is used.</p>
</dd><dt><code>key_bits</code>
<dd>
<p>Number of key bits used by the encryption algorithm.</p>
</dd><dt><code>cipher</code>
<dd>
<p>A short name of the ciphersuite used, e.g. “DHE-RSA-DES-CBC3-SHA”. The names are specific to each SSL implementation.</p>
</dd><dt><code>compression</code>
<dd>
<p>If SSL compression is in use, returns the name of the compression algorithm, or “on” if compression is used but the algorithm is not known. If compression is not in use, returns “off”.</p>
</dd></dl>

<p>See also <a href="#ssl_attribute_names-instance_method" title="PG::Connection#ssl_attribute_names (method)">#ssl_attribute_names</a> and the <a href="https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQSSLATTRIBUTE" target="_parent" title="corresponding libpq function">corresponding libpq function</a>.</p>

<p>Available since PostgreSQL-9.5</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3551-L3558'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3551' data-end='3558'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3551</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_ssl_attribute(VALUE self, VALUE attribute_name)
{
	const char *p_attr;

	p_attr = PQsslAttribute(pg_get_pgconn(self), StringValueCStr(attribute_name));
	return p_attr ? rb_str_new_cstr(p_attr) : Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="ssl_attribute_names-instance_method">
  <h3 class='signature '>
    #<strong>ssl_attribute_names</strong>  &#x21d2; <code>Array</code>&lt;<code>String</code>&gt;   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Return an array of SSL attribute names available.</p>

<p>See also <a href="#ssl_attribute-instance_method" title="PG::Connection#ssl_attribute (method)">#ssl_attribute</a></p>

<p>Available since PostgreSQL-9.5</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3570-L3581'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3570' data-end='3581'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3570</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_ssl_attribute_names(VALUE self)
{
	int i;
	const char * const * p_list = PQsslAttributeNames(pg_get_pgconn(self));
	VALUE ary = rb_ary_new();

	for ( i = 0; p_list[i]; i++ ) {
		rb_ary_push( ary, rb_str_new_cstr( p_list[i] ));
	}
	return ary;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="ssl_attributes-instance_method">
  <h3 class='signature '>
    #<strong>ssl_attributes</strong>  &#x21d2; <code>Hash</code>&lt;<code>String</code>, <code>String</code>&gt;   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns SSL-related information about the connection as key/value pairs</p>

<p>The available attributes varies depending on the SSL library being used, and the type of connection.</p>

<p>See also <a href="#ssl_attribute-instance_method" title="PG::Connection#ssl_attribute (method)">#ssl_attribute</a></p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L362-L366'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='362' data-end='366'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 362</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_ssl_attributes'>ssl_attributes</span>
	<span class='id identifier rubyid_ssl_attribute_names'><a href="#ssl_attribute_names-instance_method" title="PG::Connection#ssl_attribute_names (method)">ssl_attribute_names</a></span>.<span class='id identifier rubyid_each'>each</span>.<span class='id identifier rubyid_with_object'>with_object</span>({}) <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_n'>n</span><span class='comma'>,</span><span class='id identifier rubyid_h'>h</span><span class='op'>|</span>
		<span class='id identifier rubyid_h'>h</span>[<span class='id identifier rubyid_n'>n</span>] <span class='op'>=</span> <span class='id identifier rubyid_ssl_attribute'><a href="#ssl_attribute-instance_method" title="PG::Connection#ssl_attribute (method)">ssl_attribute</a></span>(<span class='id identifier rubyid_n'>n</span>)
	<span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="status-instance_method">
  <h3 class='signature '>
    #<strong>status</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the status of the connection, which is one:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html" title="PG::Constants (module)">Constants</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#CONNECTION_OK-constant" title="PG::Constants::CONNECTION_OK (constant)">CONNECTION_OK</a></span>
<span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html" title="PG::Constants (module)">Constants</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#CONNECTION_BAD-constant" title="PG::Constants::CONNECTION_BAD (constant)">CONNECTION_BAD</a></span></code></pre>

<p>… and other constants of kind PG::Constants::CONNECTION_*</p>

<p>This method returns the status of the last command from memory. It doesn’t do any socket access hence is not suitable to test the connectivity. See check_socket for a way to verify the socket state.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="../PG.html" title="PG (module)">PG</a></span>.<span class='id identifier rubyid_constants'>constants</span>.<span class='id identifier rubyid_grep'>grep</span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>CONNECTION_</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_find'>find</span>{<span class='op'>|</span><span class='id identifier rubyid_c'>c</span><span class='op'>|</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span>.<span class='id identifier rubyid_const_get'>const_get</span>(<span class='id identifier rubyid_c'>c</span>) <span class='op'>==</span> <span class='id identifier rubyid_conn'>conn</span>.<span class='id identifier rubyid_status'>status</span>} <span class='comment'># =&gt; :CONNECTION_OK</span></code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L794-L798'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='794' data-end='798'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 794</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_status(VALUE self)
{
	return INT2NUM(PQstatus(pg_get_pgconn(self)));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_cancel-instance_method">
  <h3 class='signature '>
    #<strong>sync_cancel</strong>  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p><code>Connection</code> INSTANCE METHODS: Cancelling Queries in Progress</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2206-L2226'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2206' data-end='2226'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2206</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_cancel(VALUE self)
{
	char errbuf[256];
	PGcancel *cancel;
	VALUE retval;
	int ret;

	cancel = PQgetCancel(pg_get_pgconn(self));
	if(cancel == NULL)
		pg_raise_conn_error( rb_ePGerror, self, &quot;Invalid connection!&quot;);

	ret = gvl_PQcancel(cancel, errbuf, sizeof(errbuf));
	if(ret == 1)
		retval = Qnil;
	else
		retval = rb_str_new2(errbuf);

	PQfreeCancel(cancel);
	return retval;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_describe_portal-instance_method">
  <h3 class='signature '>
    #<strong>sync_describe_portal</strong>(portal_name)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This function has the same behavior as <a href="#async_describe_portal-instance_method" title="PG::Connection#async_describe_portal (method)">#async_describe_portal</a>, but is implemented using the synchronous command processing API of libpq. See <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> for the differences between the two API variants. It’s not recommended to use explicit sync or async variants but <a href="#describe_portal-instance_method" title="PG::Connection#describe_portal (method)">#describe_portal</a> instead, unless you have a good reason to do so.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1554-L1571'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1554' data-end='1571'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1554</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_describe_portal(VALUE self, VALUE stmt_name)
{
	PGresult *result;
	VALUE rb_pgresult;
	t_pg_connection *this = pg_get_connection_safe( self );
	const char *stmt;
	if(NIL_P(stmt_name)) {
		stmt = NULL;
	}
	else {
		stmt = pg_cstr_enc(stmt_name, this-&gt;enc_idx);
	}
	result = gvl_PQdescribePortal(this-&gt;pgconn, stmt);
	rb_pgresult = pg_new_result(result, self);
	pg_result_check(rb_pgresult);
	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_describe_prepared-instance_method">
  <h3 class='signature '>
    #<strong>sync_describe_prepared</strong>(statement_name)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This function has the same behavior as <a href="#async_describe_prepared-instance_method" title="PG::Connection#async_describe_prepared (method)">#async_describe_prepared</a>, but is implemented using the synchronous command processing API of libpq. See <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> for the differences between the two API variants. It’s not recommended to use explicit sync or async variants but <a href="#describe_prepared-instance_method" title="PG::Connection#describe_prepared (method)">#describe_prepared</a> instead, unless you have a good reason to do so.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1526-L1543'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1526' data-end='1543'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1526</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_describe_prepared(VALUE self, VALUE stmt_name)
{
	PGresult *result;
	VALUE rb_pgresult;
	t_pg_connection *this = pg_get_connection_safe( self );
	const char *stmt;
	if(NIL_P(stmt_name)) {
		stmt = NULL;
	}
	else {
		stmt = pg_cstr_enc(stmt_name, this-&gt;enc_idx);
	}
	result = gvl_PQdescribePrepared(this-&gt;pgconn, stmt);
	rb_pgresult = pg_new_result(result, self);
	pg_result_check(rb_pgresult);
	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_encrypt_password-instance_method">
  <h3 class='signature '>
    #<strong>sync_encrypt_password</strong>(*args)  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L422-L444'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='422' data-end='444'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 422</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_encrypt_password(int argc, VALUE *argv, VALUE self)
{
	char *encrypted = NULL;
	VALUE rval = Qnil;
	VALUE password, username, algorithm;
	PGconn *conn = pg_get_pgconn(self);

	rb_scan_args( argc, argv, &quot;21&quot;, &amp;password, &amp;username, &amp;algorithm );

	Check_Type(password, T_STRING);
	Check_Type(username, T_STRING);

	encrypted = gvl_PQencryptPasswordConn(conn, StringValueCStr(password), StringValueCStr(username), RTEST(algorithm) ? StringValueCStr(algorithm) : NULL);
	if ( encrypted ) {
		rval = rb_str_new2( encrypted );
		PQfreemem( encrypted );
	} else {
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(conn));
	}

	return rval;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_exec-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>sync_exec</strong>(sql)  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>sync_exec</strong>(sql) {|pg_result| ... } </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This function has the same behavior as <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a>, but is implemented using the synchronous command processing API of libpq. It’s not recommended to use explicit sync or async variants but <a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a> instead, unless you have a good reason to do so.</p>

<p>Both <code>#sync_exec</code> and <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> release the GVL while waiting for server response, so that concurrent threads will get executed. However <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> has two advantages:</p>
<ol><li>
<p><a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> can be aborted by signals (like Ctrl-C), while <a href="#exec-instance_method" title="PG::Connection#exec (method)">#exec</a> blocks signal processing until the query is answered.</p>
</li><li>
<p>Ruby VM gets notified about IO blocked operations and can pass them through <code>Fiber.scheduler</code>. So only <code>async_*</code> methods are compatible to event based schedulers like the async gem.</p>
</li></ol>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1078-L1102'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1078' data-end='1102'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1078</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_exec(int argc, VALUE *argv, VALUE self)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	PGresult *result = NULL;
	VALUE rb_pgresult;

	/* If called with no or nil parameters, use PQexec for compatibility */
	if ( argc == 1 || (argc &gt;= 2 &amp;&amp; argc &lt;= 4 &amp;&amp; NIL_P(argv[1]) )) {
		VALUE query_str = argv[0];

		result = gvl_PQexec(this-&gt;pgconn, pg_cstr_enc(query_str, this-&gt;enc_idx));
		rb_pgresult = pg_new_result(result, self);
		pg_result_check(rb_pgresult);
		if (rb_block_given_p()) {
			return rb_ensure(rb_yield, rb_pgresult, pg_result_clear, rb_pgresult);
		}
		return rb_pgresult;
	}
	pg_deprecated(0, (&quot;forwarding exec to exec_params is deprecated&quot;));

	/* Otherwise, just call #exec_params instead for backward-compatibility */
	return pgconn_sync_exec_params( argc, argv, self );

}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_exec_params-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>sync_exec_params</strong>(sql, params[, result_format[, type_map]] )  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>sync_exec_params</strong>(sql, params[, result_format[, type_map]] ) {|pg_result| ... } </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This function has the same behavior as <a href="#async_exec_params-instance_method" title="PG::Connection#async_exec_params (method)">#async_exec_params</a>, but is implemented using the synchronous command processing API of libpq. See <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> for the differences between the two API variants. It’s not recommended to use explicit sync or async variants but <a href="#exec_params-instance_method" title="PG::Connection#exec_params (method)">#exec_params</a> instead, unless you have a good reason to do so.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1381-L1422'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1381' data-end='1422'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1381</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_exec_params( int argc, VALUE *argv, VALUE self )
{
	t_pg_connection *this = pg_get_connection_safe( self );
	PGresult *result = NULL;
	VALUE rb_pgresult;
	VALUE command, in_res_fmt;
	int nParams;
	int resultFormat;
	struct query_params_data paramsData = { this-&gt;enc_idx };

	/* For compatibility we accept 1 to 4 parameters */
	rb_scan_args(argc, argv, &quot;13&quot;, &amp;command, &amp;paramsData.params, &amp;in_res_fmt, &amp;paramsData.typemap);
	paramsData.with_types = 1;

	/*
	 * For backward compatibility no or nil for the second parameter
	 * is passed to #exec
	 */
	if ( NIL_P(paramsData.params) ) {
		pg_deprecated(1, (&quot;forwarding exec_params to exec is deprecated&quot;));
		return pgconn_sync_exec( 1, argv, self );
	}
	pgconn_query_assign_typemap( self, &amp;paramsData );

	resultFormat = NIL_P(in_res_fmt) ? 0 : NUM2INT(in_res_fmt);
	nParams = alloc_query_params( &amp;paramsData );

	result = gvl_PQexecParams(this-&gt;pgconn, pg_cstr_enc(command, paramsData.enc_idx), nParams, paramsData.types,
		(const char * const *)paramsData.values, paramsData.lengths, paramsData.formats, resultFormat);

	free_query_params( &amp;paramsData );

	rb_pgresult = pg_new_result(result, self);
	pg_result_check(rb_pgresult);

	if (rb_block_given_p()) {
		return rb_ensure(rb_yield, rb_pgresult, pg_result_clear, rb_pgresult);
	}

	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_exec_prepared-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>sync_exec_prepared</strong>(statement_name [, params, result_format[, type_map]] )  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a> </span>
      <span class='overload'>#<strong>sync_exec_prepared</strong>(statement_name [, params, result_format[, type_map]] ) {|pg_result| ... } </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This function has the same behavior as <a href="#async_exec_prepared-instance_method" title="PG::Connection#async_exec_prepared (method)">#async_exec_prepared</a>, but is implemented using the synchronous command processing API of libpq. See <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> for the differences between the two API variants. It’s not recommended to use explicit sync or async variants but <a href="#exec_prepared-instance_method" title="PG::Connection#exec_prepared (method)">#exec_prepared</a> instead, unless you have a good reason to do so.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1481-L1516'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1481' data-end='1516'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1481</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_exec_prepared(int argc, VALUE *argv, VALUE self)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	PGresult *result = NULL;
	VALUE rb_pgresult;
	VALUE name, in_res_fmt;
	int nParams;
	int resultFormat;
	struct query_params_data paramsData = { this-&gt;enc_idx };

	rb_scan_args(argc, argv, &quot;13&quot;, &amp;name, &amp;paramsData.params, &amp;in_res_fmt, &amp;paramsData.typemap);
	paramsData.with_types = 0;

	if(NIL_P(paramsData.params)) {
		paramsData.params = rb_ary_new2(0);
	}
	pgconn_query_assign_typemap( self, &amp;paramsData );

	resultFormat = NIL_P(in_res_fmt) ? 0 : NUM2INT(in_res_fmt);
	nParams = alloc_query_params( &amp;paramsData );

	result = gvl_PQexecPrepared(this-&gt;pgconn, pg_cstr_enc(name, paramsData.enc_idx), nParams,
		(const char * const *)paramsData.values, paramsData.lengths, paramsData.formats,
		resultFormat);

	free_query_params( &amp;paramsData );

	rb_pgresult = pg_new_result(result, self);
	pg_result_check(rb_pgresult);
	if (rb_block_given_p()) {
		return rb_ensure(rb_yield, rb_pgresult,
			pg_result_clear, rb_pgresult);
	}
	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_flush-instance_method">
  <h3 class='signature '>
    #<strong>sync_flush</strong>  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2195-L2204'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2195' data-end='2204'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2195</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_flush(VALUE self)
{
	PGconn *conn = pg_get_pgconn(self);
	int ret = PQflush(conn);
	if(ret == -1)
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(conn));

	return (ret) ? Qfalse : Qtrue;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_get_copy_data-instance_method">
  <h3 class='signature '>
    #<strong>sync_get_copy_data</strong>(*args)  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2635-L2677'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2635' data-end='2677'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2635</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_get_copy_data(int argc, VALUE *argv, VALUE self )
{
	VALUE async_in;
	VALUE result;
	int ret;
	char *buffer;
	VALUE decoder;
	t_pg_coder *p_coder = NULL;
	t_pg_connection *this = pg_get_connection_safe( self );

	rb_scan_args(argc, argv, &quot;02&quot;, &amp;async_in, &amp;decoder);

	if( NIL_P(decoder) ){
		if( !NIL_P(this-&gt;decoder_for_get_copy_data) ){
			p_coder = RTYPEDDATA_DATA( this-&gt;decoder_for_get_copy_data );
		}
	} else {
		/* Check argument type and use argument decoder */
		TypedData_Get_Struct(decoder, t_pg_coder, &amp;pg_coder_type, p_coder);
	}

	ret = gvl_PQgetCopyData(this-&gt;pgconn, &amp;buffer, RTEST(async_in));
	if(ret == -2){ /* error */
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));
	}
	if(ret == -1) { /* No data left */
		return Qnil;
	}
	if(ret == 0) { /* would block */
		return Qfalse;
	}

	if( p_coder ){
		t_pg_coder_dec_func dec_func = pg_coder_dec_func( p_coder, p_coder-&gt;format );
		result =  dec_func( p_coder, buffer, ret, 0, 0, this-&gt;enc_idx );
	} else {
		result = rb_str_new(buffer, ret);
	}

	PQfreemem(buffer);
	return result;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_get_last_result-instance_method">
  <h3 class='signature '>
    #<strong>sync_get_last_result</strong>()  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This function has the same behavior as <a href="#async_get_last_result-instance_method" title="PG::Connection#async_get_last_result (method)">#async_get_last_result</a>, but is implemented using the synchronous command processing API of libpq. See <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> for the differences between the two API variants. It’s not recommended to use explicit sync or async variants but <a href="#get_last_result-instance_method" title="PG::Connection#get_last_result (method)">#get_last_result</a> instead, unless you have a good reason to do so.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L3082-L3108'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='3082' data-end='3108'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 3082</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_get_last_result(VALUE self)
{
	PGconn *conn = pg_get_pgconn(self);
	VALUE rb_pgresult = Qnil;
	PGresult *cur, *prev;


	cur = prev = NULL;
	while ((cur = gvl_PQgetResult(conn)) != NULL) {
		int status;

		if (prev) PQclear(prev);
		prev = cur;

		status = PQresultStatus(cur);
		if (status == PGRES_COPY_OUT || status == PGRES_COPY_IN || status == PGRES_COPY_BOTH)
			break;
	}

	if (prev) {
		rb_pgresult = pg_new_result( prev, self );
		pg_result_check(rb_pgresult);
	}

	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_get_result-instance_method">
  <h3 class='signature '>
    #<strong>sync_get_result</strong>  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2117-L2133'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2117' data-end='2133'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2117</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_get_result(VALUE self)
{
	PGconn *conn = pg_get_pgconn(self);
	PGresult *result;
	VALUE rb_pgresult;

	result = gvl_PQgetResult(conn);
	if(result == NULL)
		return Qnil;
	rb_pgresult = pg_new_result(result, self);
	if (rb_block_given_p()) {
		return rb_ensure(rb_yield, rb_pgresult,
			pg_result_clear, rb_pgresult);
	}
	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_isnonblocking-instance_method">
  <h3 class='signature '>
    #<strong>sync_isnonblocking</strong>  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2189-L2193'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2189' data-end='2193'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2189</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_isnonblocking(VALUE self)
{
	return PQisnonblocking(pg_get_pgconn(self)) ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_prepare-instance_method">
  <h3 class='signature '>
    #<strong>sync_prepare</strong>(stmt_name, sql [, param_types ] )  &#x21d2; <a href="Result.html" title="PG::Result (class)">PG::Result</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This function has the same behavior as <a href="#async_prepare-instance_method" title="PG::Connection#async_prepare (method)">#async_prepare</a>, but is implemented using the synchronous command processing API of libpq. See <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> for the differences between the two API variants. It’s not recommended to use explicit sync or async variants but <a href="#prepare-instance_method" title="PG::Connection#prepare (method)">#prepare</a> instead, unless you have a good reason to do so.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L1432-L1470'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='1432' data-end='1470'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 1432</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_prepare(int argc, VALUE *argv, VALUE self)
{
	t_pg_connection *this = pg_get_connection_safe( self );
	PGresult *result = NULL;
	VALUE rb_pgresult;
	VALUE name, command, in_paramtypes;
	VALUE param;
	int i = 0;
	int nParams = 0;
	Oid *paramTypes = NULL;
	const char *name_cstr;
	const char *command_cstr;
	int enc_idx = this-&gt;enc_idx;

	rb_scan_args(argc, argv, &quot;21&quot;, &amp;name, &amp;command, &amp;in_paramtypes);
	name_cstr = pg_cstr_enc(name, enc_idx);
	command_cstr = pg_cstr_enc(command, enc_idx);

	if(! NIL_P(in_paramtypes)) {
		Check_Type(in_paramtypes, T_ARRAY);
		nParams = (int)RARRAY_LEN(in_paramtypes);
		paramTypes = ALLOC_N(Oid, nParams);
		for(i = 0; i &lt; nParams; i++) {
			param = rb_ary_entry(in_paramtypes, i);
			if(param == Qnil)
				paramTypes[i] = 0;
			else
				paramTypes[i] = NUM2UINT(param);
		}
	}
	result = gvl_PQprepare(this-&gt;pgconn, name_cstr, command_cstr, nParams, paramTypes);

	xfree(paramTypes);

	rb_pgresult = pg_new_result(result, self);
	pg_result_check(rb_pgresult);
	return rb_pgresult;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_put_copy_data-instance_method">
  <h3 class='signature '>
    #<strong>sync_put_copy_data</strong>(*args)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p><code>Connection</code> INSTANCE METHODS: COPY</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2561-L2613'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2561' data-end='2613'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2561</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_put_copy_data(int argc, VALUE *argv, VALUE self)
{
	int ret;
	int len;
	t_pg_connection *this = pg_get_connection_safe( self );
	VALUE value;
	VALUE buffer = Qnil;
	VALUE encoder;
	VALUE intermediate;
	t_pg_coder *p_coder = NULL;

	rb_scan_args( argc, argv, &quot;11&quot;, &amp;value, &amp;encoder );

	if( NIL_P(encoder) ){
		if( NIL_P(this-&gt;encoder_for_put_copy_data) ){
			buffer = value;
		} else {
			p_coder = RTYPEDDATA_DATA( this-&gt;encoder_for_put_copy_data );
		}
	} else {
		/* Check argument type and use argument encoder */
		TypedData_Get_Struct(encoder, t_pg_coder, &amp;pg_coder_type, p_coder);
	}

	if( p_coder ){
		t_pg_coder_enc_func enc_func;
		int enc_idx = this-&gt;enc_idx;

		enc_func = pg_coder_enc_func( p_coder );
		len = enc_func( p_coder, value, NULL, &amp;intermediate, enc_idx);

		if( len == -1 ){
			/* The intermediate value is a String that can be used directly. */
			buffer = intermediate;
		} else {
			buffer = rb_str_new(NULL, len);
			len = enc_func( p_coder, value, RSTRING_PTR(buffer), &amp;intermediate, enc_idx);
			rb_str_set_len( buffer, len );
		}
	}

	Check_Type(buffer, T_STRING);

	ret = gvl_PQputCopyData(this-&gt;pgconn, RSTRING_PTR(buffer), RSTRING_LENINT(buffer));
	if(ret == -1)
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));

	RB_GC_GUARD(intermediate);
	RB_GC_GUARD(buffer);

	return (ret) ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_put_copy_end-instance_method">
  <h3 class='signature '>
    #<strong>sync_put_copy_end</strong>(*args)  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2615-L2633'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2615' data-end='2633'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2615</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_put_copy_end(int argc, VALUE *argv, VALUE self)
{
	VALUE str;
	int ret;
	const char *error_message = NULL;
	t_pg_connection *this = pg_get_connection_safe( self );

	if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;str) == 0)
		error_message = NULL;
	else
		error_message = pg_cstr_enc(str, this-&gt;enc_idx);

	ret = gvl_PQputCopyEnd(this-&gt;pgconn, error_message);
	if(ret == -1)
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(this-&gt;pgconn));

	return (ret) ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_reset-instance_method">
  <h3 class='signature '>
    #<strong>sync_reset</strong>  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L558-L564'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='558' data-end='564'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 558</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_reset( VALUE self )
{
	pgconn_close_socket_io( self );
	gvl_PQreset( pg_get_pgconn(self) );
	return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_set_client_encoding-instance_method">
  <h3 class='signature '>
    #<strong>sync_set_client_encoding</strong>(encoding)    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This function has the same behavior as <a href="#async_set_client_encoding-instance_method" title="PG::Connection#async_set_client_encoding (method)">#async_set_client_encoding</a>, but is implemented using the synchronous command processing API of libpq. See <a href="#async_exec-instance_method" title="PG::Connection#async_exec (method)">#async_exec</a> for the differences between the two API variants. It’s not recommended to use explicit sync or async variants but <a href="#set_client_encoding-instance_method" title="PG::Connection#set_client_encoding (method)">#set_client_encoding</a> instead, unless you have a good reason to do so.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2960-L2974'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2960' data-end='2974'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2960</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_set_client_encoding(VALUE self, VALUE str)
{
	PGconn *conn = pg_get_pgconn( self );

	rb_check_frozen(self);
	Check_Type(str, T_STRING);

	if ( (gvl_PQsetClientEncoding(conn, StringValueCStr(str))) == -1 )
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(conn));

	pgconn_set_internal_encoding_index( self );

	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="sync_setnonblocking-instance_method">
  <h3 class='signature '>
    #<strong>sync_setnonblocking</strong>(state)  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2169-L2186'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2169' data-end='2186'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2169</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_sync_setnonblocking(VALUE self, VALUE state)
{
	int arg;
	PGconn *conn = pg_get_pgconn(self);
	rb_check_frozen(self);
	if(state == Qtrue)
		arg = 1;
	else if (state == Qfalse)
		arg = 0;
	else
		rb_raise(rb_eArgError, &quot;Boolean value expected&quot;);

	if(PQsetnonblocking(conn, arg) == -1)
		pg_raise_conn_error( rb_ePGerror, self, &quot;%s&quot;, PQerrorMessage(conn));

	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="trace-instance_method">
  <h3 class='signature '>
    #<strong>trace</strong>(stream)  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Enables tracing message passing between backend. The trace message will be written to the stream <em>stream</em>, which must implement a method <code>fileno</code> that returns a writable file descriptor.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2744-L2779'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2744' data-end='2779'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2744</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_trace(VALUE self, VALUE stream)
{
	VALUE fileno;
	FILE *new_fp;
	int old_fd, new_fd;
	VALUE new_file;
	t_pg_connection *this = pg_get_connection_safe( self );

	rb_check_frozen(self);
	if(!rb_respond_to(stream,rb_intern(&quot;fileno&quot;)))
		rb_raise(rb_eArgError, &quot;stream does not respond to method: fileno&quot;);

	fileno = rb_funcall(stream, rb_intern(&quot;fileno&quot;), 0);
	if(fileno == Qnil)
		rb_raise(rb_eArgError, &quot;can&#39;t get file descriptor from stream&quot;);

	/* Duplicate the file descriptor and re-open
	 * it. Then, make it into a ruby File object
	 * and assign it to an instance variable.
	 * This prevents a problem when the File
	 * object passed to this function is closed
	 * before the connection object is. */
	old_fd = NUM2INT(fileno);
	new_fd = dup(old_fd);
	new_fp = fdopen(new_fd, &quot;w&quot;);

	if(new_fp == NULL)
		rb_raise(rb_eArgError, &quot;stream is not writable&quot;);

	new_file = rb_funcall(rb_cIO, rb_intern(&quot;new&quot;), 1, INT2NUM(new_fd));
	RB_OBJ_WRITE(self, &amp;this-&gt;trace_stream, new_file);

	PQtrace(this-&gt;pgconn, new_fp);
	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="transaction-instance_method">
  <h3 class='signature '>
    #<strong>transaction</strong> {|conn| ... } &#x21d2; <code>result</code> <code>of</code> <code>the</code> <a href="#block-instance_method" title="PG::Connection#block (method)">block</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Executes a <code>BEGIN</code> at the start of the block, and a <code>COMMIT</code> at the end of the block, or <code>ROLLBACK</code> if any exception occurs.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/lib/pg/connection.rb#L305-L317'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='305' data-end='317'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/pg/connection.rb', line 305</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_transaction'>transaction</span>
	<span class='id identifier rubyid_rollback'>rollback</span> <span class='op'>=</span> <span class='kw'>false</span>
	<span class='id identifier rubyid_exec'><a href="#exec-instance_method" title="PG::Connection#exec (method)">exec</a></span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>BEGIN</span><span class='tstring_end'>&quot;</span></span>
	<span class='kw'>yield</span>(<span class='kw'>self</span>)
<span class='kw'>rescue</span> <span class='const'>Exception</span>
	<span class='id identifier rubyid_rollback'>rollback</span> <span class='op'>=</span> <span class='kw'>true</span>
	<span class='id identifier rubyid_cancel'><a href="#cancel-instance_method" title="PG::Connection#cancel (method)">cancel</a></span> <span class='kw'>if</span> <span class='id identifier rubyid_transaction_status'><a href="#transaction_status-instance_method" title="PG::Connection#transaction_status (method)">transaction_status</a></span> <span class='op'>==</span> <span class='const'><a href="../PG.html" title="PG (module)">PG</a></span><span class='op'>::</span><span class='const'><a href="Constants.html#PQTRANS_ACTIVE-constant" title="PG::Constants::PQTRANS_ACTIVE (constant)">PQTRANS_ACTIVE</a></span>
	<span class='id identifier rubyid_block'><a href="#block-instance_method" title="PG::Connection#block (method)">block</a></span>
	<span class='id identifier rubyid_exec'><a href="#exec-instance_method" title="PG::Connection#exec (method)">exec</a></span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ROLLBACK</span><span class='tstring_end'>&quot;</span></span>
	<span class='id identifier rubyid_raise'>raise</span>
<span class='kw'>ensure</span>
	<span class='id identifier rubyid_exec'><a href="#exec-instance_method" title="PG::Connection#exec (method)">exec</a></span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>COMMIT</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_rollback'>rollback</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="transaction_status-instance_method">
  <h3 class='signature '>
    #<strong>transaction_status</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>returns one of the following statuses:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="Constants.html#PQTRANS_IDLE-constant" title="PG::Constants::PQTRANS_IDLE (constant)">PQTRANS_IDLE</a></span>    <span class='op'>=</span> <span class='int'>0</span> (<span class='id identifier rubyid_connection'>connection</span> <span class='id identifier rubyid_idle'>idle</span>)
<span class='const'><a href="Constants.html#PQTRANS_ACTIVE-constant" title="PG::Constants::PQTRANS_ACTIVE (constant)">PQTRANS_ACTIVE</a></span>  <span class='op'>=</span> <span class='int'>1</span> (<span class='id identifier rubyid_command'>command</span> <span class='kw'>in</span> <span class='id identifier rubyid_progress'>progress</span>)
<span class='const'><a href="Constants.html#PQTRANS_INTRANS-constant" title="PG::Constants::PQTRANS_INTRANS (constant)">PQTRANS_INTRANS</a></span> <span class='op'>=</span> <span class='int'>2</span> (<span class='id identifier rubyid_idle'>idle</span><span class='comma'>,</span> <span class='id identifier rubyid_within'>within</span> <span class='id identifier rubyid_transaction'><a href="#transaction-instance_method" title="PG::Connection#transaction (method)">transaction</a></span> <span class='id identifier rubyid_block'><a href="#block-instance_method" title="PG::Connection#block (method)">block</a></span>)
<span class='const'><a href="Constants.html#PQTRANS_INERROR-constant" title="PG::Constants::PQTRANS_INERROR (constant)">PQTRANS_INERROR</a></span> <span class='op'>=</span> <span class='int'>3</span> (<span class='id identifier rubyid_idle'>idle</span><span class='comma'>,</span> <span class='id identifier rubyid_within'>within</span> <span class='id identifier rubyid_failed'>failed</span> <span class='id identifier rubyid_transaction'><a href="#transaction-instance_method" title="PG::Connection#transaction (method)">transaction</a></span>)
<span class='const'><a href="Constants.html#PQTRANS_UNKNOWN-constant" title="PG::Constants::PQTRANS_UNKNOWN (constant)">PQTRANS_UNKNOWN</a></span> <span class='op'>=</span> <span class='int'>4</span> (<span class='id identifier rubyid_cannot'>cannot</span> <span class='id identifier rubyid_determine'>determine</span> <span class='id identifier rubyid_status'><a href="#status-instance_method" title="PG::Connection#status (method)">status</a></span>)</code></pre>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L811-L815'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='811' data-end='815'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 811</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_transaction_status(VALUE self)
{
	return INT2NUM(PQtransactionStatus(pg_get_pgconn(self)));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="tty-instance_method">
  <h3 class='signature '>
    #<strong>tty</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Obsolete function.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L735-L739'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='735' data-end='739'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 735</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_tty(VALUE self)
{
	return rb_str_new2(&quot;&quot;);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="unescape_bytea-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>unescape_bytea</strong>(string)  </span>
      <span class='overload'>#<strong>unescape_bytea</strong>(string)  </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#unescape_bytea-class_method" title="PG::Connection.unescape_bytea (method)">.unescape_bytea</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>

<section class='method_details' id="untrace-instance_method">
  <h3 class='signature '>
    #<strong>untrace</strong>  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Disables the message tracing.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L2787-L2796'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='2787' data-end='2796'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 2787</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_untrace(VALUE self)
{
	t_pg_connection *this = pg_get_connection_safe( self );

	PQuntrace(this-&gt;pgconn);
	rb_funcall(this-&gt;trace_stream, rb_intern(&quot;close&quot;), 0);
	RB_OBJ_WRITE(self, &amp;this-&gt;trace_stream, Qnil);
	return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="user-instance_method">
  <h3 class='signature '>
    #<strong>user</strong>    </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the authenticated user name.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ged/ruby-pg/blob/master/ext/pg_connection.c#L646-L652'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='646' data-end='652'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/pg_connection.c', line 646</span></pre>
<pre class='code cpp'>

static VALUE
pgconn_user(VALUE self)
{
	char *user = PQuser(pg_get_pgconn(self));
	if (!user) return Qnil;
	return rb_str_new2(user);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="wait_for_notify-instance_method">
  <h3 class='signature '>
    <div class='inline-block'>
      <span class='overload'>#<strong>notifies_wait</strong>([ timeout ]) {|event, pid, payload| ... } &#x21d2; <code>String</code> </span>
      <span class='overload'>#<strong>wait_for_notify</strong>([ timeout ]) {|event, pid, payload| ... } &#x21d2; <code>String</code> </span>
    </div>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#notifies_wait-instance_method" title="PG::Connection#notifies_wait (method)">#notifies_wait</a>.</p>

  </div>
</div>
<div class='tags'>
  
</div>

</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>