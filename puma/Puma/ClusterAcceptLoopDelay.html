<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: Puma::ClusterAcceptLoopDelay &mdash; Puma main</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Puma::ClusterAcceptLoopDelay",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../'>Puma main</a> &raquo; 
      <a href='../_index.html#alpha_C'>Index (C)</a> &raquo; 
        <a href="../Puma.html" title="Puma (module)">Puma</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>ClusterAcceptLoopDelay&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: Puma::ClusterAcceptLoopDelay</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr>
      <td id='t2_inherits' class='box_2'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'><a href="../Object.html" title="Object (class)">Object</a></span>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/puma/puma/blob/main/lib/puma/cluster_accept_loop_delay.rb#L54'>lib/puma/cluster_accept_loop_delay.rb</a>      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p>Calculate a delay value for sleeping when running in clustered mode</p>

<p>The main reason this is a class is so it can be unit tested independently. This makes modification easier in the future if we can encode properties of the delay into a test instead of relying on end-to-end testing only.</p>

<p>This is an imprecise mechanism to address specific goals:</p>
<ul><li>
<p>Evenly distribute requests across all workers at start</p>
</li><li>
<p>Evenly distribute CPU resources across all workers</p>
</li></ul>

<h3 id="label-Goal-3A+Distribute+requests+across+workers+at+start">Goal: Distribute requests across workers at start</h3>

<p>There was a perf bug in <a href="../Puma.html" title="Puma (module)"><code>::Puma</code></a> where one worker would wake up slightly before the rest and accept all the requests on the socket even though it didn’t have enough resources to process all of them. This was originally fixed by never calling accept when a worker had more requests than threads already <a href="https://github.com/puma/puma/pull/3678/files/2736ebddb3fc8528e5150b5913fba251c37a8bf7#diff-a95f46e7ce116caddc9b9a9aa81004246d5210d5da5f4df90a818c780630166bL251-L291">github.com/puma/puma/pull/3678/files/2736ebddb3fc8528e5150b5913fba251c37a8bf7#diff-a95f46e7ce116caddc9b9a9aa81004246d5210d5da5f4df90a818c780630166bL251-L291</a></p>

<p>With the introduction of true keepalive support, there are two ways a request can come in:</p>
<ul><li>
<p>A new request from a new client comes into the socket and it must be “accept”-ed</p>
</li><li>
<p>A keepalive request is served and the connection is retained. Another request is then accepted</p>
</li></ul>

<p>Ideally the server handles requests in the order they come in, and ideally it doesn’t accept more requests than it can handle. These goals are contradictory, because when the server is at maximum capacity due to keepalive connections, it could mean we block all new requests, even if those came in before the new request on the older keepalive connection.</p>

<h3 id="label-Goal-3A+Distribute+CPU+resources+across+all+workers">Goal: Distribute CPU resources across all workers</h3>
<ul><li>
<p>This issue was opened <a href="https://github.com/puma/puma/issues/2078">github.com/puma/puma/issues/2078</a></p>
</li></ul>

<p>There are several entangled issues and it’s not exactly clear what the root cause is, but the observable outcome was that performance was better with a small sleep, and that eventually became the default.</p>

<p>An attempt to describe why this works is here: <a href="https://github.com/puma/puma/issues/2078#issuecomment-3287032470">github.com/puma/puma/issues/2078#issuecomment-3287032470</a>.</p>

<p>Summarizing: The delay is for tuning the rate at which “accept” is called on the socket. <a href="../Puma.html" title="Puma (module)"><code>::Puma</code></a> works by calling “accept” nonblock on the socket in a loop. When there are multiple workers (processes), they will “race” to accept a request at roughly the same rate. However, if one worker has all threads busy processing requests, then accepting a new request might “steal” it from a less busy worker. If a worker has no work to do, it should loop as fast as possible.</p>

<h3 id="label-Solution-3A+Distribute+requests+across+workers+at+start">Solution: Distribute requests across workers at start</h3>

<p>For now, both goals are framed as “load balancing” across workers (processes) and achieved through the same mechanism of sleeping longer to delay busier workers. Rather than the prior <a href="../Puma.html" title="Puma (module)"><code>::Puma</code></a> 6.x and earlier behavior of using a binary on/off sleep value, we increase it an amount proportional to the load the server is under, capping the maximum delay to the scenario where all threads are busy and the todo list has reached a multiplier of the maximum number of threads.</p>

<p>Private: API may change unexpectedly</p>

  </div>
</div>
</div>
<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#new-class_method" title=".new (class method)">.<strong>new</strong>(workers:, max_delay:)  &#x21d2; ClusterAcceptLoopDelay </a>
    </span>
    <span class='note title constructor'>constructor</span>
    <div class='summary_desc'>
      <div class='inline'><p>Initialize happens once, <code>call</code> happens often.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_attribute_summary'>Instance Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature ro'>
      <a href="#max_delay-instance_method" title="#max_delay (instance method)">#<strong>max_delay</strong>  </a>
    </span>
    <span class='note title readonly'>readonly</span>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#on%3F-instance_method" title="#on? (instance method)">#<strong>on?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
  </li>
</ul>
</div>  <!-- instance_attribute_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#calculate-instance_method" title="#calculate (instance method)">#<strong>calculate</strong>(busy_threads_plus_todo:, max_threads:)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>We want the extreme values of this delay to be known (minimum and maximum) as well as a predictable curve between the two.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- instance_method_summary -->
<h2 id='Constructor_Details' class='y_details'>Constructor Details</h2>

  <section class='method_details first' id="new-class_method">
  <h3 class='signature  first'>
    .<strong>new</strong>(workers:, max_delay:)  &#x21d2; <code>ClusterAcceptLoopDelay</code> 
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Initialize happens once, <code>call</code> happens often. Perform global calculations here.</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/puma/puma/blob/main/lib/puma/cluster_accept_loop_delay.rb#L58-L69'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='58' data-end='69'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/puma/cluster_accept_loop_delay.rb', line 58</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span>(
  <span class='comment'># Number of workers in the cluster
</span>  <span class='label'>workers:</span> <span class='comma'>,</span>
  <span class='comment'># Maximum delay in seconds i.e. 0.005 is 5 milliseconds
</span>  <span class='label'>max_delay:</span>
)
  <span class='ivar'>@on</span> <span class='op'>=</span> <span class='id identifier rubyid_max_delay'><a href="#max_delay-instance_method" title="Puma::ClusterAcceptLoopDelay#max_delay (method)">max_delay</a></span> <span class='op'>&gt;</span> <span class='int'>0</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_workers'>workers</span> <span class='op'>&gt;=</span> <span class='int'>2</span>
  <span class='ivar'>@max_delay</span> <span class='op'>=</span> <span class='id identifier rubyid_max_delay'><a href="#max_delay-instance_method" title="Puma::ClusterAcceptLoopDelay#max_delay (method)">max_delay</a></span>.<span class='id identifier rubyid_to_f'>to_f</span>

  <span class='comment'># Reach maximum delay when `max_threads * overload_multiplier` is reached in the system
</span>  <span class='ivar'>@overload_multiplier</span> <span class='op'>=</span> <span class='float'>25.0</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Attribute Details</h2>
<section class='method_details first' id="max_delay-instance_method">
  <h3 class='signature ro first'>
    #<strong>max_delay</strong>   <span class="extras">(<span class='readonly'>readonly</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/puma/puma/blob/main/lib/puma/cluster_accept_loop_delay.rb#L55-L55'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='55' data-end='55'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/puma/cluster_accept_loop_delay.rb', line 55</span></pre>
<pre class='code ruby'>

<span class='id identifier rubyid_attr_reader'>attr_reader</span> <span class='symbeg'>:</span><span class='id identifier rubyid_max_delay'>max_delay</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="on?-instance_method">
  <h3 class='signature ro'>
    #<strong>on?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/puma/puma/blob/main/lib/puma/cluster_accept_loop_delay.rb#L71-L73'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='71' data-end='73'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/puma/cluster_accept_loop_delay.rb', line 71</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_on?'>on?</span>
  <span class='ivar'>@on</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="calculate-instance_method">
  <h3 class='signature  first'>
    #<strong>calculate</strong>(busy_threads_plus_todo:, max_threads:)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>We want the extreme values of this delay to be known (minimum and maximum) as well as a predictable curve between the two. i.e. no step functions or hard cliffs.</p>

<p>Return value is always numeric. Returns 0 if there should be no delay.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/puma/puma/blob/main/lib/puma/cluster_accept_loop_delay.rb#L79-L89'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='79' data-end='89'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/puma/cluster_accept_loop_delay.rb', line 79</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_calculate'>calculate</span>(
  <span class='comment'># Number of threads working right now, plus number of requests in the todo list
</span>  <span class='label'>busy_threads_plus_todo:</span><span class='comma'>,</span>
  <span class='comment'># Maximum number of threads in the pool, note that the busy threads (alone) may go over this value at times
</span>  <span class='comment'># if the pool needs to be reaped. The busy thread plus todo count may go over this value by a large amount.
</span>  <span class='label'>max_threads:</span>
)
  <span class='id identifier rubyid_max_value'>max_value</span> <span class='op'>=</span> <span class='ivar'>@overload_multiplier</span> <span class='op'>*</span> <span class='id identifier rubyid_max_threads'>max_threads</span>
  <span class='comment'># Approaches max delay when `busy_threads_plus_todo` approaches `max_value`
</span>  <span class='kw'>return</span> <span class='id identifier rubyid_max_delay'><a href="#max_delay-instance_method" title="Puma::ClusterAcceptLoopDelay#max_delay (method)">max_delay</a></span> <span class='op'>*</span> <span class='id identifier rubyid_busy_threads_plus_todo'>busy_threads_plus_todo</span>.<span class='id identifier rubyid_clamp'>clamp</span>(<span class='int'>0</span><span class='comma'>,</span> <span class='id identifier rubyid_max_value'>max_value</span>) <span class='op'>/</span> <span class='id identifier rubyid_max_value'>max_value</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>