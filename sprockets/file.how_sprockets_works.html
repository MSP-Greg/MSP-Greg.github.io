<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: How Sprockets Works &mdash; Sprockets main</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "how_sprockets_works",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Sprockets main</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: How Sprockets Works&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<h1>Introduction</h1>

<blockquote>
<p>This document is based off of a transcript from <a href="https://www.youtube.com/watch?v=CzFFYelG7WY">RailsConf 2016 - How Sprockets works by Rafael França</a>. It&#39;s been edited in an attempt to make sense outside the context of a conference talk. <a href="https://github.com/rafaelfranca">Rafael</a> is amazing and does great work with <a href="Sprockets.html" title="Sprockets (module)"><code>Sprockets</code></a> and Rails.</p>
</blockquote>

<p>Rails is presented in a lot of different ways, it&#39;s not just the Rails gem but there are a lot of different components, for example: <a href="https://github.com/rails/rails/tree/master/actionview">Action View</a>, <a href="https://github.com/rails/spring">Spring</a>, <a href="https://github.com/rails/jquery-ujs">jquery-ujs</a>, <a href="https://github.com/turbolinks/turbolinks-classic">Turbolinks</a>, <a href="https://github.com/rails/sprockets">Sprockets</a>.</p>

<p>You can see that the Rails framework involves most aspects of your computer and operating system. You have things on the process level like Spring, and also things running in the browser like jquery-ujs and Turbolinks.</p>

<p>This goal of this document is to present something that is not well-known. That is, how the asset pipeline of Rails works right now [ca. 2016]. We will talk about why you need the asset pipeline, which gems are responsible for it, how it works in a Rails application, and how to extend the asset pipeline yourself.</p>

<p>First, why do we need an asset pipeline? Before we had the asset pipeline in Rails – introduced in Rails 3.1 – we had a question: &quot;Where should I put my assets?&quot;. We did not have any established convention for how to handle client-side code in Rails applications. So we typically had to put all of our assets in the <code>public</code> folder. Usually we ended up with a lot of files and it became difficult to know if they are being used or not.</p>

<p>Rails is about convention over configuration, so that was not something that we should have done with our client-side code. We also have another problem: we had to make some trade-offs between code organization and performance. Browsers had limitations; the Internet was too slow. There are trade offs to make. For example should we create many small self-contained files, or should we do fewer requests for assets in our applications? Initializing an HTTP connection to download an asset is expensive, yet working inside of one really large file is also difficult.</p>

<p>Should we write legible code? Or should we transmit fewer bytes to the clients? There were some technologies that were being used in that time, but could not be used easily in Rails applications. Technologies like <a href="https://coffeescript.org/">CoffeeScript</a>, <a href="https://sass-lang.com/">SASS</a>, and <a href="http://es6-features.org/">ECMAScript 6</a>. To solve these problems, the asset pipeline was created.</p>

<p>But how does the asset pipeline work in Rails? Right now, we have some conventions for our client-side code. So our assets live in the <code>app/assets</code> folder, and there are also <code>lib/assets</code> and <code>vendor/assets</code> folders. Assets are compiled on-the-fly in development and need to be precompiled in production. We also have asset fingerprinting so the digest of the asset content becomes part of the filename itself to provide automatic cache busting.</p>

<p>The asset pipeline is built from a collection of gems:</p>

<ul>
<li><a href="https://rubygems.org/gems/sprockets/versions/3.5.2">sprockets</a></li>
<li><a href="https://rubygems.org/gems/sprockets-rails">sprockets-rails</a></li>
<li><a href="https://rubygems.org/gems/sass-rails">sass-rails</a></li>
<li><a href="https://rubygems.org/gems/execjs">execjs</a></li>
<li><a href="https://rubygems.org/gems/coffee-rails">coffee-rails</a></li>
</ul>

<p>We will go through each gem and talk about how they work. The first gem that I&#39;m going to talk about is <a href="Sprockets.html" title="Sprockets (module)"><code>Sprockets</code></a>. It&#39;s the gem that makes it possible to compile and serve all assets. <a href="Sprockets.html" title="Sprockets (module)"><code>Sprockets</code></a> defines a processor pipeline so you can extend the way your assets are processed.</p>

<h2>Sprockets</h2>

<p><a href="Sprockets.html" title="Sprockets (module)"><code>Sprockets</code></a> has some key components that are:</p>

<ul>
<li>processors</li>
<li>transformers</li>
<li>compressors</li>
<li>directives</li>
<li>environments</li>
<li>manifest</li>
<li>pipelines</li>
</ul>

<h3>Processors</h3>

<p>The processors are the most important components in <a href="Sprockets.html" title="Sprockets (module)"><code>Sprockets</code></a>. All the functionality inside of <a href="Sprockets.html" title="Sprockets (module)"><code>Sprockets</code></a> is implemented by a processor. This is similar to how Railties is also a Rails engine. The interface for a processor is any <code>call</code>-able object that accepts an input hash and returns a hash of both data and optional metadata.</p>

<p>Example of a minimal Ruby sprockets processor that is just a lambda expression (which is <code>call</code>able):</p>

<pre class="code ruby"><code class="ruby"><span class='comment'>#=&gt; (input) {
</span>  <span class='id identifier rubyid_data'>data</span> <span class='op'>=</span> <span class='id identifier rubyid_input'>input</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_data'>data</span>].<span class='id identifier rubyid_gsub'>gsub</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>;</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span>)
  { <span class='label'>data:</span> <span class='id identifier rubyid_data'>data</span> }
<span class='embexpr_end'>}</span></code></pre>

<p>This is a minimal yet valid Sprockets processor and can be successfully called. It&#39;s doing something that is simple and easy to understand, which is just removing semicolons from the end of each line of the input. It takes a Hash as input that has some special keys that we will talk about later. It also returns a hash with specific keys, including <code>data</code> which contains the result of the processor running on the input.</p>

<p>The input hash has these keys by default:</p>

<ul>
<li><code>:data</code> - The string contents of the asset</li>
<li><code>:environment</code> - The current <a href="Sprockets/Environment.html" title="Sprockets::Environment (class)"><code>Environment</code></a> instance</li>
<li><code>:cache</code> - The <a href="Sprockets/Cache.html" title="Sprockets::Cache (class)"><code>Cache</code></a> instance</li>
<li><code>:uri</code> - The asset URI</li>
<li><code>:source_path</code> - The full path to original file</li>
<li><code>:load_path</code> - The current load path for the file</li>
<li><code>:name</code> - The logical name of the file</li>
<li><code>:content_type</code> - The MIME type of the output asset</li>
<li><code>:metadata</code> - The Hash of processor metadata</li>
</ul>

<p>The return hash has these keys:</p>

<ul>
<li><code>:data</code> - Replaces the assets <code>input[:data]</code> for the next processor in the chain</li>
<li><code>:required</code> - A Set of String asset URIs that <a href="Sprockets/Bundle.html" title="Sprockets::Bundle (class)"><code>Bundle</code></a> processor should concatenate together</li>
<li><code>:stubbed</code> - A Set of String asset URIs that will be omitted from the <code>:required</code> set</li>
<li><code>:links</code> - A Set of String asset URIs that should be compiled along with the assets</li>
<li><code>:dependencies</code> - A Set of String cache URIs that should be monitored for caching</li>
<li><code>:map</code> - An Array of source maps for the assets</li>
<li><code>:charset</code> - The MIME charset for an asset</li>
</ul>

<p>As we will see later, the <code>:required</code> is really interesting. Each dependency from your asset files will be stored in this field.</p>

<p>There are a lot of interesting built-in processors including:</p>

<ul>
<li><a href="Sprockets/BabelProcessor.html" title="Sprockets::BabelProcessor (class)"><code>BabelProcessor</code></a></li>
<li><code>CoffeScriptProcessor</code></li>
<li><a href="Sprockets/SassProcessor.html" title="Sprockets::SassProcessor (class)"><code>SassProcessor</code></a></li>
<li><code>BundlerProcessor</code></li>
</ul>

<p><code>BundlerProcessor</code> is used to run concatenated assets rather than individual files.</p>

<p>To register a processor in Sprockets, we use this syntax:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_register_bundle_processor'>register_bundle_processor</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>application/javascript</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'><a href="Sprockets/Bundle.html" title="Sprockets::Bundle (class)">Bundle</a></span>
<span class='id identifier rubyid_register_bundle_processor'>register_bundle_processor</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>text/css</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'><a href="Sprockets/Bundle.html" title="Sprockets::Bundle (class)">Bundle</a></span></code></pre>

<p>We are saying that for any file with MIME type <code>application/javascript</code>, we are using the <a href="Sprockets/Bundle.html" title="Sprockets::Bundle (class)"><code>Bundle</code></a> processor to take care of these files and concatenating them in the same file. So the <a href="Sprockets/Bundle.html" title="Sprockets::Bundle (class)"><code>Bundle</code></a> processor takes a single file asset and prepends all the <code>required</code> URIs in the contents.</p>

<h3>Transformers</h3>

<p>A transformer is a processor that converts a file from one format to another format. One of the examples is the <code>CoffeeScript</code> transformer that takes a <code>CoffeeScript</code> file and returns a JavaScript file.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_register_transformer'>register_transformer</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>text/coffescript</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>application/javascript</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'>CoffeScriptProcessor</span></code></pre>

<p>The implementation of these processors is really simple as we can see below:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>module</span> <span class='const'>CoffeScriptProcessor</span>

  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_call'>call</span>(<span class='id identifier rubyid_input'>input</span>)
    <span class='id identifier rubyid_data'>data</span> <span class='op'>=</span> <span class='id identifier rubyid_input'>input</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_data'>data</span>]

     <span class='id identifier rubyid_js'>js</span><span class='comma'>,</span> <span class='id identifier rubyid_map'>map</span> <span class='op'>=</span> <span class='id identifier rubyid_input'>input</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_cache'>cache</span>].<span class='id identifier rubyid_fetch'>fetch</span>([<span class='kw'>self</span>.<span class='id identifier rubyid_cache_key'>cache_key</span><span class='comma'>,</span> <span class='id identifier rubyid_data'>data</span>]) <span class='kw'>do</span>
       <span class='id identifier rubyid_result'>result</span> <span class='op'>=</span> <span class='const'>CoffeScript</span>.<span class='id identifier rubyid_compile'>compile</span>(<span class='id identifier rubyid_data'>data</span><span class='comma'>,</span> <span class='label'>sourceMap:</span> <span class='kw'>true</span><span class='comma'>,</span> <span class='label'>sourceFiles:</span> [<span class='id identifier rubyid_input'>input</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_source_path'>source_path</span>]])
       [<span class='id identifier rubyid_result'>result</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>js</span><span class='tstring_end'>&#39;</span></span>]<span class='comma'>,</span> <span class='id identifier rubyid_decode_source_maps'>decode_source_maps</span>(<span class='id identifier rubyid_result'>result</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>v3SourceMap</span><span class='tstring_end'>&#39;</span></span>])]
     <span class='kw'>end</span>

     <span class='id identifier rubyid_map'>map</span> <span class='op'>=</span> <span class='const'><a href="Sprockets/SourceMapUtils.html" title="Sprockets::SourceMapUtils (module)">SourceMapUtils</a></span>.<span class='id identifier rubyid_combine_source_maps'>combine_source_maps</span>(<span class='id identifier rubyid_input'>input</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_metadata'>metadata</span>][<span class='symbeg'>:</span><span class='id identifier rubyid_map'>map</span>])<span class='comma'>,</span> <span class='id identifier rubyid_map'>map</span>)
     <span class='tlambeg'>{</span> <span class='id identifier rubyid_data'>data</span><span class='op'>:</span> <span class='id identifier rubyid_js'>js</span><span class='comma'>,</span> <span class='label'>map:</span> <span class='id identifier rubyid_map'>map</span> }
  <span class='kw'>end</span>

<span class='kw'>end</span></code></pre>

<p>We can see that it&#39;s a <code>call</code>-able object that takes an input and [passes it] through the <code>CoffeeScript</code> compiler and returns the result of this operation under the <code>data</code> key in the returned hash.</p>

<h3>Compressors</h3>

<p>Compressors are a special kind of bundle processor because it runs on the concatenated file. You register a compressor using following syntax:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_register_compressor'>register_compressor</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>application/javascript</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_uglify'>uglify</span><span class='comma'>,</span> <span class='const'><a href="Sprockets/UglifierCompressor.html" title="Sprockets::UglifierCompressor (class)">UglifierCompressor</a></span></code></pre>

<p>The main difference between the compressor and the bundle processor is compressors are used differently and you can have only one compressor per MIME type. Sprockets uses a special syntax to enable compressors. You can, for instance, compress any JavaScript file using this syntax:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_env'>env</span>.<span class='id identifier rubyid_js_compressor'>js_compressor</span> <span class='op'>=</span> <span class='symbeg'>:</span><span class='id identifier rubyid_uglify'>uglify</span></code></pre>

<h3>Directives</h3>

<p>I&#39;m sure you all have seen directives before because they are just special comments that declare your bundlers and their dependencies. This, for instance, is important for the <code>application.js</code> file that is generated by a new Rails application.</p>

<pre class="code js"><code class="js">// app/assets/javascripts/application.js
//= require jquery
//= require jquery-ui
//= require users
//= require_tree .
</code></pre>

<p>It&#39;s telling us that to generate this <code>application.js</code> file, we have to require these three files – <code>jquery.js</code>, <code>jquery-ui.js</code>, and <code>users.js</code> – including all the files inside the same directory of the <code>application.js</code> – which is <code>app/assets/javascripts</code>. Another special kind of directive that we have in Sprockets version 3 are the precompile lists wherein you are telling Sprockets to precompile these two files in production.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Rails</span>.<span class='id identifier rubyid_application'>application</span>.<span class='id identifier rubyid_config'>config</span>.<span class='id identifier rubyid_assets'>assets</span>.<span class='id identifier rubyid_precompile'>precompile</span> <span class='op'>&lt;&lt;</span> <span class='qwords'><span class='qwords_beg'>%w(</span><span class='tstring_content'>application.js</span><span class='words_sep'> </span><span class='tstring_content'>application.css</span><span class='tstring_end'>)</span></span></code></pre>

<p>Sprockets has special support for <code>Procs</code> on the precompilation. Before, in Sprockets version 3, we had this code that is telling us to precompile all the known JavaScript and stylesheet files in the app directory.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>LOOSE_APP_ASSETS</span> <span class='op'>=</span> <span class='id identifier rubyid_lambda'>lambda</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_logical_path'>logical_path</span><span class='comma'>,</span> <span class='id identifier rubyid_filename'>filename</span><span class='op'>|</span>
  <span class='id identifier rubyid_filename'>filename</span>.<span class='id identifier rubyid_start_with?'>start_with?</span>(<span class='op'>::</span><span class='const'>Rails</span>.<span class='id identifier rubyid_root'>root</span>.<span class='id identifier rubyid_join'>join</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>app/assets</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_to_s'>to_s</span>) <span class='op'>&amp;&amp;</span>
    <span class='op'>!</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>.js</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>.css</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span>].<span class='id identifier rubyid_include?'>include?</span>(<span class='const'>File</span>.<span class='id identifier rubyid_extname'>extname</span>(<span class='id identifier rubyid_logical_path'>logical_path</span>))
<span class='kw'>end</span>

<span class='id identifier rubyid_config'>config</span>.<span class='id identifier rubyid_assets'>assets</span>.<span class='id identifier rubyid_precompile'>precompile</span> <span class='op'>=</span> [<span class='const'>LOOSE_APP_ASSETS</span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?:\/|\\|\A)application\.(.css|js)$</span><span class='regexp_end'>/</span></span>]</code></pre>

<p>As you can see, the code above is not easy to understand, so in Sprockets version 4, we have a new syntax for that shown below:</p>

<pre class="code js"><code class="js">// app/assets/config/manifest.js
//= link_tree ../images
//= link_directory ../javascripts .js
//= link_directory ../stylesheets .css
//= link my_engine

// my_engine/app/assets/config/my_engine.js
//= link_tree ../images/bootstrap
</code></pre>

<p>It&#39;s called the link directive, so it&#39;s easier to understand what&#39;s going on there. You can actually see that all the images in the image directory is going to be precompiled just as the JavaScript and the style sheets do. One can use this directive to compose new libraries. I have that link to my engine that&#39;s also defining its own manifest file. It&#39;s now easy to understand and to compose. Not that we are going to remove the precompile list, but these new directives are there to help to build the precompile list. We have all these directives by default in Sprockets and later we will explain how you can extend the directives to create your own.</p>

<h3>Environment</h3>

<p>Another component of Sprockets is the environment, and that is actually where your code runs. The environment has methods to retrieve and serve assets, change the load path, and register processors. When you&#39;re doing web requests for your asset file, what is going on is that the Sprockets environment is running and it&#39;s trying to find that specific file and send it back to you.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_environment'>environment</span> <span class='op'>=</span> <span class='const'><a href="Sprockets.html" title="Sprockets (module)">Sprockets</a></span><span class='op'>::</span><span class='const'><a href="Sprockets/Environment.html" title="Sprockets::Environment (class)">Environment</a></span>.<span class='id identifier rubyid_new'><a href="Sprockets/Environment.html#new-class_method" title="Sprockets::Environment.new (method)">new</a></span>
<span class='id identifier rubyid_environment'>environment</span>.<span class='id identifier rubyid_find_assets'>find_assets</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>application.js</span><span class='tstring_end'>&#39;</span></span>)</code></pre>

<p>The environment is also where you call all those methods that were discussed before, where you can register processors, compressors, and so on. As a part of the environment, we have the manifest that is just a log of the contents of all your precompiled assets in a directory and it is used to do fast lookups without having to actually compile the asset code.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_environment'>environment</span> <span class='op'>=</span> <span class='const'><a href="Sprockets.html" title="Sprockets (module)">Sprockets</a></span><span class='op'>::</span><span class='const'><a href="Sprockets/Environment.html" title="Sprockets::Environment (class)">Environment</a></span>.<span class='id identifier rubyid_new'><a href="Sprockets/Environment.html#new-class_method" title="Sprockets::Environment.new (method)">new</a></span>
<span class='const'><a href="Sprockets/Environment.html" title="Sprockets::Environment (class)">Environment</a></span>.<span class='id identifier rubyid_register_transformer'>register_transformer</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>image/svg+xml</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>image/svg</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'>SVGTransformer</span>.<span class='id identifier rubyid_new'>new</span></code></pre>

<p>The object below is really simple. It points the asset path to the fingerprinted version that&#39;s generated by Sprockets.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_javascript_include_tag'>javascript_include_tag</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>application</span><span class='tstring_end'>&#39;</span></span>
<span class='comment'>#&lt;script src=&quot;/assets/application.debug-ddbd4593b22ac054471df143715c8ce65ef84938965c7db19d8a322950ec65b6.js&quot;&gt;
</span><span class='comment'>#&lt;/script&gt;</span></code></pre>

<p>So, when one writes something like <code>javascript_include_tag &#39;application&#39;</code>, what&#39;s going on is that Sprockets looks to the manifest to generate the source attribute of this script tag. A sample manifest is shown below that maps the logical path of the file to the filename including the digest:</p>

<pre class="code ruby"><code class="ruby">{ <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>application.js</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>application-ae0e5a78gfb231d11e07e00ec30g39f0a.js</span><span class='tstring_end'>&quot;</span></span> }</code></pre>

<p>In this example, the logical path of the asset – <code>application.js</code> – is mapped to the generated file name of the asset including the digest value. In the example below, which is a reverse mapping, further details of the asset are available including mtime, logical path, and so on.</p>

<pre class="code ruby"><code class="ruby">{
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>application-2e8e9a7888bdbd11e97effec30214a82.js</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span>
  {
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>logical-path</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>application.js</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mtime</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>2016-06-16T23:09:08-06:00</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>digest</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>2e8e9a7888bdbd11e97effec30214a82</span><span class='tstring_end'>&quot;</span></span>
  }
}</code></pre>

<p>Another hash is used to expire caches of Sprockets, so you can actually use the same directory and use the assets that you precompiled in the previous deploys. Later you can use this information to expire all the assets that you do not want to be in that folder anymore. There are more things about Sprockets that can be found in the Sprockets documentation and source code, including MIME types, dependency resolvers, transformer suffix, bundle metadata reducer.</p>

<h2>sprockets-rails</h2>

<p>So a part of Sprockets, the asset pipeline is made by the <code>sprockets-rails</code> gem, and as you can guess, all this gem does is to integrate Sprockets to our Rails application so it defines helpers that we use in our application, like the examples below:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_javascript_include_tag'>javascript_include_tag</span>
<span class='id identifier rubyid_stylesheet_link_tag'>stylesheet_link_tag</span></code></pre>

<p>The gem also configures the Sprockets environment without the configurations we have in the config initializer in <code>/assets</code>. It also checks the precompile list, which has been a feature since Sprockets version 3. The gem also makes it easier to know when we make mistakes in development, for example by not including an asset in the assets precompile list.</p>

<p>For example, if we were to write the following in our template:</p>

<pre class="code xml"><code class="xml">&lt;%= javascript_include_tag &#39;foo&#39; %&gt;
</code></pre>

<p>This gem makes it possible to raise an exception that is telling you that we need to include that <code>foo.js</code> file in the manifest before using it in development. The exception in this example would be <code>Sprockets::Rails::Helper::AssetNotPrecompiled</code>.</p>

<h2>sass-rails</h2>

<p>Another gem that we have is <code>sass-rails</code> gem, so like I said before, the <a href="Sprockets/SassProcessor.html" title="Sprockets::SassProcessor (class)"><code>SassProcessor</code></a> is built-in into Sprockets itself, but there are some particularities of integrating Sass with Rails that needs to be done in this gem. The gem defines the generators that will be used by the Rails generator when we make a new scaffold that will also generate the corresponding Sass files. It also creates an importer that knows how to handle globs, paths, and ERB to support having something like this in your Sass files:</p>

<pre class="code scss"><code class="scss">@import &quot;foo/*&quot;
// bar.scss.erb
@import &quot;bar&quot;
</code></pre>

<p>Here we are using glob imports and importing an ERB file, which would not work without the gem. It also configures the Sass processor with all the information we have in our Rails application.</p>

<h2>execjs</h2>

<p>The third gem is the <code>execjs</code> gem. It allows you to run JavaScript code inside the Ruby environment and it uses the JavaScript environment that is available to you in the machine. We have some runtimes that work by default in the gem, like the Node.js environment and the V8 Google interpreter. The JavaScript code can be run directly within the Ruby VM. Using the gem is really simple as you can see from the examples below:</p>

<h3>Examples</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>execjs</span><span class='tstring_end'>&#39;</span></span>
<span class='const'>ExecJS</span>.<span class='id identifier rubyid_eval'>eval</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>&#39;red yellow blue&#39;.split(&#39; &#39;)</span><span class='tstring_end'>&quot;</span></span>
<span class='comment'># =&gt; [&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;]</span></code></pre>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>execjs</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>open-uri</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_source'>source</span> <span class='op'>=</span> <span class='id identifier rubyid_open'>open</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>https://coffeescript.org/v1/browser-compiler/coffee-script.js</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_read'>read</span>

<span class='id identifier rubyid_context'>context</span> <span class='op'>=</span> <span class='const'>ExecJS</span>.<span class='id identifier rubyid_compile'>compile</span>(<span class='id identifier rubyid_source'>source</span>)
<span class='id identifier rubyid_context'>context</span>.<span class='id identifier rubyid_call'>call</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>CoffeeScript.compile</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>square = (x) -&gt; x * x</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>bare:</span> <span class='kw'>true</span>)
<span class='comment'># =&gt; &quot;var square;\nsquare = function(x) {\n  return x * x;\n};&quot;</span></code></pre>

<p>Here we are actually getting the CoffeeScript source code from the CoffeeScript website and compiling CoffeeScript code using Ruby. So as you can see, this gem is used by the coffee-script gem to compile CoffeeScript code to JavaScript. That brings us the the next gem, which is the coffee-rails gem.</p>

<h2>coffee-rails</h2>

<p>All this gem does is configures generators, so if you don&#39;t use generators, you actually don&#39;t need the gem. It also defines a template handler so you can call handler CoffeeScript files from your controllers.</p>

<h3>Asset generation in development</h3>

<p>In development, when you are using the <code>javascript_include_tag</code> as below:</p>

<pre class="code xml"><code class="xml">&lt;%= javascript_include_tag &#39;application&#39;%&gt;
</code></pre>

<p>The method generates the following HTML code that points to the digest version of that file:</p>

<pre class="code ruby"><code class="ruby"><span class='op'>&lt;</span><span class='id identifier rubyid_script'>script</span> <span class='id identifier rubyid_src'>src</span><span class='op'>=</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>/assets/application.debug-ddbd4593b22ac054471df143715c8ce65ef84938965c7db19d8a322950ec65b6.js</span><span class='tstring_end'>&quot;</span></span><span class='op'>&gt;</span><span class='op'>&lt;</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>script&gt;
             | path
                     | name
                                | suffix
                                      | SHA1 of file contents
                                                                                                       | extension</span></code></pre>

<p>Note that the filename, is composed of the <em>path</em> to the asset, the <em>name</em> of the asset, the asset <em>suffix</em>, the SHA1 <em>digest</em> of the file contents, and the <em>extension</em> indicating file type. The <code>debug</code> suffix tells Sprockets that the debug pipeline is being used. When Sprockets generates the file in response to a request, it uses the debug pipeline which is defined like this:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_register_pipeline'>register_pipeline</span> <span class='symbeg'>:</span><span class='id identifier rubyid_debug'>debug</span> <span class='kw'>do</span>
  [<span class='const'>SourceMapCommentProcessor</span>]
<span class='kw'>end</span></code></pre>

<p>The pipeline generates your asset, and puts a SourceMapComment in the end of the file. At the end of the JavaScript code, you are going to see a comment that looks something like this:</p>

<pre class="code js"><code class="js">//# sourceMappingURL=application.js-bf4cd805a31db054ae1dr1417f5c8ce72s13468ae23cbdb19d4a3bb010eh11f3.map
</code></pre>

<p>This is telling your browser how to get all the information about the source code via this source map file. To build the source code of this asset, Sprockets is going to use the default pipeline. The default pipeline is defined as shown below. It&#39;s just a small function call inside the Sprockets environment, and what this function call does is check if you have any kind of bundle processor for that MIME type that we are going to handle and use that bundle processor to build the asset.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_register_pipeline'>register_pipeline</span> <span class='symbeg'>:</span><span class='id identifier rubyid_default'>default</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_env'>env</span><span class='comma'>,</span> <span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='id identifier rubyid_file_type'>file_type</span><span class='op'>|</span>
  <span class='id identifier rubyid_env'>env</span>.<span class='id identifier rubyid_default_processors_for'>default_processors_for</span>(<span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='id identifier rubyid_file_type'>file_type</span>)
<span class='kw'>end</span>

<span class='kw'>def</span> <span class='id identifier rubyid_default_processors_for'>default_processors_for</span>(<span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='id identifier rubyid_file_type'>file_type</span>)
  <span class='id identifier rubyid_bundled_processors'>bundled_processors</span> <span class='op'>=</span> <span class='id identifier rubyid_config'>config</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_bundle_processors'>bundle_processors</span>][<span class='id identifier rubyid_type'>type</span>]
  <span class='kw'>if</span> <span class='id identifier rubyid_bundled_processors'>bundled_processors</span>.<span class='id identifier rubyid_any?'>any?</span>
    <span class='id identifier rubyid_bundled_processors'>bundled_processors</span>
  <span class='kw'>else</span>
     <span class='id identifier rubyid_self_processors_for'>self_processors_for</span>(<span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='id identifier rubyid_file_type'>file_type</span>)
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>For JavaScript, it uses the <code>bundled_processors</code> already configured inside Sprockets. In the bundle processor, all of the required files are compiled and merged to compose the final output file. To do this, Sprockets is going to use the <em>self pipeline</em>. The self pipeline is defined like this:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_register_pipeline'>register_pipeline</span> <span class='symbeg'>:</span><span class='kw'>self</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_env'>env</span><span class='comma'>,</span> <span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='id identifier rubyid_file_type'>file_type</span><span class='op'>|</span>
  <span class='id identifier rubyid_env'>env</span>.<span class='id identifier rubyid_self_processors_for'>self_processors_for</span>(<span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='id identifier rubyid_file_type'>file_type</span>)
<span class='kw'>end</span>

<span class='kw'>def</span> <span class='id identifier rubyid_self_processors_for'>self_processors_for</span>(<span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='id identifier rubyid_file_type'>file_type</span>)
  <span class='id identifier rubyid_processors'>processors</span> <span class='op'>=</span> []

  <span class='id identifier rubyid_processors'>processors</span>.<span class='id identifier rubyid_concat'>concat</span> <span class='id identifier rubyid_config'>config</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_postprocessors'>postprocessors</span>][<span class='id identifier rubyid_type'>type</span>]
  <span class='kw'>if</span> <span class='id identifier rubyid_type'>type</span> <span class='op'>!=</span> <span class='id identifier rubyid_file_type'>file_type</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_processor'>processor</span> <span class='op'>=</span> <span class='id identifier rubyid_config'>config</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_transformers'>transformers</span>][<span class='id identifier rubyid_file_type'>file_type</span>][<span class='id identifier rubyid_type'>type</span>]
    <span class='id identifier rubyid_processors'>processors</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_processor'>processor</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_processors'>processors</span>.<span class='id identifier rubyid_concat'>concat</span> <span class='id identifier rubyid_config'>config</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_preprocessors'>preprocessors</span>][<span class='id identifier rubyid_type'>type</span>]

  <span class='kw'>if</span> <span class='id identifier rubyid_processors'>processors</span>.<span class='id identifier rubyid_any?'>any?</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_mime_type_charset_deteceter'>mime_type_charset_deteceter</span>(<span class='id identifier rubyid_type'>type</span>)
    <span class='id identifier rubyid_processors'>processors</span> <span class='op'>&lt;&lt;</span> <span class='const'><a href="Sprockets/FileReader.html" title="Sprockets::FileReader (class)">FileReader</a></span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_processors'>processors</span>
<span class='kw'>end</span></code></pre>

<p>First, it determines the <code>postprocessors</code>, <code>transformers</code>, and <code>preprocessors</code>, for that MIME type. To  read the file from the file system, it adds a new processor that is the <a href="Sprockets/FileReader.html" title="Sprockets::FileReader (class)"><code>FileReader</code></a> that reads the file system to get the source code. You can see that it is a pipeline where each component provides output which is used as input for the next component. In the end, the bundler processor merges all of the output and the result is sent back to the browser. This how the asset compilation works in development. The key difference between development and production is that in production, all of this happens in the precompile task and only the resulting static asset is returned to the browser. We can now use this knowledge to extend Sprockets itself.</p>

<h2>Creating new directives</h2>

<p>We can for instance, create new directives. For example the code below is from a real world use case:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>NpmDirectiveProcessor</span> <span class='op'>&lt;</span> <span class='const'><a href="Sprockets.html" title="Sprockets (module)">Sprockets</a></span><span class='op'>::</span><span class='const'><a href="Sprockets/DirectiveProcessor.html" title="Sprockets::DirectiveProcessor (class)">DirectiveProcessor</a></span>
  <span class='kw'>def</span> <span class='id identifier rubyid_process_npm_directive'>process_npm_directive</span>(<span class='id identifier rubyid_path'>path</span>)
    <span class='id identifier rubyid_dirs'>dirs</span> <span class='op'>=</span> <span class='id identifier rubyid_node_modules_paths'>node_modules_paths</span>(<span class='ivar'>@filename</span>)
    <span class='id identifier rubyid_uri'>uri</span><span class='comma'>,</span> <span class='id identifier rubyid_deps'>deps</span> <span class='op'>=</span> <span class='ivar'>@environment</span>.<span class='id identifier rubyid_resolve!'>resolve!</span>(
      <span class='id identifier rubyid_path'>path</span><span class='comma'>,</span>
      <span class='label'>accept:</span> <span class='ivar'>@content_type</span><span class='comma'>,</span>
      <span class='label'>pipeline:</span> <span class='symbeg'>:</span><span class='kw'>self</span><span class='comma'>,</span>
      <span class='label'>load_paths:</span> <span class='id identifier rubyid_dirs'>dirs</span>
     )
    <span class='ivar'>@dependecies</span>.<span class='id identifier rubyid_merge'>merge</span>(<span class='id identifier rubyid_deps'>deps</span>)
    <span class='ivar'>@required</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_uri'>uri</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>We have an <code>NpmDirectiveProcessor</code> that goes to your <code>node_modules_path</code> and tries to get the dependencies from the Npm installation. We create a new directive processor that is inherited from <a href="Sprockets/DirectiveProcessor.html" title="Sprockets::DirectiveProcessor (class)"><code>DirectiveProcessor</code></a>. Sprockets uses a convention that every method that starts with <code>process</code> and ends with <code>directive</code> is going to be used by directive processor. For example, if you have the <code>NpmDirectiveProcessor</code>, the method name will be <code>process_npm_directive</code>. After that, we just register that preprocessor for the appropriate MIME type with the appropriate processor.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_register_preprocessor'>register_preprocessor</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>application/javascript</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>NpmDirectiveProcessor</span><span class='tstring_end'>&#39;</span></span>.<span class='id identifier rubyid_new'>new</span>(<span class='label'>comments:</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>//</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> [<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>/*</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>*/</span><span class='tstring_end'>&#39;</span></span>]])</code></pre>

<p>Below is an example of loading the <code>lodash</code> library via Npm module:</p>

<pre class="code js"><code class="js">// app/assets/javascripts/my_component.js
//= npm lodash
</code></pre>

<p>Another real world example, is were we have a lot of images that are SVG but we also have to support browsers that do not support SVG. So, we have to convert the images from SVG to PNG. That happens automatically in the asset precompiling rake task. All we need to do is register a transformer from SVG to PNG.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_environment'>environment</span>.<span class='id identifier rubyid_register_transformer'>register_transformer</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>image/svg+xml</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>image/png</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'>SVGTransformer</span>.<span class='id identifier rubyid_new'>new</span></code></pre>

<p>We can use something like the code below when we need to generate <code>foo.png</code> from <code>foo.svg</code>. If we only have the SVG version in our file system, we can dynamically generate the PNG file on-the-fly from our SVG files in the <code>../images</code> folder. An example of that is shown below using the <code>link</code> option:</p>

<pre class="code js"><code class="js">// app/assets/config/manifest.js
// Given you have foo.svg
//= link foo.png
// or
//= link_tree ../images .png
</code></pre>

<p>This is the real code. It&#39;s just a <code>call</code> method that gets the input that is the SVG source code and uses RMagick to generate the PNG file which is returned as a binary blob under the <code>data</code> Hash key.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rmagick</span><span class='tstring_end'>&#39;</span></span>

<span class='kw'>class</span> <span class='const'>SvgTransformer</span>
  <span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_call'>call</span>(<span class='id identifier rubyid_input'>input</span>)
    <span class='id identifier rubyid_image_list'>image_list</span> <span class='op'>=</span> <span class='const'>Magick</span><span class='op'>::</span><span class='const'>Image</span>.<span class='id identifier rubyid_from_blob'>from_blob</span>(<span class='id identifier rubyid_input'>input</span>[<span class='symbeg'>:</span><span class='id identifier rubyid_data'>data</span>]) { <span class='kw'>self</span>.<span class='id identifier rubyid_format'>format</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>SVG</span><span class='tstring_end'>&#39;</span></span> }
    <span class='id identifier rubyid_image'>image</span> <span class='op'>=</span> <span class='id identifier rubyid_image_list'>image_list</span>.<span class='id identifier rubyid_first'>first</span>
    <span class='id identifier rubyid_image'>image</span>.<span class='id identifier rubyid_format'>format</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>PNG</span><span class='tstring_end'>&#39;</span></span>

    { <span class='label'>data:</span> <span class='id identifier rubyid_image'>image</span>.<span class='id identifier rubyid_to_blob'>to_blob</span> }
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>