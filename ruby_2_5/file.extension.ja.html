<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: Extension.ja &mdash; Ruby-2.5.9</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "extension.ja",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>Ruby-2.5.9</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: Extension.ja&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="file_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>

<p># extension.ja.rdoc -  -*- RDoc -*- created at: Mon Aug  7 16:45:54 JST 1995</p>

<h1 id="label-Ruby-E3-81-AE-E6-8B-A1-E5-BC-B5-E3-83-A9-E3-82-A4-E3-83-96-E3-83-A9-E3-83-AA-E3-81-AE-E4-BD-9C-E3-82-8A-E6-96-B9">Rubyの拡張ライブラリの作り方</h1>

<p>Rubyの拡張ライブラリの作り方を説明します．</p>

<h2 id="label-E5-9F-BA-E7-A4-8E-E7-9F-A5-E8-AD-98">基礎知識</h2>

<p>Cの変数には型があり，データには型がありません．ですから，た とえばポインタをintの変数に代入すると，その値は整数として取 り扱われます．逆にRubyの変数には型がなく，データに型がありま す．この違いのため，CとRubyは相互に変換しなければ，お互いの データをアクセスできません．</p>

<p>RubyのデータはVALUEというCの型で表現されます．VALUE型のデー タはそのデータタイプを自分で知っています．このデータタイプと いうのはデータ(オブジェクト)の実際の構造を意味していて，Ruby のクラスとはまた違ったものです．</p>

<p>VALUEからCにとって意味のあるデータを取り出すためには</p>
<ol><li>
<p>VALUEのデータタイプを知る</p>
</li><li>
<p>VALUEをCのデータに変換する</p>
</li></ol>

<p>の両方が必要です．(1)を忘れると間違ったデータの変換が行われ て，最悪プログラムがcore dumpします．</p>

<h3 id="label-E3-83-87-E3-83-BC-E3-82-BF-E3-82-BF-E3-82-A4-E3-83-97">データタイプ</h3>

<p>Rubyにはユーザが使う可能性のある以下のタイプがあります．</p>
<dl class="rdoc-list note-list"><dt>T_NIL      
<dd>
<p>nil</p>
</dd><dt>T_OBJECT   
<dd>
<p>通常のオブジェクト</p>
</dd><dt>T_CLASS    
<dd>
<p>クラス</p>
</dd><dt>T_MODULE   
<dd>
<p>モジュール</p>
</dd><dt>T_FLOAT    
<dd>
<p>浮動小数点数</p>
</dd><dt>T_STRING   
<dd>
<p>文字列</p>
</dd><dt>T_REGEXP   
<dd>
<p>正規表現</p>
</dd><dt>T_ARRAY    
<dd>
<p>配列</p>
</dd><dt>T_HASH     
<dd>
<p>連想配列</p>
</dd><dt>T_STRUCT   
<dd>
<p>(Rubyの)構造体</p>
</dd><dt>T_BIGNUM   
<dd>
<p>多倍長整数</p>
</dd><dt>T_FIXNUM   
<dd>
<p>Fixnum(31bitまたは63bit長整数)</p>
</dd><dt>T_COMPLEX  
<dd>
<p>複素数</p>
</dd><dt>T_RATIONAL 
<dd>
<p>有理数</p>
</dd><dt>T_FILE     
<dd>
<p>入出力</p>
</dd><dt>T_TRUE     
<dd>
<p>真</p>
</dd><dt>T_FALSE    
<dd>
<p>偽</p>
</dd><dt>T_DATA     
<dd>
<p>データ</p>
</dd><dt>T_SYMBOL   
<dd>
<p>シンボル</p>
</dd></dl>

<p>その他に内部で利用されている以下のタイプがあります．</p>

<pre class="code ruby"><code class="ruby"><span class='const'>T_ICLASS</span>
<span class='const'>T_MATCH</span>
<span class='const'>T_UNDEF</span>
<span class='const'>T_NODE</span>
<span class='const'>T_ZOMBIE</span></code></pre>

<p>ほとんどのタイプはCの構造体で実装されています．</p>

<h3 id="label-VALUE-E3-81-AE-E3-83-87-E3-83-BC-E3-82-BF-E3-82-BF-E3-82-A4-E3-83-97-E3-82-92-E3-83-81-E3-82-A7-E3-83-83-E3-82-AF-E3-81-99-E3-82-8B">VALUEのデータタイプをチェックする</h3>

<p>ruby.hではTYPE()というマクロが定義されていて，VALUEのデータ タイプを知ることが出来ます．TYPE()マクロは上で紹介したT_XXXX の形式の定数を返します．VALUEのデータタイプに応じて処理する 場合には，TYPE()の値で分岐することになります．</p>

<pre class="code ruby"><code class="ruby">switch (TYPE(obj)) {
  case T_FIXNUM:
    /* FIXNUMの処理 */
    break;
  case T_STRING:
    /* 文字列の処理 */
    break;
  case T_ARRAY:
    /* 配列の処理 */
    break;
  default:
    /* 例外を発生させる */
    rb_raise(rb_eTypeError, &quot;not valid value&quot;);
    break;
}</code></pre>

<p>それとデータタイプをチェックして，正しくなければ例外を発生す る関数が用意されています．</p>

<pre class="code ruby"><code class="ruby">void Check_Type(VALUE value, int type)</code></pre>

<p>この関数はvalueがtypeで無ければ，例外を発生させます．引数と して与えられたVALUEのデータタイプが正しいかどうかチェックす るためには，この関数を使います．</p>

<p>FIXNUMとNILに関してはより高速な判別マクロが用意されています．</p>

<pre class="code ruby"><code class="ruby"><span class='const'>FIXNUM_P</span>(<span class='id identifier rubyid_obj'>obj</span>)
<span class='const'>NIL_P</span>(<span class='id identifier rubyid_obj'>obj</span>)</code></pre>

<h3 id="label-VALUE-E3-82-92C-E3-81-AE-E3-83-87-E3-83-BC-E3-82-BF-E3-81-AB-E5-A4-89-E6-8F-9B-E3-81-99-E3-82-8B">VALUEをCのデータに変換する</h3>

<p>データタイプがT_NIL，T_FALSE，T_TRUEである時，データはそれぞ れnil，false，trueです．このデータタイプのオブジェクトはひと つずつしか存在しません．</p>

<p>データタイプがT_FIXNUMの時，これは31bitまたは63bitのサイズを 持つ整数です．longのサイズが32bitのプラットフォームであれば 31bitに，longのサイズが64bitのプラットフォームであれば63bit になります. FIXNUM を C の整数に変換するためにはマクロ 「FIX2INT()」または「FIX2LONG()」を使います．これらのマクロ を使用する際には事前にデータタイプがFIXNUMであることを確認す る必要がありますが，比較的高速に変換を行うことができます．ま た，「FIX2LONG()」は例外を発生しませんが，「FIX2INT()」は変 換結果がintのサイズに収まらない場合には例外を発生します． それから，FIXNUMに限らずRubyのデータを整数に変換する 「NUM2INT()」および「NUM2LONG()」というマクロがあります．こ れらのマクロはデータタイプのチェック無しで使えます (整数に変換できない場合には例外が発生する)．同様にチェック無し で使える変換マクロはdoubleを取り出す「NUM2DBL()」があります．</p>

<p>char* を取り出す場合， StringValue() と StringValuePtr() を使います． StringValue(var) は var が String であれば何もせず，そうでなければ var を var.to_str() の結果 に置き換えるマクロ，StringValuePtr(var) は同様に var を String に置き換えてから var のバイト列表現に対する char* を 返すマクロです．var の内容を直接置き換える処理が入るので， var は lvalue である必要があります． また，StringValuePtr() に類似した StringValueCStr() というマ クロもあります．StringValueCStr(var) は var を String に置き 換えてから var の文字列表現に対する char* を返します．返され る文字列の末尾には NUL 文字が付加されます．なお，途中に NUL 文字が含まれる場合は ArgumentError が発生します． 一方，StringValuePtr() では，末尾に NUL 文字がある保証はなく， 途中に NUL 文字が含まれている可能性もあります．</p>

<p>それ以外のデータタイプは対応するCの構造体があります．対応す る構造体のあるVALUEはそのままキャスト(型変換)すれば構造体の ポインタに変換できます．</p>

<p>構造体は「struct RXxxxx」という名前でruby.hで定義されていま す．例えば文字列は「struct RString」です．実際に使う可能性が あるのは文字列と配列くらいだと思います．</p>

<p>ruby.hでは構造体へキャストするマクロも「RXXXXX()」(全部大文 字にしたもの)という名前で提供されています(例: RSTRING())．た だし、構造体への直接のアクセスはできるだけ避け，対応する rb_xxxx() といった関数を使うようにして下さい．例えば，配列の 要素へアクセスする場合は，rb_ary_entry(ary, offset)， rb_ary_store(ary, offset, obj) を利用するようにして下さい．</p>

<p>構造体からデータを取り出すマクロが提供されています．文字列 strの長さを得るためには「RSTRING_LEN(str)」とし，文字列strを char*として得るためには「RSTRING_PTR(str)」とします．</p>

<p>Rubyの構造体を直接アクセスする時に気をつけなければならないこ とは，配列や文字列の構造体の中身は参照するだけで，直接変更し ないことです．直接変更した場合，オブジェクトの内容の整合性が とれなくなって，思わぬバグの原因になります．</p>

<h3 id="label-C-E3-81-AE-E3-83-87-E3-83-BC-E3-82-BF-E3-82-92VALUE-E3-81-AB-E5-A4-89-E6-8F-9B-E3-81-99-E3-82-8B">CのデータをVALUEに変換する</h3>

<p>VALUEの実際の構造は</p>
<dl class="rdoc-list note-list"><dt>FIXNUMの場合 
<dd>
<p>1bit左シフトして，LSBを立てる．</p>
</dd><dt>その他のポインタの場合 
<dd>
<p>そのままVALUEにキャストする．</p>
</dd></dl>

<p>となっています．よって，LSBをチェックすればVALUEがFIXNUMかど うかわかるわけです(ポインタのLSBが立っていないことを仮定して いる)．</p>

<p>ですから，FIXNUM以外のRubyのオブジェクトの構造体は単にVALUE にキャストするだけでVALUEに変換出来ます．ただし，任意の構造 体がVALUEにキャスト出来るわけではありません．キャストするの はRubyの知っている構造体(ruby.hで定義されているstruct RXxxx のもの)だけです．</p>

<p>FIXNUMに関しては変換マクロを経由する必要があります．Cの整数 からVALUEに変換するマクロは以下のものがあります．必要に応じ て使い分けてください．</p>
<dl class="rdoc-list note-list"><dt>INT2FIX() 
<dd>
<p>もとの整数が31bitまたは63bit以内に収まる自信 がある時</p>
</dd><dt>INT2NUM() 
<dd>
<p>任意の整数からVALUEへ</p>
</dd></dl>

<p>INT2NUM()は整数がFIXNUMの範囲に収まらない場合，Bignumに変換 してくれます(が，少し遅い)．</p>

<h3 id="label-Ruby-E3-81-AE-E3-83-87-E3-83-BC-E3-82-BF-E3-82-92-E6-93-8D-E4-BD-9C-E3-81-99-E3-82-8B">Rubyのデータを操作する</h3>

<p>先程も述べた通り，Rubyの構造体をアクセスする時に内容の更新を 行うことは勧められません．で，Rubyのデータを操作する時には Rubyが用意している関数を用いてください．</p>

<p>ここではもっとも使われるであろう文字列と配列の生成/操作を行 う関数をあげます(全部ではないです)．</p>

<h4 id="label-E6-96-87-E5-AD-97-E5-88-97-E3-81-AB-E5-AF-BE-E3-81-99-E3-82-8B-E9-96-A2-E6-95-B0">文字列に対する関数</h4>
<dl class="rdoc-list note-list"><dt>rb_str_new(const char *ptr, long len) 
<dd>
<p>新しいRubyの文字列を生成する．</p>
</dd><dt>rb_str_new2(const char *ptr) 
<dt>rb_str_new_cstr(const char *ptr) 
<dd>
<p>Cの文字列からRubyの文字列を生成する．この関数の機能は rb_str_new(ptr, strlen(ptr))と同等である．</p>
</dd><dt>rb_str_new_literal(const char *ptr) 
<dd>
<p>Cのリテラル文字列からRubyの文字列を生成する．</p>
</dd><dt>rb_tainted_str_new(const char *ptr, long len) 
<dd>
<p>汚染マークが付加された新しいRubyの文字列を生成する．外部 からのデータに基づく文字列には汚染マークが付加されるべき である．</p>
</dd><dt>rb_tainted_str_new2(const char *ptr) 
<dt>rb_tainted_str_new_cstr(const char *ptr) 
<dd>
<p>Cの文字列から汚染マークが付加されたRubyの文字列を生成する．</p>
</dd><dt>rb_str_append(VALUE str1, VALUE str2) 
<dd>
<p>Rubyの文字列str1にRubyの文字列str2を追加する．</p>
</dd><dt>rb_sprintf(const char *format, …) 
<dt>rb_vsprintf(const char *format, va_list ap) 
<dd>
<p>Cの文字列formatと続く引数をprintf(3)のフォーマットにしたがって 整形し，Rubyの文字列を生成する．</p>

<p>注意: “%”PRIsVALUEがObject#to_s(&#39;+&#39;フラグが指定されている ときはObject#inspect)を使ったVALUEの出力に利用できる．これ は“%i”と衝突するため，整数には“%d”を使用すること．</p>
</dd><dt>rb_str_cat(VALUE str, const char *ptr, long len) 
<dd>
<p>Rubyの文字列strにlenバイトの文字列ptrを追加する．</p>
</dd><dt>rb_str_cat2(VALUE str, const char* ptr) 
<dt>rb_str_cat_cstr(VALUE str, const char* ptr) 
<dd>
<p>Rubyの文字列strにCの文字列ptrを追加する．この関数の機能は rb_str_cat(str, ptr, strlen(ptr))と同等である．</p>
</dd><dt>rb_str_catf(VALUE str, const char* format, …) 
<dt>rb_str_vcatf(VALUE str, const char* format, va_list ap) 
<dd>
<p>Cの文字列formatと続く引数をprintf(3)のフォーマットにしたがって 整形し，Rubyの文字列strに追加する．この関数の機能は，それぞれ rb_str_append(str, rb_sprintf(format, …)) や rb_str_append(str, rb_vsprintf(format, ap)) と同等である．</p>
</dd><dt>rb_enc_str_new(const char *ptr, long len, rb_encoding *enc) 
<dt>rb_enc_str_new_cstr(const char *ptr, rb_encoding *enc) 
<dd>
<p>指定されたエンコーディングでRubyの文字列を生成する.</p>
</dd><dt>rb_enc_str_new_literal(const char *ptr, rb_encoding *enc) 
<dd>
<p>Cのリテラル文字列から指定されたエンコーディングでRubyの文字列を生成する．</p>
</dd><dt>rb_usascii_str_new(const char *ptr, long len) 
<dt>rb_usascii_str_new_cstr(const char *ptr) 
<dd>
<p>エンコーディングがUS-ASCIIのRubyの文字列を生成する.</p>
</dd><dt>rb_usascii_str_new_literal(const char *ptr) 
<dd>
<p>Cのリテラル文字列からエンコーディングがUS-ASCIIのRubyの文字列を生成する．</p>
</dd><dt>rb_utf8_str_new(const char *ptr, long len) 
<dt>rb_utf8_str_new_cstr(const char *ptr) 
<dd>
<p>エンコーディングがUTF-8のRubyの文字列を生成する.</p>
</dd><dt>rb_utf8_str_new_literal(const char *ptr) 
<dd>
<p>Cのリテラル文字列からエンコーディングがUTF-8のRubyの文字列を生成する．</p>
</dd><dt>rb_str_resize(VALUE str, long len) 
<dd>
<p>Rubyの文字列のサイズをlenバイトに変更する．strの長さは前 以てセットされていなければならない．lenが元の長さよりも短 い時は，lenバイトを越えた部分の内容は捨てられる．lenが元 の長さよりも長い時は，元の長さを越えた部分の内容は保存さ れないでゴミになるだろう．この関数の呼び出しによって RSTRING_PTR(str)が変更されるかもしれないことに注意．</p>
</dd><dt>rb_str_set_len(VALUE str, long len) 
<dd>
<p>Rubyの文字列のサイズをlenバイトにセットする．strが変更可 能でなければ例外が発生する．RSTRING_LEN(str)とは無関係に， lenバイトまでの内容は保存される．lenはstrの容量を越えてい てはならない．</p>
</dd></dl>

<h4 id="label-E9-85-8D-E5-88-97-E3-81-AB-E5-AF-BE-E3-81-99-E3-82-8B-E9-96-A2-E6-95-B0">配列に対する関数</h4>
<dl class="rdoc-list note-list"><dt>rb_ary_new() 
<dd>
<p>要素が0の配列を生成する．</p>
</dd><dt>rb_ary_new2(long len) 
<dt>rb_ary_new_capa(long len) 
<dd>
<p>要素が0の配列を生成する．len要素分の領域をあらかじめ割り 当てておく．</p>
</dd><dt>rb_ary_new3(long n, …) 
<dt>rb_ary_new_from_args(long n, …) 
<dd>
<p>引数で指定したn要素を含む配列を生成する．</p>
</dd><dt>rb_ary_new4(long n, VALUE *elts) 
<dt>rb_ary_new_from_values(long n, VALUE *elts) 
<dd>
<p>配列で与えたn要素の配列を生成する．</p>
</dd><dt>rb_ary_to_ary(VALUE obj) 
<dd>
<p>オブジェクトを配列に変換する. Object#to_aryと同等である.</p>
</dd></dl>

<p>他にも配列を操作する関数が多数ある. これらは 引数aryに配列を渡さなければならない. さもないと コアを吐く.</p>
<dl class="rdoc-list note-list"><dt>rb_ary_aref(int argc, const VALUE *argv, VALUE ary) 
<dd>
<p>Array#[]と同等.</p>
</dd><dt>rb_ary_entry(VALUE ary, long offset) 
<dd>
<p><a href=“offset”>ary</a></p>
</dd><dt>rb_ary_store(VALUE ary, long offset, VALUE obj) 
<dd>
<p><a href=“offset”>ary</a> = obj</p>
</dd><dt>rb_ary_subseq(VALUE ary, long beg, long len) 
<dd>
<p>ary[beg, len]</p>
</dd><dt>rb_ary_push(VALUE ary, VALUE val) 
<dt>rb_ary_pop(VALUE ary) 
<dt>rb_ary_shift(VALUE ary) 
<dt>rb_ary_unshift(VALUE ary, VALUE val) 
<dd>
<p>ary.push, ary.pop, ary.shift, ary.unshift</p>
</dd><dt>rb_ary_cat(VALUE ary, const VALUE *ptr, long len) 
<dd>
<p>配列aryにptrからlen個のオブジェクトを追加する．</p>
</dd></dl>

<h2 id="label-Ruby-E3-81-AE-E6-A9-9F-E8-83-BD-E3-82-92-E4-BD-BF-E3-81-86">Rubyの機能を使う</h2>

<p>原理的にRubyで書けることはCでも書けます．RubyそのものがCで記 述されているんですから，当然といえば当然なんですけど．ここで はRubyの拡張に使うことが多いだろうと予測される機能を中心に紹 介します．</p>

<h3 id="label-Ruby-E3-81-AB-E6-A9-9F-E8-83-BD-E3-82-92-E8-BF-BD-E5-8A-A0-E3-81-99-E3-82-8B">Rubyに機能を追加する</h3>

<p>Rubyで提供されている関数を使えばRubyインタプリタに新しい機能 を追加することができます．Rubyでは以下の機能を追加する関数が 提供されています．</p>
<ul><li>
<p>クラス，モジュール</p>
</li><li>
<p>メソッド，特異メソッドなど</p>
</li><li>
<p>定数</p>
</li></ul>

<p>では順に紹介します．</p>

<h4 id="label-E3-82-AF-E3-83-A9-E3-82-B9-2F-E3-83-A2-E3-82-B8-E3-83-A5-E3-83-BC-E3-83-AB-E5-AE-9A-E7-BE-A9">クラス/モジュール定義</h4>

<p>クラスやモジュールを定義するためには，以下の関数を使います．</p>

<pre class="code ruby"><code class="ruby">VALUE rb_define_class(const char *name, VALUE super)
VALUE rb_define_module(const char *name)</code></pre>

<p>これらの関数は新しく定義されたクラスやモジュールを返します． メソッドや定数の定義にこれらの値が必要なので，ほとんどの場合 は戻り値を変数に格納しておく必要があるでしょう．</p>

<p>クラスやモジュールを他のクラスの内部にネストして定義する時に は以下の関数を使います．</p>

<pre class="code ruby"><code class="ruby">VALUE rb_define_class_under(VALUE outer, const char *name, VALUE super)
VALUE rb_define_module_under(VALUE outer, const char *name)</code></pre>

<h4 id="label-E3-83-A1-E3-82-BD-E3-83-83-E3-83-89-2F-E7-89-B9-E7-95-B0-E3-83-A1-E3-82-BD-E3-83-83-E3-83-89-E5-AE-9A-E7-BE-A9">メソッド/特異メソッド定義</h4>

<p>メソッドや特異メソッドを定義するには以下の関数を使います．</p>

<pre class="code ruby"><code class="ruby">void rb_define_method(VALUE klass, const char *name,
                      VALUE (*func)(ANYARGS), int argc)

void rb_define_singleton_method(VALUE object, const char *name,
                                VALUE (*func)(ANYARGS), int argc)</code></pre>

<p>念のため説明すると「特異メソッド」とは，その特定のオブジェク トに対してだけ有効なメソッドです．RubyではよくSmalltalkにお けるクラスメソッドとして，クラスに対する特異メソッドが使われ ます．</p>

<p>これらの関数の argcという引数はCの関数へ渡される引数の数(と 形式)を決めます．argcが0以上の時は関数に引き渡す引数の数を意 味します．16個以上の引数は使えません(が，要りませんよね，そ んなに)．実際の関数には先頭の引数としてselfが与えられますの で，指定した数より1多い引数を持つことになります．</p>

<p>argcが負の時は引数の数ではなく，形式を指定したことになります． argcが-1の時は引数を配列に入れて渡されます．argcが-2の時は引 数はRubyの配列として渡されます．</p>

<p>メソッドを定義する関数はまだいくつかあります. ひとつはメソッド 名としてIDを取ります. IDについては2.2.2を参照.</p>

<pre class="code ruby"><code class="ruby">void rb_define_method_id(VALUE klass, ID name,
                         VALUE (*func)(ANYARGS), int argc)</code></pre>

<p>private/protectedなメソッドを定義するふたつの関数があります.</p>

<pre class="code ruby"><code class="ruby">void rb_define_private_method(VALUE klass, const char *name,
                              VALUE (*func)(ANYARGS), int argc)
void rb_define_protected_method(VALUE klass, const char *name,
                                VALUE (*func)(ANYARGS), int argc)</code></pre>

<p>privateメソッドとは関数形式でしか呼び出すことの出来ないメソッ ドです．</p>

<p>最後に， rb_define_module関数はモジュール関数を定義します． モジュール関数とはモジュールの特異メソッドであり，同時に privateメソッドでもあるものです．例をあげるとMathモジュール のsqrt()などがあげられます．このメソッドは</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Math</span>.<span class='id identifier rubyid_sqrt'>sqrt</span>(<span class='int'>4</span>)</code></pre>

<p>という形式でも</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_include'>include</span> <span class='const'>Math</span>
<span class='id identifier rubyid_sqrt'>sqrt</span>(<span class='int'>4</span>)</code></pre>

<p>という形式でも使えます．モジュール関数を定義する関数は以下の 通りです．</p>

<pre class="code ruby"><code class="ruby">void rb_define_module_function(VALUE module, const char *name,
                               VALUE (*func)(ANYARGS), int argc)</code></pre>

<p>関数的メソッド(Kernelモジュールのprivate method)を定義するた めの関数は以下の通りです．</p>

<pre class="code ruby"><code class="ruby">void rb_define_global_function(const char *name, VALUE (*func)(ANYARGS), int argc)</code></pre>

<p>メソッドの別名を定義するための関数は以下の通りです．</p>

<pre class="code ruby"><code class="ruby">void rb_define_alias(VALUE module, const char* new, const char* old);</code></pre>

<p>属性の取得・設定メソッドを定義するには</p>

<pre class="code ruby"><code class="ruby">void rb_define_attr(VALUE klass, const char *name, int read, int write)</code></pre>

<p>クラスメソッドallocateを定義したり削除したりするための関数は 以下の通りです．</p>

<pre class="code ruby"><code class="ruby">void rb_define_alloc_func(VALUE klass, VALUE (*func)(VALUE klass));
void rb_undef_alloc_func(VALUE klass);</code></pre>

<p>funcはクラスを引数として受け取って，新しく割り当てられたイン スタンスを返さなくてはなりません．このインスタンスは，外部リ ソースなどを含まない，できるだけ「空」のままにしておいたほう がよいでしょう．</p>

<p>継承したクラスにある既存のメソッドをオーバーライドしているな ら，オーバーライドされたメソッドを呼び出すには以下の関数を使 います．</p>

<pre class="code ruby"><code class="ruby">VALUE rb_call_super(int argc, const VALUE *argv)</code></pre>

<p>現在のスコープのレシーバは(他に方法がなければ)，以下の関数で 得ることができます．</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_rb_current_receiver'>rb_current_receiver</span>(<span class='id identifier rubyid_void'>void</span>)</code></pre>

<h4 id="label-E5-AE-9A-E6-95-B0-E5-AE-9A-E7-BE-A9">定数定義</h4>

<p>拡張ライブラリが必要な定数はあらかじめ定義しておいた方が良い でしょう．定数を定義する関数は二つあります．</p>

<pre class="code ruby"><code class="ruby">void rb_define_const(VALUE klass, const char *name, VALUE val)
void rb_define_global_const(const char *name, VALUE val)</code></pre>

<p>前者は特定のクラス/モジュールに属する定数を定義するもの，後 者はグローバルな定数を定義するものです．</p>

<h3 id="label-Ruby-E3-81-AE-E6-A9-9F-E8-83-BD-E3-82-92C-E3-81-8B-E3-82-89-E5-91-BC-E3-81-B3-E5-87-BA-E3-81-99">Rubyの機能をCから呼び出す</h3>

<p>既に『1.5 Rubyのデータを操作する』で一部紹介したような関数を 使えば，Rubyの機能を実現している関数を直接呼び出すことが出来 ます．</p>

<p># このような関数の一覧表はいまのところありません．ソースを見 # るしかないですね．</p>

<p>それ以外にもRubyの機能を呼び出す方法はいくつかあります．</p>

<h4 id="label-Ruby-E3-81-AE-E3-83-97-E3-83-AD-E3-82-B0-E3-83-A9-E3-83-A0-E3-82-92eval-E3-81-99-E3-82-8B">Rubyのプログラムをevalする</h4>

<p>CからRubyの機能を呼び出すもっとも簡単な方法として，文字列で 与えられたRubyのプログラムを評価する以下の関数があります．</p>

<pre class="code ruby"><code class="ruby"><span class='const'>VALUE</span> <span class='id identifier rubyid_rb_eval_string'>rb_eval_string</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_str'>str</span>)</code></pre>

<p>この評価は現在の環境で行われます．つまり，現在のローカル変数 などを受け継ぎます．</p>

<p>評価は例外を発生するかもしれないことに注意しましょう. より安全 な関数もあります.</p>

<pre class="code ruby"><code class="ruby">VALUE rb_eval_string_protect(const char *str, int *state)</code></pre>

<p>この関数はエラーが発生するとnilを返します．そして，成功時には *stateはゼロに，さもなくば非ゼロになります．</p>

<h4 id="label-ID-E3-81-BE-E3-81-9F-E3-81-AF-E3-82-B7-E3-83-B3-E3-83-9C-E3-83-AB">IDまたはシンボル</h4>

<p>Cから文字列を経由せずにRubyのメソッドを呼び出すこともできま す．その前に，Rubyインタプリタ内でメソッドや変数名を指定する 時に使われているIDについて説明しておきましょう．</p>

<p>IDとは変数名，メソッド名を表す整数です．Rubyの中では</p>

<pre class="code ruby"><code class="ruby"><span class='symbeg'>:</span><span class='id identifier rubyid_識別子'>識別子</span></code></pre>

<p>または</p>

<pre class="code ruby"><code class="ruby"><span class='symbeg'>:&quot;</span><span class='tstring_content'>任意の文字列</span><span class='tstring_end'>&quot;</span></span></code></pre>

<p>でアクセスできます．Cからこの整数を得るためには関数</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_rb_intern'>rb_intern</span>(<span class='id identifier rubyid_const'>const</span> <span class='id identifier rubyid_char'>char</span> <span class='op'>*</span><span class='id identifier rubyid_name'>name</span>)
<span class='id identifier rubyid_rb_intern_str'>rb_intern_str</span>(<span class='const'>VALUE</span> <span class='id identifier rubyid_name'>name</span>)</code></pre>

<p>を使います．Rubyから引数として与えられたシンボル(または文字 列)をIDに変換するには以下の関数を使います．</p>

<pre class="code ruby"><code class="ruby">rb_to_id(VALUE symbol)
rb_check_id(volatile VALUE *name)
rb_check_id_cstr(const char *name, long len, rb_encoding *enc)</code></pre>

<p>もし引数がシンボルでも文字列でもなければ，to_strメソッドで文 字列に変換しようとします．第二の関数はその変換結果を*nameに保 存し,その名前が既知のシンボルでない場合は0を返します．この関 数が0以外を返した場合は*nameは常にシンボルか文字列であり，0を 返した場合は常に文字列です．第三の関数はRubyの文字列ではなく NUL終端されたCの文字列を使います．</p>

<p>Rubyから引数として与えられたシンボル(または文字列)をシンボル に変換するには以下の関数を使います．</p>

<pre class="code ruby"><code class="ruby">rb_to_symbol(VALUE name)
rb_check_symbol(volatile VALUE *namep)
rb_check_symbol_cstr(const char *ptr, long len, rb_encoding *enc)</code></pre>

<p>これらの関数は，IDの代わりにシンボルを返すことを除けば上記の 関数と同じです．</p>

<h4 id="label-C-E3-81-8B-E3-82-89Ruby-E3-81-AE-E3-83-A1-E3-82-BD-E3-83-83-E3-83-89-E3-82-92-E5-91-BC-E3-81-B3-E5-87-BA-E3-81-99">CからRubyのメソッドを呼び出す</h4>

<p>Cから文字列を経由せずにRubyのメソッドを呼び出すためには以下 の関数を使います．</p>

<pre class="code ruby"><code class="ruby">VALUE rb_funcall(VALUE recv, ID mid, int argc, ...)</code></pre>

<p>この関数はオブジェクトrecvのmidで指定されるメソッドを呼び出 します．その他に引数の指定の仕方が違う以下の関数もあります．</p>

<pre class="code ruby"><code class="ruby">VALUE rb_funcall2(VALUE recv, ID mid, int argc, VALUE *argv)
VALUE rb_funcallv(VALUE recv, ID mid, int argc, VALUE *argv)
VALUE rb_apply(VALUE recv, ID mid, VALUE args)</code></pre>

<p>applyには引数としてRubyの配列を与えます．</p>

<h4 id="label-E5-A4-89-E6-95-B0-2F-E5-AE-9A-E6-95-B0-E3-82-92-E5-8F-82-E7-85-A7-2F-E6-9B-B4-E6-96-B0-E3-81-99-E3-82-8B">変数/定数を参照/更新する</h4>

<p>Cから関数を使って参照・更新できるのは，定数，インスタンス変 数です．大域変数は一部のものはCの大域変数としてアクセスでき ます．ローカル変数を参照する方法は公開していません．</p>

<p>オブジェクトのインスタンス変数を参照・更新する関数は以下の通 りです．</p>

<pre class="code ruby"><code class="ruby">VALUE rb_ivar_get(VALUE obj, ID id)
VALUE rb_ivar_set(VALUE obj, ID id, VALUE val)</code></pre>

<p>idはrb_intern()で得られるものを使ってください．</p>

<p>定数を参照するには以下の関数を使ってください．</p>

<pre class="code ruby"><code class="ruby">VALUE rb_const_get(VALUE obj, ID id)</code></pre>

<p>定数を新しく定義するためには『2.1.3 定数定義』で紹介さ れている関数を使ってください．</p>

<h2 id="label-Ruby-E3-81-A8C-E3-81-A8-E3-81-AE-E6-83-85-E5-A0-B1-E5-85-B1-E6-9C-89">RubyとCとの情報共有</h2>

<p>C言語とRubyの間で情報を共有する方法について解説します．</p>

<h3 id="label-C-E3-81-8B-E3-82-89-E5-8F-82-E7-85-A7-E3-81-A7-E3-81-8D-E3-82-8BRuby-E3-81-AE-E5-AE-9A-E6-95-B0">Cから参照できるRubyの定数</h3>

<p>以下のRubyの定数はCのレベルから参照できます．</p>
<dl class="rdoc-list note-list"><dt>Qtrue 
<dt>Qfalse 
<dd>
<p>真偽値．QfalseはC言語でも偽とみなされます(つまり0)．</p>
</dd><dt>Qnil 
<dd>
<p>C言語から見た「nil」．</p>
</dd></dl>

<h3 id="label-C-E3-81-A8Ruby-E3-81-A7-E5-85-B1-E6-9C-89-E3-81-95-E3-82-8C-E3-82-8B-E5-A4-A7-E5-9F-9F-E5-A4-89-E6-95-B0">CとRubyで共有される大域変数</h3>

<p>CとRubyで大域変数を使って情報を共有できます．共有できる大域 変数にはいくつかの種類があります．そのなかでもっとも良く使わ れると思われるのはrb_define_variable()です．</p>

<pre class="code ruby"><code class="ruby">void rb_define_variable(const char *name, VALUE *var)</code></pre>

<p>この関数はRubyとCとで共有する大域変数を定義します．変数名が `$&#39;で始まらない時には自動的に追加されます．この変数の値を変 更すると自動的にRubyの対応する変数の値も変わります．</p>

<p>またRuby側からは更新できない変数もあります．このread onlyの 変数は以下の関数で定義します．</p>

<pre class="code ruby"><code class="ruby">void rb_define_readonly_variable(const char *name, VALUE *var)</code></pre>

<p>これら変数の他にhookをつけた大域変数を定義できます．hook付き の大域変数は以下の関数を用いて定義します．hook付き大域変数の 値の参照や設定はhookで行う必要があります．</p>

<pre class="code ruby"><code class="ruby">void rb_define_hooked_variable(const char *name, VALUE *var,
                               VALUE (*getter)(), void (*setter)())</code></pre>

<p>この関数はCの関数によってhookのつけられた大域変数を定義しま す．変数が参照された時には関数getterが，変数に値がセットされ た時には関数setterが呼ばれる．hookを指定しない場合はgetterや setterに0を指定します． – getterもsetterも0ならばrb_define_variable()と同じになる． ++</p>

<p>getterとsetterの仕様は次の通りです．</p>

<pre class="code ruby"><code class="ruby">VALUE (*getter)(ID id, VALUE *var);
void (*setter)(VALUE val, ID id, VALUE *var);</code></pre>

<p>それから，対応するCの変数を持たないRubyの大域変数を定義する こともできます. その変数の値はフック関数のみによって取得・設定 されます.</p>

<pre class="code ruby"><code class="ruby">void rb_define_virtual_variable(const char *name,
                                VALUE (*getter)(), void (*setter)())</code></pre>

<p>この関数によって定義されたRubyの大域変数が参照された時には getterが，変数に値がセットされた時にはsetterが呼ばれます．</p>

<p>getterとsetterの仕様は以下の通りです．</p>

<pre class="code ruby"><code class="ruby">(*getter)(ID id);
(*setter)(VALUE val, ID id);</code></pre>

<h3 id="label-C-E3-81-AE-E3-83-87-E3-83-BC-E3-82-BF-E3-82-92Ruby-E3-82-AA-E3-83-96-E3-82-B8-E3-82-A7-E3-82-AF-E3-83-88-E3-81-AB-E3-81-99-E3-82-8B">CのデータをRubyオブジェクトにする</h3>

<p>Cの世界で定義されたデータ(構造体)をRubyのオブジェクトとして 取り扱いたい場合がありえます．このような場合はTypedData_XXX マクロ群を用いて構造体へのポインタとRubyのオブジェクトとを互 いに変換できます．</p>

<p>– 古い(非Typedな)Data_XXXマクロ群は非推奨になりました． 将来のバージョンのRubyでは古いマクロは動作しなくなる可能性 があります． ++</p>

<h4 id="label-E6-A7-8B-E9-80-A0-E4-BD-93-E3-81-8B-E3-82-89-E3-82-AA-E3-83-96-E3-82-B8-E3-82-A7-E3-82-AF-E3-83-88-E3-81-B8">構造体からオブジェクトへ</h4>

<p>構造体へのポインタsvalをRubyオブジェクトに変換するには次のマ クロを使います。</p>

<pre class="code ruby"><code class="ruby"><span class='const'>TypedData_Wrap_Struct</span>(<span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='id identifier rubyid_data_type'>data_type</span><span class='comma'>,</span> <span class='id identifier rubyid_sval'>sval</span>)</code></pre>

<p>このマクロの戻り値は生成されたオブジェクトを表すVALUE値です．</p>

<p>klassはこのオブジェクトのクラスです．data_typeはこの構造体を Rubyが管理するための情報を記述したconst rb_data_type_t型への ポインタです．</p>

<p>なお, klassは, Objectや他のクラスではなくData (rb_cData)とい う特別なクラスから派生することが推奨されます． Dataから派生しない場合には, 必ずrb_undef_alloc_func(klass) を呼び出してください．</p>

<p>rb_data_type_tは次のように定義されています．</p>

<pre class="code ruby"><code class="ruby">typedef struct rb_data_type_struct rb_data_type_t;

struct rb_data_type_struct {
        const char *wrap_struct_name;
        struct {
                void (*dmark)(void*);
                void (*dfree)(void*);
                size_t (*dsize)(const void *);
                void *reserved[2];
        } function;
        const rb_data_type_t *parent;
        void *data;
        VALUE flags;
};</code></pre>

<p>wrap_struct_nameはこの構造体を識別する名前です．主に統計情報 の収集と出力に用いられます．プロセス内で一意であれば特にCや Rubyの識別子として有効である必要はありません．</p>

<p>dmarkおよびdfree関数はGC実行中に呼び出されます. なお, GC実行中はRubyオブジェクトのアロケーションは禁止されま す. よって, dmarkおよびdfree関数でRubyオブジェクトのアロケー ションは行わないでください.</p>

<p>dmarkはガーベージコレクタがオブジェクトへの参照をマークする ときに用いる関数です．この構造体がRubyのオブジェクトへの参照 を保持するときには, dmarkではrb_gc_markなどを用いて構造体内 のすべての参照をマークしなければなりません． そのような参照を含まない時には0を指定します．</p>

<p>– そのような参照は勧められません． ++</p>

<p>dfreeはこの構造体がもう不要になった時に呼ばれる関数です．こ の関数がガーベージコレクタから呼ばれます．これが-1の場合は， 単純に構造体が解放されます．</p>

<p>dsizeは構造体が消費しているメモリのバイト数を返す関数です． 引数として構造体へのポインタが渡されます．実装困難であれば0 を渡しても差し支えありませんが, できるだけ指定するようにして ください．</p>

<p>reservedとparentは0で埋めなければなりません．</p>

<p>dataにはユーザー定義の任意の値を指定できます．Rubyはこの値に は関知しないので，好きに使ってください．</p>

<p>flagsには次のフラグのうち当てはまるもののビット和を指定しま す．いずれもRubyのガーベージコレクタについての深い理解を必要 としますので，良くわからない場合には0を指定すると良いでしょ う．</p>
<dl class="rdoc-list note-list"><dt>RUBY_TYPED_FREE_IMMEDIATELY 
<dd>
<p>このフラグを指定すると，ガーベージコレクタはこの構造体が不 要になった場合にはGC中に直ちにdfreeを呼び出します． dfreeがRuby内部のロック(GVL)を解放する可能性がない場合はこ のフラグを指定できます．</p>

<p>指定しない場合はdfree呼び出しは遅延され, ファイナライザと 同じタイミングで実行されます．</p>
</dd><dt>RUBY_TYPED_WB_PROTECTED 
<dd>
<p>オブジェクトの実装がライトバリアをサポートしていることを示 します．このフラグを指定するとRubyはそのオブジェクトに対し てGCをより効率的に実行できます． ただし，指定する場合はユーザーはそのオブジェクトのすべての メソッドの実装に適切にライトバリアを挿入する責任があります． さもなくばRubyは実行時にクラッシュする可能性があります．</p>

<p>ライトバリアについてはdoc/extension.ja.rdocのAppendix D “世代別GC”も参照してください．</p>
</dd></dl>

<p>Cの構造体の割当と対応するオブジェクトの生成を同時に行うマク ロとして以下のものが提供されています．</p>

<pre class="code ruby"><code class="ruby"><span class='const'>TypedData_Make_Struct</span>(<span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='id identifier rubyid_data_type'>data_type</span><span class='comma'>,</span> <span class='id identifier rubyid_sval'>sval</span>)</code></pre>

<p>このマクロの戻り値は生成されたオブジェクトのVALUE値 です．このマクロは以下の式のように働きます:</p>

<pre class="code ruby"><code class="ruby">(<span class='id identifier rubyid_sval'>sval</span> <span class='op'>=</span> <span class='const'>ZALLOC</span>(<span class='id identifier rubyid_type'>type</span>)<span class='comma'>,</span> <span class='const'>TypedData_Wrap_Struct</span>(<span class='id identifier rubyid_klass'>klass</span><span class='comma'>,</span> <span class='id identifier rubyid_data_type'>data_type</span><span class='comma'>,</span> <span class='id identifier rubyid_sval'>sval</span>))</code></pre>

<p>klass, data_typeはData_Wrap_Structと同じ働きをします．type は割り当てるC構造体の型です．割り当てられた構造体は変数sval に代入されます．この変数の型は (type*) である必要があります．</p>

<h4 id="label-E3-82-AA-E3-83-96-E3-82-B8-E3-82-A7-E3-82-AF-E3-83-88-E3-81-8B-E3-82-89-E6-A7-8B-E9-80-A0-E4-BD-93-E3-81-B8">オブジェクトから構造体へ</h4>

<p>TypedData_Wrap_StructやTypedData_Make_Structで生成したオブジェ クトから構造体へのポインタを復元するには以下のマクロを用いま す．</p>

<pre class="code ruby"><code class="ruby">TypedData_Get_Struct(obj, type, &amp;data_type, sval)</code></pre>

<p>Cの構造体へのポインタは変数svalに代入されます．</p>

<p>これらのマクロの使い方はちょっと分かりにくいので，後で説明す る例題を参照してください．</p>

<h2 id="label-E4-BE-8B-3A+dbm-E3-81-AE-E6-8B-A1-E5-BC-B5-E3-83-A9-E3-82-A4-E3-83-96-E3-83-A9-E3-83-AA-E3-81-AE-E4-BD-9C-E6-88-90">例: dbmの拡張ライブラリの作成</h2>

<h3 id="label-E3-83-87-E3-82-A3-E3-83-AC-E3-82-AF-E3-83-88-E3-83-AA-E3-82-92-E4-BD-9C-E3-82-8B">ディレクトリを作る</h3>

<pre class="code ruby"><code class="ruby">% mkdir ext/dbm</code></pre>

<p>Ruby 1.1からは任意のディレクトリでダイナミックライブラリを作 ることができるようになりました．Rubyに静的にリンクする場合に はRubyを展開したディレクトリの下，extディレクトリの中に拡張 ライブラリ用のディレクトリを作る必要があります．名前は適当に 選んで構いません．</p>

<h3 id="label-E8-A8-AD-E8-A8-88-E3-81-99-E3-82-8B">設計する</h3>

<p>まあ，当然なんですけど，どういう機能を実現するかどうかまず設 計する必要があります．どんなクラスをつくるか，そのクラスには どんなメソッドがあるか，クラスが提供する定数などについて設計 します．</p>

<h3 id="label-C-E3-82-B3-E3-83-BC-E3-83-89-E3-82-92-E6-9B-B8-E3-81-8F">Cコードを書く</h3>

<p>拡張ライブラリ本体となるC言語のソースを書きます．C言語のソー スがひとつの時には「ライブラリ名.c」を選ぶと良いでしょう．C 言語のソースが複数の場合には逆に「ライブラリ名.c」というファ イル名は避ける必要があります．オブジェクトファイルとモジュー ル生成時に中間的に生成される「ライブラリ名.o」というファイル とが衝突するからです．また，後述する mkmf ライブラリのいくつ かの関数がコンパイルを要するテストのために「conftest.c」とい うファイル名を使用することに注意してください．ソースファイル 名として「conftest.c」を使用してはなりません．</p>

<p>Rubyは拡張ライブラリをロードする時に「Init_ライブラリ名」と いう関数を自動的に実行します．dbmライブラリの場合「Init_dbm」 です．この関数の中でクラス，モジュール，メソッド，定数などの 定義を行います．dbm.cから一部引用します．</p>

<pre class="code ruby"><code class="ruby">void
Init_dbm(void)
{
    /* DBMクラスを定義する */
    VALUE cDBM = rb_define_class(&quot;DBM&quot;, rb_cObject);
    /* DBMはEnumerableモジュールをインクルードする */
    rb_include_module(cDBM, rb_mEnumerable);

    /* DBMクラスのクラスメソッドopen(): 引数はCの配列で受ける */
    rb_define_singleton_method(cDBM, &quot;open&quot;, fdbm_s_open, -1);

    /* DBMクラスのメソッドclose(): 引数はなし */
    rb_define_method(cDBM, &quot;close&quot;, fdbm_close, 0);
    /* DBMクラスのメソッド[]: 引数は1個 */
    rb_define_method(cDBM, &quot;[]&quot;, fdbm_fetch, 1);

    /* ... */

    /* DBMデータを格納するインスタンス変数名のためのID */
    id_dbm = rb_intern(&quot;dbm&quot;);
}</code></pre>

<p>DBMライブラリはdbmのデータと対応するオブジェクトになるはずで すから，Cの世界のdbmをRubyの世界に取り込む必要があります．</p>

<p>dbm.cではTypedData_Make_Structを以下のように使っています．</p>

<pre class="code ruby"><code class="ruby">struct dbmdata {
    int  di_size;
    DBM *di_dbm;
};

static const rb_data_type_t dbm_type = {
    &quot;dbm&quot;,
    {0, free_dbm, memsize_dbm,},
    0, 0,
    RUBY_TYPED_FREE_IMMEDIATELY,
};

obj = TypedData_Make_Struct(klass, struct dbmdata, &amp;dbm_type, dbmp);</code></pre>

<p>ここではdbmdata構造体へのポインタをDataにカプセル化してい ます．DBM*を直接カプセル化しないのはclose()した時の処理を考 えてのことです．</p>

<p>Dataオブジェクトからdbmstruct構造体のポインタを取り出すため に以下のマクロを使っています．</p>

<pre class="code ruby"><code class="ruby">#define GetDBM(obj, dbmp) do {\
    TypedData_Get_Struct((obj), struct dbmdata, &amp;dbm_type, (dbmp));\
    if ((dbmp) == 0) closed_dbm();\
    if ((dbmp)-&gt;di_dbm == 0) closed_dbm();\
} while (0)</code></pre>

<p>ちょっと複雑なマクロですが，要するにdbmdata構造体のポインタ の取り出しと，closeされているかどうかのチェックをまとめてい るだけです．</p>

<p>DBMクラスにはたくさんメソッドがありますが，分類すると3種類の 引数の受け方があります．ひとつは引数の数が固定のもので，例と してはdeleteメソッドがあります．deleteメソッドを実装している fdbm_delete()はこのようになっています．</p>

<pre class="code ruby"><code class="ruby">static VALUE
fdbm_delete(VALUE obj, VALUE keystr)
{
    /* ... */
}</code></pre>

<p>引数の数が固定のタイプは第1引数がself，第2引数以降がメソッド の引数となります．</p>

<p>引数の数が不定のものはCの配列で受けるものとRubyの配列で受け るものとがあります．dbmライブラリの中で，Cの配列で受けるもの はDBMのクラスメソッドであるopen()です．これを実装している関 数fdbm_s_open()はこうなっています．</p>

<pre class="code ruby"><code class="ruby">static VALUE
fdbm_s_open(int argc, VALUE *argv, VALUE klass)
{
    /* ... */

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;file, &amp;vmode) == 1) {
        mode = 0666;          /* default value */
    }

    /* ... */
}</code></pre>

<p>このタイプの関数は第1引数が与えられた引数の数，第2引数が与え られた引数の入っている配列になります．selfは第3引数として与 えられます．</p>

<p>この配列で与えられた引数を解析するための関数がopen()でも使わ れているrb_scan_args()です．第3引数に指定したフォーマットに従 い，第4引数以降に指定したVALUEへの参照に値を代入してくれま す．</p>

<p>引数の数をチェックするだけならrb_check_arity()が使えます． これは引数をリストとして扱いたいときに便利です．</p>

<p>引数をRubyの配列として受け取るメソッドの例には Thread#initializeがあります．実装はこうです．</p>

<pre class="code ruby"><code class="ruby">static VALUE
thread_initialize(VALUE thread, VALUE args)
{
    /* ... */
}</code></pre>

<p>第1引数はself，第2引数はRubyの配列です．</p>

<p>*注意事項*</p>

<p>Rubyと共有はしないがRubyのオブジェクトを格納する可能性のある Cの大域変数は以下の関数を使ってRubyインタプリタに変数の存在 を教えてあげてください．でないとGCでトラブルを起こします．</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_void'>void</span> <span class='id identifier rubyid_rb_global_variable'>rb_global_variable</span>(<span class='const'>VALUE</span> <span class='op'>*</span><span class='id identifier rubyid_var'>var</span>)</code></pre>

<h3 id="label-extconf.rb-E3-82-92-E7-94-A8-E6-84-8F-E3-81-99-E3-82-8B">extconf.rbを用意する</h3>

<p>Makefileを作る場合の雛型になるextconf.rbというファイルを作り ます．extconf.rbはライブラリのコンパイルに必要な条件のチェッ クなどを行うことが目的です．まず，</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>mkmf</span><span class='tstring_end'>&#39;</span></span></code></pre>

<p>をextconf.rbの先頭に置きます．extconf.rbの中では以下のRuby関 数を使うことが出来ます．</p>

<pre class="code ruby"><code class="ruby">have_library(lib, func): ライブラリの存在チェック
have_func(func, header): 関数の存在チェック
have_header(header): ヘッダファイルの存在チェック
create_makefile(target[, target_prefix]): Makefileの生成</code></pre>

<p>以下の変数を使うことができます．</p>

<pre class="code ruby"><code class="ruby">$CFLAGS: コンパイル時に追加的に指定するフラグ(-Oなど)
$CPPFLAGS: プリプロセッサに追加的に指定するフラグ(-Iや-Dなど)
$LDFLAGS: リンク時に追加的に指定するフラグ(-Lなど)
$objs: リンクされるオブジェクトファイル名のリスト</code></pre>

<p>オブジェクトファイルのリストは，通常はソースファイルを検索し て自動的に生成されますが，makeの途中でソースを生成するような 場合は明示的に指定する必要があります．</p>

<p>ライブラリをコンパイルする条件が揃わず，そのライブラリをコン パイルしない時にはcreate_makefileを呼ばなければMakefileは生 成されず，コンパイルも行われません．</p>

<h3 id="label-depend-E3-82-92-E7-94-A8-E6-84-8F-E3-81-99-E3-82-8B">dependを用意する</h3>

<p>もし，ディレクトリにdependというファイルが存在すれば， Makefileが依存関係をチェックしてくれます．</p>

<pre class="code ruby"><code class="ruby">% gcc -MM *.c &gt; depend</code></pre>

<p>などで作ることが出来ます．あって損は無いでしょう．</p>

<h3 id="label-Makefile-E3-82-92-E7-94-9F-E6-88-90-E3-81-99-E3-82-8B">Makefileを生成する</h3>

<p>Makefileを実際に生成するためには</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ruby'>ruby</span> <span class='id identifier rubyid_extconf'>extconf</span>.<span class='id identifier rubyid_rb'>rb</span></code></pre>

<p>とします．extconf.rbに require &#39;mkmf&#39; の行がない場合にはエラー になりますので，引数を追加して</p>

<pre class="code ruby"><code class="ruby">ruby -r mkmf extconf.rb</code></pre>

<p>としてください．</p>

<p>site_ruby ディレクトリでなく， vendor_ruby ディレクトリにインストールする場合には 以下のように –vendor オプションを加えてください．</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ruby'>ruby</span> <span class='id identifier rubyid_extconf'>extconf</span>.<span class='id identifier rubyid_rb'>rb</span> <span class='op'>-</span><span class='op'>-</span><span class='id identifier rubyid_vendor'>vendor</span></code></pre>

<p>ディレクトリをext以下に用意した場合にはRuby全体のmakeの時に 自動的にMakefileが生成されますので，このステップは不要です．</p>

<h3 id="label-make-E3-81-99-E3-82-8B">makeする</h3>

<p>動的リンクライブラリを生成する場合にはその場でmakeしてくださ い．必要であれば make install でインストールされます．</p>

<p>ext以下にディレクトリを用意した場合は，Rubyのディレクトリで makeを実行するとMakefileを生成からmake，必要によってはそのモ ジュールのRubyへのリンクまで自動的に実行してくれます． extconf.rbを書き換えるなどしてMakefileの再生成が必要な時はま たRubyディレクトリでmakeしてください．</p>

<p>拡張ライブラリはmake installでRubyライブラリのディレクトリの 下にコピーされます．もし拡張ライブラリと協調して使うRubyで記 述されたプログラムがあり，Rubyライブラリに置きたい場合には， 拡張ライブラリ用のディレクトリの下に lib というディレクトリ を作り，そこに 拡張子 .rb のファイルを置いておけば同時にイン ストールされます．</p>

<h3 id="label-E3-83-87-E3-83-90-E3-83-83-E3-82-B0">デバッグ</h3>

<p>まあ，デバッグしないと動かないでしょうね．ext/Setupにディレ クトリ名を書くと静的にリンクするのでデバッガが使えるようにな ります．その分コンパイルが遅くなりますけど．</p>

<h3 id="label-E3-81-A7-E3-81-8D-E3-81-82-E3-81-8C-E3-82-8A">できあがり</h3>

<p>後はこっそり使うなり，広く公開するなり，売るなり，ご自由にお 使いください．Rubyの作者は拡張ライブラリに関して一切の権利を 主張しません．</p>

<h2 id="label-Appendix+A.+Ruby-E3-81-AE-E3-82-BD-E3-83-BC-E3-82-B9-E3-82-B3-E3-83-BC-E3-83-89-E3-81-AE-E5-88-86-E9-A1-9E">Appendix A. Rubyのソースコードの分類</h2>

<p>Rubyのソースはいくつかに分類することが出来ます．このうちクラ スライブラリの部分は基本的に拡張ライブラリと同じ作り方になっ ています．これらのソースは今までの説明でほとんど理解できると 思います．</p>

<h3 id="label-Ruby-E8-A8-80-E8-AA-9E-E3-81-AE-E3-82-B3-E3-82-A2">Ruby言語のコア</h3>
<dl class="rdoc-list note-list"><dt>class.c    
<dd>
<p>クラスとモジュール</p>
</dd><dt>error.c    
<dd>
<p>例外クラスと例外機構</p>
</dd><dt>gc.c       
<dd>
<p>記憶領域管理</p>
</dd><dt>load.c     
<dd>
<p>ライブラリのロード</p>
</dd><dt>object.c   
<dd>
<p>オブジェクト</p>
</dd><dt>variable.c 
<dd>
<p>変数と定数</p>
</dd></dl>

<h3 id="label-Ruby-E3-81-AE-E6-A7-8B-E6-96-87-E8-A7-A3-E6-9E-90-E5-99-A8">Rubyの構文解析器</h3>
<dl class="rdoc-list note-list"><dt>parse.y       
<dd>
<p>字句解析器と構文定義</p>
</dd><dt>parse.c       
<dd>
<p>自動生成</p>
</dd><dt>defs/keywords 
<dd>
<p>予約語</p>
</dd><dt>lex.c         
<dd>
<p>自動生成</p>
</dd></dl>

<h3 id="label-Ruby-E3-81-AE-E8-A9-95-E4-BE-A1-E5-99-A8+-28-E9-80-9A-E7-A7-B0YARV-29">Rubyの評価器 (通称YARV)</h3>

<pre class="code ruby"><code class="ruby">compile.c
eval.c
eval_error.c
eval_jump.c
eval_safe.c
insns.def           : 仮想機械語の定義
iseq.c              : VM::ISeqの実装
thread.c            : スレッド管理とコンテキスト切り替え
thread_win32.c      : スレッド実装
thread_pthread.c    : 同上
vm.c
vm_dump.c
vm_eval.c
vm_exec.c
vm_insnhelper.c
vm_method.c

defs/opt_insns_unif.def  : 命令融合
defs/opt_operand.def     : 最適化のための定義

  #=&gt; insn*.inc           : 自動生成
  #=&gt; opt*.inc            : 自動生成
  #=&gt; vm.inc              : 自動生成</code></pre>

<h3 id="label-E6-AD-A3-E8-A6-8F-E8-A1-A8-E7-8F-BE-E3-82-A8-E3-83-B3-E3-82-B8-E3-83-B3+-28-E9-AC-BC-E8-BB-8A-29">正規表現エンジン (鬼車)</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_regex'>regex</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_regcomp'>regcomp</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_regenc'>regenc</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_regerror'>regerror</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_regexec'>regexec</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_regparse'>regparse</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_regsyntax'>regsyntax</span>.<span class='id identifier rubyid_c'>c</span></code></pre>

<h3 id="label-E3-83-A6-E3-83-BC-E3-83-86-E3-82-A3-E3-83-AA-E3-83-86-E3-82-A3-E9-96-A2-E6-95-B0">ユーティリティ関数</h3>
<dl class="rdoc-list note-list"><dt>debug.c    
<dd>
<p>Cデバッガ用のデバッグシンボル</p>
</dd><dt>dln.c      
<dd>
<p>動的ローディング</p>
</dd><dt>st.c       
<dd>
<p>汎用ハッシュ表</p>
</dd><dt>strftime.c 
<dd>
<p>時刻整形</p>
</dd><dt>util.c     
<dd>
<p>その他のユーティリティ</p>
</dd></dl>

<h3 id="label-Ruby-E3-82-B3-E3-83-9E-E3-83-B3-E3-83-89-E3-81-AE-E5-AE-9F-E8-A3-85">Rubyコマンドの実装</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_dmyext'>dmyext</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_dmydln'>dmydln</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_dmyencoding'>dmyencoding</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_id'>id</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_inits'>inits</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_main'>main</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_ruby'>ruby</span>.<span class='id identifier rubyid_c'>c</span>
<span class='id identifier rubyid_version'>version</span>.<span class='id identifier rubyid_c'>c</span>

<span class='id identifier rubyid_gem_prelude'>gem_prelude</span>.<span class='id identifier rubyid_rb'>rb</span>
<span class='id identifier rubyid_prelude'>prelude</span>.<span class='id identifier rubyid_rb'>rb</span></code></pre>

<h3 id="label-E3-82-AF-E3-83-A9-E3-82-B9-E3-83-A9-E3-82-A4-E3-83-96-E3-83-A9-E3-83-AA">クラスライブラリ</h3>
<dl class="rdoc-list note-list"><dt>array.c      
<dd>
<p>Array</p>
</dd><dt>bignum.c     
<dd>
<p>Bignum</p>
</dd><dt>compar.c     
<dd>
<p>Comparable</p>
</dd><dt>complex.c    
<dd>
<p>Complex</p>
</dd><dt>cont.c       
<dd>
<p>Fiber, Continuation</p>
</dd><dt>dir.c        
<dd>
<p>Dir</p>
</dd><dt>enum.c       
<dd>
<p>Enumerable</p>
</dd><dt>enumerator.c 
<dd>
<p>Enumerator</p>
</dd><dt>file.c       
<dd>
<p>File</p>
</dd><dt>hash.c       
<dd>
<p>Hash</p>
</dd><dt>io.c         
<dd>
<p>IO</p>
</dd><dt>marshal.c    
<dd>
<p>Marshal</p>
</dd><dt>math.c       
<dd>
<p>Math</p>
</dd><dt>numeric.c    
<dd>
<p>Numeric, Integer, Fixnum, Float</p>
</dd><dt>pack.c       
<dd>
<p>Array#pack, String#unpack</p>
</dd><dt>proc.c       
<dd>
<p>Binding, Proc</p>
</dd><dt>process.c    
<dd>
<p>Process</p>
</dd><dt>random.c     
<dd>
<p>乱数</p>
</dd><dt>range.c      
<dd>
<p>Range</p>
</dd><dt>rational.c   
<dd>
<p>Rational</p>
</dd><dt>re.c         
<dd>
<p>Regexp, MatchData</p>
</dd><dt>signal.c     
<dd>
<p>Signal</p>
</dd><dt>sprintf.c    
<dd>
<p>String#sprintf</p>
</dd><dt>string.c     
<dd>
<p>String</p>
</dd><dt>struct.c     
<dd>
<p>Struct</p>
</dd><dt>time.c       
<dd>
<p>Time</p>
</dd><dt>defs/known_errors.def 
<dd>
<p>例外クラス Errno::*</p>
</dd><dt>-&gt; known_errors.inc   
<dd>
<p>自動生成</p>
</dd></dl>

<h3 id="label-E5-A4-9A-E8-A8-80-E8-AA-9E-E5-8C-96">多言語化</h3>
<dl class="rdoc-list note-list"><dt>encoding.c  
<dd>
<p>Encoding</p>
</dd><dt>transcode.c 
<dd>
<p>Encoding::Converter</p>
</dd><dt>enc/*.c     
<dd>
<p>エンコーディングクラス群</p>
</dd><dt>enc/trans/* 
<dd>
<p>コードポイント対応表</p>
</dd></dl>

<h3 id="label-goruby-E3-82-B3-E3-83-9E-E3-83-B3-E3-83-89-E3-81-AE-E5-AE-9F-E8-A3-85">gorubyコマンドの実装</h3>

<pre class="code ruby"><code class="ruby">goruby.c
golf_prelude.rb      : goruby固有のライブラリ
  #=&gt; golf_prelude.c  : 自動生成</code></pre>

<h2 id="label-Appendix+B.+-E6-8B-A1-E5-BC-B5-E7-94-A8-E9-96-A2-E6-95-B0-E3-83-AA-E3-83-95-E3-82-A1-E3-83-AC-E3-83-B3-E3-82-B9">Appendix B. 拡張用関数リファレンス</h2>

<p>C言語からRubyの機能を利用するAPIは以下の通りである．</p>

<h3 id="label-E5-9E-8B">型</h3>
<dl class="rdoc-list note-list"><dt>VALUE 
<dd>
<p>Rubyオブジェクトを表現する型．必要に応じてキャストして用いる． 組み込み型を表現するCの型はruby.hに記述してあるRで始まる構造 体である．VALUE型をこれらにキャストするためにRで始まる構造体 名を全て大文字にした名前のマクロが用意されている．</p>
</dd></dl>

<h3 id="label-E5-A4-89-E6-95-B0-E3-83-BB-E5-AE-9A-E6-95-B0">変数・定数</h3>
<dl class="rdoc-list note-list"><dt>Qnil 
<dd>
<p>定数: nilオブジェクト</p>
</dd><dt>Qtrue 
<dd>
<p>定数: trueオブジェクト(真のデフォルト値)</p>
</dd><dt>Qfalse 
<dd>
<p>定数: falseオブジェクト</p>
</dd></dl>

<h3 id="label-C-E3-83-87-E3-83-BC-E3-82-BF-E3-81-AE-E3-82-AB-E3-83-97-E3-82-BB-E3-83-AB-E5-8C-96">Cデータのカプセル化</h3>
<dl class="rdoc-list note-list"><dt>Data_Wrap_Struct(VALUE klass, void (*mark)(), void (*free)(), void *sval) 
<dd>
<p>Cの任意のポインタをカプセル化したRubyオブジェクトを返す．こ のポインタがRubyからアクセスされなくなった時，freeで指定した 関数が呼ばれる．また，このポインタの指すデータが他のRubyオブ ジェクトを指している場合，markに指定する関数でマークする必要 がある．</p>
</dd><dt>Data_Make_Struct(klass, type, mark, free, sval) 
<dd>
<p>type型のメモリをmallocし，変数svalに代入した後，それをカプセ ル化したデータを返すマクロ．</p>
</dd><dt>Data_Get_Struct(data, type, sval) 
<dd>
<p>dataからtype型のポインタを取り出し変数svalに代入するマクロ．</p>
</dd></dl>

<h3 id="label-E5-9E-8B-E3-83-81-E3-82-A7-E3-83-83-E3-82-AF">型チェック</h3>

<pre class="code ruby"><code class="ruby">RB_TYPE_P(value, type)
TYPE(value)
FIXNUM_P(value)
NIL_P(value)
RB_INTEGER_TYPE_P(value)
RB_FLOAT_TYPE_P(value)
void Check_Type(VALUE value, int type)
SafeStringValue(value)</code></pre>

<h3 id="label-E5-9E-8B-E5-A4-89-E6-8F-9B">型変換</h3>

<pre class="code ruby"><code class="ruby">FIX2INT(value), INT2FIX(i)
FIX2LONG(value), LONG2FIX(l)
NUM2INT(value), INT2NUM(i)
NUM2UINT(value), UINT2NUM(ui)
NUM2LONG(value), LONG2NUM(l)
NUM2ULONG(value), ULONG2NUM(ul)
NUM2LL(value), LL2NUM(ll)
NUM2ULL(value), ULL2NUM(ull)
NUM2OFFT(value), OFFT2NUM(off)
NUM2SIZET(value), SIZET2NUM(size)
NUM2SSIZET(value), SSIZET2NUM(ssize)
rb_integer_pack(value, words, numwords, wordsize, nails, flags), rb_integer_unpack(words, numwords, wordsize, nails, flags)
NUM2DBL(value)
rb_float_new(f)
RSTRING_LEN(str)
RSTRING_PTR(str)
StringValue(value)
StringValuePtr(value)
StringValueCStr(value)
rb_str_new2(s)</code></pre>

<h3 id="label-E3-82-AF-E3-83-A9-E3-82-B9-2F-E3-83-A2-E3-82-B8-E3-83-A5-E3-83-BC-E3-83-AB-E5-AE-9A-E7-BE-A9">クラス/モジュール定義</h3>
<dl class="rdoc-list note-list"><dt>VALUE rb_define_class(const char *name, VALUE super) 
<dd>
<p>superのサブクラスとして新しいRubyクラスを定義する．</p>
</dd><dt>VALUE rb_define_class_under(VALUE module, const char *name, VALUE super) 
<dd>
<p>superのサブクラスとして新しいRubyクラスを定義し，moduleの 定数として定義する．</p>
</dd><dt>VALUE rb_define_module(const char *name) 
<dd>
<p>新しいRubyモジュールを定義する．</p>
</dd><dt>VALUE rb_define_module_under(VALUE module, const char *name) 
<dd>
<p>新しいRubyモジュールを定義し，moduleの定数として定義する．</p>
</dd><dt>void rb_include_module(VALUE klass, VALUE module) 
<dd>
<p>モジュールをインクルードする．classがすでにmoduleをインク ルードしている時には何もしない(多重インクルードの禁止)．</p>
</dd><dt>void rb_extend_object(VALUE object, VALUE module) 
<dd>
<p>オブジェクトをモジュール(で定義されているメソッド)で拡張する．</p>
</dd></dl>

<h3 id="label-E5-A4-A7-E5-9F-9F-E5-A4-89-E6-95-B0-E5-AE-9A-E7-BE-A9">大域変数定義</h3>
<dl class="rdoc-list note-list"><dt>void rb_define_variable(const char *name, VALUE *var) 
<dd>
<p>RubyとCとで共有するグローバル変数を定義する．変数名が`$&#39;で 始まらない時には自動的に追加される．nameとしてRubyの識別子 として許されない文字(例えば` &#39;)を含む場合にはRubyプログラ ムからは見えなくなる．</p>
</dd><dt>void rb_define_readonly_variable(const char *name, VALUE *var) 
<dd>
<p>RubyとCとで共有するread onlyのグローバル変数を定義する． read onlyであること以外はrb_define_variable()と同じ．</p>
</dd><dt>void rb_define_virtual_variable(const char *name, VALUE (*getter)(), void (*setter)()) 
<dd>
<p>関数によって実現されるRuby変数を定義する．変数が参照された 時にはgetterが，変数に値がセットされた時にはsetterが呼ばれ る．</p>
</dd><dt>void rb_define_hooked_variable(const char *name, VALUE *var, VALUE (*getter)(), void (*setter)()) 
<dd>
<p>関数によってhookのつけられたグローバル変数を定義する．変数 が参照された時にはgetterが，関数に値がセットされた時には setterが呼ばれる．getterやsetterに0を指定した時にはhookを 指定しないのと同じ事になる．</p>
</dd><dt>void rb_global_variable(VALUE *var) 
<dd>
<p>GCのため，Rubyプログラムからはアクセスされないが, Rubyオブ ジェクトを含む大域変数をマークする．</p>
</dd></dl>

<h3 id="label-E5-AE-9A-E6-95-B0">定数</h3>
<dl class="rdoc-list note-list"><dt>void rb_define_const(VALUE klass, const char *name, VALUE val) 
<dd>
<p>定数を定義する．</p>
</dd><dt>void rb_define_global_const(const char *name, VALUE val) 
<dd>
<p>大域定数を定義する．</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_rb_define_const'>rb_define_const</span>(<span class='id identifier rubyid_rb_cObject'>rb_cObject</span><span class='comma'>,</span> <span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_val'>val</span>)</code></pre>

<p>と同じ意味．</p>
</dd></dl>

<h3 id="label-E3-83-A1-E3-82-BD-E3-83-83-E3-83-89-E5-AE-9A-E7-BE-A9">メソッド定義</h3>
<dl class="rdoc-list note-list"><dt>rb_define_method(VALUE klass, const char *name, VALUE (*func)(ANYARGS), int argc) 
<dd>
<p>メソッドを定義する．argcはselfを除く引数の数．argcが-1の時, 関数には引数の数(selfを含まない)を第1引数, 引数の配列を第2 引数とする形式で与えられる(第3引数はself)．argcが-2の時, 第1引数がself, 第2引数がargs(argsは引数を含むRubyの配列)と いう形式で与えられる．</p>
</dd><dt>rb_define_private_method(VALUE klass, const char *name, VALUE (*func)(ANYARGS), int argc) 
<dd>
<p>privateメソッドを定義する．引数はrb_define_method()と同じ．</p>
</dd><dt>rb_define_singleton_method(VALUE klass, const char *name, VALUE (*func)(ANYARGS), int argc) 
<dd>
<p>特異メソッドを定義する．引数はrb_define_method()と同じ．</p>
</dd><dt>rb_check_arity(int argc, int min, int max) 
<dd>
<p>引数の数であるargcがmin..maxの範囲に入っているかをチェックします． もしmaxがUNLIMITED_ARGUMENTSなら，上限はチェックしません． もしargcが範囲外ならArgumentErrorが発生します．</p>
</dd><dt>rb_scan_args(int argc, VALUE *argv, const char *fmt, …) 
<dd>
<p>argc, argv形式で与えられた指定されたフォーマットに従って引 数を分解し，続くVALUEへの参照にセットします．このフォーマッ トは，ABNFで記述すると以下の通りです．</p>

<pre class="code ruby"><code class="ruby">scan-arg-spec  := param-arg-spec [option-hash-arg-spec] [block-arg-spec]

param-arg-spec := pre-arg-spec [post-arg-spec] / post-arg-spec /
                  pre-opt-post-arg-spec
pre-arg-spec   := num-of-leading-mandatory-args [num-of-optional-args]
post-arg-spec  := sym-for-variable-length-args
                  [num-of-trailing-mandatory-args]
pre-opt-post-arg-spec := num-of-leading-mandatory-args num-of-optional-args
                         num-of-trailing-mandatory-args
option-hash-arg-spec := sym-for-option-hash-arg
block-arg-spec := sym-for-block-arg

num-of-leading-mandatory-args  := DIGIT ; 先頭に置かれる省略不能な引数の数
num-of-optional-args           := DIGIT ; 続いて置かれる省略可能な引数の数
sym-for-variable-length-args   := &quot;*&quot;   ; 続いて置かれる可変長引数を
                                        ; Rubyの配列で取得するための指定
num-of-trailing-mandatory-args := DIGIT ; 終端に置かれる省略不能な引数の数
sym-for-option-hash-arg        := &quot;:&quot;   ; オプションハッシュを取得する
                                        ; ための指定; 省略不能な引数の
                                        ; 数よりも多くの引数が指定され，
                                        ; 最後の引数がハッシュ（または
                                        ; #to_hashで変換可能）の場合に
                                        ; 取得される．最後の引数がnilの
                                        ; 場合，可変長引数指定がなく，
                                        ; 省略不能引数の数よりも多くの
                                        ; 引数が指定された場合に取得される
sym-for-block-arg              := &quot;&amp;&quot;   ; イテレータブロックを取得するための
                                        ; 指定</code></pre>

<p>フォーマットが“12”の場合，引数は最低1つで，3つ(1+2)まで許さ れるという意味になります．従って，フォーマット文字列に続い て3つのVALUEへの参照を置く必要があります．それらには取得した 変数がセットされます．変数への参照の代わりにNULLを指定する こともでき，その場合は取得した引数の値は捨てられます．なお， 省略可能引数が省略された時の変数の値はnil(C言語のレベルでは Qnil)になります．</p>

<p>返り値は与えられた引数の数です．オプションハッシュおよびイ テレータブロックは数えません．</p>
</dd><dt>int rb_get_kwargs(VALUE keyword_hash, const ID *table, int required, int optional, VALUE *values) 
<dd>
<p>キーワードで指定された値をtableにしたがって取り出します． tableの最初のrequired個のIDは必須キーワードを表し，続く optional (optionalが負の場合は-optional-1) 個のIDは省略可能 キーワードです．必須キーワードがkeyword_hash中にない場合， “missing keyword”ArgumentErrorが発生します．省略可能キーワー ドがない場合は，values中の対応する要素にはQundefがセットされ ます．keyword_hashに使用されない要素がある場合は，optionalが 負なら無視されますが，そうでなければ“unknown keyword” ArgumentErrorが発生します．</p>
</dd><dt>VALUE rb_extract_keywords(VALUE *original_hash) 
<dd>
<p>original_hashで参照されるHashオブジェクトから，Symbolである キーとその値を新しいHashに取り出します．original_hashの指す 先には，元のHashがSymbol以外のキーを含んでいた場合はそれらが コピーされた別の新しいHash，そうでなければ0が保存されます．</p>
</dd></dl>

<h3 id="label-Ruby-E3-83-A1-E3-82-BD-E3-83-83-E3-83-89-E5-91-BC-E3-81-B3-E5-87-BA-E3-81-97">Rubyメソッド呼び出し</h3>
<dl class="rdoc-list note-list"><dt>VALUE rb_funcall(VALUE recv, ID mid, int narg, …) 
<dd>
<p>メソッド呼び出し．文字列からmidを得るためにはrb_intern()を 使う． private/protectedなメソッドでも呼び出せる．</p>
</dd><dt>VALUE rb_funcall2(VALUE recv, ID mid, int argc, VALUE *argv) 
<dt>VALUE rb_funcallv(VALUE recv, ID mid, int argc, VALUE *argv) 
<dd>
<p>メソッド呼び出し．引数をargc, argv形式で渡す． private/protectedなメソッドでも呼び出せる．</p>
</dd><dt>VALUE rb_funcallv_public(VALUE recv, ID mid, int argc, VALUE *argv) 
<dd>
<p>メソッド呼び出し． publicなメソッドしか呼べない．</p>
</dd><dt>VALUE rb_eval_string(const char *str) 
<dd>
<p>文字列をRubyスクリプトとしてコンパイル・実行する．</p>
</dd><dt>ID rb_intern(const char *name) 
<dd>
<p>文字列に対応するIDを返す．</p>
</dd><dt>char *rb_id2name(ID id) 
<dd>
<p>IDに対応する文字列を返す(デバッグ用)．</p>
</dd><dt>char *rb_class2name(VALUE klass) 
<dd>
<p>クラスの名前を返す(デバッグ用)．クラスが名前を持たない時に は, 祖先を遡って名前を持つクラスの名前を返す．</p>
</dd><dt>int rb_respond_to(VALUE obj, ID id) 
<dd>
<p>objがidで示されるメソッドを持つかどうかを返す．</p>
</dd></dl>

<h3 id="label-E3-82-A4-E3-83-B3-E3-82-B9-E3-82-BF-E3-83-B3-E3-82-B9-E5-A4-89-E6-95-B0">インスタンス変数</h3>
<dl class="rdoc-list note-list"><dt>VALUE rb_iv_get(VALUE obj, const char *name) 
<dd>
<p>objのインスタンス変数の値を得る．`@&#39;で始まらないインスタン ス変数は Rubyプログラムからアクセスできない「隠れた」イン スタンス変数になる．定数は大文字の名前を持つクラス(または モジュール)のインスタンス変数として実装されている．</p>
</dd><dt>VALUE rb_iv_set(VALUE obj, const char *name, VALUE val) 
<dd>
<p>objのインスタンス変数をvalにセットする．</p>
</dd></dl>

<h3 id="label-E5-88-B6-E5-BE-A1-E6-A7-8B-E9-80-A0">制御構造</h3>
<dl class="rdoc-list note-list"><dt>VALUE rb_block_call(VALUE obj, ID mid, int argc, VALUE * argv, VALUE (*func) (ANYARGS), VALUE data2) 
<dd>
<p>funcをブロックとして設定し，objをレシーバ，argcとargvを引数 としてmidメソッドを呼び出す．funcは第一引数にyieldされた値， 第二引数にdata2を受け取る．複数の値がyieldされた場合(Cでは rb_yield_values()とrb_yield_values2(), rb_yield_splat())， data2はArrayとしてパックされている．第三, 第四引数のargcと argvによってyieldされた値を取り出すことができる．</p>
</dd><dt>[OBSOLETE] VALUE rb_iterate(VALUE (*func1)(), VALUE arg1, VALUE (*func2)(), VALUE arg2) 
<dd>
<p>func2をブロックとして設定し, func1をイテレータとして呼ぶ． func1には arg1が引数として渡され, func2には第1引数にイテレー タから与えられた値, 第2引数にarg2が渡される．</p>

<p>1.9でrb_iterateを使う場合は, func1の中でRubyレベルのメソッド を呼び出さなければならない. 1.9でobsoleteとなった. 代わりにrb_block_callが用意された.</p>
</dd><dt>VALUE rb_yield(VALUE val) 
<dd>
<p>valを値としてイテレータブロックを呼び出す．</p>
</dd><dt>VALUE rb_rescue(VALUE (*func1)(ANYARGS), VALUE arg1, VALUE (*func2)(ANYARGS), VALUE arg2) 
<dd>
<p>関数func1をarg1を引数に呼び出す．func1の実行中に例外が発生 した時には func2をarg2を第一引数, 発生した例外オブジェクト を第二引数として呼ぶ．戻り値は例外が発生しなかった時はfunc1 の戻り値, 例外が発生した時にはfunc2の戻り値である．</p>
</dd><dt>VALUE rb_ensure(VALUE (*func1)(ANYARGS), VALUE arg1, VALUE (*func2)(ANYARGS), VALUE arg2) 
<dd>
<p>関数func1をarg1を引数として実行し, 実行終了後(たとえ例外が 発生しても) func2をarg2を引数として実行する．戻り値はfunc1 の戻り値である(例外が発生した時は戻らない)．</p>
</dd><dt>VALUE rb_protect(VALUE (*func) (VALUE), VALUE arg, int *state) 
<dd>
<p>関数funcをargを引数として実行し, 例外が発生しなければその戻 り値を返す．例外が発生した場合は, *stateに非0をセットして Qnilを返す． rb_jump_tag()を呼ばずに捕捉した例外を無視する場合には， rb_set_errinfo(Qnil)でエラー情報をクリアしなければならない．</p>
</dd><dt>void rb_jump_tag(int state) 
<dd>
<p>rb_protect()やrb_eval_string_protect()で捕捉された例外を再 送する．stateはそれらの関数から返された値でなければならない． この関数は直接の呼び出し元に戻らない．</p>
</dd><dt>void rb_iter_break() 
<dd>
<p>現在の最も内側のブロックを終了する．この関数は直接の呼び出 し元に戻らない．</p>
</dd><dt>void rb_iter_break_value(VALUE value) 
<dd>
<p>現在の最も内側のブロックをvalueで終了する．ブロックは引数で 与えられたvalueを返す．この関数は直接の呼び出し元に戻らない．</p>
</dd></dl>

<h3 id="label-E4-BE-8B-E5-A4-96-E3-83-BB-E3-82-A8-E3-83-A9-E3-83-BC">例外・エラー</h3>
<dl class="rdoc-list note-list"><dt>void rb_warning(const char *fmt, …) 
<dd>
<p>rb_verbose時に標準エラー出力に警告情報を表示する．引数は printf()と同じ．</p>
</dd><dt>void rb_raise(rb_eRuntimeError, const char *fmt, …) 
<dd>
<p>RuntimeError例外を発生させる．引数はprintf()と同じ．</p>
</dd><dt>void rb_raise(VALUE exception, const char *fmt, …) 
<dd>
<p>exceptionで指定した例外を発生させる．fmt以下の引数は printf()と同じ．</p>
</dd><dt>void rb_fatal(const char *fmt, …) 
<dd>
<p>致命的例外を発生させる．通常の例外処理は行なわれず, インター プリタが終了する(ただしensureで指定されたコードは終了前に 実行される)．</p>
</dd><dt>void rb_bug(const char *fmt, …) 
<dd>
<p>インタープリタなどプログラムのバグでしか発生するはずのない 状況の時呼ぶ．インタープリタはコアダンプし直ちに終了する． 例外処理は一切行なわれない．</p>
</dd></dl>

<p>注意: “%”PRIsVALUEがObject#to_s(&#39;+&#39;フラグが指定されていると きはObject#inspect)を使ったVALUEの出力に利用できる．これは “%i”と衝突するため，整数には“%d”を使用すること．</p>

<h3 id="label-Ruby-E3-81-AE-E5-88-9D-E6-9C-9F-E5-8C-96-E3-83-BB-E5-AE-9F-E8-A1-8C">Rubyの初期化・実行</h3>

<p>Rubyをアプリケーションに埋め込む場合には以下のインタフェース を使う．通常の拡張ライブラリには必要ない．</p>
<dl class="rdoc-list note-list"><dt>void ruby_init() 
<dd>
<p>Rubyインタプリタの初期化を行なう．</p>
</dd><dt>void *ruby_options(int argc, char **argv) 
<dd>
<p>Rubyインタプリタのコマンドライン引数の処理を行ない， Rubyのソースコードをコンパイルする． コンパイルされたソースへのポインタ，もしくは特殊値を返す.</p>
</dd><dt>int ruby_run_node(void *n) 
<dd>
<p>コンパイルされたコードを実行する． 実行に成功した場合はEXIT_SUCCESSを，エラーが起こったときはそれ以外を返す．</p>
</dd><dt>void ruby_script(char *name) 
<dd>
<p>Rubyのスクリプト名($0)を設定する．</p>
</dd></dl>

<h3 id="label-E3-82-A4-E3-83-B3-E3-82-BF-E3-83-97-E3-83-AA-E3-82-BF-E3-81-AE-E3-82-A4-E3-83-99-E3-83-B3-E3-83-88-E3-81-AE-E3-83-95-E3-83-83-E3-82-AF">インタプリタのイベントのフック</h3>
<dl class="rdoc-list note-list"><dt>void rb_add_event_hook(rb_event_hook_func_t func, rb_event_flag_t events, VALUE data) 
<dd>
<p>指定されたインタプリタのイベントに対するフック関数を追加します． eventsは以下の値のorでなければなりません:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>RUBY_EVENT_LINE</span>
<span class='const'>RUBY_EVENT_CLASS</span>
<span class='const'>RUBY_EVENT_END</span>
<span class='const'>RUBY_EVENT_CALL</span>
<span class='const'>RUBY_EVENT_RETURN</span>
<span class='const'>RUBY_EVENT_C_CALL</span>
<span class='const'>RUBY_EVENT_C_RETURN</span>
<span class='const'>RUBY_EVENT_RAISE</span>
<span class='const'>RUBY_EVENT_ALL</span></code></pre>

<p>rb_event_hook_func_tの定義は以下の通りです:</p>

<pre class="code ruby"><code class="ruby">typedef void (*rb_event_hook_func_t)(rb_event_t event, VALUE data,
                                     VALUE self, ID id, VALUE klass)</code></pre>

<p>rb_add_event_hook() の第3引数 data は，フック関数の第2引数と して渡されます．これは1.8では現在のNODEへのポインタでした．以 下の RB_EVENT_HOOKS_HAVE_CALLBACK_DATA も参照してください．</p>
</dd><dt>int rb_remove_event_hook(rb_event_hook_func_t func) 
<dd>
<p>指定されたフック関数を削除します．</p>
</dd></dl>

<h3 id="label-E3-83-A1-E3-83-A2-E3-83-AA-E4-BD-BF-E7-94-A8-E9-87-8F">メモリ使用量</h3>
<dl class="rdoc-list note-list"><dt>void rb_gc_adjust_memory_usage(ssize_t diff) 
<dd>
<p>登録された外部のメモリ使用量を調整します．この関数で外部のライブラリが どのくらいメモリを使っているのかをGCに伝えることができます．正のdiffで この関数を呼び出すとメモリ使用量の増加を意味します．新しいメモリブロッ クが確保されたり，ブロックがより大きなサイズで再割り当てされたりした場 合などです．負のdiffでこの関数を呼び出すとメモリ使用量の減少を意味しま す．メモリブロックが解放されたり，メモリブロックがより小さいサイズで再 確保されたりした場合などです．この関数はGCを引き起こすかもしれません．</p>
</dd></dl>

<h3 id="label-E4-BA-92-E6-8F-9B-E6-80-A7-E3-81-AE-E3-81-9F-E3-82-81-E3-81-AE-E3-83-9E-E3-82-AF-E3-83-AD">互換性のためのマクロ</h3>

<p>APIの互換性をチェックするために以下のマクロがデフォルトで定義されています．</p>
<dl class="rdoc-list note-list"><dt>NORETURN_STYLE_NEW 
<dd>
<p>NORETURN マクロが関数型マクロとして定義されていることを意味する．</p>
</dd><dt>HAVE_RB_DEFINE_ALLOC_FUNC 
<dd>
<p>rb_define_alloc_func() 関数が提供されていること，つまり allocation framework が使われることを意味する． have_func(“rb_define_alloc_func”, “ruby.h”) の結果と同じ．</p>
</dd><dt>HAVE_RB_REG_NEW_STR 
<dd>
<p>StringオブジェクトからRegexpオブジェクトを作る rb_reg_new_str() 関数が提供されていることを意味する． have_func(“rb_reg_new_str”, “ruby.h”). の結果と同じ．</p>
</dd><dt>HAVE_RB_IO_T 
<dd>
<p>rb_io_t 型が提供されていることを意味する．</p>
</dd><dt>USE_SYMBOL_AS_METHOD_NAME 
<dd>
<p>メソッド名を返すメソッド，Module#methods, #singleton_methods などがSymbolを返すことを意味する．</p>
</dd><dt>HAVE_RUBY_*_H 
<dd>
<p>ruby.h で定義されている．対応するヘッダが提供されていること を意味する．たとえば，HAVE_RUBY_ST_H が定義されている場合は 単なる st.h ではなく ruby/st.h を使用する．</p>
</dd><dt>RB_EVENT_HOOKS_HAVE_CALLBACK_DATA 
<dd>
<p>rb_add_event_hook() がフック関数に渡す data を第3引数として 受け取ることを意味する．</p>
</dd></dl>

<h2 id="label-Appendix+C.+extconf.rb-E3-81-A7-E4-BD-BF-E3-81-88-E3-82-8B-E9-96-A2-E6-95-B0-E3-81-9F-E3-81-A1">Appendix C. extconf.rbで使える関数たち</h2>

<p>extconf.rbの中では利用可能なコンパイル条件チェックの関数は以 下の通りである．</p>
<dl class="rdoc-list note-list"><dt>have_macro(macro, headers) 
<dd>
<p>ヘッダファイルheaderをインクルードしてマクロmacroが定義さ れているかどうかチェックする．マクロが定義されている時true を返す．</p>
</dd><dt>have_library(lib, func) 
<dd>
<p>関数funcを定義しているライブラリlibの存在をチェックする． チェックに成功すると，-llibを$libsに追加し，trueを返す．</p>
</dd><dt>find_library(lib, func, path…) 
<dd>
<p>関数funcを定義しているライブラリlibの存在を -Lpath を追加 しながらチェックする．チェックに成功すると，-llibを$libsに 追加し，trueを返す．</p>
</dd><dt>have_func(func, header) 
<dd>
<p>ヘッダファイルheaderをインクルードして関数funcの存在をチェ ックする．funcが標準ではリンクされないライブラリ内のもので ある時には先にhave_libraryでそのライブラリをチェックしてお く事．チェックに成功すると，プリプロセッサマクロ <code>HAVE_{FUNC</code>} を定義し，trueを返す．</p>
</dd><dt>have_var(var, header) 
<dd>
<p>ヘッダファイルheaderをインクルードして変数varの存在をチェッ クする．varが標準ではリンクされないライブラリ内のものであ る時には先にhave_libraryでそのライブラリをチェックしておく 事．チェックに成功すると，プリプロセッサマクロ <code>HAVE_{VAR</code>} を定義し，trueを返す．</p>
</dd><dt>have_header(header) 
<dd>
<p>ヘッダファイルの存在をチェックする．チェックに成功すると， プリプロセッサマクロ <code>HAVE_{HEADER_H</code>} を定義し，trueを返す． (スラッシュやドットはアンダースコアに置換される)</p>
</dd><dt>find_header(header, path…) 
<dd>
<p>ヘッダファイルheaderの存在を -Ipath を追加しながらチェック する．チェックに成功すると，プリプロセッサマクロ <code>HAVE_{HEADER_H</code>} を定義し，trueを返す． (スラッシュやドットはアンダースコアに置換される)</p>
</dd><dt>have_struct_member(type, member[, header[, opt]]) 
<dd>
<p>ヘッダファイルheaderをインクルードして型typeが定義され， なおかつメンバmemberが存在するかをチェックする．チェックに 成功すると，プリプロセッサマクロ <code>HAVE_{TYPE</code>_<code>MEMBER</code>} を 定義し，trueを返す．</p>
</dd><dt>have_type(type, header, opt) 
<dd>
<p>ヘッダファイルheaderをインクルードして型typeが存在するかを チェックする．チェックに成功すると，プリプロセッサマクロ <code>HAVE_TYPE_{TYPE</code>} を定義し，trueを返す．</p>
</dd><dt>check_sizeof(type, header) 
<dd>
<p>ヘッダファイルheaderをインクルードして型typeのchar単位サイ ズを調べる．チェックに成功すると，プリプロセッサマクロ <code>SIZEOF_{TYPE</code>} を定義し，そのサイズを返す．定義されていな いときはnilを返す．</p>
</dd><dt>create_makefile(target[, target_prefix]) 
<dd>
<p>拡張ライブラリ用のMakefileを生成する．この関数を呼ばなけれ ばそのライブラリはコンパイルされない．targetはモジュール名 を表す．</p>
</dd><dt>find_executable(command, path) 
<dd>
<p>コマンドcommandをFile::PATH_SEPARATORで区切られたパス名の リストpathから探す．pathがnilまたは省略された場合は，環境 変数PATHの値を使用する．実行可能なコマンドが見つかった場合 はパスを含むファイル名，見つからなかった場合はnilを返す．</p>
</dd><dt>with_config(withval[, default=nil]) 
<dd>
<p>コマンドライン上の–with-&lt;withval&gt;で指定されたオプション値 を得る．</p>
</dd><dt>enable_config(config, *defaults) 
<dt>disable_config(config, *defaults) 
<dd>
<p>コマンドライン上の–enable-&lt;config&gt;または –disable-&lt;config&gt;で指定された真偽値を得る． –enable-&lt;config&gt;が指定されていた場合はtrue， –disable-&lt;config&gt;が指定されていた場合はfalseを返す． どちらも指定されていない場合は，ブロックつきで呼び出されて いる場合は*defaultsをyieldした結果，ブロックなしなら *defaultsを返す．</p>
</dd><dt>dir_config(target[, default_dir]) 
<dt>dir_config(target[, default_include, default_lib]) 
<dd>
<p>コマンドライン上の–with-&lt;target&gt;-dir, –with-&lt;target&gt;-include, –with-&lt;target&gt;-libのいずれかで指定されるディレクトリを $CFLAGS や $LDFLAGS に追加する．–with-&lt;target&gt;-dir=/pathは –with-&lt;target&gt;-include=/path/include –with-&lt;target&gt;-lib=/path/lib と等価である．追加された include ディレクトリと lib ディレ クトリの配列を返す． ([include_dir, lib_dir])</p>
</dd><dt>pkg_config(pkg, option=nil) 
<dd>
<p>pkg-configコマンドからパッケージpkgの情報を [cflags, ldflags, libs] の配列として得る．$CFLAGS, $LDFLAGS, $libs にはそれぞれの値が 追加される．</p>

<p>pkg-configの実際のコマンドは，以下の順で試される．</p>
<ol><li>
<p>コマンドラインで–with-<code>pkg</code>-config=<code>command</code>オプションが 指定された場合: <code>command</code> <code>option</code></p>
</li><li>
<p><code>pkg</code>-config <code>option</code></p>
</li><li>
<p>pkg-config <code>option</code> <code>pkg</code></p>
</li></ol>

<p>optionが指定された場合は，上記の配列の代わりにそのオプションを 指定して得られた出力をstripしたものを返す．</p>
</dd></dl>

<h2 id="label-Appendix+D.+-E4-B8-96-E4-BB-A3-E5-88-A5GC">Appendix D. 世代別GC</h2>

<p>Ruby 2.1から世代別GCに対応しました．我々はこれをRGenGCと呼んでいます． RGenGCは，過去の拡張ライブラリに（ほぼ）互換性を保つように開発されている ため，拡張ライブラリ側の対応はほぼ不要です．</p>

<p>ただし，対応をすることで性能を向上することができる可能性があります．もし 拡張ライブラリに高い性能が必要である場合は対応を検討して下さい．</p>

<p>とくにRARRAY_PTR()/RHASH_TBL()のようなマクロを用いてポインタに直接アクセ スするようなコードは書かないようにして下さい．代わりに，rb_ary_aref(), rb_ary_store() などの，適切な API 関数を利用するようにして下さい．</p>

<p>そのほか，対応についての詳細は extension.rdoc の「Appendix D. Generational GC」を参照して下さい．</p>

<p>:enddoc: Local variables: :enddoc: fill-column: 60 :enddoc: end:</p>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>