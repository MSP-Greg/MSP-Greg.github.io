<!DOCTYPE html>
<html>
<head>

<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen' content='yes'>
<meta name='mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>File: README &mdash; SimpleCov main</title>

<link rel='stylesheet'  type='text/css' href='../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "README",
    relpath = '';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='.'>SimpleCov main</a> &raquo; 
      <a href='_index.html'>Index</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>File: README&nbsp;&#x25B2;</a></span>
          </div>

    <a id='list_href' href="class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='file'>
<h1><a href="SimpleCov.html" title="SimpleCov (module)"><code>SimpleCov</code></a> <a href="https://badge.fury.io/rb/simplecov"><img src="https://badge.fury.io/rb/simplecov.svg" alt="Gem Version"></a> <a href="https://github.com/simplecov-ruby/simplecov/actions?query=workflow%3Astable" title="SimpleCov is built around the clock by github.com"><img src="https://github.com/simplecov-ruby/simplecov/workflows/stable/badge.svg?branch=main" alt="Build Status"></a> <a href="https://codeclimate.com/github/simplecov-ruby/simplecov/maintainability"><img src="https://api.codeclimate.com/v1/badges/c071d197d61953a7e482/maintainability" alt="Maintainability"></a> <a href="http://inch-ci.org/github/simplecov-ruby/simplecov"><img src="http://inch-ci.org/github/simplecov-ruby/simplecov.svg?branch=main" alt="Inline docs"></a></h1>

<p><strong>Code coverage for Ruby</strong></p>

<ul>
<li><a href="https://github.com/simplecov-ruby/simplecov" title="Source Code @ GitHub">Source Code</a></li>
<li><a href="http://rubydoc.info/gems/simplecov/frames" title="RDoc API Documentation at Rubydoc.info">API documentation</a></li>
<li><a href="https://github.com/simplecov-ruby/simplecov/blob/main/CHANGELOG.md" title="Project Changelog">Changelog</a></li>
<li><a href="http://rubygems.org/gems/simplecov" title="SimpleCov @ rubygems.org">Rubygem</a></li>
<li><a href="https://github.com/simplecov-ruby/simplecov/actions?query=workflow%3Astable" title="SimpleCov is built around the clock by github.com">Continuous Integration</a></li>
</ul>

<p><a href="SimpleCov.html" title="SimpleCov (module)"><code>SimpleCov</code></a> is a code coverage analysis tool for Ruby. It uses <a href="https://docs.ruby-lang.org/en/master/Coverage.html" title="API doc for Ruby&#39;s Coverage library">Ruby&#39;s built-in Coverage</a> library to gather code
coverage data, but makes processing its results much easier by providing a clean API to filter, group, merge, format,
and display those results, giving you a complete code coverage suite that can be set up with just a couple lines of
code.
SimpleCov/Coverage track covered ruby code, gathering coverage for common templating solutions like erb, slim and haml is not supported.</p>

<p>In most cases, you&#39;ll want overall coverage results for your projects, including all types of tests, Cucumber features,
etc. <a href="SimpleCov.html" title="SimpleCov (module)"><code>SimpleCov</code></a> automatically takes care of this by caching and merging results when generating reports, so your
report actually includes coverage across your test suites and thereby gives you a better picture of blank spots.</p>

<p>The official formatter of <a href="SimpleCov.html" title="SimpleCov (module)"><code>SimpleCov</code></a> is packaged as a separate gem called <a href="https://github.com/simplecov-ruby/simplecov-html" title="SimpleCov HTML Formatter Source Code @ GitHub">simplecov-html</a>, but will be installed and
configured automatically when you launch <a href="SimpleCov.html" title="SimpleCov (module)"><code>SimpleCov</code></a>. If you&#39;re curious, you can find it <a href="https://github.com/simplecov-ruby/simplecov-html" title="SimpleCov HTML Formatter Source Code @ GitHub">on GitHub, too</a>.</p>

<h2>Contact</h2>

<p><em>Code and Bug Reports</em></p>

<ul>
<li><a href="https://github.com/simplecov-ruby/simplecov/issues">Issue Tracker</a></li>
<li>See [CONTRIBUTING]) for how to contribute along
with some common problems to check out before creating an issue.</li>
</ul>

<p><em>Questions, Problems, Suggestions, etc.</em></p>

<ul>
<li><a href="https://groups.google.com/forum/#!forum/simplecov">Mailing List</a> &quot;Open mailing list for discussion and announcements
on Google Groups&quot;</li>
</ul>

<h2>Getting started</h2>

<ol>
<li><p>Add SimpleCov to your <code>Gemfile</code> and <code>bundle install</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>require:</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='label'>group:</span> <span class='symbeg'>:</span><span class='id identifier rubyid_test'>test</span></code></pre></li>
<li><p>Load and launch <a href="SimpleCov.html" title="SimpleCov (module)"><code>SimpleCov</code></a> <strong>at the very top</strong> of your <code>test/test_helper.rb</code>
(<em>or <code>spec_helper.rb</code>, <code>rails_helper</code>, cucumber <code>env.rb</code>, or whatever your preferred test
framework uses</em>):</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span>
<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span>

<span class='comment'># Previous content of test helper now starts here</span></code></pre>

<p><strong>Note:</strong> If SimpleCov starts after your application code is already loaded
(via <code>require</code>), it won&#39;t be able to track your files and their coverage!
The <a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">SimpleCov.start</a> <strong>must</strong> be issued <strong>before any of your application
code is required!</strong></p>

<p>This is especially true if you use anything that keeps your tests application loaded like spring, check out the <strong><a href="#want-to-use-spring-with-simplecov">spring section</a></strong>.</p>

<p>SimpleCov must be running in the process that you want the code coverage
analysis to happen on. When testing a server process (e.g. a JSON API
endpoint) via a separate test process (e.g. when using Selenium) where you
want to see all code executed by the <code>rails server</code>, and not just code
executed in your actual test files, you need to require SimpleCov in the
server process. For rails for instance, you&#39;ll want to add something like this
to the top of <code>bin/rails</code>, but below the &quot;shebang&quot; line (<code>#! /usr/bin/env
ruby</code>) and after config/boot is required:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>if</span> <span class='const'>ENV</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>RAILS_ENV</span><span class='tstring_end'>&#39;</span></span>] <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span>
  <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rails</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>required simplecov</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span></code></pre></li>
<li><p>Run your full test suite to see the percent coverage that your application has.</p></li>
<li><p>After running your tests, open <code>coverage/index.html</code> in the browser of your choice. For example, in a Mac Terminal,
run the following command from your application&#39;s root directory:</p></li>
</ol>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_open'>open</span> <span class='id identifier rubyid_coverage'>coverage</span><span class='op'>/</span><span class='id identifier rubyid_index'>index</span>.<span class='id identifier rubyid_html'>html</span></code></pre>

<p>in a debian/ubuntu Terminal,</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_xdg'>xdg</span><span class='op'>-</span><span class='id identifier rubyid_open'>open</span> <span class='id identifier rubyid_coverage'>coverage</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>index.html</span></code></pre>

<p><strong>Note:</strong> <a href="https://dwheeler.com/essays/open-files-urls.html">This guide</a> can help if you&#39;re unsure which command your particular
   operating system requires.</p>

<ol>
<li>Add the following to your <code>.gitignore</code> file to ensure that coverage results
are not tracked by Git (optional):</li>
</ol>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_echo'>echo</span> <span class='id identifier rubyid_coverage'>coverage</span> <span class='op'>&gt;&gt;</span> .<span class='id identifier rubyid_gitignore'>gitignore</span></code></pre>

<p>If you&#39;re making a Rails application, SimpleCov comes with built-in configurations (see below for information on
   profiles) that will get you started with groups for your Controllers, Models and Helpers. To use it, the
   first two lines of your test_helper should be like this:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span>
<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rails</span><span class='tstring_end'>&#39;</span></span></code></pre>

<h2>Example output</h2>

<p><strong>Coverage results report, fully browsable locally with sorting and much more:</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/137793/17071162/db6f253e-502d-11e6-9d84-e40c3d75f333.png" alt="SimpleCov coverage report"></p>

<p><strong>Source file coverage details view:</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/137793/17071163/db6f9f0a-502d-11e6-816c-edb2c66fad8d.png" alt="SimpleCov source file detail view"></p>

<h2>Use it with any framework!</h2>

<p>Similarly to the usage with Test::Unit described above, the only thing you have to do is to add the <a href="SimpleCov.html" title="SimpleCov (module)"><code>SimpleCov</code></a>
config to the very top of your Cucumber/RSpec/whatever setup file.</p>

<p>Add the setup code to the <strong>top</strong> of <code>features/support/env.rb</code> (for Cucumber) or <code>spec/spec_helper.rb</code> (for RSpec).
Other test frameworks should work accordingly, whatever their setup file may be:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span>
<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rails</span><span class='tstring_end'>&#39;</span></span></code></pre>

<p>You could even track what kind of code your UI testers are touching if you want to go overboard with things. SimpleCov
does not care what kind of framework it is running in; it just looks at what code is being executed and generates a
report about it.</p>

<h3>Notes on specific frameworks and test utilities</h3>

<p>For some frameworks and testing tools there are quirks and problems you might want to know about if you want
to use SimpleCov with them. Here&#39;s an overview of the known ones:</p>

<table>
  <tr><th>Framework</th><th>Notes</th><th>Issue</th></tr>
  <tr>
    <th>
      parallel_tests
    </th>
    <td>
      As of 0.8.0, SimpleCov should correctly recognize parallel_tests and
      supplement your test suite names with their corresponding test env
      numbers. SimpleCov locks the resultset cache while merging, ensuring no
      race conditions occur when results are merged.
    </td>
    <td>
      <a href="https://github.com/simplecov-ruby/simplecov/issues/64">#64</a> &amp;
      <a href="https://github.com/simplecov-ruby/simplecov/pull/185">#185</a>
    </td>
  </tr>
  <tr>
    <th>
      knapsack_pro
    </th>
    <td>
      To make SimpleCov work with Knapsack Pro Queue Mode to split tests in parallel on CI jobs you need to provide CI node index number to the <code>SimpleCov.command_name</code> in <code>KnapsackPro::Hooks::Queue.before_queue</code> hook.
    </td>
    <td>
      <a href="https://knapsackpro.com/faq/question/how-to-use-simplecov-in-queue-mode">Tip</a>
    </td>
  </tr>
  <tr>
    <th>
      RubyMine
    </th>
    <td>
      The <a href="https://www.jetbrains.com/ruby/">RubyMine IDE</a> has
      built-in support for SimpleCov's coverage reports, though you might need
      to explicitly set the output root using <code>SimpleCov.root('foo/bar/baz')</code>
    </td>
    <td>
      <a href="https://github.com/simplecov-ruby/simplecov/issues/95">#95</a>
    </td>
  </tr>
  <tr>
    <th>
      Spork
    </th>
    <td>
      Because of how Spork works internally (using preforking), there used to
      be trouble when using SimpleCov with it, but that has apparently been
      resolved with a specific configuration strategy. See <a
      href="https://github.com/simplecov-ruby/simplecov/issues/42#issuecomment-4440284">this</a>
      comment.
    </td>
    <td>
      <a href="https://github.com/simplecov-ruby/simplecov/issues/42#issuecomment-4440284">#42</a>
    </td>
  </tr>
  <tr>
    <th>
      Spring
    </th>
    <td>
      <a href="#want-to-use-spring-with-simplecov">See section below.</a>
    </td>
    <td>
      <a href="https://github.com/simplecov-ruby/simplecov/issues/381">#381</a>
    </td>
  </tr>
  <tr>
    <th>
      Test/Unit
    </th>
    <td>
      Test Unit 2 used to mess with ARGV, leading to a failure to detect the
      test process name in SimpleCov. <code>test-unit</code> releases 2.4.3+
      (Dec 11th, 2011) should have this problem resolved.
    </td>
    <td>
      <a href="https://github.com/simplecov-ruby/simplecov/issues/45">#45</a> &amp;
      <a href="https://github.com/test-unit/test-unit/pull/12">test-unit/test-unit#12</a>
    </td>
  </tr>
</table>

<h2>Configuring SimpleCov</h2>

<p><a href="http://rubydoc.info/gems/simplecov/SimpleCov/Configuration" title="Configuration options API documentation">Configuration</a> settings can be applied in three formats, which are completely equivalent:</p>

<ul>
<li><p>The most common way is to configure it directly in your start block:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_some_config_option'>some_config_option</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span></code></pre></li>
<li><p>You can also set all configuration options directly:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_some_config_option'>some_config_option</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span></code></pre></li>
<li><p>If you do not want to start coverage immediately after launch or want to add additional configuration later on in a
concise way, use:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_configure'><a href="SimpleCov/Configuration.html#configure-instance_method" title="SimpleCov::Configuration#configure (method)">configure</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_some_config_option'>some_config_option</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foo</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span></code></pre></li>
</ul>

<p>Please check out the <a href="http://rubydoc.info/gems/simplecov/SimpleCov/Configuration" title="Configuration options API documentation">Configuration</a> API documentation to find out what you can customize.</p>

<h2>Using .simplecov for centralized config</h2>

<p>If you use SimpleCov to merge multiple test suite results (e.g. Test/Unit and Cucumber) into a single report, you&#39;d
normally have to set up all your config options twice, once in <code>test_helper.rb</code> and once in <code>env.rb</code>.</p>

<p>To avoid this, you can place a file called <code>.simplecov</code> in your project root. You can then just leave the
<code>require &#39;simplecov&#39;</code> in each test setup helper (<strong>at the top</strong>) and move the <a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">SimpleCov.start</a> code with all your
custom config options into <code>.simplecov</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># test/test_helper.rb
</span><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span>

<span class='comment'># features/support/env.rb
</span><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span>

<span class='comment'># .simplecov
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rails</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>do</span>
  <span class='comment'># any custom configs like groups and filters can be here at a central place
</span><span class='kw'>end</span></code></pre>

<p>Using <code>.simplecov</code> rather than separately requiring SimpleCov multiple times is recommended if you are merging multiple
test frameworks like Cucumber and RSpec that rely on each other, as invoking SimpleCov multiple times can cause coverage
information to be lost.</p>

<h2>Branch coverage (ruby &quot;~&gt; 2.5&quot;)</h2>

<p>Add branch coverage measurement statistics to your results. Supported in CRuby versions 2.5+.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_enable_coverage'>enable_coverage</span> <span class='symbeg'>:</span><span class='id identifier rubyid_branch'>branch</span>
<span class='kw'>end</span></code></pre>

<p>Branch coverage is a feature introduced in Ruby 2.5 concerning itself with whether a
particular branch of a condition had been executed. Line coverage on the other hand
is only interested in whether a line of code has been executed.</p>

<p>This comes in handy for instance for one line conditionals:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_number'>number</span>.<span class='id identifier rubyid_odd?'>odd?</span> <span class='op'>?</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>odd</span><span class='tstring_end'>&quot;</span></span> <span class='op'>:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>even</span><span class='tstring_end'>&quot;</span></span></code></pre>

<p>In line coverage this line would always be marked as executed but you&#39;d never know if both
conditions were met. Guard clauses have a similar story:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>return</span> <span class='kw'>if</span> <span class='id identifier rubyid_number'>number</span>.<span class='id identifier rubyid_odd?'>odd?</span>

<span class='comment'># more code</span></code></pre>

<p>If all the code in that method was covered you&#39;d never know if the guard clause was ever
triggered! With line coverage as just evaluating the condition marks it as covered.</p>

<p>In the HTML report the lines of code will be annotated like <code>branch_type: hit_count</code>:</p>

<ul>
<li><code>then: 2</code> - the then branch (of an <code>if</code>) was executed twice</li>
<li><code>else: 0</code> - the else branch (of an <code>if</code> or <code>case</code>) was never executed</li>
</ul>

<p>Not that even if you don&#39;t declare an <code>else</code> branch it will still show up in the coverage
reports meaning that the condition of the <code>if</code> was not hit or that no <code>when</code> of <code>case</code>
was hit during the test runs.</p>

<p><strong>Is branch coverage strictly better?</strong> No. Branch coverage really only concerns itself with
conditionals - meaning coverage of sequential code is of no interest to it. A file without
conditional logic will have no branch coverage data and SimpleCov will report 0 of 0
branches covered as 100% (as everything that can be covered was covered).</p>

<p>Hence, we recommend looking at both metrics together. Branch coverage might also be a good
overall metric to look at - while you might be missing only 10% of your lines that might
account for 50% of your branches for instance.</p>

<h2>Primary Coverage</h2>

<p>By default, the primary coverage type is <code>line</code>. To set the primary coverage to something else, use the following:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># or in configure SimpleCov.primary_coverage :branch
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_enable_coverage'>enable_coverage</span> <span class='symbeg'>:</span><span class='id identifier rubyid_branch'>branch</span>
  <span class='id identifier rubyid_primary_coverage'>primary_coverage</span> <span class='symbeg'>:</span><span class='id identifier rubyid_branch'>branch</span>
<span class='kw'>end</span></code></pre>

<p>Primary coverage determines what will come first in all output, and the type of coverage to check if you don&#39;t specify the type of coverage when customizing exit behavior (<code>SimpleCov.minimum_coverage 90</code>).</p>

<p>Note that coverage must first be enabled for non-default coverage types.</p>

<h2>Coverage for eval</h2>

<p>You can measure coverage for code that is evaluated by <code>Kernel#eval</code>. Supported in CRuby versions 3.2+.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_enable_coverage_for_eval'>enable_coverage_for_eval</span>
<span class='kw'>end</span></code></pre>

<p>This is typically useful for ERB. Set <code>ERB#filename=</code> to make it possible for SimpleCov to trace the original .erb source file.</p>

<h2>Filters</h2>

<p>Filters can be used to remove selected files from your coverage data. By default, a filter is applied that removes all
files OUTSIDE of your project&#39;s root directory - otherwise you&#39;d end up with billions of coverage reports for source
files in the gems you are using.</p>

<p>You can define your own to remove things like configuration files, tests or whatever you don&#39;t need in your coverage
report.</p>

<h3>Defining custom filters</h3>

<p>You can currently define a filter using either a String or Regexp (that will then be Regexp-matched against each source
file&#39;s path), a block or by passing in your own Filter class.</p>

<h4>String filter</h4>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_add_filter'>add_filter</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>/test/</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span></code></pre>

<p>This simple string filter will remove all files that match &quot;/test/&quot; in their path.</p>

<h4>Regex filter</h4>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_add_filter'>add_filter</span> <span class='tstring'><span class='regexp_beg'>%r{</span><span class='tstring_content'>^/test/</span><span class='regexp_end'>}</span></span>
<span class='kw'>end</span></code></pre>

<p>This simple regex filter will remove all files that start with /test/ in their path.</p>

<h4>Block filter</h4>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_add_filter'>add_filter</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_source_file'>source_file</span><span class='op'>|</span>
    <span class='id identifier rubyid_source_file'>source_file</span>.<span class='id identifier rubyid_lines'>lines</span>.<span class='id identifier rubyid_count'>count</span> <span class='op'>&lt;</span> <span class='int'>5</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>Block filters receive a SimpleCov::SourceFile instance and expect your block to return either true (if the file is to be
removed from the result) or false (if the result should be kept). Please check out the RDoc for SimpleCov::SourceFile to
learn about the methods available to you. In the above example, the filter will remove all files that have less than 5
lines of code.</p>

<h4>Custom filter class</h4>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>LineFilter</span> <span class='op'>&lt;</span> <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Filter.html" title="SimpleCov::Filter (class)">Filter</a></span>
  <span class='kw'>def</span> <span class='id identifier rubyid_matches?'>matches?</span>(<span class='id identifier rubyid_source_file'>source_file</span>)
    <span class='id identifier rubyid_source_file'>source_file</span>.<span class='id identifier rubyid_lines'>lines</span>.<span class='id identifier rubyid_count'>count</span> <span class='op'>&lt;</span> <span class='id identifier rubyid_filter_argument'>filter_argument</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_add_filter'><a href="SimpleCov/Configuration.html#add_filter-instance_method" title="SimpleCov::Configuration#add_filter (method)">add_filter</a></span> <span class='const'>LineFilter</span>.<span class='id identifier rubyid_new'>new</span>(<span class='int'>5</span>)</code></pre>

<p>Defining your own filters is pretty easy: Just inherit from SimpleCov::Filter and define a method
&#39;matches?(source_file)&#39;. When running the filter, a true return value from this method will result in the removal of the
given source_file. The filter_argument method is being set in the SimpleCov::Filter initialize method and thus is set to
5 in this example.</p>

<h4>Array filter</h4>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_proc'>proc</span> <span class='op'>=</span> <span class='const'>Proc</span>.<span class='id identifier rubyid_new'>new</span> { <span class='op'>|</span><span class='id identifier rubyid_source_file'>source_file</span><span class='op'>|</span> <span class='kw'>false</span> }
  <span class='id identifier rubyid_add_filter'>add_filter</span> [<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>string</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>regex</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='id identifier rubyid_proc'>proc</span><span class='comma'>,</span> <span class='const'>LineFilter</span>.<span class='id identifier rubyid_new'>new</span>(<span class='int'>5</span>)]
<span class='kw'>end</span></code></pre>

<p>You can pass in an array containing any of the other filter types.</p>

<h4>Ignoring/skipping code</h4>

<p>You can exclude code from the coverage report by wrapping it in <code># :nocov:</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># :nocov:
</span><span class='kw'>def</span> <span class='id identifier rubyid_skip_this_method'>skip_this_method</span>
  <span class='id identifier rubyid_never_reached'>never_reached</span>
<span class='kw'>end</span>
<span class='comment'># :nocov:</span></code></pre>

<p>The name of the token can be changed to your liking. <a href="https://github.com/simplecov-ruby/simplecov/blob/main/features/config_nocov_token.feature">Learn more about the nocov feature.</a></p>

<p><strong>Note:</strong> You shouldn&#39;t have to use the nocov token to skip private methods that are being included in your coverage. If
you appropriately test the public interface of your classes and objects you should automatically get full coverage of
your private methods.</p>

<h2>Default root filter and coverage for things outside of it</h2>

<p>By default, SimpleCov filters everything outside of the <code>SimpleCov.root</code> directory. However, sometimes you may want
to include coverage reports for things you include as a gem, for example a Rails Engine.</p>

<p>Here&#39;s an example by <a href="https://github.com/lsaffie">@lsaffie</a> from <a href="https://github.com/simplecov-ruby/simplecov/issues/221">#221</a>
that shows how you can achieve just that:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='symbeg'>:</span><span class='id identifier rubyid_rails'>rails</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_filters'>filters</span>.<span class='id identifier rubyid_clear'>clear</span> <span class='comment'># This will remove the :root_filter and :bundler_filter that come via simplecov&#39;s defaults
</span>  <span class='id identifier rubyid_add_filter'>add_filter</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_src'>src</span><span class='op'>|</span>
    <span class='op'>!</span>(<span class='id identifier rubyid_src'>src</span>.<span class='id identifier rubyid_filename'>filename</span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^</span><span class='embexpr_beg'>#{</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_root'><a href="SimpleCov/Configuration.html#root-instance_method" title="SimpleCov::Configuration#root (method)">root</a></span><span class='embexpr_end'>}</span><span class='regexp_end'>/</span></span>) <span class='kw'>unless</span> <span class='id identifier rubyid_src'>src</span>.<span class='id identifier rubyid_filename'>filename</span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>my_engine</span><span class='regexp_end'>/</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<h2>Groups</h2>

<p>You can separate your source files into groups. For example, in a Rails app, you&#39;ll want to have separate listings for
Models, Controllers, Helpers, and Libs. Group definition works similarly to Filters (and also accepts custom
filter classes), but source files end up in a group when the filter passes (returns true), as opposed to filtering
results, which exclude files from results when the filter results in a true value.</p>

<p>Add your groups with:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_add_group'>add_group</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Models</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>app/models</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_add_group'>add_group</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Controllers</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>app/controllers</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_add_group'>add_group</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Long files</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_src_file'>src_file</span><span class='op'>|</span>
    <span class='id identifier rubyid_src_file'>src_file</span>.<span class='id identifier rubyid_lines'>lines</span>.<span class='id identifier rubyid_count'>count</span> <span class='op'>&gt;</span> <span class='int'>100</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_add_group'>add_group</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Multiple Files</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> [<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>app/models</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>app/controllers</span><span class='tstring_end'>&quot;</span></span>] <span class='comment'># You can also pass in an array
</span>  <span class='id identifier rubyid_add_group'>add_group</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Short files</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='const'>LineFilter</span>.<span class='id identifier rubyid_new'>new</span>(<span class='int'>5</span>) <span class='comment'># Using the LineFilter class defined in Filters section above
</span><span class='kw'>end</span></code></pre>

<h2>Merging results</h2>

<p>You normally want to have your coverage analyzed across ALL of your test suites, right?</p>

<p>Simplecov automatically caches coverage results in your
(coverage_path)/.resultset.json, and will merge or override those with
subsequent runs, depending on whether simplecov considers those subsequent runs
as different test suites or as the same test suite as the cached results. To
make this distinction, simplecov has the concept of &quot;test suite names&quot;.</p>

<h3>Test suite names</h3>

<p>SimpleCov tries to guess the name of the currently running test suite based upon the shell command the tests
are running on. This should work fine for Unit Tests, RSpec, and Cucumber. If it fails, it will use the shell
command that invoked the test suite as a command name.</p>

<p>If you have some non-standard setup and still want nicely labeled test suites, you have to give Simplecov a
cue as to what the name of the currently running test suite is. You can do so by specifying
<code>SimpleCov.command_name</code> in one test file that is part of your specific suite.</p>

<p>To customize the suite names on a Rails app (yeah, sorry for being Rails-biased, but everyone knows what
the structure of those projects is. You can apply this accordingly to the RSpecs in your
Outlook-WebDAV-Calendar-Sync gem), you could do something like this:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># test/unit/some_test.rb
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_command_name'><a href="SimpleCov/Configuration.html#command_name-instance_method" title="SimpleCov::Configuration#command_name (method)">command_name</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>test:units</span><span class='tstring_end'>&#39;</span></span>

<span class='comment'># test/functionals/some_controller_test.rb
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_command_name'><a href="SimpleCov/Configuration.html#command_name-instance_method" title="SimpleCov::Configuration#command_name (method)">command_name</a></span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>test:functionals</span><span class='tstring_end'>&quot;</span></span>

<span class='comment'># test/integration/some_integration_test.rb
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_command_name'><a href="SimpleCov/Configuration.html#command_name-instance_method" title="SimpleCov::Configuration#command_name (method)">command_name</a></span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>test:integration</span><span class='tstring_end'>&quot;</span></span>

<span class='comment'># features/support/env.rb
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_command_name'><a href="SimpleCov/Configuration.html#command_name-instance_method" title="SimpleCov::Configuration#command_name (method)">command_name</a></span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>features</span><span class='tstring_end'>&quot;</span></span></code></pre>

<p>Note that this only has to be invoked ONCE PER TEST SUITE, so even if you have 200 unit test files,
specifying it in <code>some_test.rb</code> is enough.</p>

<p>Last but not least <strong>if multiple suites resolve to the same <code>command_name</code></strong> be aware that the coverage results <strong>will
clobber each other instead of being merged</strong>.  SimpleCov is smart enough to detect unique names for the most common
setups, but if you have more than one test suite that doesn&#39;t follow a common pattern then you will want to manually
ensure that each suite gets a unique <code>command_name</code>.</p>

<p>If you are running tests in parallel each process has the potential to clobber results from the other test processes.
If you are relying on the default <code>command_name</code> then SimpleCov will attempt to detect and avoid parallel test suite
<code>command_name</code> collisions based on the presence of <code>ENV['PARALLEL_TEST_GROUPS']</code> and <code>ENV['TEST_ENV_NUMBER']</code>.  If your
parallel test runner does not set one or both of these then <em>you must</em> set a <code>command_name</code> and ensure that it is unique
per process (eg. <code>command_name &quot;Unit Tests PID #{$$}&quot;</code>).</p>

<p>If you are using parallel_tests, you must incorporate <code>TEST_ENV_NUMBER</code> into the command name yourself, in
order for SimpleCov to merge the results correctly. For example:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># spec/spec_helper.rb
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_command_name'><a href="SimpleCov/Configuration.html#command_name-instance_method" title="SimpleCov::Configuration#command_name (method)">command_name</a></span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>features</span><span class='tstring_end'>&quot;</span></span> <span class='op'>+</span> (<span class='const'>ENV</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>TEST_ENV_NUMBER</span><span class='tstring_end'>&#39;</span></span>] <span class='op'>||</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span>)</code></pre>

<p><a href="https://github.com/simplecov-ruby/simplecov-html" title="SimpleCov HTML Formatter Source Code @ GitHub">simplecov-html</a> prints the used test suites in the footer of the generated coverage report.</p>

<h3>Merging test runs under the same execution environment</h3>

<p>Test results are automatically merged with previous runs in the same execution
environment when generating the result, so when coverage is set up properly for
Cucumber and your unit / functional / integration tests, all of those test
suites will be taken into account when building the coverage report.</p>

<h4>Timeout for merge</h4>

<p>Of course, your cached coverage data is likely to become invalid at some point. Thus, when automatically merging
subsequent test runs, result sets that are older than <code>SimpleCov.merge_timeout</code> will not be used any more. By default,
the timeout is 600 seconds (10 minutes), and you can raise (or lower) it by specifying <code>SimpleCov.merge_timeout 3600</code>
(1 hour), or, inside a configure/start block, with just <code>merge_timeout 3600</code>.</p>

<p>You can deactivate this automatic merging altogether with <code>SimpleCov.use_merging false</code>.</p>

<h3>Merging test runs under different execution environments</h3>

<p>If your tests are done in parallel across multiple build machines, you can fetch them all and merge them into a single
result set using the <a href="SimpleCov.html#collate-class_method" title="SimpleCov.collate (method)">SimpleCov.collate</a> method. This can be added to a Rakefile or script file, having downloaded a set of
<code>.resultset.json</code> files from each parallel test run.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># lib/tasks/coverage_report.rake
</span><span class='id identifier rubyid_namespace'>namespace</span> <span class='symbeg'>:</span><span class='id identifier rubyid_coverage'>coverage</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_desc'>desc</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Collates all result sets generated by the different test runners</span><span class='tstring_end'>&quot;</span></span>
  <span class='id identifier rubyid_task'>task</span> <span class='symbeg'>:</span><span class='id identifier rubyid_report'>report</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span>

    <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_collate'><a href="SimpleCov.html#collate-class_method" title="SimpleCov.collate (method)">collate</a></span> <span class='const'>Dir</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>simplecov-resultset-*/.resultset.json</span><span class='tstring_end'>&quot;</span></span>]
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p><a href="SimpleCov.html#collate-class_method" title="SimpleCov.collate (method)">SimpleCov.collate</a> also takes an optional simplecov profile and an optional
block for configuration, just the same as <a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">SimpleCov.start</a> or
<code>SimpleCov.configure</code>.  This means you can configure a separate formatter for
the collated output. For instance, you can make the formatter in
<a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">SimpleCov.start</a> the <a href="SimpleCov/Formatter/SimpleFormatter.html" title="SimpleCov::Formatter::SimpleFormatter (class)"><code>::SimpleCov::Formatter::SimpleFormatter</code></a>, and only use more
complex formatters in the final <a href="SimpleCov.html#collate-class_method" title="SimpleCov.collate (method)">SimpleCov.collate</a> run.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># spec/spec_helper.rb
</span><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span>

<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rails</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>do</span>
  <span class='comment'># Disambiguates individual test runs
</span>  <span class='id identifier rubyid_command_name'>command_name</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Job </span><span class='embexpr_beg'>#{</span><span class='const'>ENV</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>TEST_ENV_NUMBER</span><span class='tstring_end'>&quot;</span></span>]<span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='const'>ENV</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>TEST_ENV_NUMBER</span><span class='tstring_end'>&quot;</span></span>]

  <span class='kw'>if</span> <span class='const'>ENV</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>CI</span><span class='tstring_end'>&#39;</span></span>]
    <span class='id identifier rubyid_formatter'>formatter</span> <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter.html" title="SimpleCov::Formatter (module)">Formatter</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter/SimpleFormatter.html" title="SimpleCov::Formatter::SimpleFormatter (class)">SimpleFormatter</a></span>
  <span class='kw'>else</span>
    <span class='id identifier rubyid_formatter'>formatter</span> <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter.html" title="SimpleCov::Formatter (module)">Formatter</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter/MultiFormatter.html" title="SimpleCov::Formatter::MultiFormatter (class)">MultiFormatter</a></span>.<span class='id identifier rubyid_new'><a href="SimpleCov/Formatter/MultiFormatter.html#new-class_method" title="SimpleCov::Formatter::MultiFormatter.new (method)">new</a></span>([
      <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter.html" title="SimpleCov::Formatter (module)">Formatter</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter/SimpleFormatter.html" title="SimpleCov::Formatter::SimpleFormatter (class)">SimpleFormatter</a></span><span class='comma'>,</span>
      <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter.html" title="SimpleCov::Formatter (module)">Formatter</a></span><span class='op'>::</span><span class='const'>HTMLFormatter</span>
    ])
  <span class='kw'>end</span>

  <span class='id identifier rubyid_track_files'>track_files</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>**/*.rb</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span></code></pre>

<pre class="code ruby"><code class="ruby"><span class='comment'># lib/tasks/coverage_report.rake
</span><span class='id identifier rubyid_namespace'>namespace</span> <span class='symbeg'>:</span><span class='id identifier rubyid_coverage'>coverage</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_task'>task</span> <span class='symbeg'>:</span><span class='id identifier rubyid_report'>report</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span>

    <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_collate'><a href="SimpleCov.html#collate-class_method" title="SimpleCov.collate (method)">collate</a></span> <span class='const'>Dir</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>simplecov-resultset-*/.resultset.json</span><span class='tstring_end'>&quot;</span></span>]<span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rails</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>do</span>
      <span class='id identifier rubyid_formatter'>formatter</span> <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter.html" title="SimpleCov::Formatter (module)">Formatter</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter/MultiFormatter.html" title="SimpleCov::Formatter::MultiFormatter (class)">MultiFormatter</a></span>.<span class='id identifier rubyid_new'><a href="SimpleCov/Formatter/MultiFormatter.html#new-class_method" title="SimpleCov::Formatter::MultiFormatter.new (method)">new</a></span>([
        <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter.html" title="SimpleCov::Formatter (module)">Formatter</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter/SimpleFormatter.html" title="SimpleCov::Formatter::SimpleFormatter (class)">SimpleFormatter</a></span><span class='comma'>,</span>
        <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter.html" title="SimpleCov::Formatter (module)">Formatter</a></span><span class='op'>::</span><span class='const'>HTMLFormatter</span>
      ])
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<h2>Running simplecov against subprocesses</h2>

<p><code>SimpleCov.enable_for_subprocesses</code> will allow SimpleCov to observe subprocesses starting using <a href="Process.html#fork-class_method" title="Process.fork (method)">Process.fork</a>.
This modifies ruby&#39;s core Process.fork method so that SimpleCov can see into it, appending <code>&quot; (subprocess #{pid})&quot;</code>
to the <code>SimpleCov.command_name</code>, with results that can be merged together using SimpleCov&#39;s merging feature.</p>

<p>To configure this, use <code>.at_fork</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_enable_for_subprocesses'><a href="SimpleCov/Configuration.html#enable_for_subprocesses-instance_method" title="SimpleCov::Configuration#enable_for_subprocesses (method)">enable_for_subprocesses</a></span> <span class='kw'>true</span>
<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_at_fork'><a href="SimpleCov/Configuration.html#at_fork-instance_method" title="SimpleCov::Configuration#at_fork (method)">at_fork</a></span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_pid'>pid</span><span class='op'>|</span>
  <span class='comment'># This needs a unique name so it won&#39;t be overwritten
</span>  <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_command_name'><a href="SimpleCov/Configuration.html#command_name-instance_method" title="SimpleCov::Configuration#command_name (method)">command_name</a></span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_command_name'><a href="SimpleCov/Configuration.html#command_name-instance_method" title="SimpleCov::Configuration#command_name (method)">command_name</a></span><span class='embexpr_end'>}</span><span class='tstring_content'> (subprocess: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_pid'>pid</span><span class='embexpr_end'>}</span><span class='tstring_content'>)</span><span class='tstring_end'>&quot;</span></span>
  <span class='comment'># be quiet, the parent process will be in charge of output and checking coverage totals
</span>  <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_print_error_status'><a href="SimpleCov/Configuration.html#print_error_status-instance_method" title="SimpleCov::Configuration#print_error_status (method)">print_error_status</a></span> <span class='op'>=</span> <span class='kw'>false</span>
  <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_formatter'><a href="SimpleCov/Configuration.html#formatter-instance_method" title="SimpleCov::Configuration#formatter (method)">formatter</a></span> <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter.html" title="SimpleCov::Formatter (module)">Formatter</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter/SimpleFormatter.html" title="SimpleCov::Formatter::SimpleFormatter (class)">SimpleFormatter</a></span>
  <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_minimum_coverage'><a href="SimpleCov/Configuration.html#minimum_coverage-instance_method" title="SimpleCov::Configuration#minimum_coverage (method)">minimum_coverage</a></span> <span class='int'>0</span>
  <span class='comment'># start
</span>  <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span>
<span class='kw'>end</span></code></pre>

<p>NOTE: SimpleCov must have already been started before <a href="Process.html#fork-class_method" title="Process.fork (method)">Process.fork</a> was called.</p>

<h3>Running simplecov against spawned subprocesses</h3>

<p>Perhaps you&#39;re testing a ruby script with <code>PTY.spawn</code> or <code>Open3.popen</code>, or <code>Process.spawn</code> or etc.
SimpleCov can cover this too.</p>

<p>Add a .simplecov_spawn.rb file to your project root</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># .simplecov_spawn.rb
</span><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span> <span class='comment'># this will also pick up whatever config is in .simplecov
</span>                    <span class='comment'># so ensure it just contains configuration, and doesn&#39;t call SimpleCov.start.
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_command_name'><a href="SimpleCov/Configuration.html#command_name-instance_method" title="SimpleCov::Configuration#command_name (method)">command_name</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>spawn</span><span class='tstring_end'>&#39;</span></span> <span class='comment'># As this is not for a test runner directly, script doesn&#39;t have a pre-defined base command_name
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_at_fork'><a href="SimpleCov/Configuration.html#at_fork-instance_method" title="SimpleCov::Configuration#at_fork (method)">at_fork</a></span>.<span class='id identifier rubyid_call'>call</span>(<span class='const'><a href="Process.html" title="Process (module)">Process</a></span>.<span class='id identifier rubyid_pid'>pid</span>) <span class='comment'># Use the per-process setup described previously
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='comment'># only now can we start.</span></code></pre>

<p>Then, instead of calling your script directly, like:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>PTY</span>.<span class='id identifier rubyid_spawn'>spawn</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>my_script.rb</span><span class='tstring_end'>&#39;</span></span>) <span class='kw'>do</span> <span class='comment'># ...</span></code></pre>

<p>Use bin/ruby to require the new .simplecov_spawn file, then your script</p>

<pre class="code ruby"><code class="ruby"><span class='const'>PTY</span>.<span class='id identifier rubyid_spawn'>spawn</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>ruby -r./.simplecov_spawn my_script.rb</span><span class='tstring_end'>&#39;</span></span>) <span class='kw'>do</span> <span class='comment'># ...</span></code></pre>

<h2>Running coverage only on demand</h2>

<p>The Ruby STDLIB Coverage library that SimpleCov builds upon is <em>very</em> fast (on a ~10 min Rails test suite, the speed
drop was only a couple seconds for me), and therefore it&#39;s SimpleCov&#39;s policy to just generate coverage every time you
run your tests because it doesn&#39;t do your test speed any harm and you&#39;re always equipped with the latest and greatest
coverage results.</p>

<p>Because of this, SimpleCov has no explicit built-in mechanism to run coverage only on demand.</p>

<p>However, you can still accomplish this very easily by introducing an ENV variable conditional into your SimpleCov setup
block, like this:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='kw'>if</span> <span class='const'>ENV</span>[<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>COVERAGE</span><span class='tstring_end'>&quot;</span></span>]</code></pre>

<p>Then, SimpleCov will only run if you execute your tests like this:</p>

<pre class="code shell"><code class="shell">COVERAGE=true rake test
</code></pre>

<h2>Errors and exit statuses</h2>

<p>To aid in debugging issues, if an error is raised, SimpleCov will print a message to <code>STDERR</code>
with the exit status of the error, like:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span> <span class='id identifier rubyid_failed'>failed</span> <span class='id identifier rubyid_with'>with</span> <span class='id identifier rubyid_exit'>exit</span> <span class='int'>1</span></code></pre>

<p>This <code>STDERR</code> message can be disabled with:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_print_error_status'><a href="SimpleCov/Configuration.html#print_error_status-instance_method" title="SimpleCov::Configuration#print_error_status (method)">print_error_status</a></span> <span class='op'>=</span> <span class='kw'>false</span></code></pre>

<h2>Profiles</h2>

<p>By default, SimpleCov&#39;s only config assumption is that you only want coverage reports for files inside your project
root. To save yourself from repetitive configuration, you can use predefined blocks of configuration, called &#39;profiles&#39;,
or define your own.</p>

<p>You can then pass the name of the profile to be used as the first argument to SimpleCov.start. For example, simplecov
comes bundled with a &#39;rails&#39; profile. It looks somewhat like this:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_profiles'><a href="SimpleCov/Configuration.html#profiles-instance_method" title="SimpleCov::Configuration#profiles (method)">profiles</a></span>.<span class='id identifier rubyid_define'>define</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rails</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_add_filter'>add_filter</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>/test/</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_add_filter'>add_filter</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>/config/</span><span class='tstring_end'>&#39;</span></span>

  <span class='id identifier rubyid_add_group'>add_group</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Controllers</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>app/controllers</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_add_group'>add_group</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Models</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>app/models</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_add_group'>add_group</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Helpers</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>app/helpers</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_add_group'>add_group</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Libraries</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>lib</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span></code></pre>

<p>As you can see, it&#39;s just a SimpleCov.configure block. In your test_helper.rb, launch SimpleCov with:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rails</span><span class='tstring_end'>&#39;</span></span></code></pre>

<p>or</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rails</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>do</span>
  <span class='comment'># additional config here
</span><span class='kw'>end</span></code></pre>

<h3>Custom profiles</h3>

<p>You can load additional profiles with the SimpleCov.load_profile(&#39;xyz&#39;) method. This allows you to build upon an
existing profile and customize it so you can reuse it in unit tests and Cucumber features. For example:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># lib/simplecov_custom_profile.rb
</span><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span>
<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_profiles'><a href="SimpleCov/Configuration.html#profiles-instance_method" title="SimpleCov::Configuration#profiles (method)">profiles</a></span>.<span class='id identifier rubyid_define'>define</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>myprofile</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_load_profile'>load_profile</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rails</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_add_filter'>add_filter</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>vendor</span><span class='tstring_end'>&#39;</span></span> <span class='comment'># Don&#39;t include vendored stuff
</span><span class='kw'>end</span>

<span class='comment'># features/support/env.rb
</span><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov_custom_profile</span><span class='tstring_end'>&#39;</span></span>
<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>myprofile</span><span class='tstring_end'>&#39;</span></span>

<span class='comment'># test/test_helper.rb
</span><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov_custom_profile</span><span class='tstring_end'>&#39;</span></span>
<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>myprofile</span><span class='tstring_end'>&#39;</span></span></code></pre>

<h2>Customizing exit behaviour</h2>

<p>You can define what SimpleCov should do when your test suite finishes by customizing the at_exit hook:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_at_exit'><a href="SimpleCov/Configuration.html#at_exit-instance_method" title="SimpleCov::Configuration#at_exit (method)">at_exit</a></span> <span class='kw'>do</span>
  <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_result'><a href="SimpleCov.html#result-class_method" title="SimpleCov.result (method)">result</a></span>.<span class='id identifier rubyid_format!'>format!</span>
<span class='kw'>end</span></code></pre>

<p>Above is the default behaviour. Do whatever you like instead!</p>

<h3>Minimum coverage</h3>

<p>You can define the minimum coverage percentage expected. SimpleCov will return non-zero if unmet.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_minimum_coverage'><a href="SimpleCov/Configuration.html#minimum_coverage-instance_method" title="SimpleCov::Configuration#minimum_coverage (method)">minimum_coverage</a></span> <span class='int'>90</span>
<span class='comment'># same as above (the default is to check line coverage)
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_minimum_coverage'><a href="SimpleCov/Configuration.html#minimum_coverage-instance_method" title="SimpleCov::Configuration#minimum_coverage (method)">minimum_coverage</a></span> <span class='label'>line:</span> <span class='int'>90</span>
<span class='comment'># check for a minimum line coverage of 90% and minimum 80% branch coverage
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_minimum_coverage'><a href="SimpleCov/Configuration.html#minimum_coverage-instance_method" title="SimpleCov::Configuration#minimum_coverage (method)">minimum_coverage</a></span> <span class='label'>line:</span> <span class='int'>90</span><span class='comma'>,</span> <span class='label'>branch:</span> <span class='int'>80</span></code></pre>

<h3>Minimum coverage by file</h3>

<p>You can define the minimum coverage by file percentage expected. SimpleCov will return non-zero if unmet. This is useful
to help ensure coverage is relatively consistent, rather than being skewed by particularly good or bad areas of the code.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_minimum_coverage_by_file'><a href="SimpleCov/Configuration.html#minimum_coverage_by_file-instance_method" title="SimpleCov::Configuration#minimum_coverage_by_file (method)">minimum_coverage_by_file</a></span> <span class='int'>80</span>
<span class='comment'># same as above (the default is to check line coverage by file)
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_minimum_coverage_by_file'><a href="SimpleCov/Configuration.html#minimum_coverage_by_file-instance_method" title="SimpleCov::Configuration#minimum_coverage_by_file (method)">minimum_coverage_by_file</a></span> <span class='label'>line:</span> <span class='int'>80</span>
<span class='comment'># check for a minimum line coverage by file of 90% and minimum 80% branch coverage
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_minimum_coverage_by_file'><a href="SimpleCov/Configuration.html#minimum_coverage_by_file-instance_method" title="SimpleCov::Configuration#minimum_coverage_by_file (method)">minimum_coverage_by_file</a></span> <span class='label'>line:</span> <span class='int'>90</span><span class='comma'>,</span> <span class='label'>branch:</span> <span class='int'>80</span></code></pre>

<h3>Maximum coverage drop</h3>

<p>You can define the maximum coverage drop percentage at once. SimpleCov will return non-zero if exceeded.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_maximum_coverage_drop'><a href="SimpleCov/Configuration.html#maximum_coverage_drop-instance_method" title="SimpleCov::Configuration#maximum_coverage_drop (method)">maximum_coverage_drop</a></span> <span class='int'>5</span>
<span class='comment'># same as above (the default is to check line drop)
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_maximum_coverage_drop'><a href="SimpleCov/Configuration.html#maximum_coverage_drop-instance_method" title="SimpleCov::Configuration#maximum_coverage_drop (method)">maximum_coverage_drop</a></span> <span class='label'>line:</span> <span class='int'>5</span>
<span class='comment'># check for a maximum line drop of 5% and maximum 10% branch drop
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_maximum_coverage_drop'><a href="SimpleCov/Configuration.html#maximum_coverage_drop-instance_method" title="SimpleCov::Configuration#maximum_coverage_drop (method)">maximum_coverage_drop</a></span> <span class='label'>line:</span> <span class='int'>5</span><span class='comma'>,</span> <span class='label'>branch:</span> <span class='int'>10</span></code></pre>

<h3>Refuse dropping coverage</h3>

<p>You can also entirely refuse dropping coverage between test runs:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_refuse_coverage_drop'><a href="SimpleCov/Configuration.html#refuse_coverage_drop-instance_method" title="SimpleCov::Configuration#refuse_coverage_drop (method)">refuse_coverage_drop</a></span>
<span class='comment'># same as above (the default is to only refuse line drop)
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_refuse_coverage_drop'><a href="SimpleCov/Configuration.html#refuse_coverage_drop-instance_method" title="SimpleCov::Configuration#refuse_coverage_drop (method)">refuse_coverage_drop</a></span> <span class='symbeg'>:</span><span class='id identifier rubyid_line'>line</span>
<span class='comment'># refuse drop for line and branch
</span><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_refuse_coverage_drop'><a href="SimpleCov/Configuration.html#refuse_coverage_drop-instance_method" title="SimpleCov::Configuration#refuse_coverage_drop (method)">refuse_coverage_drop</a></span> <span class='symbeg'>:</span><span class='id identifier rubyid_line'>line</span><span class='comma'>,</span> <span class='symbeg'>:</span><span class='id identifier rubyid_branch'>branch</span></code></pre>

<h2>Using your own formatter</h2>

<p>You can use your own formatter with:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_formatter'><a href="SimpleCov/Configuration.html#formatter-instance_method" title="SimpleCov::Configuration#formatter (method)">formatter</a></span> <span class='op'>=</span> <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter.html" title="SimpleCov::Formatter (module)">Formatter</a></span><span class='op'>::</span><span class='const'>HTMLFormatter</span></code></pre>

<p>Calling <code>SimpleCov.result.format!</code> will be invoked with <code>SimpleCov::Formatter::YourFormatter.new.format(result)</code>,
and <code>result</code> is an instance of <a href="SimpleCov/Result.html" title="SimpleCov::Result (class)"><code>::SimpleCov::Result</code></a>. Do whatever your wish with that!</p>

<h2>Using multiple formatters</h2>

<p>As of SimpleCov 0.9, you can specify multiple result formats. Formatters besides the default HTML formatter require separate gems, however.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>simplecov-html</span><span class='tstring_end'>&quot;</span></span>

<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_formatters'><a href="SimpleCov/Configuration.html#formatters-instance_method" title="SimpleCov::Configuration#formatters (method)">formatters</a></span> <span class='op'>=</span> [
  <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter.html" title="SimpleCov::Formatter (module)">Formatter</a></span><span class='op'>::</span><span class='const'>HTMLFormatter</span><span class='comma'>,</span>
  <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter.html" title="SimpleCov::Formatter (module)">Formatter</a></span><span class='op'>::</span><span class='const'>CSVFormatter</span><span class='comma'>,</span>
]</code></pre>

<h2>JSON formatter</h2>

<p>SimpleCov is packaged with a separate gem called <a href="https://github.com/codeclimate-community/simplecov_json_formatter">simplecov_json_formatter</a> that provides you with a JSON formatter, this formatter could be useful for different use cases, such as for CI consumption or for reporting to external services.</p>

<p>In order to use it you will need to manually load the installed gem like so:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>simplecov_json_formatter</span><span class='tstring_end'>&quot;</span></span>
<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_formatter'><a href="SimpleCov/Configuration.html#formatter-instance_method" title="SimpleCov::Configuration#formatter (method)">formatter</a></span> <span class='op'>=</span> <span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span><span class='op'>::</span><span class='const'><a href="SimpleCov/Formatter.html" title="SimpleCov::Formatter (module)">Formatter</a></span><span class='op'>::</span><span class='const'>JSONFormatter</span></code></pre>

<blockquote>
<p><em>Note:</em> In case you plan to report your coverage results to CodeClimate services, know that SimpleCov will automatically use the
 JSON formatter along with the HTML formatter when the <code>CC_TEST_REPORTER_ID</code> variable is present in the environment.</p>
</blockquote>

<h2>Available formatters, editor integrations and hosted services</h2>

<ul>
<li><a href="file.alternate-formatters.html">Open Source formatter and integration plugins for SimpleCov</a></li>
<li><a href="file.editor-integration.html">Editor Integration</a></li>
<li><a href="file.commercial-services.html">Hosted (commercial) services</a></li>
</ul>

<h2>Ruby version compatibility</h2>

<p>SimpleCov is built in <a href="https://github.com/simplecov-ruby/simplecov/actions?query=workflow%3Astable" title="SimpleCov is built around the clock by github.com">Continuous Integration</a> on Ruby 2.5+ as well as JRuby 9.2+.</p>

<p>Note for JRuby =&gt; You need to pass JRUBY_OPTS=&quot;--debug&quot; or create .jrubyrc and add debug.fullTrace=true</p>

<h2>Want to find dead code in production?</h2>

<p>Try <a href="https://github.com/danmayer/coverband">Coverband</a>.</p>

<h2>Want to use Spring with SimpleCov?</h2>

<p>If you&#39;re using <a href="https://github.com/rails/spring">Spring</a> to speed up test suite runs and want to run SimpleCov along
with them, you&#39;ll find that it often misreports coverage with the default config due to some sort of eager loading
issue. Don&#39;t despair!</p>

<p>One solution is to <a href="https://github.com/simplecov-ruby/simplecov/issues/381#issuecomment-347651728">explicitly call eager
load</a>
in your <code>test_helper.rb</code> / <code>spec_helper.rb</code> after calling <a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">SimpleCov.start</a>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>simplecov</span><span class='tstring_end'>&#39;</span></span>
<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rails</span><span class='tstring_end'>&#39;</span></span>
<span class='const'>Rails</span>.<span class='id identifier rubyid_application'>application</span>.<span class='id identifier rubyid_eager_load!'>eager_load!</span></code></pre>

<p>Alternatively, you could disable Spring while running SimpleCov:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>DISABLE_SPRING</span><span class='op'>=</span><span class='int'>1</span> <span class='id identifier rubyid_rake'>rake</span> <span class='id identifier rubyid_test'>test</span></code></pre>

<p>Or you could remove <code>gem &#39;spring&#39;</code> from your <code>Gemfile</code>.</p>

<h2>Troubleshooting</h2>

<p>The <strong>most common problem is that simplecov isn&#39;t required and started before everything else</strong>. In order to track
coverage for your whole application <strong>simplecov needs to be the first one</strong> so that it (and the underlying coverage
library) can subsequently track loaded files and their usage.</p>

<p>If you are missing coverage for some code a simple trick is to put a puts statement in there and right after
<a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">SimpleCov.start</a> so you can see if the file really was loaded after simplecov was started.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># my_code.rb
</span><span class='kw'>class</span> <span class='const'>MyCode</span>

  <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>MyCode is being loaded!</span><span class='tstring_end'>&quot;</span></span>

  <span class='kw'>def</span> <span class='id identifier rubyid_my_method'>my_method</span>
    <span class='comment'># ...
</span>  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='comment'># spec_helper.rb/rails_helper.rb/test_helper.rb/.simplecov whatever
</span>
<span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span>.<span class='id identifier rubyid_start'><a href="SimpleCov.html#start-class_method" title="SimpleCov.start (method)">start</a></span>
<span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>SimpleCov started successfully!</span><span class='tstring_end'>&quot;</span></span></code></pre>

<p>Now when you run your test suite and you see:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><a href="SimpleCov.html" title="SimpleCov (module)">SimpleCov</a></span> <span class='id identifier rubyid_started'>started</span> <span class='id identifier rubyid_successfully!'>successfully!</span>
<span class='const'>MyCode</span> <span class='id identifier rubyid_is'>is</span> <span class='id identifier rubyid_being'>being</span> <span class='id identifier rubyid_loaded!'>loaded!</span></code></pre>

<p>then it&#39;s good otherwise you likely have a problem :)</p>

<h2>Code of Conduct</h2>

<p>Everyone participating in this project&#39;s development, issue trackers and other channels is expected to follow our
<a href="file.CODE_OF_CONDUCT.html">Code of Conduct</a></p>

<h2>Contributing</h2>

<p>See the [contributing guide]).</p>

<h2>Kudos</h2>

<p>Thanks to Aaron Patterson for the original idea for this!</p>

<h2>Copyright</h2>

<p>Copyright (c) 2010-2017 Christoph Olszowka. See MIT-LICENSE for details.</p>

<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>