<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen'       content='yes'>
<meta name='apple-mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: Unicorn::HttpParser &mdash; Unicorn master</title>

<link rel='stylesheet'  type='text/css' href='../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "Unicorn::HttpParser",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../'>Unicorn master</a> &raquo; 
      <a href='../_index.html#alpha_H'>Index (H)</a> &raquo; 
        <a class='nodoc' href="../Unicorn.html" title="Unicorn (module)">Unicorn</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>HttpParser&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: Unicorn::HttpParser</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr>
      <td id='t2_inherits' class='box_2'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'><a href="../Object.html" title="Object (class)">Object</a></span>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2 o'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L8'>lib/unicorn/http_request.rb</a><span class='defines'>,<br /><a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L980'>ext/unicorn_http/unicorn_http.rl</a></span>
      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='t2_cnst' class='h2_sum'>Constant Summary</h2>
<div>
<ul class='constants summary full'>
  <li>
    <span id='CHUNK_MAX-constant' class='summary_signature'>CHUNK_MAX =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>The maximum size a single chunk when using chunked transfer encoding. This is only a theoretical maximum used to detect errors in clients, it is highly unlikely to encounter clients that send more than several kilobytes at once.</p>

  </div>
</div>
    <a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L1016'># File 'ext/unicorn_http/unicorn_http.rl', line 1016</a>    <pre class='code c'><span class='const'>OFFT2NUM</span>(<span class='const'>UH_OFF_T_MAX</span>)</pre>
  </li>
  <li>
    <span id='DEFAULTS-constant' class='summary_signature nodoc'>DEFAULTS =</span>
    <span class='nodoc note title'>Internal use only</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>default parameters we merge into the request env for Rack handlers</p>

  </div>
</div>
    <a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L11-L22'># File 'lib/unicorn/http_request.rb', line 11</a>    <pre class='code ruby'>{
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rack.errors</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='gvar'>$stderr</span><span class='comma'>,</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rack.multiprocess</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='comma'>,</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rack.multithread</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rack.run_once</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>false</span><span class='comma'>,</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rack.version</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> [<span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span>]<span class='comma'>,</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>rack.hijack?</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='kw'>true</span><span class='comma'>,</span>
  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>SCRIPT_NAME</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span>

  <span class='comment'># this is not in the Rack spec, but some apps may rely on it
</span>  <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>SERVER_SOFTWARE</span><span class='tstring_end'>&quot;</span></span> <span class='op'>=&gt;</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Unicorn </span><span class='embexpr_beg'>#{</span><span class='const'><a href="../Unicorn.html" title="Unicorn (module)">Unicorn</a></span><span class='op'>::</span><span class='const'><a href="Const.html" title="Unicorn::Const (module)">Const</a></span><span class='op'>::</span><span class='const'>UNICORN_VERSION</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
}</pre>
  </li>
  <li>
    <span id='EMPTY_ARRAY-constant' class='summary_signature nodoc'>EMPTY_ARRAY =</span>
    <span class='nodoc note title'>Internal use only</span>
    <br/>
    <a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L28-L28'># File 'lib/unicorn/http_request.rb', line 28</a>    <pre class='code ruby'>[].<span class='id identifier rubyid_freeze'>freeze</span></pre>
  </li>
  <li>
    <span id='HTTP_RESPONSE_START-constant' class='summary_signature nodoc'>HTTP_RESPONSE_START =</span>
    <span class='nodoc note title'>Internal use only</span>
    <br/>
    <a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L27-L27'># File 'lib/unicorn/http_request.rb', line 27</a>    <pre class='code ruby'>[ <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>HTTP</span><span class='tstring_end'>&#39;</span></span>.<span class='id identifier rubyid_freeze'>freeze</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>/1.1 </span><span class='tstring_end'>&#39;</span></span>.<span class='id identifier rubyid_freeze'>freeze</span> ]</pre>
  </li>
  <li>
    <span id='LENGTH_MAX-constant' class='summary_signature'>LENGTH_MAX =</span>
    <div class='docstring'>
  <div class='discussion'>
    
<p>The maximum size of the body as specified by Content-Length. This is only a theoretical maximum, the actual limit is subject to the limits of the file system used for <code>Dir.tmpdir</code>.</p>

  </div>
</div>
    <a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L1023'># File 'ext/unicorn_http/unicorn_http.rl', line 1023</a>    <pre class='code c'><span class='const'>OFFT2NUM</span>(<span class='const'>UH_OFF_T_MAX</span>)</pre>
  </li>
  <li>
    <span id='NULL_IO-constant' class='summary_signature nodoc'>NULL_IO =</span>
    <span class='nodoc note title'>Internal use only</span>
    <br/>
    <a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L24-L24'># File 'lib/unicorn/http_request.rb', line 24</a>    <pre class='code ruby'><span class='const'>StringIO</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Unicorn::HttpParser.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_end'>&quot;</span></span>)</pre>
  </li>
  <li>
    <span id='TCPI-constant' class='summary_signature nodoc'>TCPI =</span>
    <span class='nodoc note title'>Internal use only</span>
    <br/>
    <a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L108-L108'># File 'lib/unicorn/http_request.rb', line 108</a>    <pre class='code ruby'><span class='const'>Raindrops</span><span class='op'>::</span><span class='const'>TCP_Info</span>.<span class='id identifier rubyid_allocate'>allocate</span></pre>
  </li>
</ul>
</div>

<h2 class='h2_sum' id='class_attribute_summary'>Class Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature wo'>
      <a href="#max_header_len=-class_method" title=".max_header_len= (class method)">.<strong>max_header_len=</strong>(len)  </a>
    </span>
    <span class='note title writeonly'>writeonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>this is only intended for use with Rainbows!</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw nodoc'>
      <a href="#check_client_connection-class_method" title=".check_client_connection (class method)">.<strong>check_client_connection</strong>  </a>
    </span>
    <span class='note title rw'>rw</span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
  <li>
    <span class='summary_signature rw nodoc'>
      <a href="#check_client_connection=-class_method" title=".check_client_connection= (class method)">.<strong>check_client_connection=</strong>(bool)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
  <li>
    <span class='summary_signature rw nodoc'>
      <a href="#input_class-class_method" title=".input_class (class method)">.<strong>input_class</strong>  </a>
    </span>
    <span class='note title rw'>rw</span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
  <li>
    <span class='summary_signature rw nodoc'>
      <a href="#input_class=-class_method" title=".input_class= (class method)">.<strong>input_class=</strong>(klass)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
</ul>
</div>  <!-- class_attribute_summary -->

<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#new-class_method" title="new (class method)">.<strong>new</strong>  &#x21d2; parser </a>
    </span>
    <span class='note title constructor'>constructor</span>
    <div class='summary_desc'>
      <div class='inline'><p>Creates a new parser.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature nodoc'>
      <a href="#is_chunked%3F-class_method" title=".is_chunked? (class method)">.<strong>is_chunked?</strong>(v)  &#x21d2; Boolean </a>
    </span>
    <span class='nodoc note title'>Internal use only</span>
    <div class='summary_desc'>
      <div class='inline'><p>called by ext/unicorn_http/unicorn_http.rl via rb_funcall.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_attribute_summary'>Instance Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature ro'>
      <a href="#body_eof%3F-instance_method" title="#body_eof? (instance method)">#<strong>body_eof?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Detects if we’re done filtering the body or not.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#headers%3F-instance_method" title="#headers? (instance method)">#<strong>headers?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>This should be used to detect if a request has headers (and if the response will have headers as well).</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#keepalive%3F-instance_method" title="#keepalive? (instance method)">#<strong>keepalive?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>This should be used to detect if a request can really handle keepalives and pipelining.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#next%3F-instance_method" title="#next? (instance method)">#<strong>next?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Exactly like <a href="#keepalive%3F-instance_method" title="Unicorn::HttpParser#keepalive? (method)">#keepalive?</a>, except it will reset the internal parser state on next parse if it returns true.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#response_start_sent-instance_method" title="#response_start_sent (instance method)">#<strong>response_start_sent</strong>  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>ignored by Ruby anyways.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#response_start_sent=-instance_method" title="#response_start_sent= (instance method)">#<strong>response_start_sent=</strong>(boolean)  </a>
    </span>
    <span class='note title rw'>rw</span>
  </li>
  <li>
    <span class='summary_signature ro nodoc'>
      <a href="#chunkable_response%3F-instance_method" title="#chunkable_response? (instance method)">#<strong>chunkable_response?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
  <li>
    <span class='summary_signature ro nodoc'>
      <a href="#hijacked%3F-instance_method" title="#hijacked? (instance method)">#<strong>hijacked?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
</ul>
</div>  <!-- instance_attribute_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#add_parse-instance_method" title="#add_parse (instance method)">#<strong>add_parse</strong>(buffer)  &#x21d2; env<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>adds the contents of <code>buffer</code> to the internal buffer and attempts to continue parsing.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#buf-instance_method" title="#buf (instance method)">#<strong>buf</strong>  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#clear-instance_method" title="#clear (instance method)">#<strong>clear</strong>  &#x21d2; parser </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Resets the parser to it’s initial state so that you can reuse it rather than making new ones.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#content_length-instance_method" title="#content_length (instance method)">#<strong>content_length</strong>  &#x21d2; nil, Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the number of bytes left to run through <a href="#filter_body-instance_method" title="Unicorn::HttpParser#filter_body (method)">#filter_body</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#env-instance_method" title="#env (instance method)">#<strong>env</strong>  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#filter_body-instance_method" title="#filter_body (instance method)">#<strong>filter_body</strong>(dst, src)  &#x21d2; nil/src </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Takes a String of <code>src</code>, will modify data if dechunking is done.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#headers-instance_method" title="#headers (instance method)">#<strong>headers</strong>(env, buf)  </a>
      (also: #trailers)
    </span>
    <span class='note title readonly'>readonly</span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#hijacked!-instance_method" title="#hijacked! (instance method)">#<strong>hijacked!</strong>  </a>
    </span>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#parse-instance_method" title="#parse (instance method)">#<strong>parse</strong>  &#x21d2; env<sup>?</sup> </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Takes a Hash and a String of data, parses the String of data filling in the Hash returning the Hash if parsing is finished, nil otherwise When returning the env Hash, it may modify data to point to where body processing should begin.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#trailers-instance_method" title="#trailers (instance method)">#<strong>trailers</strong>(env, buf)  </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Alias for <a href="#headers-instance_method" title="Unicorn::HttpParser#headers (method)">#headers</a>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature nodoc'>
      <a href="#call-instance_method" title="#call (instance method)">#<strong>call</strong>  </a>
    </span>
    <span class='nodoc note title'>Internal use only</span>
    <div class='summary_desc'>
      <div class='inline'><p>for rack.hijack, we respond to this method so no extra allocation of a proc object.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature nodoc'>
      <a href="#check_client_connection-instance_method" title="#check_client_connection (instance method)">#<strong>check_client_connection</strong>(socket, ai)  </a>
    </span>
    <span class='nodoc note title'>Internal use only</span>
    <div class='summary_desc'>
      <div class='inline'><p>Ruby 2.2+ can show struct tcp_info as a string <code>Socket::Option#inspect</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature nodoc'>
      <a href="#closed_state%3F-instance_method" title="#closed_state? (instance method)">#<strong>closed_state?</strong>(state)  &#x21d2; Boolean </a>
    </span>
    <span class='nodoc note title'>Internal use only</span>
    <div class='summary_desc'>
      <div class='inline'><p>raindrops before 0.18 only supported TCP_INFO under Linux.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature nodoc'>
      <a href="#closed_state_str%3F-instance_method" title="#closed_state_str? (instance method)">#<strong>closed_state_str?</strong>(state)  &#x21d2; Boolean </a>
    </span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
  <li>
    <span class='summary_signature nodoc'>
      <a href="#read_headers-instance_method" title="#read_headers (instance method)">#<strong>read_headers</strong>(socket, ai)  </a>
    </span>
    <span class='nodoc note title'>Internal use only</span>
    <div class='summary_desc'>
      <div class='inline'><p>Does the majority of the IO processing.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature nodoc'>
      <a href="#write_http_header-instance_method" title="#write_http_header (instance method)">#<strong>write_http_header</strong>(socket)  </a>
    </span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
</ul>
</div>  <!-- instance_method_summary -->
<h2 id='Constructor_Details' class='y_details'>Constructor Details</h2>

  <section class='method_details first' id="new-class_method">
  <h3 class='signature  first'>
    .<strong>new</strong>  &#x21d2; <code>parser</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Creates a new parser.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L624-L633'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='624' data-end='633'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 624</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_init(VALUE self)
{
  struct http_parser *hp = data_get(self);

  http_parser_init(hp);
  hp-&gt;buf = rb_str_new(NULL, 0);
  hp-&gt;env = rb_hash_new();

  return self;
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Class Attribute Details</h2>
<section class='method_details first' id="check_client_connection-class_method">
  <h3 class='signature rw  nodoc first'>
    .<strong>check_client_connection</strong>   <span class="extras">(<span class='rw'>rw</span>)</span>
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L41-L43'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='41' data-end='43'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/unicorn/http_request.rb', line 41</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_check_client_connection'>check_client_connection</span>
  <span class='cvar'>@@check_client_connection</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="check_client_connection=-class_method">
  <h3 class='signature rw  nodoc'>
    .<strong>check_client_connection=</strong>(bool)   <span class="extras">(<span class='rw'>rw</span>)</span>
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L45-L47'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='45' data-end='47'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/unicorn/http_request.rb', line 45</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_check_client_connection='>check_client_connection=</span>(<span class='id identifier rubyid_bool'>bool</span>)
  <span class='cvar'>@@check_client_connection</span> <span class='op'>=</span> <span class='id identifier rubyid_bool'>bool</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="input_class-class_method">
  <h3 class='signature rw  nodoc'>
    .<strong>input_class</strong>   <span class="extras">(<span class='rw'>rw</span>)</span>
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L33-L35'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='33' data-end='35'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/unicorn/http_request.rb', line 33</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_input_class'>input_class</span>
  <span class='cvar'>@@input_class</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="input_class=-class_method">
  <h3 class='signature rw  nodoc'>
    .<strong>input_class=</strong>(klass)   <span class="extras">(<span class='rw'>rw</span>)</span>
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L37-L39'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='37' data-end='39'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/unicorn/http_request.rb', line 37</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_input_class='>input_class=</span>(<span class='id identifier rubyid_klass'>klass</span>)
  <span class='cvar'>@@input_class</span> <span class='op'>=</span> <span class='id identifier rubyid_klass'>klass</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="max_header_len=-class_method">
  <h3 class='signature wo'>
    .<strong>max_header_len=</strong>(len)   <span class="extras">(<span class='writeonly'>writeonly</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>this is only intended for use with Rainbows!</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L43-L46'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='43' data-end='46'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 43</span></pre>
<pre class='code cpp'>

static VALUE set_maxhdrlen(VALUE self, VALUE len)
{
  return UINT2NUM(MAX_HEADER_LEN = NUM2UINT(len));
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Class Method Details</h2>
<section class='method_details first' id="is_chunked?-class_method">
  <h3 class='signature nodoc first'>
    .<strong>is_chunked?</strong>(v)  &#x21d2; <code>Boolean</code> 
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
<div class='docstring'>
  <div class='discussion'>
    
<p>called by ext/unicorn_http/unicorn_http.rl via rb_funcall</p>

  </div>
</div>
<div class='tags'>
  <p class='tag_title'>Raises:</p>
<ul class='raise'>
  <li>
    <span class='type'>(<a href="HttpParserError.html" title="Unicorn::HttpParserError (class)">Unicorn::HttpParserError</a>)</span>
  </li>
</ul>

</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L192-L200'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='192' data-end='200'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/unicorn/http_request.rb', line 192</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='kw'>self</span>.<span class='id identifier rubyid_is_chunked?'>is_chunked?</span>(<span class='id identifier rubyid_v'>v</span>) <span class='comment'># :nodoc:
</span>  <span class='id identifier rubyid_vals'>vals</span> <span class='op'>=</span> <span class='id identifier rubyid_v'>v</span>.<span class='id identifier rubyid_split'>split</span>(<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[ \t]*,[ \t]*</span><span class='regexp_end'>/</span></span>).<span class='id identifier rubyid_map!'>map!</span>(<span class='op'>&amp;</span><span class='symbeg'>:</span><span class='id identifier rubyid_downcase'>downcase</span>)
  <span class='kw'>if</span> <span class='id identifier rubyid_vals'>vals</span>.<span class='id identifier rubyid_pop'>pop</span> <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>chunked</span><span class='tstring_end'>&#39;</span></span>.<span class='id identifier rubyid_freeze'>freeze</span>
    <span class='kw'>return</span> <span class='kw'>true</span> <span class='kw'>unless</span> <span class='id identifier rubyid_vals'>vals</span>.<span class='id identifier rubyid_include?'>include?</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>chunked</span><span class='tstring_end'>&#39;</span></span>.<span class='id identifier rubyid_freeze'>freeze</span>)
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../Unicorn.html" title="Unicorn (module)">Unicorn</a></span><span class='op'>::</span><span class='const'><a href="HttpParserError.html" title="Unicorn::HttpParserError (class)">HttpParserError</a></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>double chunked</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> []
  <span class='kw'>end</span>
  <span class='kw'>return</span> <span class='kw'>false</span> <span class='kw'>unless</span> <span class='id identifier rubyid_vals'>vals</span>.<span class='id identifier rubyid_include?'>include?</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>chunked</span><span class='tstring_end'>&#39;</span></span>.<span class='id identifier rubyid_freeze'>freeze</span>)
  <span class='id identifier rubyid_raise'>raise</span> <span class='const'><a href="../Unicorn.html" title="Unicorn (module)">Unicorn</a></span><span class='op'>::</span><span class='const'><a href="HttpParserError.html" title="Unicorn::HttpParserError (class)">HttpParserError</a></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>chunked not last</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> []
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Attribute Details</h2>
<section class='method_details first' id="body_eof?-instance_method">
  <h3 class='signature ro first'>
    #<strong>body_eof?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Detects if we’re done filtering the body or not.  This can be used to detect when to stop calling <a href="#filter_body-instance_method" title="Unicorn::HttpParser#filter_body (method)">#filter_body</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L785-L793'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='785' data-end='793'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 785</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_body_eof(VALUE self)
{
  struct http_parser *hp = data_get(self);

  if (HP_FL_TEST(hp, CHUNKED))
    return chunked_eof(hp) ? Qtrue : Qfalse;

  return hp-&gt;len.content == 0 ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="chunkable_response?-instance_method">
  <h3 class='signature ro  nodoc'>
    #<strong>chunkable_response?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L814-L819'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='814' data-end='819'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 814</span></pre>
<pre class='code cpp'>

static VALUE chunkable_response_p(VALUE self)
{
  const struct http_parser *hp = data_get(self);

  return HP_FL_ALL(hp, RES_CHUNKABLE) ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="headers?-instance_method">
  <h3 class='signature ro'>
    #<strong>headers?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This should be used to detect if a request has headers (and if the response will have headers as well).  HTTP/0.9 requests should return false, all subsequent HTTP versions will return true</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L847-L852'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='847' data-end='852'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 847</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_has_headers(VALUE self)
{
  struct http_parser *hp = data_get(self);

  return HP_FL_TEST(hp, HASHEADER) ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="hijacked?-instance_method">
  <h3 class='signature ro  nodoc'>
    #<strong>hijacked?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L103-L105'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='103' data-end='105'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/unicorn/http_request.rb', line 103</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_hijacked?'>hijacked?</span>
  <span class='id identifier rubyid_env'><a href="#env-instance_method" title="Unicorn::HttpParser#env (method)">env</a></span>.<span class='id identifier rubyid_include?'>include?</span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rack.hijack_io</span><span class='tstring_end'>&#39;</span></span>.<span class='id identifier rubyid_freeze'>freeze</span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="keepalive?-instance_method">
  <h3 class='signature ro'>
    #<strong>keepalive?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>This should be used to detect if a request can really handle keepalives and pipelining.  Currently, the rules are:</p>
<ol><li>
<p>MUST be a GET or HEAD request</p>
</li><li>
<p>MUST be HTTP/1.1 <code>or</code> HTTP/1.0 with “Connection: keep-alive”</p>
</li><li>
<p>MUST NOT have “Connection: close” set</p>
</li></ol>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L806-L811'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='806' data-end='811'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 806</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_keepalive(VALUE self)
{
  struct http_parser *hp = data_get(self);

  return HP_FL_ALL(hp, KEEPALIVE) ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="next?-instance_method">
  <h3 class='signature ro'>
    #<strong>next?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Exactly like <a href="#keepalive%3F-instance_method" title="Unicorn::HttpParser#keepalive? (method)">#keepalive?</a>, except it will reset the internal parser state on next parse if it returns true.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L828-L837'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='828' data-end='837'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 828</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_next(VALUE self)
{
  struct http_parser *hp = data_get(self);

  if (HP_FL_ALL(hp, KEEPALIVE)) {
    HP_FL_SET(hp, TO_CLEAR);
    return Qtrue;
  }
  return Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="response_start_sent-instance_method">
  <h3 class='signature rw'>
    #<strong>response_start_sent</strong>   <span class="extras">(<span class='rw'>rw</span>)</span>
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>ignored by Ruby anyways</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L963-L968'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='963' data-end='968'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 963</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_rssget(VALUE self)
{
  struct http_parser *hp = data_get(self);

  return HP_FL_TEST(hp, RESSTART) ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="response_start_sent=-instance_method">
  <h3 class='signature rw'>
    #<strong>response_start_sent=</strong>(boolean)   <span class="extras">(<span class='rw'>rw</span>)</span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L951-L961'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='951' data-end='961'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 951</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_rssset(VALUE self, VALUE boolean)
{
  struct http_parser *hp = data_get(self);

  if (RTEST(boolean))
    HP_FL_SET(hp, RESSTART);
  else
    HP_FL_UNSET(hp, RESSTART);

  return boolean; /* ignored by Ruby anyways */
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="add_parse-instance_method">
  <h3 class='signature  first'>
    #<strong>add_parse</strong>(buffer)  &#x21d2; <a href="#env-instance_method" title="Unicorn::HttpParser#env (method)">env</a><sup>?</sup>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>adds the contents of <code>buffer</code> to the internal buffer and attempts to continue parsing.  Returns the <a href="#env-instance_method" title="Unicorn::HttpParser#env (method)">#env</a> Hash on success or nil if more data is needed.</p>

<p>Raises HttpParserError if there are parsing errors.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L742-L750'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='742' data-end='750'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 742</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_add_parse(VALUE self, VALUE buffer)
{
  struct http_parser *hp = data_get(self);

  Check_Type(buffer, T_STRING);
  rb_str_buf_append(hp-&gt;buf, buffer);

  return HttpParser_parse(self);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="buf-instance_method">
  <h3 class='signature '>
    #<strong>buf</strong>  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L854-L857'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='854' data-end='857'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 854</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_buf(VALUE self)
{
  return data_get(self)-&gt;buf;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="call-instance_method">
  <h3 class='signature nodoc'>
    #<strong>call</strong>  
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
<div class='docstring'>
  <div class='discussion'>
    
<p>for rack.hijack, we respond to this method so no extra allocation of a proc object</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L98-L101'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='98' data-end='101'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/unicorn/http_request.rb', line 98</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_call'>call</span>
  <span class='id identifier rubyid_hijacked!'><a href="#hijacked!-instance_method" title="Unicorn::HttpParser#hijacked! (method)">hijacked!</a></span>
  <span class='id identifier rubyid_env'><a href="#env-instance_method" title="Unicorn::HttpParser#env (method)">env</a></span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rack.hijack_io</span><span class='tstring_end'>&#39;</span></span>] <span class='op'>=</span> <span class='id identifier rubyid_env'><a href="#env-instance_method" title="Unicorn::HttpParser#env (method)">env</a></span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>unicorn.socket</span><span class='tstring_end'>&#39;</span></span>]
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="check_client_connection-instance_method">
  <h3 class='signature nodoc'>
    #<strong>check_client_connection</strong>(socket, ai)  
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
<div class='docstring'>
  <div class='discussion'>
    
<p>Ruby 2.2+ can show struct tcp_info as a string <code>Socket::Option#inspect</code>. Not that efficient, but probably still better than doing unnecessary work after a client gives up.</p>

<p>See additional method definition at line 110.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L155-L163'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='155' data-end='163'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/unicorn/http_request.rb', line 155</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_check_client_connection'>check_client_connection</span>(<span class='id identifier rubyid_socket'>socket</span><span class='comma'>,</span> <span class='id identifier rubyid_ai'>ai</span>) <span class='comment'># :nodoc:
</span>  <span class='kw'>if</span> <span class='id identifier rubyid_ai'>ai</span>.<span class='id identifier rubyid_ip?'>ip?</span>
    <span class='comment'># Raindrops::TCP_Info#get!, #state (reads struct tcp_info#tcpi_state)
</span>    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>Errno</span><span class='op'>::</span><span class='const'>EPIPE</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>client closed connection</span><span class='tstring_end'>&quot;</span></span>.<span class='id identifier rubyid_freeze'>freeze</span><span class='comma'>,</span>
          <span class='const'><a href="#EMPTY_ARRAY-constant" title="Unicorn::HttpParser::EMPTY_ARRAY (constant)">EMPTY_ARRAY</a></span> <span class='kw'>if</span> <span class='id identifier rubyid_closed_state?'><a href="#closed_state%3F-instance_method" title="Unicorn::HttpParser#closed_state? (method)">closed_state?</a></span>(<span class='const'><a href="#TCPI-constant" title="Unicorn::HttpParser::TCPI (constant)">TCPI</a></span>.<span class='id identifier rubyid_get!'>get!</span>(<span class='id identifier rubyid_socket'>socket</span>).<span class='id identifier rubyid_state'>state</span>)
  <span class='kw'>else</span>
    <span class='id identifier rubyid_write_http_header'><a href="#write_http_header-instance_method" title="Unicorn::HttpParser#write_http_header (method)">write_http_header</a></span>(<span class='id identifier rubyid_socket'>socket</span>)
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="clear-instance_method">
  <h3 class='signature '>
    #<strong>clear</strong>  &#x21d2; <code>parser</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Resets the parser to it’s initial state so that you can reuse it rather than making new ones.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L642-L654'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='642' data-end='654'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 642</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_clear(VALUE self)
{
  struct http_parser *hp = data_get(self);

  /* we can&#39;t safely reuse .buf and .env if hijacked */
  if (HP_FL_TEST(hp, HIJACK))
    return HttpParser_init(self);

  http_parser_init(hp);
  rb_hash_clear(hp-&gt;env);

  return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="closed_state?-instance_method">
  <h3 class='signature nodoc'>
    #<strong>closed_state?</strong>(state)  &#x21d2; <code>Boolean</code> 
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
<div class='docstring'>
  <div class='discussion'>
    
<p>raindrops before 0.18 only supported TCP_INFO under Linux</p>

  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L139-L148'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='139' data-end='148'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/unicorn/http_request.rb', line 139</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_closed_state?'>closed_state?</span>(<span class='id identifier rubyid_state'>state</span>) <span class='comment'># :nodoc:
</span>  <span class='kw'>case</span> <span class='id identifier rubyid_state'>state</span>
  <span class='kw'>when</span> <span class='int'>1</span> <span class='comment'># ESTABLISHED
</span>    <span class='kw'>false</span>
  <span class='kw'>when</span> <span class='int'>8</span><span class='comma'>,</span> <span class='int'>6</span><span class='comma'>,</span> <span class='int'>7</span><span class='comma'>,</span> <span class='int'>9</span><span class='comma'>,</span> <span class='int'>11</span> <span class='comment'># CLOSE_WAIT, TIME_WAIT, CLOSE, LAST_ACK, CLOSING
</span>    <span class='kw'>true</span>
  <span class='kw'>else</span>
    <span class='kw'>false</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="closed_state_str?-instance_method">
  <h3 class='signature nodoc'>
    #<strong>closed_state_str?</strong>(state)  &#x21d2; <code>Boolean</code> 
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
<div class='docstring'>
  <div class='discussion'>
    
  </div>
</div>
<div class='tags'>
  
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L171-L181'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='171' data-end='181'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/unicorn/http_request.rb', line 171</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_closed_state_str?'>closed_state_str?</span>(<span class='id identifier rubyid_state'>state</span>)
  <span class='kw'>case</span> <span class='id identifier rubyid_state'>state</span>
  <span class='kw'>when</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>ESTABLISHED</span><span class='tstring_end'>&#39;</span></span>
    <span class='kw'>false</span>
  <span class='comment'># not a typo, ruby maps TCP_CLOSE (no &#39;D&#39;) to state=CLOSED (w/ &#39;D&#39;)
</span>  <span class='kw'>when</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>CLOSE_WAIT</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>TIME_WAIT</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>CLOSED</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>LAST_ACK</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>CLOSING</span><span class='tstring_end'>&#39;</span></span>
    <span class='kw'>true</span>
  <span class='kw'>else</span>
    <span class='kw'>false</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="content_length-instance_method">
  <h3 class='signature '>
    #<strong>content_length</strong>  &#x21d2; <code>nil</code>, <code>Integer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the number of bytes left to run through <a href="#filter_body-instance_method" title="Unicorn::HttpParser#filter_body (method)">#filter_body</a>. This will initially be the value of the “Content-Length” HTTP header after header parsing is complete and will decrease in value as <a href="#filter_body-instance_method" title="Unicorn::HttpParser#filter_body (method)">#filter_body</a> is called for each chunk.  This should return zero for requests with no body.</p>

<p>This will return nil on “Transfer-Encoding: chunked” requests.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L684-L689'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='684' data-end='689'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 684</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_content_length(VALUE self)
{
  struct http_parser *hp = data_get(self);

  return HP_FL_TEST(hp, CHUNKED) ? Qnil : OFFT2NUM(hp-&gt;len.content);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="env-instance_method">
  <h3 class='signature '>
    #<strong>env</strong>  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L859-L862'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='859' data-end='862'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 859</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_env(VALUE self)
{
  return data_get(self)-&gt;env;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="filter_body-instance_method">
  <h3 class='signature '>
    #<strong>filter_body</strong>(dst, src)  &#x21d2; <code>nil</code>/<code>src</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Takes a String of <code>src</code>, will modify data if dechunking is done. Returns <code>nil</code> if there is more data left to process.  Returns <code>src</code> if body processing is complete. When returning <code>src</code>, it may modify <code>src</code> so the start of the string points to where the body ended so that trailer processing can begin.</p>

<p>Raises HttpParserError if there are dechunking errors. Basically this is a glorified memcpy(3) that copies <code>src</code> into <a href="#buf-instance_method" title="Unicorn::HttpParser#buf (method)">#buf</a> while filtering it through the dechunker.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L887-L949'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='887' data-end='949'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 887</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_filter_body(VALUE self, VALUE dst, VALUE src)
{
  struct http_parser *hp = data_get(self);
  char *srcptr;
  long srclen;

  srcptr = RSTRING_PTR(src);
  srclen = RSTRING_LEN(src);

  StringValue(dst);

  if (HP_FL_TEST(hp, CHUNKED)) {
    if (!chunked_eof(hp)) {
      rb_str_modify(dst);
      rb_str_resize(dst, srclen); /* we can never copy more than srclen bytes */

      hp-&gt;s.dest_offset = 0;
      hp-&gt;cont = dst;
      hp-&gt;buf = src;
      http_parser_execute(hp, srcptr, srclen);
      if (hp-&gt;cs == http_parser_error)
        parser_raise(eHttpParserError, &quot;Invalid HTTP format, parsing fails.&quot;);

      assert(hp-&gt;s.dest_offset &lt;= hp-&gt;offset &amp;&amp;
             &quot;destination buffer overflow&quot;);
      advance_str(src, hp-&gt;offset);
      rb_str_set_len(dst, hp-&gt;s.dest_offset);

      if (RSTRING_LEN(dst) == 0 &amp;&amp; chunked_eof(hp)) {
        assert(hp-&gt;len.chunk == 0 &amp;&amp; &quot;chunk at EOF but more to parse&quot;);
      } else {
        src = Qnil;
      }
    }
  } else {
    /* no need to enter the Ragel machine for unchunked transfers */
    assert(hp-&gt;len.content &gt;= 0 &amp;&amp; &quot;negative Content-Length&quot;);
    if (hp-&gt;len.content &gt; 0) {
      long nr = MIN(srclen, hp-&gt;len.content);

      rb_str_modify(dst);
      rb_str_resize(dst, nr);
      /*
       * using rb_str_replace() to avoid memcpy() doesn&#39;t help in
       * most cases because a GC-aware programmer will pass an explicit
       * buffer to env[&quot;rack.input&quot;].read and reuse the buffer in a loop.
       * This causes copy-on-write behavior to be triggered anyways
       * when the src buffer is modified (when reading off the socket).
       */
      hp-&gt;buf = src;
      memcpy(RSTRING_PTR(dst), srcptr, nr);
      hp-&gt;len.content -= nr;
      if (hp-&gt;len.content == 0) {
        HP_FL_SET(hp, REQEOF);
        hp-&gt;cs = http_parser_first_final;
      }
      advance_str(src, nr);
      src = Qnil;
    }
  }
  hp-&gt;offset = 0; /* for trailer parsing */
  return src;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="headers-instance_method">
  <h3 class='signature ro'>
    #<strong>headers</strong>(env, buf)   <span class="extras">(<span class='readonly'>readonly</span>)</span>
    <span class='aliases'>Also known as: <span class='names'>#trailers</span></span>
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L763-L771'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='763' data-end='771'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 763</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_headers(VALUE self, VALUE env, VALUE buf)
{
  struct http_parser *hp = data_get(self);

  hp-&gt;env = env;
  hp-&gt;buf = buf;

  return HttpParser_parse(self);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="hijacked!-instance_method">
  <h3 class='signature '>
    #<strong>hijacked!</strong>  
  </h3>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L864-L871'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='864' data-end='871'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 864</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_hijacked_bang(VALUE self)
{
  struct http_parser *hp = data_get(self);

  HP_FL_SET(hp, HIJACK);

  return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="parse-instance_method">
  <h3 class='signature '>
    #<strong>parse</strong>  &#x21d2; <a href="#env-instance_method" title="Unicorn::HttpParser#env (method)">env</a><sup>?</sup>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Takes a Hash and a String of data, parses the String of data filling in the Hash returning the Hash if parsing is finished, nil otherwise When returning the env Hash, it may modify data to point to where body processing should begin.</p>

<p>Raises HttpParserError if there are parsing errors.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/ext/unicorn_http/unicorn_http.rl#L703-L729'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='703' data-end='729'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/unicorn_http/unicorn_http.rl', line 703</span></pre>
<pre class='code cpp'>

static VALUE HttpParser_parse(VALUE self)
{
  struct http_parser *hp = data_get(self);
  VALUE data = hp-&gt;buf;

  if (HP_FL_TEST(hp, TO_CLEAR))
    HttpParser_clear(self);

  http_parser_execute(hp, RSTRING_PTR(data), RSTRING_LEN(data));
  if (hp-&gt;offset &gt; MAX_HEADER_LEN)
    parser_raise(e413, &quot;HTTP header is too large&quot;);

  if (hp-&gt;cs == http_parser_first_final ||
      hp-&gt;cs == http_parser_en_ChunkedBody) {
    advance_str(data, hp-&gt;offset + 1);
    hp-&gt;offset = 0;
    if (HP_FL_TEST(hp, INTRAILER))
      HP_FL_SET(hp, REQEOF);

    return hp-&gt;env;
  }

  if (hp-&gt;cs == http_parser_error)
    parser_raise(eHttpParserError, &quot;Invalid HTTP format, parsing fails.&quot;);

  return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="read_headers-instance_method">
  <h3 class='signature nodoc'>
    #<strong>read_headers</strong>(socket, ai)  
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
<div class='docstring'>
  <div class='discussion'>
    
<p>Does the majority of the IO processing.  It has been written in Ruby using about 8 different IO processing strategies.</p>

<p>It is currently carefully constructed to make sure that it gets the best possible performance for the common case: GET requests that are fully complete after a single read(2)</p>

<p>Anyone who thinks they can make it faster is more than welcome to take a crack at it.</p>

<p>returns an environment hash suitable for Rack if successful This does minimal exception trapping and it is up to the caller to handle any socket errors (e.g. user aborted upload).</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L64-L94'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='64' data-end='94'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/unicorn/http_request.rb', line 64</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_read_headers'>read_headers</span>(<span class='id identifier rubyid_socket'>socket</span><span class='comma'>,</span> <span class='id identifier rubyid_ai'>ai</span>)
  <span class='id identifier rubyid_e'>e</span> <span class='op'>=</span> <span class='id identifier rubyid_env'><a href="#env-instance_method" title="Unicorn::HttpParser#env (method)">env</a></span>

  <span class='comment'># From https://www.ietf.org/rfc/rfc3875:
</span>  <span class='comment'># &quot;Script authors should be aware that the REMOTE_ADDR and
</span>  <span class='comment'>#  REMOTE_HOST meta-variables (see sections 4.1.8 and 4.1.9)
</span>  <span class='comment'>#  may not identify the ultimate source of the request.  They
</span>  <span class='comment'>#  identify the client for the immediate request to the server;
</span>  <span class='comment'>#  that client may be a proxy, gateway, or other intermediary
</span>  <span class='comment'>#  acting on behalf of the actual source client.&quot;
</span>  <span class='id identifier rubyid_e'>e</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>REMOTE_ADDR</span><span class='tstring_end'>&#39;</span></span>] <span class='op'>=</span> <span class='id identifier rubyid_ai'>ai</span>.<span class='id identifier rubyid_unix?'>unix?</span> <span class='op'>?</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>127.0.0.1</span><span class='tstring_end'>&#39;</span></span> <span class='op'>:</span> <span class='id identifier rubyid_ai'>ai</span>.<span class='id identifier rubyid_ip_address'>ip_address</span>

  <span class='comment'># short circuit the common case with small GET requests first
</span>  <span class='id identifier rubyid_socket'>socket</span>.<span class='id identifier rubyid_readpartial'>readpartial</span>(<span class='int'>16384</span><span class='comma'>,</span> <span class='id identifier rubyid_buf'><a href="#buf-instance_method" title="Unicorn::HttpParser#buf (method)">buf</a></span>)
  <span class='kw'>if</span> <span class='id identifier rubyid_parse'><a href="#parse-instance_method" title="Unicorn::HttpParser#parse (method)">parse</a></span>.<span class='id identifier rubyid_nil?'>nil?</span>
    <span class='comment'># Parser is not done, queue up more data to read and continue parsing
</span>    <span class='comment'># an Exception thrown from the parser will throw us out of the loop
</span>    <span class='kw'>false</span> <span class='kw'>until</span> <span class='id identifier rubyid_add_parse'><a href="#add_parse-instance_method" title="Unicorn::HttpParser#add_parse (method)">add_parse</a></span>(<span class='id identifier rubyid_socket'>socket</span>.<span class='id identifier rubyid_readpartial'>readpartial</span>(<span class='int'>16384</span>))
  <span class='kw'>end</span>

  <span class='id identifier rubyid_check_client_connection'><a href="#check_client_connection-class_method" title="Unicorn::HttpParser.check_client_connection (method)">check_client_connection</a></span>(<span class='id identifier rubyid_socket'>socket</span><span class='comma'>,</span> <span class='id identifier rubyid_ai'>ai</span>) <span class='kw'>if</span> <span class='cvar'>@@check_client_connection</span>

  <span class='id identifier rubyid_e'>e</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rack.input</span><span class='tstring_end'>&#39;</span></span>] <span class='op'>=</span> <span class='int'>0</span> <span class='op'>==</span> <span class='id identifier rubyid_content_length'><a href="#content_length-instance_method" title="Unicorn::HttpParser#content_length (method)">content_length</a></span> <span class='op'>?</span>
                    <span class='const'><a href="#NULL_IO-constant" title="Unicorn::HttpParser::NULL_IO (constant)">NULL_IO</a></span> <span class='op'>:</span> <span class='cvar'>@@input_class</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="Unicorn::HttpParser.new (method)">new</a></span>(<span class='id identifier rubyid_socket'>socket</span><span class='comma'>,</span> <span class='kw'>self</span>)

  <span class='comment'># for Rack hijacking in Rack 1.5 and later
</span>  <span class='id identifier rubyid_e'>e</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>unicorn.socket</span><span class='tstring_end'>&#39;</span></span>] <span class='op'>=</span> <span class='id identifier rubyid_socket'>socket</span>
  <span class='id identifier rubyid_e'>e</span>[<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>rack.hijack</span><span class='tstring_end'>&#39;</span></span>] <span class='op'>=</span> <span class='kw'>self</span>

  <span class='id identifier rubyid_e'>e</span>.<span class='id identifier rubyid_merge!'>merge!</span>(<span class='const'><a href="#DEFAULTS-constant" title="Unicorn::HttpParser::DEFAULTS (constant)">DEFAULTS</a></span>)
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="trailers-instance_method">
  <h3 class='signature '>
    #<strong>trailers</strong>(env, buf)  
  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Alias for <a href="#headers-instance_method" title="Unicorn::HttpParser#headers (method)">#headers</a>. This is an alias for <a href="#headers-instance_method" title="Unicorn::HttpParser#headers (method)">#headers</a></p>

  </div>
</div>

</section>

<section class='method_details' id="write_http_header-instance_method">
  <h3 class='signature nodoc'>
    #<strong>write_http_header</strong>(socket)  
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/defunkt/unicorn/blob/master/lib/unicorn/http_request.rb#L184-L189'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='184' data-end='189'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'lib/unicorn/http_request.rb', line 184</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_write_http_header'>write_http_header</span>(<span class='id identifier rubyid_socket'>socket</span>) <span class='comment'># :nodoc:
</span>  <span class='kw'>if</span> <span class='id identifier rubyid_headers?'><a href="#headers%3F-instance_method" title="Unicorn::HttpParser#headers? (method)">headers?</a></span>
    <span class='kw'>self</span>.<span class='id identifier rubyid_response_start_sent'><a href="#response_start_sent-instance_method" title="Unicorn::HttpParser#response_start_sent (method)">response_start_sent</a></span> <span class='op'>=</span> <span class='kw'>true</span>
    <span class='const'><a href="#HTTP_RESPONSE_START-constant" title="Unicorn::HttpParser::HTTP_RESPONSE_START (constant)">HTTP_RESPONSE_START</a></span>.<span class='id identifier rubyid_each'>each</span> { <span class='op'>|</span><span class='id identifier rubyid_c'>c</span><span class='op'>|</span> <span class='id identifier rubyid_socket'>socket</span>.<span class='id identifier rubyid_write'>write</span>(<span class='id identifier rubyid_c'>c</span>) }
  <span class='kw'>end</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>