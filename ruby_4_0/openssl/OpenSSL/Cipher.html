<!DOCTYPE html>
<html>
<head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=no'>
<meta name='apple-touch-fullscreen' content='yes'>
<meta name='mobile-web-app-capable' content='yes'>
<meta name='apple-mobile-web-app-status-bar-style' content='rgba(228,228,228,1.0)'>

<title>Class: OpenSSL::Cipher &mdash; openssl  Ruby-4.0.1 p0</title>

<link rel='stylesheet'  type='text/css' href='../../../css/y_fonts.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/highlight.github.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_style.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_list.css' />
<link rel='stylesheet'  type='text/css' href='../../../css/y_color.css' />

<script type='text/javascript'>
  var pathId = "OpenSSL::Cipher",
    relpath = '../';

  var t2Info = {
    CSEP: '.',
    ISEP: '#',
    NSEP: '::'
  };
</script>

<script type='text/javascript' charset='utf-8' src='../../../js/highlight.pack.js'></script>
<script type='text/javascript' charset='utf-8' src='../../../js/y_app.js'></script>

</head>
<body>
<svg id='y_wait' class viewBox='0 0 90 90'></svg>
<div id='settings' class='hidden'></div>
<div id='y_list' class='d h'>
  <header id='list_header'></header>
  <nav id= 'list_nav' class='y_nav l_nav'>
    <ul id='list_items'></ul>
  </nav>
</div>
<div id='y_toc' class='f h'>
  <header id='toc_header'></header>
  <nav id= 'toc_nav' class='y_nav t_nav'>
  <ol id='toc_items'></ol>
  </nav>
</div>
<div id='y_main' tabindex='-1'>
  <header id='y_header'>
    <div id='y_menu'>
      <a id='home_no_xhr' href='/'>Home</a> &raquo; 
      <a href='../../'>Ruby-4.0.1</a> &raquo; 
      <a href='../'>openssl</a> &raquo; 
      <a href='../_index.html#alpha_C'>Index (C)</a> &raquo; 
        <a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a> &raquo; 
      <span class='title'><a id='t2_doc_top' href='#'>Cipher&nbsp;&#x25B2;</a></span>
    </div>

    <a id='list_href' href="../class_list.html"></a>
    <div id='y_measure_em' class='y_measure'></div>
    <div id='y_measure_vh' class='y_measure'></div>
    <span id='y_measure_50pre' class='y_measure'><code>123456789_123456789_123456789_123456789_123456789_</code></span>
  </header>
<div id='content' class='class'>
<h1>Class: OpenSSL::Cipher</h1>
<div id='t2_rel_sf_div'>
<table id='t2_rel_sf' class='y_box'>
  <thead>
    <tr><td id='t2_relations' colspan='2'>Relationships & Source Files</td></tr>
  </thead>
  <tbody>
    <tr><td class='box_h' colspan='2'>Namespace Children</td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Classes:</div>
      <div class='box_11'>
          <a href="Cipher/Cipher.html" title="OpenSSL::Cipher::Cipher (class)"><code>Cipher</code></a>      </div>
    </td></tr>
    <tr><td colspan='2'>
      <div class='box_1'>Exceptions:</div>
      <div class='box_11'>
          <a href="Cipher/AuthTagError.html" title="OpenSSL::Cipher::AuthTagError (class)"><code>AuthTagError</code></a>,
        <a href="Cipher/CipherError.html" title="OpenSSL::Cipher::CipherError (class)"><code>CipherError</code></a>      </div>
    </td></tr>
    <tr><td class='box_h' colspan='2'>Extension / Inclusion / Inheritance Descendants</td></tr>
    <tr>
      <td colspan='2'>
        <div class='box_2'>Subclasses:</div>
        <div class='box_22'>
          <a href="Cipher/Cipher.html" title="OpenSSL::Cipher::Cipher (class)">Cipher</a>
        </div>
      </td>
    </tr>
    <tr>
      <td id='t2_inherits' class='box_2'>Inherits:</td>
      <td class='box_rel'>
        <span class='inheritName'><a href="../Object.html" title="Object (class)">Object</a></span>
      </td>
    </tr>
    <tr class='single'>
      <td id='t2_defined_in' class='box_2 o'>Defined in:</td>
      <td class='box_rel'><a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L1105'>ext/openssl/ossl_cipher.c</a><span class='defines'>,<br /><a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/lib/openssl/cipher.rb#L16'>ext/openssl/lib/openssl/cipher.rb</a></span>
      </td>
    </tr>
  </tbody>
</table>
</div>
<h2 id='h2_overview'>Overview</h2>
<div id='overview_ds'>
<div class='docstring'>
  <div class='discussion'>
    
<p>Provides symmetric algorithms for encryption and decryption. The algorithms that are available depend on the particular version of <a href="../OpenSSL.html" title="OpenSSL (module)"><code>::OpenSSL</code></a> that is installed.</p>

<h3 id="label-Listing+all+supported+algorithms">Listing all supported algorithms</h3>

<p>A list of supported algorithms can be obtained by</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_puts'>puts</span> <span class='const'><a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a></span><span class='op'>::</span><span class='const'>Cipher</span>.<span class='id identifier rubyid_ciphers'><a href="#ciphers-class_method" title="OpenSSL::Cipher.ciphers (method)">ciphers</a></span></code></pre>

<h3 id="label-Instantiating+a+Cipher">Instantiating a Cipher</h3>

<p>There are several ways to create a <code>Cipher</code> instance. Generally, a <code>Cipher</code> algorithm is categorized by its name, the key length in bits and the cipher mode to be used. The most generic way to create a <code>Cipher</code> is the following</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_cipher'>cipher</span> <span class='op'>=</span> <span class='const'><a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a></span><span class='op'>::</span><span class='const'>Cipher</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="OpenSSL::Cipher.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>&lt;name&gt;-&lt;key length&gt;-&lt;mode&gt;</span><span class='tstring_end'>&#39;</span></span>)</code></pre>

<p>That is, a string consisting of the hyphenated concatenation of the individual components name, key length and mode. Either all uppercase or all lowercase strings may be used, for example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_cipher'>cipher</span> <span class='op'>=</span> <span class='const'><a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a></span><span class='op'>::</span><span class='const'>Cipher</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="OpenSSL::Cipher.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>aes-128-cbc</span><span class='tstring_end'>&#39;</span></span>)</code></pre>

<h3 id="label-Choosing+either+encryption+or+decryption+mode">Choosing either encryption or decryption mode</h3>

<p>Encryption and decryption are often very similar operations for symmetric algorithms, this is reflected by not having to choose different classes for either operation, both can be done using the same class. Still, after obtaining a <code>Cipher</code> instance, we need to tell the instance what it is that we intend to do with it, so we need to call either</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_encrypt'><a href="#encrypt-instance_method" title="OpenSSL::Cipher#encrypt (method)">encrypt</a></span></code></pre>

<p>or</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_decrypt'><a href="#decrypt-instance_method" title="OpenSSL::Cipher#decrypt (method)">decrypt</a></span></code></pre>

<p>on the <code>Cipher</code> instance. This should be the first call after creating the instance, otherwise configuration that has already been set could get lost in the process.</p>

<h3 id="label-Choosing+a+key">Choosing a key</h3>

<p>Symmetric encryption requires a key that is the same for the encrypting and for the decrypting party and after initial key establishment should be kept as private information. There are a lot of ways to create insecure keys, the most notable is to simply take a password as the key without processing the password further. A simple and secure way to create a key for a particular <code>Cipher</code> is</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_cipher'>cipher</span> <span class='op'>=</span> <span class='const'><a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a></span><span class='op'>::</span><span class='const'>Cipher</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="OpenSSL::Cipher.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>aes-256-cfb</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_encrypt'><a href="#encrypt-instance_method" title="OpenSSL::Cipher#encrypt (method)">encrypt</a></span>
<span class='id identifier rubyid_key'>key</span> <span class='op'>=</span> <span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_random_key'><a href="#random_key-instance_method" title="OpenSSL::Cipher#random_key (method)">random_key</a></span> <span class='comment'># also sets the generated key on the Cipher</span></code></pre>

<p>If you absolutely need to use passwords as encryption keys, you should use Password-Based Key Derivation Function 2 (PBKDF2) by generating the key with the help of the functionality provided by <a href="PKCS5.html#pbkdf2_hmac_sha1-class_method" title="OpenSSL::PKCS5.pbkdf2_hmac_sha1 (method)">PKCS5.pbkdf2_hmac_sha1</a> or <a href="PKCS5.html#pbkdf2_hmac-class_method" title="OpenSSL::PKCS5.pbkdf2_hmac (method)">PKCS5.pbkdf2_hmac</a>.</p>

<p>Although there is <a href="#pkcs5_keyivgen-instance_method" title="OpenSSL::Cipher#pkcs5_keyivgen (method)">#pkcs5_keyivgen</a>, its use is deprecated and it should only be used in legacy applications because it does not use the newer <code>PKCS#5</code> v2 algorithms.</p>

<h3 id="label-Choosing+an+IV">Choosing an IV</h3>

<p>The cipher modes CBC, CFB, OFB and CTR all need an “initialization vector”, or short, IV. ECB mode is the only mode that does not require an IV, but there is almost no legitimate use case for this mode because of the fact that it does not sufficiently hide plaintext patterns. Therefore</p>

<p><strong>You should never use ECB mode unless you are absolutely sure that you absolutely need it</strong></p>

<p>Because of this, you will end up with a mode that explicitly requires an IV in any case. Although the IV can be seen as public information, i.e. it may be transmitted in public once generated, it should still stay unpredictable to prevent certain kinds of attacks. Therefore, ideally</p>

<p><strong>Always create a secure random IV for every encryption of your Cipher</strong></p>

<p>A new, random IV should be created for every encryption of data. Think of the IV as a nonce (number used once) - it’s public but random and unpredictable. A secure random IV can be created as follows</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_cipher'>cipher</span> <span class='op'>=</span> <span class='op'>...</span>
<span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_encrypt'><a href="#encrypt-instance_method" title="OpenSSL::Cipher#encrypt (method)">encrypt</a></span>
<span class='id identifier rubyid_key'>key</span> <span class='op'>=</span> <span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_random_key'><a href="#random_key-instance_method" title="OpenSSL::Cipher#random_key (method)">random_key</a></span>
<span class='id identifier rubyid_iv'>iv</span> <span class='op'>=</span> <span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_random_iv'><a href="#random_iv-instance_method" title="OpenSSL::Cipher#random_iv (method)">random_iv</a></span> <span class='comment'># also sets the generated IV on the Cipher</span></code></pre>

<p>Although the key is generally a random value, too, it is a bad choice as an IV. There are elaborate ways how an attacker can take advantage of such an IV. As a general rule of thumb, exposing the key directly or indirectly should be avoided at all cost and exceptions only be made with good reason.</p>

<h3 id="label-Calling+-7BCipher-23final-7D">Calling <a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">#final</a></h3>

<p>ECB (which should not be used) and CBC are both block-based modes. This means that unlike for the other streaming-based modes, they operate on fixed-size blocks of data, and therefore they require a “finalization” step to produce or correctly decrypt the last block of data by appropriately handling some form of padding. Therefore it is essential to add the output of <a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">#final</a> to your encryption/decryption buffer or you will end up with decryption errors or truncated data.</p>

<p>Although this is not really necessary for streaming-mode ciphers, it is still recommended to apply the same pattern of adding the output of <a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">#final</a> there as well - it also enables you to switch between modes more easily in the future.</p>

<h3 id="label-Encrypting+and+decrypting+some+data">Encrypting and decrypting some data</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_data'>data</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Very, very confidential data</span><span class='tstring_end'>&quot;</span></span>

<span class='id identifier rubyid_cipher'>cipher</span> <span class='op'>=</span> <span class='const'><a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a></span><span class='op'>::</span><span class='const'>Cipher</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="OpenSSL::Cipher.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>aes-128-cbc</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_encrypt'><a href="#encrypt-instance_method" title="OpenSSL::Cipher#encrypt (method)">encrypt</a></span>
<span class='id identifier rubyid_key'>key</span> <span class='op'>=</span> <span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_random_key'><a href="#random_key-instance_method" title="OpenSSL::Cipher#random_key (method)">random_key</a></span>
<span class='id identifier rubyid_iv'>iv</span> <span class='op'>=</span> <span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_random_iv'><a href="#random_iv-instance_method" title="OpenSSL::Cipher#random_iv (method)">random_iv</a></span>

<span class='id identifier rubyid_encrypted'>encrypted</span> <span class='op'>=</span> <span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_update'><a href="#update-instance_method" title="OpenSSL::Cipher#update (method)">update</a></span>(<span class='id identifier rubyid_data'>data</span>) <span class='op'>+</span> <span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_final'><a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">final</a></span>
<span class='comment'>#...
</span><span class='id identifier rubyid_decipher'>decipher</span> <span class='op'>=</span> <span class='const'><a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a></span><span class='op'>::</span><span class='const'>Cipher</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="OpenSSL::Cipher.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>aes-128-cbc</span><span class='tstring_end'>&#39;</span></span>)
<span class='id identifier rubyid_decipher'>decipher</span>.<span class='id identifier rubyid_decrypt'><a href="#decrypt-instance_method" title="OpenSSL::Cipher#decrypt (method)">decrypt</a></span>
<span class='id identifier rubyid_decipher'>decipher</span>.<span class='id identifier rubyid_key'>key</span> <span class='op'>=</span> <span class='id identifier rubyid_key'>key</span>
<span class='id identifier rubyid_decipher'>decipher</span>.<span class='id identifier rubyid_iv'>iv</span> <span class='op'>=</span> <span class='id identifier rubyid_iv'>iv</span>

<span class='id identifier rubyid_plain'>plain</span> <span class='op'>=</span> <span class='id identifier rubyid_decipher'>decipher</span>.<span class='id identifier rubyid_update'><a href="#update-instance_method" title="OpenSSL::Cipher#update (method)">update</a></span>(<span class='id identifier rubyid_encrypted'>encrypted</span>) <span class='op'>+</span> <span class='id identifier rubyid_decipher'>decipher</span>.<span class='id identifier rubyid_final'><a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">final</a></span>

<span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_data'>data</span> <span class='op'>==</span> <span class='id identifier rubyid_plain'>plain</span> <span class='comment'>#=&gt; true</span></code></pre>

<h3 id="label-Authenticated+Encryption+and+Associated+Data+-28AEAD-29">Authenticated Encryption and Associated Data (AEAD)</h3>

<p>If the <a href="../OpenSSL.html" title="OpenSSL (module)"><code>::OpenSSL</code></a> version used supports it, an Authenticated Encryption mode (such as GCM or CCM) should always be preferred over any unauthenticated mode. Currently, <a href="../OpenSSL.html" title="OpenSSL (module)"><code>::OpenSSL</code></a> supports AE only in combination with Associated Data (AEAD) where additional associated data is included in the encryption process to compute a tag at the end of the encryption. This tag will also be used in the decryption process and by verifying its validity, the authenticity of a given ciphertext is established.</p>

<p>This is superior to unauthenticated modes in that it allows to detect if somebody effectively changed the ciphertext after it had been encrypted. This prevents malicious modifications of the ciphertext that could otherwise be exploited to modify ciphertexts in ways beneficial to potential attackers.</p>

<p>Associated data, also called additional authenticated data (AAD), is optionally used where there is additional information, such as headers or some metadata, that must be also authenticated but not necessarily need to be encrypted.</p>

<p>An example using the GCM (Galois/Counter Mode). You have 16 bytes <em>key</em>, 12 bytes (96 bits) <em>nonce</em> and the associated data <em>auth_data</em>. Be sure not to reuse the <em>key</em> and <em>nonce</em> pair. Reusing an nonce ruins the security guarantees of GCM mode.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_key'>key</span> <span class='op'>=</span> <span class='const'><a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a></span><span class='op'>::</span><span class='const'><a href="Random.html" title="OpenSSL::Random (module)">Random</a></span>.<span class='id identifier rubyid_random_bytes'><a href="Random.html#random_bytes-class_method" title="OpenSSL::Random.random_bytes (method)">random_bytes</a></span>(<span class='int'>16</span>)
<span class='id identifier rubyid_nonce'>nonce</span> <span class='op'>=</span> <span class='const'><a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a></span><span class='op'>::</span><span class='const'><a href="Random.html" title="OpenSSL::Random (module)">Random</a></span>.<span class='id identifier rubyid_random_bytes'><a href="Random.html#random_bytes-class_method" title="OpenSSL::Random.random_bytes (method)">random_bytes</a></span>(<span class='int'>12</span>)
<span class='id identifier rubyid_auth_data'>auth_data</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>authenticated but unencrypted data</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_data'>data</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>encrypted data</span><span class='tstring_end'>&quot;</span></span>

<span class='id identifier rubyid_cipher'>cipher</span> <span class='op'>=</span> <span class='const'><a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a></span><span class='op'>::</span><span class='const'>Cipher</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="OpenSSL::Cipher.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>aes-128-gcm</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_encrypt'><a href="#encrypt-instance_method" title="OpenSSL::Cipher#encrypt (method)">encrypt</a></span>
<span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_key'>key</span> <span class='op'>=</span> <span class='id identifier rubyid_key'>key</span>
<span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_iv'>iv</span> <span class='op'>=</span> <span class='id identifier rubyid_nonce'>nonce</span>
<span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_auth_data'>auth_data</span> <span class='op'>=</span> <span class='id identifier rubyid_auth_data'>auth_data</span>

<span class='id identifier rubyid_encrypted'>encrypted</span> <span class='op'>=</span> <span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_update'><a href="#update-instance_method" title="OpenSSL::Cipher#update (method)">update</a></span>(<span class='id identifier rubyid_data'>data</span>) <span class='op'>+</span> <span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_final'><a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">final</a></span>
<span class='id identifier rubyid_tag'>tag</span> <span class='op'>=</span> <span class='id identifier rubyid_cipher'>cipher</span>.<span class='id identifier rubyid_auth_tag'><a href="#auth_tag-instance_method" title="OpenSSL::Cipher#auth_tag (method)">auth_tag</a></span>(<span class='int'>16</span>)</code></pre>

<p>Now you are the receiver. You know the <em>key</em> and have received <em>nonce</em>, <em>auth_data</em>, <em>encrypted</em> and <em>tag</em> through an untrusted network. Note that GCM accepts an arbitrary length tag between 1 and 16 bytes. You may additionally need to check that the received tag has the correct length, or you allow attackers to forge a valid single byte tag for the tampered ciphertext with a probability of 1/256.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_raise'>raise</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>tag is truncated!</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_tag'>tag</span>.<span class='id identifier rubyid_bytesize'>bytesize</span> <span class='op'>==</span> <span class='int'>16</span>
<span class='id identifier rubyid_decipher'>decipher</span> <span class='op'>=</span> <span class='const'><a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a></span><span class='op'>::</span><span class='const'>Cipher</span>.<span class='id identifier rubyid_new'><a href="#new-class_method" title="OpenSSL::Cipher.new (method)">new</a></span>(<span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>aes-128-gcm</span><span class='tstring_end'>&#39;</span></span>).<span class='id identifier rubyid_decrypt'><a href="#decrypt-instance_method" title="OpenSSL::Cipher#decrypt (method)">decrypt</a></span>
<span class='id identifier rubyid_decipher'>decipher</span>.<span class='id identifier rubyid_key'>key</span> <span class='op'>=</span> <span class='id identifier rubyid_key'>key</span>
<span class='id identifier rubyid_decipher'>decipher</span>.<span class='id identifier rubyid_iv'>iv</span> <span class='op'>=</span> <span class='id identifier rubyid_nonce'>nonce</span>
<span class='id identifier rubyid_decipher'>decipher</span>.<span class='id identifier rubyid_auth_tag'><a href="#auth_tag-instance_method" title="OpenSSL::Cipher#auth_tag (method)">auth_tag</a></span> <span class='op'>=</span> <span class='id identifier rubyid_tag'>tag</span> <span class='comment'># could be called at any time before #final
</span><span class='id identifier rubyid_decipher'>decipher</span>.<span class='id identifier rubyid_auth_data'>auth_data</span> <span class='op'>=</span> <span class='id identifier rubyid_auth_data'>auth_data</span>

<span class='id identifier rubyid_decrypted'>decrypted</span> <span class='op'>=</span> <span class='id identifier rubyid_decipher'>decipher</span>.<span class='id identifier rubyid_update'><a href="#update-instance_method" title="OpenSSL::Cipher#update (method)">update</a></span>(<span class='id identifier rubyid_encrypted'>encrypted</span>) <span class='op'>+</span> <span class='id identifier rubyid_decipher'>decipher</span>.<span class='id identifier rubyid_final'><a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">final</a></span>

<span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_data'>data</span> <span class='op'>==</span> <span class='id identifier rubyid_decrypted'>decrypted</span> <span class='comment'>#=&gt; true</span></code></pre>

<p>Note that other AEAD ciphers may require additional steps, such as setting the expected tag length (#auth_tag_len=) or the total data length (#ccm_data_len=) in advance. Make sure to read the relevant man page for details.</p>

  </div>
</div>
</div>
<h2 class='h2_sum' id='class_method_summary'>Class Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#new-class_method" title="new (class method)">.<strong>new</strong>(string)  &#x21d2; Cipher </a>
    </span>
    <span class='note title constructor'>constructor</span>
    <div class='summary_desc'>
      <div class='inline'><p>The string must contain a valid cipher name like “aes-256-cbc”.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature mf'>
      <a href="#ciphers-class_method" title="ciphers (class method)">.<strong>ciphers</strong>  &#x21d2; array[string...] </a>
    </span>
    <span class='mod_func note title'>mod_func</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the names of all available ciphers in an array.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- class_method_summary -->

<h2 class='h2_sum' id='instance_attribute_summary'>Instance Attribute Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature wo'>
      <a href="#auth_data=-instance_method" title="#auth_data= (instance method)">#<strong>auth_data=</strong>(string)  </a>
    </span>
    <span class='note title writeonly'>writeonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Sets additional authenticated data (AAD), also called associated data, for this <code>Cipher</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#auth_tag-instance_method" title="#auth_tag (instance method)">#<strong>auth_tag</strong>(tag_len = 16)  &#x21d2; String </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Gets the generated authentication tag.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#auth_tag=-instance_method" title="#auth_tag= (instance method)">#<strong>auth_tag=</strong>(string)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Sets the authentication tag to verify the integrity of the ciphertext.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature wo'>
      <a href="#auth_tag_len=-instance_method" title="#auth_tag_len= (instance method)">#<strong>auth_tag_len=</strong>(integer)  </a>
    </span>
    <span class='note title writeonly'>writeonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Sets the length of the expected authentication tag for this <code>Cipher</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature ro'>
      <a href="#authenticated%3F-instance_method" title="#authenticated? (instance method)">#<strong>authenticated?</strong>  &#x21d2; Boolean </a>
    </span>
    <span class='note title readonly'>readonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Indicates whether this <code>Cipher</code> instance uses an AEAD mode.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature wo'>
      <a href="#ccm_data_len=-instance_method" title="#ccm_data_len= (instance method)">#<strong>ccm_data_len=</strong>(integer)  </a>
    </span>
    <span class='note title writeonly'>writeonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Sets the total length of the plaintext / ciphertext message that will be processed by <a href="#update-instance_method" title="OpenSSL::Cipher#update (method)">#update</a> in CCM mode.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature wo'>
      <a href="#iv=-instance_method" title="#iv= (instance method)">#<strong>iv=</strong>(string)  </a>
    </span>
    <span class='note title writeonly'>writeonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Sets the cipher IV.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#iv_len-instance_method" title="#iv_len (instance method)">#<strong>iv_len</strong>  &#x21d2; Integer </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the expected length in bytes for an IV for this <code>Cipher</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#iv_len=-instance_method" title="#iv_len= (instance method)">#<strong>iv_len=</strong>(integer)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Sets the IV/nonce length for this <code>Cipher</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature wo'>
      <a href="#key=-instance_method" title="#key= (instance method)">#<strong>key=</strong>(string)  </a>
    </span>
    <span class='note title writeonly'>writeonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Sets the cipher key.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#key_len-instance_method" title="#key_len (instance method)">#<strong>key_len</strong>  &#x21d2; Integer </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the key length in bytes of the <code>Cipher</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature rw'>
      <a href="#key_len=-instance_method" title="#key_len= (instance method)">#<strong>key_len=</strong>(integer)  </a>
    </span>
    <span class='note title rw'>rw</span>
    <div class='summary_desc'>
      <div class='inline'><p>Sets the key length of the cipher.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature wo'>
      <a href="#padding=-instance_method" title="#padding= (instance method)">#<strong>padding=</strong>(1 or 0)  </a>
    </span>
    <span class='note title writeonly'>writeonly</span>
    <div class='summary_desc'>
      <div class='inline'><p>Enables or disables padding.</p></div>
    </div>
  </li>
</ul>
</div>  <!-- instance_attribute_summary -->

<h2 class='h2_sum' id='instance_method_summary'>Instance Method Summary</h2>
<div class='div_sum'>
<ul class='summary full'>
  <li>
    <span class='summary_signature '>
      <a href="#block_size-instance_method" title="#block_size (instance method)">#<strong>block_size</strong>  &#x21d2; Integer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the size in bytes of the blocks on which this <code>Cipher</code> operates on.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#decrypt-instance_method" title="#decrypt (instance method)">#<strong>decrypt</strong>  &#x21d2; self </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Initializes the <code>Cipher</code> for decryption.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#encrypt-instance_method" title="#encrypt (instance method)">#<strong>encrypt</strong>  &#x21d2; self </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Initializes the <code>Cipher</code> for encryption.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#final-instance_method" title="#final (instance method)">#<strong>final</strong>  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the remaining data held in the cipher object.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#name-instance_method" title="#name (instance method)">#<strong>name</strong>  &#x21d2; String </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Returns the short name of the cipher which may differ slightly from the original name provided.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#pkcs5_keyivgen-instance_method" title="#pkcs5_keyivgen (instance method)">#<strong>pkcs5_keyivgen</strong>(pass, salt = nil, iterations = 2048, digest = &quot;MD5&quot;)  &#x21d2; nil </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Generates and sets the key/IV based on a password.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#random_iv-instance_method" title="#random_iv (instance method)">#<strong>random_iv</strong>  &#x21d2; iv </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Generate a random IV with <a href="Random.html#random_bytes-class_method" title="OpenSSL::Random.random_bytes (method)">Random.random_bytes</a> and sets it to the cipher, and returns it.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#random_key-instance_method" title="#random_key (instance method)">#<strong>random_key</strong>  &#x21d2; key </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Generate a random key with <a href="Random.html#random_bytes-class_method" title="OpenSSL::Random.random_bytes (method)">Random.random_bytes</a> and sets it to the cipher, and returns it.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#reset-instance_method" title="#reset (instance method)">#<strong>reset</strong>  &#x21d2; self </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Fully resets the internal state of the <code>Cipher</code>.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature '>
      <a href="#update-instance_method" title="#update (instance method)">#<strong>update</strong>(data [, buffer])  &#x21d2; String, buffer </a>
    </span>
    <div class='summary_desc'>
      <div class='inline'><p>Encrypts data in a streaming fashion.</p></div>
    </div>
  </li>
  <li>
    <span class='summary_signature nodoc'>
      <a href="#initialize_copy-instance_method" title="#initialize_copy (instance method)">#<strong>initialize_copy</strong>(other)  </a>
    </span>
    <span class='nodoc note title'>Internal use only</span>
  </li>
</ul>
</div>  <!-- instance_method_summary -->
<h2 id='Constructor_Details' class='y_details'>Constructor Details</h2>

  <section class='method_details first' id="new-class_method">
  <h3 class='signature  first'>
    .<strong>new</strong>(string)  &#x21d2; <code>Cipher</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>The string must contain a valid cipher name like “aes-256-cbc”.</p>

<p>A list of cipher names is available by calling <a href="#ciphers-class_method" title="OpenSSL::Cipher.ciphers (method)">.ciphers</a>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L143-L161'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='143' data-end='161'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 143</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_initialize(VALUE self, VALUE str)
{
    EVP_CIPHER_CTX *ctx;
    const EVP_CIPHER *cipher;
    VALUE cipher_holder;

    GetCipherInit(self, ctx);
    if (ctx) {
        ossl_raise(rb_eRuntimeError, &quot;Cipher already initialized!&quot;);
    }
    cipher = ossl_evp_cipher_fetch(str, &amp;cipher_holder);
    AllocCipher(self, ctx);
    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)
        ossl_raise(eCipherError, &quot;EVP_CipherInit_ex&quot;);
    rb_ivar_set(self, id_cipher_holder, cipher_holder);

    return self;
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Class Method Details</h2>
<section class='method_details first' id="ciphers-class_method">
  <h3 class='signature private first'>
    .<strong>ciphers</strong>  &#x21d2; <code>array</code>[<code>string</code>...]  <span class="extras">(<span class='mod_func'>mod_func</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the names of all available ciphers in an array.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L196-L207'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='196' data-end='207'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 196</span></pre>
<pre class='code cpp'>

static VALUE
ossl_s_ciphers(VALUE self)
{
    VALUE ary;

    ary = rb_ary_new();
    OBJ_NAME_do_all_sorted(OBJ_NAME_TYPE_CIPHER_METH,
                           add_cipher_name_to_ary,
                           (void*)ary);

    return ary;
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Attribute Details</h2>
<section class='method_details first' id="auth_data=-instance_method">
  <h3 class='signature wo first'>
    #<strong>auth_data=</strong>(string)   <span class="extras">(<span class='writeonly'>writeonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sets additional authenticated data (AAD), also called associated data, for this <code>Cipher</code>. This method is available for AEAD ciphers.</p>

<p>The contents of this field should be non-sensitive data which will be added to the ciphertext to generate the authentication tag which validates the contents of the ciphertext.</p>

<p>This method must be called after <a href="#key=-instance_method" title="OpenSSL::Cipher#key= (method)">#key=</a> and <a href="#iv=-instance_method" title="OpenSSL::Cipher#iv= (method)">#iv=</a> have been set, but before starting actual encryption or decryption with <a href="#update-instance_method" title="OpenSSL::Cipher#update (method)">#update</a>. In some cipher modes, <a href="#auth_tag_len=-instance_method" title="OpenSSL::Cipher#auth_tag_len= (method)">#auth_tag_len=</a> and <a href="#ccm_data_len=-instance_method" title="OpenSSL::Cipher#ccm_data_len= (method)">#ccm_data_len=</a> may also need to be called before this method.</p>

<p>See also the “AEAD Interface” section of the man page EVP_EncryptInit(3). This method internally calls EVP_CipherUpdate() with the output buffer set to NULL.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L592-L612'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='592' data-end='612'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 592</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_set_auth_data(VALUE self, VALUE data)
{
    EVP_CIPHER_CTX *ctx;
    unsigned char *in;
    long in_len, out_len;

    StringValue(data);

    in = (unsigned char *) RSTRING_PTR(data);
    in_len = RSTRING_LEN(data);

    GetCipher(self, ctx);
    if (!(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_AEAD_CIPHER))
        ossl_raise(eCipherError, &quot;AEAD not supported by this cipher&quot;);

    if (!ossl_cipher_update_long(ctx, NULL, &amp;out_len, in, in_len))
        ossl_raise(eCipherError, &quot;couldn&#39;t set additional authenticated data&quot;);

    return data;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="auth_tag-instance_method">
  <h3 class='signature rw'>
    #<strong>auth_tag</strong>(tag_len = 16)  &#x21d2; <code>String</code>  <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Gets the generated authentication tag. This method is available for AEAD ciphers, and should be called after encryption has been finalized by calling <a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">#final</a>.</p>

<p>The returned tag will be <em>tag_len</em> bytes long. Some cipher modes require the desired length in advance using a separate call to <a href="#auth_tag_len=-instance_method" title="OpenSSL::Cipher#auth_tag_len= (method)">#auth_tag_len=</a>, before starting encryption.</p>

<p>See also the “AEAD Interface” section of the man page EVP_EncryptInit(3). This method internally calls EVP_CIPHER_CTX_ctrl() with EVP_CTRL_AEAD_GET_TAG.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L630-L653'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='630' data-end='653'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 630</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_get_auth_tag(int argc, VALUE *argv, VALUE self)
{
    VALUE vtag_len, ret;
    EVP_CIPHER_CTX *ctx;
    int tag_len = 16;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;vtag_len);
    if (NIL_P(vtag_len))
        vtag_len = rb_attr_get(self, id_auth_tag_len);
    if (!NIL_P(vtag_len))
        tag_len = NUM2INT(vtag_len);

    GetCipher(self, ctx);

    if (!(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_AEAD_CIPHER))
        ossl_raise(eCipherError, &quot;authentication tag not supported by this cipher&quot;);

    ret = rb_str_new(NULL, tag_len);
    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, tag_len, RSTRING_PTR(ret)))
        ossl_raise(eCipherError, &quot;retrieving the authentication tag failed&quot;);

    return ret;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="auth_tag=-instance_method">
  <h3 class='signature rw'>
    #<strong>auth_tag=</strong>(string)   <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sets the authentication tag to verify the integrity of the ciphertext.</p>

<p>The authentication tag must be set before <a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">#final</a> is called. The tag is verified during the <a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">#final</a> call.</p>

<p>Note that, for CCM mode and OCB mode, the expected length of the tag must be set before starting decryption by a separate call to <a href="#auth_tag_len=-instance_method" title="OpenSSL::Cipher#auth_tag_len= (method)">#auth_tag_len=</a>. The content of the tag can be provided at any time before <a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">#final</a> is called.</p>

<p><strong>NOTE</strong>: The caller must ensure that the String passed to this method has the desired length. Some cipher modes support variable tag lengths, and this method may accept a truncated tag without raising an exception.</p>

<p>See also the “AEAD Interface” section of the man page EVP_EncryptInit(3). This method internally calls EVP_CIPHER_CTX_ctrl() with EVP_CTRL_AEAD_SET_TAG.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L676-L695'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='676' data-end='695'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 676</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_set_auth_tag(VALUE self, VALUE vtag)
{
    EVP_CIPHER_CTX *ctx;
    unsigned char *tag;
    int tag_len;

    StringValue(vtag);
    tag = (unsigned char *) RSTRING_PTR(vtag);
    tag_len = RSTRING_LENINT(vtag);

    GetCipher(self, ctx);
    if (!(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_AEAD_CIPHER))
        ossl_raise(eCipherError, &quot;authentication tag not supported by this cipher&quot;);

    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, tag_len, tag))
        ossl_raise(eCipherError, &quot;unable to set AEAD tag&quot;);

    return vtag;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="auth_tag_len=-instance_method">
  <h3 class='signature wo'>
    #<strong>auth_tag_len=</strong>(integer)   <span class="extras">(<span class='writeonly'>writeonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sets the length of the expected authentication tag for this <code>Cipher</code>. This method is available for some of AEAD ciphers that require the length to be set before starting encryption or decryption, such as CCM mode or OCB mode.</p>

<p>For CCM mode and OCB mode, the tag length must be set before <a href="#iv=-instance_method" title="OpenSSL::Cipher#iv= (method)">#iv=</a> is set.</p>

<p>See also the “AEAD Interface” section of the man page EVP_EncryptInit(3). This method internally calls EVP_CIPHER_CTX_ctrl() with EVP_CTRL_AEAD_SET_TAG and a NULL buffer.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L711-L728'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='711' data-end='728'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 711</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_set_auth_tag_len(VALUE self, VALUE vlen)
{
    int tag_len = NUM2INT(vlen);
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);
    if (!(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_AEAD_CIPHER))
        ossl_raise(eCipherError, &quot;AEAD not supported by this cipher&quot;);

    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, tag_len, NULL))
        ossl_raise(eCipherError, &quot;unable to set authentication tag length&quot;);

    /* for #auth_tag */
    rb_ivar_set(self, id_auth_tag_len, INT2NUM(tag_len));

    return vlen;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="authenticated?-instance_method">
  <h3 class='signature ro'>
    #<strong>authenticated?</strong>  &#x21d2; <code>Boolean</code>  <span class="extras">(<span class='readonly'>readonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Indicates whether this <code>Cipher</code> instance uses an AEAD mode.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L562-L570'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='562' data-end='570'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 562</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_is_authenticated(VALUE self)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);

    return (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) ? Qtrue : Qfalse;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="ccm_data_len=-instance_method">
  <h3 class='signature wo'>
    #<strong>ccm_data_len=</strong>(integer)   <span class="extras">(<span class='writeonly'>writeonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sets the total length of the plaintext / ciphertext message that will be processed by <a href="#update-instance_method" title="OpenSSL::Cipher#update (method)">#update</a> in CCM mode.</p>

<p>Make sure to call this method after <a href="#key=-instance_method" title="OpenSSL::Cipher#key= (method)">#key=</a> and <a href="#iv=-instance_method" title="OpenSSL::Cipher#iv= (method)">#iv=</a> have been set, and before <a href="#auth_data=-instance_method" title="OpenSSL::Cipher#auth_data= (method)">#auth_data=</a> or <a href="#update-instance_method" title="OpenSSL::Cipher#update (method)">#update</a> are called.</p>

<p>This method is only available for CCM mode ciphers.</p>

<p>See also the “AEAD Interface” section of the man page EVP_EncryptInit(3).</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L883-L896'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='883' data-end='896'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 883</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_set_ccm_data_len(VALUE self, VALUE data_len)
{
    int in_len, out_len;
    EVP_CIPHER_CTX *ctx;

    in_len = NUM2INT(data_len);

    GetCipher(self, ctx);
    if (EVP_CipherUpdate(ctx, NULL, &amp;out_len, NULL, in_len) != 1)
        ossl_raise(eCipherError, NULL);

    return data_len;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="iv=-instance_method">
  <h3 class='signature wo'>
    #<strong>iv=</strong>(string)   <span class="extras">(<span class='writeonly'>writeonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sets the cipher IV. Please note that since you should never be using ECB mode, an IV is always explicitly required and should be set prior to encryption. The IV itself can be safely transmitted in public.</p>

<p>This method expects the String to have the length equal to <a href="#iv_len-instance_method" title="OpenSSL::Cipher#iv_len (method)">#iv_len</a>. To use a different IV length with an AEAD cipher, <a href="#iv_len=-instance_method" title="OpenSSL::Cipher#iv_len= (method)">#iv_len=</a> must be set prior to calling this method.</p>

<p><strong>NOTE</strong>: In OpenSSL API conventions, the IV value may correspond to the “nonce” instead in some cipher modes. Refer to the <a href="../OpenSSL.html" title="OpenSSL (module)"><code>::OpenSSL</code></a> man pages for details.</p>

<p>See also the man page EVP_CipherInit_ex(3).</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L534-L554'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='534' data-end='554'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 534</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_set_iv(VALUE self, VALUE iv)
{
    EVP_CIPHER_CTX *ctx;
    int iv_len = 0;

    StringValue(iv);
    GetCipher(self, ctx);

    if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)
        iv_len = (int)(VALUE)EVP_CIPHER_CTX_get_app_data(ctx);
    if (!iv_len)
        iv_len = EVP_CIPHER_CTX_iv_length(ctx);
    if (RSTRING_LEN(iv) != iv_len)
        ossl_raise(rb_eArgError, &quot;iv must be %d bytes&quot;, iv_len);

    if (EVP_CipherInit_ex(ctx, NULL, NULL, NULL, (unsigned char *)RSTRING_PTR(iv), -1) != 1)
        ossl_raise(eCipherError, NULL);

    return iv;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="iv_len-instance_method">
  <h3 class='signature rw'>
    #<strong>iv_len</strong>  &#x21d2; <a href="../Integer.html" title="Integer (class)">Integer</a>  <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the expected length in bytes for an IV for this <code>Cipher</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L838-L851'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='838' data-end='851'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 838</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_iv_length(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    int len = 0;

    GetCipher(self, ctx);
    if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)
        len = (int)(VALUE)EVP_CIPHER_CTX_get_app_data(ctx);
    if (!len)
        len = EVP_CIPHER_CTX_iv_length(ctx);

    return INT2NUM(len);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="iv_len=-instance_method">
  <h3 class='signature rw'>
    #<strong>iv_len=</strong>(integer)   <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sets the IV/nonce length for this <code>Cipher</code>. This method is available for AEAD ciphers that support variable IV lengths. This method can be called if a different IV length than OpenSSL’s default is desired, prior to calling <a href="#iv=-instance_method" title="OpenSSL::Cipher#iv= (method)">#iv=</a>.</p>

<p>See also the “AEAD Interface” section of the man page EVP_EncryptInit(3). This method internally calls EVP_CIPHER_CTX_ctrl() with EVP_CTRL_AEAD_SET_IVLEN.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L743-L763'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='743' data-end='763'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 743</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_set_iv_length(VALUE self, VALUE iv_length)
{
    int len = NUM2INT(iv_length);
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);
    if (!(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_AEAD_CIPHER))
        ossl_raise(eCipherError, &quot;cipher does not support AEAD&quot;);

    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, len, NULL))
        ossl_raise(eCipherError, &quot;unable to set IV length&quot;);

    /*
     * EVP_CIPHER_CTX_iv_length() returns the default length. So we need to save
     * the length somewhere. Luckily currently we aren&#39;t using app_data.
     */
    EVP_CIPHER_CTX_set_app_data(ctx, (void *)(VALUE)len);

    return iv_length;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="key=-instance_method">
  <h3 class='signature wo'>
    #<strong>key=</strong>(string)   <span class="extras">(<span class='writeonly'>writeonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sets the cipher key. To generate a key, you should either use a secure random byte string or, if the key is to be derived from a password, you should rely on PBKDF2 functionality provided by <a href="PKCS5.html" title="OpenSSL::PKCS5 (module)"><code>PKCS5</code></a>. To generate a secure random-based key, <a href="#random_key-instance_method" title="OpenSSL::Cipher#random_key (method)">#random_key</a> may be used.</p>

<p>Only call this method after calling <a href="#encrypt-instance_method" title="OpenSSL::Cipher#encrypt (method)">#encrypt</a> or <a href="#decrypt-instance_method" title="OpenSSL::Cipher#decrypt (method)">#decrypt</a>.</p>

<p>See also the man page EVP_CipherInit_ex(3).</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L495-L514'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='495' data-end='514'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 495</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_set_key(VALUE self, VALUE key)
{
    EVP_CIPHER_CTX *ctx;
    int key_len;

    StringValue(key);
    GetCipher(self, ctx);

    key_len = EVP_CIPHER_CTX_key_length(ctx);
    if (RSTRING_LEN(key) != key_len)
        ossl_raise(rb_eArgError, &quot;key must be %d bytes&quot;, key_len);

    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)
        ossl_raise(eCipherError, NULL);

    rb_ivar_set(self, id_key_set, Qtrue);

    return key;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="key_len-instance_method">
  <h3 class='signature rw'>
    #<strong>key_len</strong>  &#x21d2; <a href="../Integer.html" title="Integer (class)">Integer</a>  <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the key length in bytes of the <code>Cipher</code>.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L822-L830'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='822' data-end='830'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 822</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_key_length(VALUE self)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);

    return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="key_len=-instance_method">
  <h3 class='signature rw'>
    #<strong>key_len=</strong>(integer)   <span class="extras">(<span class='rw'>rw</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Sets the key length of the cipher.  If the cipher is a fixed length cipher then attempting to set the key length to any value other than the fixed value is an error.</p>

<p>Under normal circumstances you do not need to call this method (and probably shouldn’t).</p>

<p>See EVP_CIPHER_CTX_set_key_length for further information.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L778-L789'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='778' data-end='789'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 778</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_set_key_length(VALUE self, VALUE key_length)
{
    int len = NUM2INT(key_length);
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);
    if (EVP_CIPHER_CTX_set_key_length(ctx, len) != 1)
        ossl_raise(eCipherError, NULL);

    return key_length;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="padding=-instance_method">
  <h3 class='signature wo'>
    #<strong>padding=</strong>(1 or 0)   <span class="extras">(<span class='writeonly'>writeonly</span>)</span>  </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Enables or disables padding. By default encryption operations are padded using standard block padding and the padding is checked and removed when decrypting. If the pad parameter is zero then no padding is performed, the total amount of data encrypted or decrypted must then be a multiple of the block size or an error will occur.</p>

<p>See EVP_CIPHER_CTX_set_padding for further information.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L804-L814'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='804' data-end='814'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 804</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_set_padding(VALUE self, VALUE padding)
{
    EVP_CIPHER_CTX *ctx;
    int pad = NUM2INT(padding);

    GetCipher(self, ctx);
    if (EVP_CIPHER_CTX_set_padding(ctx, pad) != 1)
        ossl_raise(eCipherError, NULL);
    return padding;
}
</pre>
  </div>
</div>
</section>

<h2 class='y_details'>Instance Method Details</h2>
<section class='method_details first' id="block_size-instance_method">
  <h3 class='signature  first'>
    #<strong>block_size</strong>  &#x21d2; <a href="../Integer.html" title="Integer (class)">Integer</a>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the size in bytes of the blocks on which this <code>Cipher</code> operates on.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L859-L867'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='859' data-end='867'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 859</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_block_size(VALUE self)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);

    return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="decrypt-instance_method">
  <h3 class='signature '>
    #<strong>decrypt</strong>  &#x21d2; <code>self</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Initializes the <code>Cipher</code> for decryption.</p>

<p>Make sure to call either <a href="#encrypt-instance_method" title="OpenSSL::Cipher#encrypt (method)">#encrypt</a> or <code>#decrypt</code> before using the <code>Cipher</code> for any operation or setting any parameters.</p>

<p>Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 0).</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L273-L277'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='273' data-end='277'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 273</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_decrypt(VALUE self)
{
    return ossl_cipher_init(self, 0);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="encrypt-instance_method">
  <h3 class='signature '>
    #<strong>encrypt</strong>  &#x21d2; <code>self</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Initializes the <code>Cipher</code> for encryption.</p>

<p>Make sure to call either <code>#encrypt</code> or <a href="#decrypt-instance_method" title="OpenSSL::Cipher#decrypt (method)">#decrypt</a> before using the <code>Cipher</code> for any operation or setting any parameters.</p>

<p>Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 1).</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L256-L260'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='256' data-end='260'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 256</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_encrypt(VALUE self)
{
    return ossl_cipher_init(self, 1);
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="final-instance_method">
  <h3 class='signature '>
    #<strong>final</strong>  &#x21d2; <code>String</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the remaining data held in the cipher object. Further calls to <a href="#update-instance_method" title="OpenSSL::Cipher#update (method)">#update</a> or <code>#final</code> are invalid. This call should always be made as the last call of an encryption or decryption operation, after having fed the entire plaintext or ciphertext to the <code>Cipher</code> instance.</p>

<p>When encrypting using an AEAD cipher, the authentication tag can be retrieved by <a href="#auth_tag-instance_method" title="OpenSSL::Cipher#auth_tag (method)">#auth_tag</a> after <code>#final</code> has been called.</p>

<p>When decrypting using an AEAD cipher, this method will verify the integrity of the ciphertext and the associated data with the authentication tag, which must be set by <a href="#auth_tag=-instance_method" title="OpenSSL::Cipher#auth_tag= (method)">#auth_tag=</a> prior to calling this method. If the verification fails, <a href="Cipher/CipherError.html" title="OpenSSL::Cipher::CipherError (class)"><code>Cipher::CipherError</code></a> will be raised.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L439-L463'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='439' data-end='463'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 439</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_final(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    int out_len;
    VALUE str;

    GetCipher(self, ctx);
    str = rb_str_new(0, EVP_CIPHER_CTX_block_size(ctx));
    if (!EVP_CipherFinal_ex(ctx, (unsigned char *)RSTRING_PTR(str), &amp;out_len)) {
        /* For AEAD ciphers, this is likely an authentication failure */
        if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) {
            /* For AEAD ciphers, EVP_CipherFinal_ex failures are authentication tag verification failures */
            ossl_raise(eAuthTagError, &quot;AEAD authentication tag verification failed&quot;);
        }
        else {
            /* For non-AEAD ciphers */
            ossl_raise(eCipherError, &quot;cipher final failed&quot;);
        }
    }
    assert(out_len &lt;= RSTRING_LEN(str));
    rb_str_set_len(str, out_len);

    return str;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="initialize_copy-instance_method">
  <h3 class='signature nodoc'>
    #<strong>initialize_copy</strong>(other)  
  </h3>
  <div class='note nodoc inline-block'>
    <strong>This method is for internal use only.</strong>
  </div><div></div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L164-L181'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='164' data-end='181'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 164</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_copy(VALUE self, VALUE other)
{
    EVP_CIPHER_CTX *ctx1, *ctx2;

    rb_check_frozen(self);
    if (self == other) return self;

    GetCipherInit(self, ctx1);
    if (!ctx1) {
        AllocCipher(self, ctx1);
    }
    GetCipher(other, ctx2);
    if (EVP_CIPHER_CTX_copy(ctx1, ctx2) != 1)
        ossl_raise(eCipherError, NULL);

    return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="name-instance_method">
  <h3 class='signature '>
    #<strong>name</strong>  &#x21d2; <code>String</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Returns the short name of the cipher which may differ slightly from the original name provided.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L472-L480'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='472' data-end='480'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 472</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_name(VALUE self)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);

    return rb_str_new2(EVP_CIPHER_name(EVP_CIPHER_CTX_cipher(ctx)));
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="pkcs5_keyivgen-instance_method">
  <h3 class='signature '>
    #<strong>pkcs5_keyivgen</strong>(pass, salt = nil, iterations = 2048, digest = &quot;MD5&quot;)  &#x21d2; <code>nil</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Generates and sets the key/IV based on a password.</p>

<p><strong>WARNING</strong>: This method is deprecated and should not be used. This method corresponds to EVP_BytesToKey(), a non-standard <a href="../OpenSSL.html" title="OpenSSL (module)"><code>::OpenSSL</code></a> extension of the legacy PKCS <code>#5</code> v1.5 key derivation function. See <a href="KDF.html" title="OpenSSL::KDF (module)"><code>KDF</code></a> for other options to derive keys from passwords.</p>

<h4 id="label-Parameters">Parameters</h4>
<ul><li>
<p><em>salt</em> must be an 8 byte string if provided.</p>
</li><li>
<p><em>iterations</em> is an integer with a default of 2048.</p>
</li><li>
<p><em>digest</em> is a <a href="Digest.html" title="OpenSSL::Digest (class)"><code>Digest</code></a> object that defaults to ‘MD5’</p>
</li></ul>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L295-L327'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='295' data-end='327'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 295</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    const EVP_MD *digest;
    VALUE vpass, vsalt, viter, vdigest, md_holder;
    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH], *salt = NULL;
    int iter;

    rb_scan_args(argc, argv, &quot;13&quot;, &amp;vpass, &amp;vsalt, &amp;viter, &amp;vdigest);
    StringValue(vpass);
    if(!NIL_P(vsalt)){
        StringValue(vsalt);
        if(RSTRING_LEN(vsalt) != PKCS5_SALT_LEN)
            ossl_raise(eCipherError, &quot;salt must be an 8-octet string&quot;);
        salt = (unsigned char *)RSTRING_PTR(vsalt);
    }
    iter = NIL_P(viter) ? 2048 : NUM2INT(viter);
    if (iter &lt;= 0)
        rb_raise(rb_eArgError, &quot;iterations must be a positive integer&quot;);
    digest = NIL_P(vdigest) ? EVP_md5() : ossl_evp_md_fetch(vdigest, &amp;md_holder);
    GetCipher(self, ctx);
    EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), digest, salt,
                   (unsigned char *)RSTRING_PTR(vpass), RSTRING_LENINT(vpass), iter, key, iv);
    if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, -1) != 1)
        ossl_raise(eCipherError, NULL);
    OPENSSL_cleanse(key, sizeof key);
    OPENSSL_cleanse(iv, sizeof iv);

    rb_ivar_set(self, id_key_set, Qtrue);

    return Qnil;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="random_iv-instance_method">
  <h3 class='signature '>
    #<strong>random_iv</strong>  &#x21d2; <code>iv</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Generate a random IV with <a href="Random.html#random_bytes-class_method" title="OpenSSL::Random.random_bytes (method)">Random.random_bytes</a> and sets it to the cipher, and returns it.</p>

<p>You must call <a href="#encrypt-instance_method" title="OpenSSL::Cipher#encrypt (method)">#encrypt</a> or <a href="#decrypt-instance_method" title="OpenSSL::Cipher#decrypt (method)">#decrypt</a> before calling this method.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/lib/openssl/cipher.rb#L55-L58'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='55' data-end='58'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/lib/openssl/cipher.rb', line 55</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_random_iv'>random_iv</span>
  <span class='id identifier rubyid_str'>str</span> <span class='op'>=</span> <span class='const'><a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a></span><span class='op'>::</span><span class='const'><a href="Random.html" title="OpenSSL::Random (module)">Random</a></span>.<span class='id identifier rubyid_random_bytes'><a href="Random.html#random_bytes-class_method" title="OpenSSL::Random.random_bytes (method)">random_bytes</a></span>(<span class='kw'>self</span>.<span class='id identifier rubyid_iv_len'><a href="#iv_len-instance_method" title="OpenSSL::Cipher#iv_len (method)">iv_len</a></span>)
  <span class='kw'>self</span>.<span class='id identifier rubyid_iv'>iv</span> <span class='op'>=</span> <span class='id identifier rubyid_str'>str</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="random_key-instance_method">
  <h3 class='signature '>
    #<strong>random_key</strong>  &#x21d2; <code>key</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Generate a random key with <a href="Random.html#random_bytes-class_method" title="OpenSSL::Random.random_bytes (method)">Random.random_bytes</a> and sets it to the cipher, and returns it.</p>

<p>You must call <a href="#encrypt-instance_method" title="OpenSSL::Cipher#encrypt (method)">#encrypt</a> or <a href="#decrypt-instance_method" title="OpenSSL::Cipher#decrypt (method)">#decrypt</a> before calling this method.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/lib/openssl/cipher.rb#L43-L46'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='43' data-end='46'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/lib/openssl/cipher.rb', line 43</span></pre>
<pre class='code ruby'>

<span class='kw'>def</span> <span class='id identifier rubyid_random_key'>random_key</span>
  <span class='id identifier rubyid_str'>str</span> <span class='op'>=</span> <span class='const'><a href="../OpenSSL.html" title="OpenSSL (module)">OpenSSL</a></span><span class='op'>::</span><span class='const'><a href="Random.html" title="OpenSSL::Random (module)">Random</a></span>.<span class='id identifier rubyid_random_bytes'><a href="Random.html#random_bytes-class_method" title="OpenSSL::Random.random_bytes (method)">random_bytes</a></span>(<span class='kw'>self</span>.<span class='id identifier rubyid_key_len'><a href="#key_len-instance_method" title="OpenSSL::Cipher#key_len (method)">key_len</a></span>)
  <span class='kw'>self</span>.<span class='id identifier rubyid_key'>key</span> <span class='op'>=</span> <span class='id identifier rubyid_str'>str</span>
<span class='kw'>end</span>
</pre>
  </div>
</div>
</section>

<section class='method_details' id="reset-instance_method">
  <h3 class='signature '>
    #<strong>reset</strong>  &#x21d2; <code>self</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Fully resets the internal state of the <code>Cipher</code>. By using this, the same <code>Cipher</code> instance may be used several times for encryption or decryption tasks.</p>

<p>Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1).</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L218-L228'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='218' data-end='228'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 218</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_reset(VALUE self)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);
    if (EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1) != 1)
        ossl_raise(eCipherError, NULL);

    return self;
}
</pre>
  </div>
</div>
</section>

<section class='method_details' id="update-instance_method">
  <h3 class='signature '>
    #<strong>update</strong>(data [, buffer])  &#x21d2; <code>String</code>, <code>buffer</code>   </h3>
<div class='docstring'>
  <div class='discussion'>
    
<p>Encrypts data in a streaming fashion. Hand consecutive blocks of data to the <code>#update</code> method in order to encrypt it. Returns the encrypted data chunk. When done, the output of <a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">#final</a> should be additionally added to the result.</p>

<p>If <em>buffer</em> is given, the encryption/decryption result will be written to it. <em>buffer</em> will be resized automatically.</p>

<p><strong>NOTE</strong>: When decrypting using an AEAD cipher, the integrity of the output is not verified until <a href="#final-instance_method" title="OpenSSL::Cipher#final (method)">#final</a> has been called.</p>

  </div>
</div>
  <span class='link_repo'>[&#8202;<a class='repo' href='https://github.com/ruby/ruby/blob/v4.0.1/ext/openssl/ossl_cipher.c#L369-L420'>GitHub</a>&#8202;]</span>
<div class='source_code h'>
  <pre class='lines_num' data-start='369' data-end='420'></pre>
  <div class='lines_code'>
<pre><span class='info file'># File 'ext/openssl/ossl_cipher.c', line 369</span></pre>
<pre class='code cpp'>

static VALUE
ossl_cipher_update(int argc, VALUE *argv, VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    unsigned char *in;
    long in_len, out_len;
    VALUE data, str;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;data, &amp;str);

    if (!RTEST(rb_attr_get(self, id_key_set)))
        ossl_raise(eCipherError, &quot;key not set&quot;);

    StringValue(data);
    in = (unsigned char *)RSTRING_PTR(data);
    in_len = RSTRING_LEN(data);
    GetCipher(self, ctx);

    /*
     * As of OpenSSL 3.2, there is no reliable way to determine the required
     * output buffer size for arbitrary cipher modes.
     * https://github.com/openssl/openssl/issues/22628
     *
     * in_len+block_size is usually sufficient, but AES key wrap with padding
     * ciphers require in_len+15 even though they have a block size of 8 bytes.
     *
     * Using EVP_MAX_BLOCK_LENGTH (32) as a safe upper bound for ciphers
     * currently implemented in OpenSSL, but this can change in the future.
     */
    if (in_len &gt; LONG_MAX - EVP_MAX_BLOCK_LENGTH) {
        ossl_raise(rb_eRangeError,
                   &quot;data too big to make output buffer: %ld bytes&quot;, in_len);
    }
    out_len = in_len + EVP_MAX_BLOCK_LENGTH;

    if (NIL_P(str)) {
        str = rb_str_new(0, out_len);
    } else {
        StringValue(str);
        if ((long)rb_str_capacity(str) &gt;= out_len)
            rb_str_modify(str);
        else
            rb_str_modify_expand(str, out_len - RSTRING_LEN(str));
    }

    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &amp;out_len, in, in_len))
        ossl_raise(eCipherError, NULL);
    assert(out_len &lt;= RSTRING_LEN(str));
    rb_str_set_len(str, out_len);

    return str;
}
</pre>
  </div>
</div>
</section>


<div id='footer'></div>
</div> <!-- content  -->
</div> <!-- y_main   -->
</body>
</html>